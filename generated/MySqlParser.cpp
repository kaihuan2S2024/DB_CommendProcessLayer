
// Generated from MySqlParser.g4 by ANTLR 4.13.0


#include "MySqlParserListener.h"
#include "MySqlParserVisitor.h"

#include "MySqlParser.h"


using namespace antlrcpp;
using namespace antlrcpptest;

using namespace antlr4;

namespace {

struct MySqlParserStaticData final {
  MySqlParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  MySqlParserStaticData(const MySqlParserStaticData&) = delete;
  MySqlParserStaticData(MySqlParserStaticData&&) = delete;
  MySqlParserStaticData& operator=(const MySqlParserStaticData&) = delete;
  MySqlParserStaticData& operator=(MySqlParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag mysqlparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
MySqlParserStaticData *mysqlparserParserStaticData = nullptr;

void mysqlparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (mysqlparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(mysqlparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<MySqlParserStaticData>(
    std::vector<std::string>{
      "root", "sqlStatements", "sqlStatement", "emptyStatement_", "ddlStatement", 
      "dmlStatement", "transactionStatement", "replicationStatement", "preparedStatement", 
      "compoundStatement", "administrationStatement", "utilityStatement", 
      "createDatabase", "createEvent", "createIndex", "createLogfileGroup", 
      "createProcedure", "createFunction", "createRole", "createServer", 
      "createTable", "createTablespaceInnodb", "createTablespaceNdb", "createTrigger", 
      "withClause", "commonTableExpressions", "cteName", "cteColumnName", 
      "createView", "createDatabaseOption", "charSet", "ownerStatement", 
      "scheduleExpression", "timestampValue", "intervalExpr", "intervalType", 
      "enableType", "indexType", "indexOption", "procedureParameter", "functionParameter", 
      "routineOption", "serverOption", "createDefinitions", "createDefinition", 
      "columnDefinition", "columnConstraint", "tableConstraint", "referenceDefinition", 
      "referenceAction", "referenceControlType", "indexColumnDefinition", 
      "tableOption", "tableType", "tablespaceStorage", "partitionDefinitions", 
      "partitionFunctionDefinition", "subpartitionFunctionDefinition", "partitionDefinition", 
      "partitionDefinerAtom", "partitionDefinerVector", "subpartitionDefinition", 
      "partitionOption", "alterDatabase", "alterEvent", "alterFunction", 
      "alterInstance", "alterLogfileGroup", "alterProcedure", "alterServer", 
      "alterTable", "alterTablespace", "alterView", "alterSpecification", 
      "alterPartitionSpecification", "dropDatabase", "dropEvent", "dropIndex", 
      "dropLogfileGroup", "dropProcedure", "dropFunction", "dropServer", 
      "dropTable", "dropTablespace", "dropTrigger", "dropView", "dropRole", 
      "setRole", "renameTable", "renameTableClause", "truncateTable", "callStatement", 
      "deleteStatement", "doStatement", "handlerStatement", "insertStatement", 
      "loadDataStatement", "loadXmlStatement", "replaceStatement", "selectStatement", 
      "updateStatement", "valuesStatement", "insertStatementValue", "updatedElement", 
      "assignmentField", "lockClause", "singleDeleteStatement", "multipleDeleteStatement", 
      "handlerOpenStatement", "handlerReadIndexStatement", "handlerReadStatement", 
      "handlerCloseStatement", "singleUpdateStatement", "multipleUpdateStatement", 
      "orderByClause", "orderByExpression", "tableSources", "tableSource", 
      "tableSourceItem", "indexHint", "indexHintType", "joinPart", "queryExpression", 
      "queryExpressionNointo", "querySpecification", "querySpecificationNointo", 
      "unionParenthesis", "unionStatement", "lateralStatement", "jsonTable", 
      "jsonColumnList", "jsonColumn", "jsonOnEmpty", "jsonOnError", "selectSpec", 
      "selectElements", "selectElement", "selectIntoExpression", "selectFieldsInto", 
      "selectLinesInto", "fromClause", "groupByClause", "havingClause", 
      "windowClause", "groupByItem", "limitClause", "limitClauseAtom", "startTransaction", 
      "beginWork", "commitWork", "rollbackWork", "savepointStatement", "rollbackStatement", 
      "releaseStatement", "lockTables", "unlockTables", "setAutocommitStatement", 
      "setTransactionStatement", "transactionMode", "lockTableElement", 
      "lockAction", "transactionOption", "transactionLevel", "changeMaster", 
      "changeReplicationFilter", "purgeBinaryLogs", "resetMaster", "resetSlave", 
      "startSlave", "stopSlave", "startGroupReplication", "stopGroupReplication", 
      "masterOption", "stringMasterOption", "decimalMasterOption", "boolMasterOption", 
      "channelOption", "replicationFilter", "tablePair", "threadType", "untilOption", 
      "connectionOption", "gtuidSet", "xaStartTransaction", "xaEndTransaction", 
      "xaPrepareStatement", "xaCommitWork", "xaRollbackWork", "xaRecoverWork", 
      "prepareStatement", "executeStatement", "deallocatePrepare", "routineBody", 
      "blockStatement", "caseStatement", "ifStatement", "iterateStatement", 
      "leaveStatement", "loopStatement", "repeatStatement", "returnStatement", 
      "whileStatement", "cursorStatement", "declareVariable", "declareCondition", 
      "declareCursor", "declareHandler", "handlerConditionValue", "procedureSqlStatement", 
      "caseAlternative", "elifAlternative", "alterUser", "createUser", "dropUser", 
      "grantStatement", "roleOption", "grantProxy", "renameUser", "revokeStatement", 
      "revokeProxy", "setPasswordStatement", "userSpecification", "userAuthOption", 
      "authenticationRule", "tlsOption", "userResourceOption", "userPasswordOption", 
      "userLockOption", "privelegeClause", "privilege", "privilegeLevel", 
      "renameUserClause", "analyzeTable", "checkTable", "checksumTable", 
      "optimizeTable", "repairTable", "checkTableOption", "createUdfunction", 
      "installPlugin", "uninstallPlugin", "setStatement", "showStatement", 
      "variableClause", "showCommonEntity", "showFilter", "showGlobalInfoClause", 
      "showSchemaEntity", "showProfileType", "binlogStatement", "cacheIndexStatement", 
      "flushStatement", "killStatement", "loadIndexIntoCache", "resetStatement", 
      "shutdownStatement", "tableIndexes", "flushOption", "flushTableOption", 
      "loadedTableIndexes", "simpleDescribeStatement", "fullDescribeStatement", 
      "helpStatement", "useStatement", "signalStatement", "resignalStatement", 
      "signalConditionInformation", "withStatement", "tableStatement", "diagnosticsStatement", 
      "diagnosticsConditionInformationName", "describeObjectClause", "fullId", 
      "tableName", "roleName", "fullColumnName", "indexColumnName", "userName", 
      "mysqlVariable", "charsetName", "collationName", "engineName", "engineNameBase", 
      "uuidSet", "xid", "xuidStringId", "authPlugin", "uid", "simpleId", 
      "dottedId", "decimalLiteral", "fileSizeLiteral", "stringLiteral", 
      "booleanLiteral", "hexadecimalLiteral", "nullNotnull", "constant", 
      "dataType", "collectionOptions", "convertedDataType", "lengthOneDimension", 
      "lengthTwoDimension", "lengthTwoOptionalDimension", "uidList", "fullColumnNameList", 
      "tables", "indexColumnNames", "expressions", "expressionsWithDefaults", 
      "constants", "simpleStrings", "userVariables", "defaultValue", "currentTimestamp", 
      "expressionOrDefault", "ifExists", "ifNotExists", "orReplace", "waitNowaitClause", 
      "functionCall", "specificFunction", "caseFuncAlternative", "levelsInWeightString", 
      "levelInWeightListElement", "aggregateWindowedFunction", "nonAggregateWindowedFunction", 
      "overClause", "windowSpec", "windowName", "frameClause", "frameUnits", 
      "frameExtent", "frameBetween", "frameRange", "partitionClause", "scalarFunctionName", 
      "passwordFunctionClause", "functionArgs", "functionArg", "expression", 
      "predicate", "expressionAtom", "unaryOperator", "comparisonOperator", 
      "logicalOperator", "bitOperator", "mathOperator", "jsonOperator", 
      "charsetNameBase", "transactionLevelBase", "privilegesBase", "intervalTypeBase", 
      "dataTypeBase", "keywordsCanBeId", "functionNameBase"
    },
    std::vector<std::string>{
      "", "", "", "", "", "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", "'ANALYZE'", 
      "'AND'", "'ARRAY'", "'AS'", "'ASC'", "'ATTRIBUTE'", "'BEFORE'", "'BETWEEN'", 
      "'BOTH'", "'BUCKETS'", "'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'", 
      "'CHANGE'", "'CHARACTER'", "'CHECK'", "'COLLATE'", "'COLUMN'", "'CONDITION'", 
      "'CONSTRAINT'", "'CONTINUE'", "'CONVERT'", "'CREATE'", "'CROSS'", 
      "'CURRENT'", "'CURRENT_ROLE'", "'CURRENT_USER'", "'CURSOR'", "'DATABASE'", 
      "'DATABASES'", "'DECLARE'", "'DEFAULT'", "'DELAYED'", "'DELETE'", 
      "'DESC'", "'DESCRIBE'", "'DETERMINISTIC'", "'DIAGNOSTICS'", "'DISTINCT'", 
      "'DISTINCTROW'", "'DROP'", "'EACH'", "'ELSE'", "'ELSEIF'", "'EMPTY'", 
      "'ENCLOSED'", "'ENFORCED'", "'ESCAPED'", "'EXCEPT'", "'EXISTS'", "'EXIT'", 
      "'EXPLAIN'", "'FALSE'", "'FETCH'", "'FOR'", "'FORCE'", "'FOREIGN'", 
      "'FROM'", "'FULLTEXT'", "'GENERATED'", "'GET'", "'GRANT'", "'GROUP'", 
      "'HAVING'", "'HIGH_PRIORITY'", "'HISTOGRAM'", "'IF'", "'IGNORE'", 
      "'IGNORED'", "'IN'", "'INDEX'", "'INFILE'", "'INNER'", "'INOUT'", 
      "'INSERT'", "'INTERVAL'", "'INTO'", "'IS'", "'ITERATE'", "'JOIN'", 
      "'KEY'", "'KEYS'", "'KILL'", "'LATERAL'", "'LEADING'", "'LEAVE'", 
      "'LEFT'", "'LIKE'", "'LIMIT'", "'LINEAR'", "'LINES'", "'LOAD'", "'LOCK'", 
      "'LOCKED'", "'LOOP'", "'LOW_PRIORITY'", "'MASTER_BIND'", "'MASTER_SSL_VERIFY_SERVER_CERT'", 
      "'MATCH'", "'MAXVALUE'", "'MINVALUE'", "'MODIFIES'", "'NATURAL'", 
      "'NOT'", "'NO_WRITE_TO_BINLOG'", "'NULL'", "'NUMBER'", "'ON'", "'OPTIMIZE'", 
      "'OPTION'", "'OPTIONAL'", "'OPTIONALLY'", "'OR'", "'ORDER'", "'OUT'", 
      "'OUTER'", "'OUTFILE'", "'OVER'", "'PARTITION'", "'PRIMARY'", "'PROCEDURE'", 
      "'PURGE'", "'RANGE'", "'READ'", "'READS'", "'REFERENCES'", "'REGEXP'", 
      "'RELEASE'", "'RENAME'", "'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESIGNAL'", 
      "'RESTRICT'", "'RETAIN'", "'RETURN'", "'REVOKE'", "'RIGHT'", "'RLIKE'", 
      "'SCHEMA'", "'SCHEMAS'", "'SELECT'", "'SET'", "'SEPARATOR'", "'SHOW'", 
      "'SIGNAL'", "'SKIP'", "'SKIP_QUERY_REWRITE'", "'SPATIAL'", "'SQL'", 
      "'SQLEXCEPTION'", "'SQLSTATE'", "'SQLWARNING'", "'SQL_BIG_RESULT'", 
      "'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'", "'SSL'", "'STACKED'", 
      "'STARTING'", "'STATEMENT'", "'STRAIGHT_JOIN'", "'TABLE'", "'TERMINATED'", 
      "'THEN'", "'TO'", "'TRAILING'", "'TRIGGER'", "'TRUE'", "'UNDO'", "'UNION'", 
      "'UNIQUE'", "'UNLOCK'", "'UNSIGNED'", "'UPDATE'", "'USAGE'", "'USE'", 
      "'USING'", "'VALUES'", "'WHEN'", "'WHERE'", "'WHILE'", "'WITH'", "'WRITE'", 
      "'XOR'", "'ZEROFILL'", "'TINYINT'", "'SMALLINT'", "'MEDIUMINT'", "'MIDDLEINT'", 
      "'INT'", "'INT1'", "'INT2'", "'INT3'", "'INT4'", "'INT8'", "'INTEGER'", 
      "'BIGINT'", "'REAL'", "'DOUBLE'", "'PRECISION'", "'FLOAT'", "'FLOAT4'", 
      "'FLOAT8'", "'DECIMAL'", "'DEC'", "'NUMERIC'", "'DATE'", "'TIME'", 
      "'TIMESTAMP'", "'DATETIME'", "'YEAR'", "'CHAR'", "'VARCHAR'", "'NVARCHAR'", 
      "'NATIONAL'", "'BINARY'", "'VARBINARY'", "'TINYBLOB'", "'BLOB'", "'MEDIUMBLOB'", 
      "'LONG'", "'LONGBLOB'", "'TINYTEXT'", "'TEXT'", "'MEDIUMTEXT'", "'LONGTEXT'", 
      "'ENUM'", "'VARYING'", "'SERIAL'", "'YEAR_MONTH'", "'DAY_HOUR'", "'DAY_MINUTE'", 
      "'DAY_SECOND'", "'HOUR_MINUTE'", "'HOUR_SECOND'", "'MINUTE_SECOND'", 
      "'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'", "'HOUR_MICROSECOND'", 
      "'DAY_MICROSECOND'", "'JSON_ARRAY'", "'JSON_ARRAYAGG'", "'JSON_ARRAY_APPEND'", 
      "'JSON_ARRAY_INSERT'", "'JSON_CONTAINS'", "'JSON_CONTAINS_PATH'", 
      "'JSON_DEPTH'", "'JSON_EXTRACT'", "'JSON_INSERT'", "'JSON_KEYS'", 
      "'JSON_LENGTH'", "'JSON_MERGE'", "'JSON_MERGE_PATCH'", "'JSON_MERGE_PRESERVE'", 
      "'JSON_OBJECT'", "'JSON_OBJECTAGG'", "'JSON_OVERLAPS'", "'JSON_PRETTY'", 
      "'JSON_QUOTE'", "'JSON_REMOVE'", "'JSON_REPLACE'", "'JSON_SCHEMA_VALID'", 
      "'JSON_SCHEMA_VALIDATION_REPORT'", "'JSON_SEARCH'", "'JSON_SET'", 
      "'JSON_STORAGE_FREE'", "'JSON_STORAGE_SIZE'", "'JSON_TABLE'", "'JSON_TYPE'", 
      "'JSON_UNQUOTE'", "'JSON_VALID'", "'JSON_VALUE'", "'NESTED'", "'ORDINALITY'", 
      "'PATH'", "'AVG'", "'BIT_AND'", "'BIT_OR'", "'BIT_XOR'", "'COUNT'", 
      "'CUME_DIST'", "'DENSE_RANK'", "'FIRST_VALUE'", "'GROUP_CONCAT'", 
      "'LAG'", "'LAST_VALUE'", "'LEAD'", "'MAX'", "'MIN'", "'NTILE'", "'NTH_VALUE'", 
      "'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'", "'STD'", "'STDDEV'", "'STDDEV_POP'", 
      "'STDDEV_SAMP'", "'SUM'", "'VAR_POP'", "'VAR_SAMP'", "'VARIANCE'", 
      "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'LOCALTIME'", 
      "'CURDATE'", "'CURTIME'", "'DATE_ADD'", "'DATE_SUB'", "'EXTRACT'", 
      "'LOCALTIMESTAMP'", "'NOW'", "'POSITION'", "'SUBSTR'", "'SUBSTRING'", 
      "'SYSDATE'", "'TRIM'", "'UTC_DATE'", "'UTC_TIME'", "'UTC_TIMESTAMP'", 
      "'ACCOUNT'", "'ACTION'", "'AFTER'", "'AGGREGATE'", "'ALGORITHM'", 
      "'ANY'", "'AT'", "'AUTHORS'", "'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", 
      "'AUTO_INCREMENT'", "'AVG_ROW_LENGTH'", "'BEGIN'", "'BINLOG'", "'BIT'", 
      "'BLOCK'", "'BOOL'", "'BOOLEAN'", "'BTREE'", "'CACHE'", "'CASCADED'", 
      "'CHAIN'", "'CHANGED'", "'CHANNEL'", "'CHECKSUM'", "'PAGE_CHECKSUM'", 
      "'CIPHER'", "'CLASS_ORIGIN'", "'CLIENT'", "'CLOSE'", "'CLUSTERING'", 
      "'COALESCE'", "'CODE'", "'COLUMNS'", "'COLUMN_FORMAT'", "'COLUMN_NAME'", 
      "'COMMENT'", "'COMMIT'", "'COMPACT'", "'COMPLETION'", "'COMPRESSED'", 
      "", "'CONCURRENT'", "'CONNECT'", "'CONNECTION'", "'CONSISTENT'", "'CONSTRAINT_CATALOG'", 
      "'CONSTRAINT_SCHEMA'", "'CONSTRAINT_NAME'", "'CONTAINS'", "'CONTEXT'", 
      "'CONTRIBUTORS'", "'COPY'", "'CPU'", "'CYCLE'", "'CURSOR_NAME'", "'DATA'", 
      "'DATAFILE'", "'DEALLOCATE'", "'DEFAULT_AUTH'", "'DEFINER'", "'DELAY_KEY_WRITE'", 
      "'DES_KEY_FILE'", "'DIRECTORY'", "'DISABLE'", "'DISCARD'", "'DISK'", 
      "'DO'", "'DUMPFILE'", "'DUPLICATE'", "'DYNAMIC'", "'ENABLE'", "'ENCRYPTED'", 
      "'ENCRYPTION'", "'ENCRYPTION_KEY_ID'", "'END'", "'ENDS'", "'ENGINE'", 
      "'ENGINES'", "'ERROR'", "'ERRORS'", "'ESCAPE'", "'EVEN'", "'EVENT'", 
      "'EVENTS'", "'EVERY'", "'EXCHANGE'", "'EXCLUSIVE'", "'EXPIRE'", "'EXPORT'", 
      "'EXTENDED'", "'EXTENT_SIZE'", "'FAILED_LOGIN_ATTEMPTS'", "'FAST'", 
      "'FAULTS'", "'FIELDS'", "'FILE_BLOCK_SIZE'", "'FILTER'", "'FIRST'", 
      "'FIXED'", "'FLUSH'", "'FOLLOWING'", "'FOLLOWS'", "'FOUND'", "'FULL'", 
      "'FUNCTION'", "'GENERAL'", "'GLOBAL'", "'GRANTS'", "'GROUP_REPLICATION'", 
      "'HANDLER'", "'HASH'", "'HELP'", "'HISTORY'", "'HOST'", "'HOSTS'", 
      "'IDENTIFIED'", "'IGNORE_SERVER_IDS'", "'IMPORT'", "'INCREMENT'", 
      "'INDEXES'", "'INITIAL_SIZE'", "'INPLACE'", "'INSERT_METHOD'", "'INSTALL'", 
      "'INSTANCE'", "'INSTANT'", "'INVISIBLE'", "'INVOKER'", "'IO'", "'IO_THREAD'", 
      "'IPC'", "'ISOLATION'", "'ISSUER'", "'JSON'", "'KEY_BLOCK_SIZE'", 
      "'LANGUAGE'", "'LAST'", "'LEAVES'", "'LESS'", "'LEVEL'", "'LIST'", 
      "'LOCAL'", "'LOGFILE'", "'LOGS'", "'MASTER'", "'MASTER_AUTO_POSITION'", 
      "'MASTER_CONNECT_RETRY'", "'MASTER_DELAY'", "'MASTER_HEARTBEAT_PERIOD'", 
      "'MASTER_HOST'", "'MASTER_LOG_FILE'", "'MASTER_LOG_POS'", "'MASTER_PASSWORD'", 
      "'MASTER_PORT'", "'MASTER_RETRY_COUNT'", "'MASTER_SSL'", "'MASTER_SSL_CA'", 
      "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'", "'MASTER_SSL_CIPHER'", 
      "'MASTER_SSL_CRL'", "'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'", "'MASTER_TLS_VERSION'", 
      "'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'", "'MAX_QUERIES_PER_HOUR'", 
      "'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'", "'MAX_USER_CONNECTIONS'", 
      "'MEDIUM'", "'MEMBER'", "'MERGE'", "'MESSAGE_TEXT'", "'MID'", "'MIGRATE'", 
      "'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'", "'MYSQL'", "'MYSQL_ERRNO'", 
      "'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'", "'NEXT'", "'NO'", "'NOCACHE'", 
      "'NOCOPY'", "'NOCYCLE'", "'NOMAXVALUE'", "'NOMINVALUE'", "'NOWAIT'", 
      "'NODEGROUP'", "'NONE'", "'ODBC'", "'OFFLINE'", "'OFFSET'", "'OF'", 
      "'OJ'", "'OLD_PASSWORD'", "'ONE'", "'ONLINE'", "'ONLY'", "'OPEN'", 
      "'OPTIMIZER_COSTS'", "'OPTIONS'", "'OWNER'", "'PACK_KEYS'", "'PAGE'", 
      "'PAGE_COMPRESSED'", "'PAGE_COMPRESSION_LEVEL'", "'PARSER'", "'PARTIAL'", 
      "'PARTITIONING'", "'PARTITIONS'", "'PASSWORD'", "'PASSWORD_LOCK_TIME'", 
      "'PHASE'", "'PLUGIN'", "'PLUGIN_DIR'", "'PLUGINS'", "'PORT'", "'PRECEDES'", 
      "'PRECEDING'", "'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'", 
      "'PROFILE'", "'PROFILES'", "'PROXY'", "'QUERY'", "'QUICK'", "'REBUILD'", 
      "'RECOVER'", "'RECURSIVE'", "'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'", 
      "'RELAY_LOG_FILE'", "'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'", 
      "'REPAIR'", "'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'", 
      "'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'", 
      "'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'", "'RESET'", "'RESTART'", 
      "'RESUME'", "'RETURNED_SQLSTATE'", "'RETURNING'", "'RETURNS'", "'REUSE'", 
      "'ROLE'", "'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", 
      "'ROW_FORMAT'", "'RTREE'", "'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", 
      "'SEQUENCE'", "'SERVER'", "'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", 
      "'SIMPLE'", "'SLAVE'", "'SLOW'", "'SNAPSHOT'", "'SOCKET'", "'SOME'", 
      "'SONAME'", "'SOUNDS'", "'SOURCE'", "'SQL_AFTER_GTIDS'", "'SQL_AFTER_MTS_GAPS'", 
      "'SQL_BEFORE_GTIDS'", "'SQL_BUFFER_RESULT'", "'SQL_CACHE'", "'SQL_NO_CACHE'", 
      "'SQL_THREAD'", "'START'", "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'", 
      "'STATS_SAMPLE_PAGES'", "'STATUS'", "'STOP'", "'STORAGE'", "'STORED'", 
      "'STRING'", "'SUBCLASS_ORIGIN'", "'SUBJECT'", "'SUBPARTITION'", "'SUBPARTITIONS'", 
      "'SUSPEND'", "'SWAPS'", "'SWITCHES'", "'TABLE_NAME'", "'TABLESPACE'", 
      "'TABLE_TYPE'", "'TEMPORARY'", "'TEMPTABLE'", "'THAN'", "'TRADITIONAL'", 
      "'TRANSACTION'", "'TRANSACTIONAL'", "'TRIGGERS'", "'TRUNCATE'", "'UNBOUNDED'", 
      "'UNDEFINED'", "'UNDOFILE'", "'UNDO_BUFFER_SIZE'", "'UNINSTALL'", 
      "'UNKNOWN'", "'UNTIL'", "'UPGRADE'", "'USER'", "'USE_FRM'", "'USER_RESOURCES'", 
      "'VALIDATION'", "'VALUE'", "'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", 
      "'WAIT'", "'WARNINGS'", "'WINDOW'", "'WITHOUT'", "'WORK'", "'WRAPPER'", 
      "'X509'", "'XA'", "'XML'", "'YES'", "'EUR'", "'USA'", "'JIS'", "'ISO'", 
      "'INTERNAL'", "'QUARTER'", "'MONTH'", "'DAY'", "'HOUR'", "'MINUTE'", 
      "'WEEK'", "'SECOND'", "'MICROSECOND'", "'ADMIN'", "'APPLICATION_PASSWORD_ADMIN'", 
      "'AUDIT_ABORT_EXEMPT'", "'AUDIT_ADMIN'", "'AUTHENTICATION_POLICY_ADMIN'", 
      "'BACKUP_ADMIN'", "'BINLOG_ADMIN'", "'BINLOG_ENCRYPTION_ADMIN'", "'CLONE_ADMIN'", 
      "'CONNECTION_ADMIN'", "'ENCRYPTION_KEY_ADMIN'", "'EXECUTE'", "'FILE'", 
      "'FIREWALL_ADMIN'", "'FIREWALL_EXEMPT'", "'FIREWALL_USER'", "'FLUSH_OPTIMIZER_COSTS'", 
      "'FLUSH_STATUS'", "'FLUSH_TABLES'", "'FLUSH_USER_RESOURCES'", "'GROUP_REPLICATION_ADMIN'", 
      "'INNODB_REDO_LOG_ARCHIVE'", "'INNODB_REDO_LOG_ENABLE'", "'INVOKE'", 
      "'LAMBDA'", "'NDB_STORED_USER'", "'PASSWORDLESS_USER_ADMIN'", "'PERSIST_RO_VARIABLES_ADMIN'", 
      "'PRIVILEGES'", "'PROCESS'", "'RELOAD'", "'REPLICATION_APPLIER'", 
      "'REPLICATION_SLAVE_ADMIN'", "'RESOURCE_GROUP_ADMIN'", "'RESOURCE_GROUP_USER'", 
      "'ROLE_ADMIN'", "'ROUTINE'", "'S3'", "'SERVICE_CONNECTION_ADMIN'", 
      "", "'SET_USER_ID'", "'SHOW_ROUTINE'", "'SHUTDOWN'", "'SUPER'", "'SYSTEM_VARIABLES_ADMIN'", 
      "'TABLES'", "'TABLE_ENCRYPTION_ADMIN'", "'VERSION_TOKEN_ADMIN'", "'XA_RECOVER_ADMIN'", 
      "'ARMSCII8'", "'ASCII'", "'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", 
      "'CP1257'", "'CP850'", "'CP852'", "'CP866'", "'CP932'", "'DEC8'", 
      "'EUCJPMS'", "'EUCKR'", "'GB18030'", "'GB2312'", "'GBK'", "'GEOSTD8'", 
      "'GREEK'", "'HEBREW'", "'HP8'", "'KEYBCS2'", "'KOI8R'", "'KOI8U'", 
      "'LATIN1'", "'LATIN2'", "'LATIN5'", "'LATIN7'", "'MACCE'", "'MACROMAN'", 
      "'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'", "'UTF16'", "'UTF16LE'", 
      "'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'", "'ARCHIVE'", "'BLACKHOLE'", 
      "'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'", "'MRG_MYISAM'", "'MYISAM'", 
      "'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'", "'TOKUDB'", "'REPEATABLE'", 
      "'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'", "'GEOMETRYCOLLECTION'", 
      "'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'", "'MULTILINESTRING'", 
      "'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'", "'ABS'", 
      "'ACOS'", "'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'", 
      "'AREA'", "'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'", 
      "'ASYMMETRIC_DECRYPT'", "'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'", 
      "'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", "'ATAN'", "'ATAN2'", "'BENCHMARK'", 
      "'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", "'BUFFER'", "'CATALOG_NAME'", 
      "'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", "'CHARSET'", 
      "'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", "'CONCAT'", 
      "'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", "'COS'", 
      "'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'", 
      "'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'", 
      "'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'", 
      "'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'", 
      "'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENGINE_ATTRIBUTE'", 
      "'ENVELOPE'", "'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'", 
      "'EXTRACTVALUE'", "'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'", 
      "'FOUND_ROWS'", "'FROM_BASE64'", "'FROM_DAYS'", "'FROM_UNIXTIME'", 
      "'GEOMCOLLFROMTEXT'", "'GEOMCOLLFROMWKB'", "'GEOMETRYCOLLECTIONFROMTEXT'", 
      "'GEOMETRYCOLLECTIONFROMWKB'", "'GEOMETRYFROMTEXT'", "'GEOMETRYFROMWKB'", 
      "'GEOMETRYN'", "'GEOMETRYTYPE'", "'GEOMFROMTEXT'", "'GEOMFROMWKB'", 
      "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'", "'GREATEST'", "'GTID_SUBSET'", 
      "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'", "'INET6_ATON'", "'INET6_NTOA'", 
      "'INET_ATON'", "'INET_NTOA'", "'INSTR'", "'INTERIORRINGN'", "'INTERSECTS'", 
      "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'", "'ISSIMPLE'", "'IS_FREE_LOCK'", 
      "'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'", "'IS_IPV6'", 
      "'IS_USED_LOCK'", "'LAST_INSERT_ID'", "'LCASE'", "'LEAST'", "'LENGTH'", 
      "'LINEFROMTEXT'", "'LINEFROMWKB'", "'LINESTRINGFROMTEXT'", "'LINESTRINGFROMWKB'", 
      "'LN'", "'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'", "'LOG2'", "'LOWER'", 
      "'LPAD'", "'LTRIM'", "'MAKEDATE'", "'MAKETIME'", "'MAKE_SET'", "'MASTER_POS_WAIT'", 
      "'MBRCONTAINS'", "'MBRDISJOINT'", "'MBREQUAL'", "'MBRINTERSECTS'", 
      "'MBROVERLAPS'", "'MBRTOUCHES'", "'MBRWITHIN'", "'MD5'", "'MLINEFROMTEXT'", 
      "'MLINEFROMWKB'", "'MONTHNAME'", "'MPOINTFROMTEXT'", "'MPOINTFROMWKB'", 
      "'MPOLYFROMTEXT'", "'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'", 
      "'MULTILINESTRINGFROMWKB'", "'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'", 
      "'MULTIPOLYGONFROMTEXT'", "'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", 
      "'NULLIF'", "'NUMGEOMETRIES'", "'NUMINTERIORRINGS'", "'NUMPOINTS'", 
      "'OCT'", "'OCTET_LENGTH'", "'ORD'", "'OVERLAPS'", "'PERIOD_ADD'", 
      "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'", "'POINTFROMWKB'", "'POINTN'", 
      "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'", "'POLYGONFROMWKB'", 
      "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'", "'RANDOM_BYTES'", 
      "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'", "'ROW_COUNT'", "'RPAD'", 
      "'RTRIM'", "'SEC_TO_TIME'", "'SECONDARY_ENGINE_ATTRIBUTE'", "'SESSION_USER'", 
      "'SHA'", "'SHA1'", "'SHA2'", "'SCHEMA_NAME'", "'SIGN'", "'SIN'", "'SLEEP'", 
      "'SOUNDEX'", "'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'", "'SRID'", 
      "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'", "'ST_ASBINARY'", 
      "'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'", "'ST_CENTROID'", 
      "'ST_CONTAINS'", "'ST_CROSSES'", "'ST_DIFFERENCE'", "'ST_DIMENSION'", 
      "'ST_DISJOINT'", "'ST_DISTANCE'", "'ST_ENDPOINT'", "'ST_ENVELOPE'", 
      "'ST_EQUALS'", "'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'", "'ST_GEOMCOLLFROMTXT'", 
      "'ST_GEOMCOLLFROMWKB'", "'ST_GEOMETRYCOLLECTIONFROMTEXT'", "'ST_GEOMETRYCOLLECTIONFROMWKB'", 
      "'ST_GEOMETRYFROMTEXT'", "'ST_GEOMETRYFROMWKB'", "'ST_GEOMETRYN'", 
      "'ST_GEOMETRYTYPE'", "'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'", "'ST_INTERIORRINGN'", 
      "'ST_INTERSECTION'", "'ST_INTERSECTS'", "'ST_ISCLOSED'", "'ST_ISEMPTY'", 
      "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", "'ST_LINEFROMWKB'", "'ST_LINESTRINGFROMTEXT'", 
      "'ST_LINESTRINGFROMWKB'", "'ST_NUMGEOMETRIES'", "'ST_NUMINTERIORRING'", 
      "'ST_NUMINTERIORRINGS'", "'ST_NUMPOINTS'", "'ST_OVERLAPS'", "'ST_POINTFROMTEXT'", 
      "'ST_POINTFROMWKB'", "'ST_POINTN'", "'ST_POLYFROMTEXT'", "'ST_POLYFROMWKB'", 
      "'ST_POLYGONFROMTEXT'", "'ST_POLYGONFROMWKB'", "'ST_SRID'", "'ST_STARTPOINT'", 
      "'ST_SYMDIFFERENCE'", "'ST_TOUCHES'", "'ST_UNION'", "'ST_WITHIN'", 
      "'ST_X'", "'ST_Y'", "'SUBDATE'", "'SUBSTRING_INDEX'", "'SUBTIME'", 
      "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", "'TIMESTAMPADD'", "'TIMESTAMPDIFF'", 
      "'TIME_FORMAT'", "'TIME_TO_SEC'", "'TOUCHES'", "'TO_BASE64'", "'TO_DAYS'", 
      "'TO_SECONDS'", "'TP_CONNECTION_ADMIN'", "'UCASE'", "'UNCOMPRESS'", 
      "'UNCOMPRESSED_LENGTH'", "'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'", 
      "'UPPER'", "'UUID'", "'UUID_SHORT'", "'VALIDATE_PASSWORD_STRENGTH'", 
      "'VERSION'", "'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'", "'WEEKDAY'", "'WEEKOFYEAR'", 
      "'WEIGHT_STRING'", "'WITHIN'", "'YEARWEEK'", "'Y'", "'X'", "':='", 
      "'+='", "'-='", "'*='", "'/='", "'%='", "'&='", "'^='", "'|='", "'*'", 
      "'/'", "'%'", "'+'", "'-'", "'DIV'", "'MOD'", "'='", "'>'", "'<'", 
      "'!'", "'~'", "'|'", "'&'", "'^'", "'.'", "'('", "')'", "','", "';'", 
      "'@'", "'0'", "'1'", "'2'", "'''", "'\"'", "'`'", "':'"
    },
    std::vector<std::string>{
      "", "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT", 
      "ADD", "ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "ARRAY", "AS", 
      "ASC", "ATTRIBUTE", "BEFORE", "BETWEEN", "BOTH", "BUCKETS", "BY", 
      "CALL", "CASCADE", "CASE", "CAST", "CHANGE", "CHARACTER", "CHECK", 
      "COLLATE", "COLUMN", "CONDITION", "CONSTRAINT", "CONTINUE", "CONVERT", 
      "CREATE", "CROSS", "CURRENT", "CURRENT_ROLE", "CURRENT_USER", "CURSOR", 
      "DATABASE", "DATABASES", "DECLARE", "DEFAULT", "DELAYED", "DELETE", 
      "DESC", "DESCRIBE", "DETERMINISTIC", "DIAGNOSTICS", "DISTINCT", "DISTINCTROW", 
      "DROP", "EACH", "ELSE", "ELSEIF", "EMPTY", "ENCLOSED", "ENFORCED", 
      "ESCAPED", "EXCEPT", "EXISTS", "EXIT", "EXPLAIN", "FALSE", "FETCH", 
      "FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", "GENERATED", "GET", 
      "GRANT", "GROUP", "HAVING", "HIGH_PRIORITY", "HISTOGRAM", "IF", "IGNORE", 
      "IGNORED", "IN", "INDEX", "INFILE", "INNER", "INOUT", "INSERT", "INTERVAL", 
      "INTO", "IS", "ITERATE", "JOIN", "KEY", "KEYS", "KILL", "LATERAL", 
      "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR", "LINES", "LOAD", 
      "LOCK", "LOCKED", "LOOP", "LOW_PRIORITY", "MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT", 
      "MATCH", "MAXVALUE", "MINVALUE", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG", 
      "NULL_LITERAL", "NUMBER", "ON", "OPTIMIZE", "OPTION", "OPTIONAL", 
      "OPTIONALLY", "OR", "ORDER", "OUT", "OUTER", "OUTFILE", "OVER", "PARTITION", 
      "PRIMARY", "PROCEDURE", "PURGE", "RANGE", "READ", "READS", "REFERENCES", 
      "REGEXP", "RELEASE", "RENAME", "REPEAT", "REPLACE", "REQUIRE", "RESIGNAL", 
      "RESTRICT", "RETAIN", "RETURN", "REVOKE", "RIGHT", "RLIKE", "SCHEMA", 
      "SCHEMAS", "SELECT", "SET", "SEPARATOR", "SHOW", "SIGNAL", "SKIP_", 
      "SKIP_QUERY_REWRITE", "SPATIAL", "SQL", "SQLEXCEPTION", "SQLSTATE", 
      "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT", 
      "SSL", "STACKED", "STARTING", "STATEMENT", "STRAIGHT_JOIN", "TABLE", 
      "TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", "TRUE", "UNDO", 
      "UNION", "UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE", "USE", 
      "USING", "VALUES", "WHEN", "WHERE", "WHILE", "WITH", "WRITE", "XOR", 
      "ZEROFILL", "TINYINT", "SMALLINT", "MEDIUMINT", "MIDDLEINT", "INT", 
      "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER", "BIGINT", "REAL", 
      "DOUBLE", "PRECISION", "FLOAT", "FLOAT4", "FLOAT8", "DECIMAL", "DEC", 
      "NUMERIC", "DATE", "TIME", "TIMESTAMP", "DATETIME", "YEAR", "CHAR", 
      "VARCHAR", "NVARCHAR", "NATIONAL", "BINARY", "VARBINARY", "TINYBLOB", 
      "BLOB", "MEDIUMBLOB", "LONG", "LONGBLOB", "TINYTEXT", "TEXT", "MEDIUMTEXT", 
      "LONGTEXT", "ENUM", "VARYING", "SERIAL", "YEAR_MONTH", "DAY_HOUR", 
      "DAY_MINUTE", "DAY_SECOND", "HOUR_MINUTE", "HOUR_SECOND", "MINUTE_SECOND", 
      "SECOND_MICROSECOND", "MINUTE_MICROSECOND", "HOUR_MICROSECOND", "DAY_MICROSECOND", 
      "JSON_ARRAY", "JSON_ARRAYAGG", "JSON_ARRAY_APPEND", "JSON_ARRAY_INSERT", 
      "JSON_CONTAINS", "JSON_CONTAINS_PATH", "JSON_DEPTH", "JSON_EXTRACT", 
      "JSON_INSERT", "JSON_KEYS", "JSON_LENGTH", "JSON_MERGE", "JSON_MERGE_PATCH", 
      "JSON_MERGE_PRESERVE", "JSON_OBJECT", "JSON_OBJECTAGG", "JSON_OVERLAPS", 
      "JSON_PRETTY", "JSON_QUOTE", "JSON_REMOVE", "JSON_REPLACE", "JSON_SCHEMA_VALID", 
      "JSON_SCHEMA_VALIDATION_REPORT", "JSON_SEARCH", "JSON_SET", "JSON_STORAGE_FREE", 
      "JSON_STORAGE_SIZE", "JSON_TABLE", "JSON_TYPE", "JSON_UNQUOTE", "JSON_VALID", 
      "JSON_VALUE", "NESTED", "ORDINALITY", "PATH", "AVG", "BIT_AND", "BIT_OR", 
      "BIT_XOR", "COUNT", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "GROUP_CONCAT", 
      "LAG", "LAST_VALUE", "LEAD", "MAX", "MIN", "NTILE", "NTH_VALUE", "PERCENT_RANK", 
      "RANK", "ROW_NUMBER", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", 
      "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE", "CURRENT_DATE", "CURRENT_TIME", 
      "CURRENT_TIMESTAMP", "LOCALTIME", "CURDATE", "CURTIME", "DATE_ADD", 
      "DATE_SUB", "EXTRACT", "LOCALTIMESTAMP", "NOW", "POSITION", "SUBSTR", 
      "SUBSTRING", "SYSDATE", "TRIM", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", 
      "ACCOUNT", "ACTION", "AFTER", "AGGREGATE", "ALGORITHM", "ANY", "AT", 
      "AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE", "AUTO_INCREMENT", "AVG_ROW_LENGTH", 
      "BEGIN", "BINLOG", "BIT", "BLOCK", "BOOL", "BOOLEAN", "BTREE", "CACHE", 
      "CASCADED", "CHAIN", "CHANGED", "CHANNEL", "CHECKSUM", "PAGE_CHECKSUM", 
      "CIPHER", "CLASS_ORIGIN", "CLIENT", "CLOSE", "CLUSTERING", "COALESCE", 
      "CODE", "COLUMNS", "COLUMN_FORMAT", "COLUMN_NAME", "COMMENT", "COMMIT", 
      "COMPACT", "COMPLETION", "COMPRESSED", "COMPRESSION", "CONCURRENT", 
      "CONNECT", "CONNECTION", "CONSISTENT", "CONSTRAINT_CATALOG", "CONSTRAINT_SCHEMA", 
      "CONSTRAINT_NAME", "CONTAINS", "CONTEXT", "CONTRIBUTORS", "COPY", 
      "CPU", "CYCLE", "CURSOR_NAME", "DATA", "DATAFILE", "DEALLOCATE", "DEFAULT_AUTH", 
      "DEFINER", "DELAY_KEY_WRITE", "DES_KEY_FILE", "DIRECTORY", "DISABLE", 
      "DISCARD", "DISK", "DO", "DUMPFILE", "DUPLICATE", "DYNAMIC", "ENABLE", 
      "ENCRYPTED", "ENCRYPTION", "ENCRYPTION_KEY_ID", "END", "ENDS", "ENGINE", 
      "ENGINES", "ERROR", "ERRORS", "ESCAPE", "EVEN", "EVENT", "EVENTS", 
      "EVERY", "EXCHANGE", "EXCLUSIVE", "EXPIRE", "EXPORT", "EXTENDED", 
      "EXTENT_SIZE", "FAILED_LOGIN_ATTEMPTS", "FAST", "FAULTS", "FIELDS", 
      "FILE_BLOCK_SIZE", "FILTER", "FIRST", "FIXED", "FLUSH", "FOLLOWING", 
      "FOLLOWS", "FOUND", "FULL", "FUNCTION", "GENERAL", "GLOBAL", "GRANTS", 
      "GROUP_REPLICATION", "HANDLER", "HASH", "HELP", "HISTORY", "HOST", 
      "HOSTS", "IDENTIFIED", "IGNORE_SERVER_IDS", "IMPORT", "INCREMENT", 
      "INDEXES", "INITIAL_SIZE", "INPLACE", "INSERT_METHOD", "INSTALL", 
      "INSTANCE", "INSTANT", "INVISIBLE", "INVOKER", "IO", "IO_THREAD", 
      "IPC", "ISOLATION", "ISSUER", "JSON", "KEY_BLOCK_SIZE", "LANGUAGE", 
      "LAST", "LEAVES", "LESS", "LEVEL", "LIST", "LOCAL", "LOGFILE", "LOGS", 
      "MASTER", "MASTER_AUTO_POSITION", "MASTER_CONNECT_RETRY", "MASTER_DELAY", 
      "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST", "MASTER_LOG_FILE", "MASTER_LOG_POS", 
      "MASTER_PASSWORD", "MASTER_PORT", "MASTER_RETRY_COUNT", "MASTER_SSL", 
      "MASTER_SSL_CA", "MASTER_SSL_CAPATH", "MASTER_SSL_CERT", "MASTER_SSL_CIPHER", 
      "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", "MASTER_SSL_KEY", "MASTER_TLS_VERSION", 
      "MASTER_USER", "MAX_CONNECTIONS_PER_HOUR", "MAX_QUERIES_PER_HOUR", 
      "MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS", 
      "MEDIUM", "MEMBER", "MERGE", "MESSAGE_TEXT", "MID", "MIGRATE", "MIN_ROWS", 
      "MODE", "MODIFY", "MUTEX", "MYSQL", "MYSQL_ERRNO", "NAME", "NAMES", 
      "NCHAR", "NEVER", "NEXT", "NO", "NOCACHE", "NOCOPY", "NOCYCLE", "NOMAXVALUE", 
      "NOMINVALUE", "NOWAIT", "NODEGROUP", "NONE", "ODBC", "OFFLINE", "OFFSET", 
      "OF", "OJ", "OLD_PASSWORD", "ONE", "ONLINE", "ONLY", "OPEN", "OPTIMIZER_COSTS", 
      "OPTIONS", "OWNER", "PACK_KEYS", "PAGE", "PAGE_COMPRESSED", "PAGE_COMPRESSION_LEVEL", 
      "PARSER", "PARTIAL", "PARTITIONING", "PARTITIONS", "PASSWORD", "PASSWORD_LOCK_TIME", 
      "PHASE", "PLUGIN", "PLUGIN_DIR", "PLUGINS", "PORT", "PRECEDES", "PRECEDING", 
      "PREPARE", "PRESERVE", "PREV", "PROCESSLIST", "PROFILE", "PROFILES", 
      "PROXY", "QUERY", "QUICK", "REBUILD", "RECOVER", "RECURSIVE", "REDO_BUFFER_SIZE", 
      "REDUNDANT", "RELAY", "RELAY_LOG_FILE", "RELAY_LOG_POS", "RELAYLOG", 
      "REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB", "REPLICATE_DO_TABLE", 
      "REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE", "REPLICATE_REWRITE_DB", 
      "REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE", "REPLICATION", 
      "RESET", "RESTART", "RESUME", "RETURNED_SQLSTATE", "RETURNING", "RETURNS", 
      "REUSE", "ROLE", "ROLLBACK", "ROLLUP", "ROTATE", "ROW", "ROWS", "ROW_FORMAT", 
      "RTREE", "SAVEPOINT", "SCHEDULE", "SECURITY", "SEQUENCE", "SERVER", 
      "SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE", "SLAVE", "SLOW", 
      "SNAPSHOT", "SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE", "SQL_AFTER_GTIDS", 
      "SQL_AFTER_MTS_GAPS", "SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT", "SQL_CACHE", 
      "SQL_NO_CACHE", "SQL_THREAD", "START", "STARTS", "STATS_AUTO_RECALC", 
      "STATS_PERSISTENT", "STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", 
      "STORED", "STRING", "SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", 
      "SUBPARTITIONS", "SUSPEND", "SWAPS", "SWITCHES", "TABLE_NAME", "TABLESPACE", 
      "TABLE_TYPE", "TEMPORARY", "TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", 
      "TRANSACTIONAL", "TRIGGERS", "TRUNCATE", "UNBOUNDED", "UNDEFINED", 
      "UNDOFILE", "UNDO_BUFFER_SIZE", "UNINSTALL", "UNKNOWN", "UNTIL", "UPGRADE", 
      "USER", "USE_FRM", "USER_RESOURCES", "VALIDATION", "VALUE", "VARIABLES", 
      "VIEW", "VIRTUAL", "VISIBLE", "WAIT", "WARNINGS", "WINDOW", "WITHOUT", 
      "WORK", "WRAPPER", "X509", "XA", "XML", "YES", "EUR", "USA", "JIS", 
      "ISO", "INTERNAL", "QUARTER", "MONTH", "DAY", "HOUR", "MINUTE", "WEEK", 
      "SECOND", "MICROSECOND", "ADMIN", "APPLICATION_PASSWORD_ADMIN", "AUDIT_ABORT_EXEMPT", 
      "AUDIT_ADMIN", "AUTHENTICATION_POLICY_ADMIN", "BACKUP_ADMIN", "BINLOG_ADMIN", 
      "BINLOG_ENCRYPTION_ADMIN", "CLONE_ADMIN", "CONNECTION_ADMIN", "ENCRYPTION_KEY_ADMIN", 
      "EXECUTE", "FILE", "FIREWALL_ADMIN", "FIREWALL_EXEMPT", "FIREWALL_USER", 
      "FLUSH_OPTIMIZER_COSTS", "FLUSH_STATUS", "FLUSH_TABLES", "FLUSH_USER_RESOURCES", 
      "GROUP_REPLICATION_ADMIN", "INNODB_REDO_LOG_ARCHIVE", "INNODB_REDO_LOG_ENABLE", 
      "INVOKE", "LAMBDA", "NDB_STORED_USER", "PASSWORDLESS_USER_ADMIN", 
      "PERSIST_RO_VARIABLES_ADMIN", "PRIVILEGES", "PROCESS", "RELOAD", "REPLICATION_APPLIER", 
      "REPLICATION_SLAVE_ADMIN", "RESOURCE_GROUP_ADMIN", "RESOURCE_GROUP_USER", 
      "ROLE_ADMIN", "ROUTINE", "S3", "SERVICE_CONNECTION_ADMIN", "SESSION_VARIABLES_ADMIN", 
      "SET_USER_ID", "SHOW_ROUTINE", "SHUTDOWN", "SUPER", "SYSTEM_VARIABLES_ADMIN", 
      "TABLES", "TABLE_ENCRYPTION_ADMIN", "VERSION_TOKEN_ADMIN", "XA_RECOVER_ADMIN", 
      "ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256", "CP1257", 
      "CP850", "CP852", "CP866", "CP932", "DEC8", "EUCJPMS", "EUCKR", "GB18030", 
      "GB2312", "GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", "KOI8R", 
      "KOI8U", "LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN", 
      "SJIS", "SWE7", "TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32", 
      "UTF8", "UTF8MB3", "UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED", 
      "INNODB", "MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA", 
      "TOKUDB", "REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE", 
      "GEOMETRYCOLLECTION", "GEOMCOLLECTION", "GEOMETRY", "LINESTRING", 
      "MULTILINESTRING", "MULTIPOINT", "MULTIPOLYGON", "POINT", "POLYGON", 
      "ABS", "ACOS", "ADDDATE", "ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", 
      "AREA", "ASBINARY", "ASIN", "ASTEXT", "ASWKB", "ASWKT", "ASYMMETRIC_DECRYPT", 
      "ASYMMETRIC_DERIVE", "ASYMMETRIC_ENCRYPT", "ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", 
      "ATAN", "ATAN2", "BENCHMARK", "BIN", "BIT_COUNT", "BIT_LENGTH", "BUFFER", 
      "CATALOG_NAME", "CEIL", "CEILING", "CENTROID", "CHARACTER_LENGTH", 
      "CHARSET", "CHAR_LENGTH", "COERCIBILITY", "COLLATION", "COMPRESS", 
      "CONCAT", "CONCAT_WS", "CONNECTION_ID", "CONV", "CONVERT_TZ", "COS", 
      "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY", "CREATE_ASYMMETRIC_PUB_KEY", 
      "CREATE_DH_PARAMETERS", "CREATE_DIGEST", "CROSSES", "DATEDIFF", "DATE_FORMAT", 
      "DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "DECODE", "DEGREES", 
      "DES_DECRYPT", "DES_ENCRYPT", "DIMENSION", "DISJOINT", "ELT", "ENCODE", 
      "ENCRYPT", "ENDPOINT", "ENGINE_ATTRIBUTE", "ENVELOPE", "EQUALS", "EXP", 
      "EXPORT_SET", "EXTERIORRING", "EXTRACTVALUE", "FIELD", "FIND_IN_SET", 
      "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64", "FROM_DAYS", "FROM_UNIXTIME", 
      "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB", "GEOMETRYCOLLECTIONFROMTEXT", 
      "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT", "GEOMETRYFROMWKB", 
      "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB", "GET_FORMAT", 
      "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT", 
      "HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA", 
      "INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL", 
      "ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED", 
      "IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH", 
      "LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB", 
      "LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", 
      "LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS", 
      "MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES", 
      "MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", 
      "MPOINTFROMTEXT", "MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", 
      "MULTILINESTRINGFROMTEXT", "MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", 
      "MULTIPOINTFROMWKB", "MULTIPOLYGONFROMTEXT", "MULTIPOLYGONFROMWKB", 
      "NAME_CONST", "NULLIF", "NUMGEOMETRIES", "NUMINTERIORRINGS", "NUMPOINTS", 
      "OCT", "OCTET_LENGTH", "ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", 
      "PI", "POINTFROMTEXT", "POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", 
      "POLYGONFROMTEXT", "POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", 
      "RAND", "RANDOM_BYTES", "RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT", 
      "RPAD", "RTRIM", "SEC_TO_TIME", "SECONDARY_ENGINE_ATTRIBUTE", "SESSION_USER", 
      "SHA", "SHA1", "SHA2", "SCHEMA_NAME", "SIGN", "SIN", "SLEEP", "SOUNDEX", 
      "SQL_THREAD_WAIT_AFTER_GTIDS", "SQRT", "SRID", "STARTPOINT", "STRCMP", 
      "STR_TO_DATE", "ST_AREA", "ST_ASBINARY", "ST_ASTEXT", "ST_ASWKB", 
      "ST_ASWKT", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS", "ST_CROSSES", 
      "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_ENDPOINT", 
      "ST_ENVELOPE", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT", 
      "ST_GEOMCOLLFROMTXT", "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT", 
      "ST_GEOMETRYCOLLECTIONFROMWKB", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB", 
      "ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB", 
      "ST_INTERIORRINGN", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED", 
      "ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", "ST_LINEFROMWKB", 
      "ST_LINESTRINGFROMTEXT", "ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", 
      "ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS", "ST_NUMPOINTS", "ST_OVERLAPS", 
      "ST_POINTFROMTEXT", "ST_POINTFROMWKB", "ST_POINTN", "ST_POLYFROMTEXT", 
      "ST_POLYFROMWKB", "ST_POLYGONFROMTEXT", "ST_POLYGONFROMWKB", "ST_SRID", 
      "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_TOUCHES", "ST_UNION", "ST_WITHIN", 
      "ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX", "SUBTIME", "SYSTEM_USER", 
      "TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIME_FORMAT", 
      "TIME_TO_SEC", "TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS", "TP_CONNECTION_ADMIN", 
      "UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP", 
      "UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH", 
      "VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR", 
      "WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", "X_FUNCTION", 
      "VAR_ASSIGN", "PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", 
      "MOD_ASSIGN", "AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE", 
      "MODULE", "PLUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", 
      "LESS_SYMBOL", "EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", 
      "BIT_XOR_OP", "DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", 
      "AT_SIGN", "ZERO_DECIMAL", "ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB", 
      "DOUBLE_QUOTE_SYMB", "REVERSE_QUOTE_SYMB", "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING", 
      "FILESIZE_LITERAL", "START_NATIONAL_STRING_LITERAL", "STRING_LITERAL", 
      "DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL", 
      "BIT_STRING", "STRING_CHARSET_NAME", "DOT_ID", "ID", "REVERSE_QUOTE_ID", 
      "STRING_USER_NAME", "IP_ADDRESS", "LOCAL_ID", "GLOBAL_ID", "ERROR_RECONGNIGION"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,1161,7385,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,
  	7,152,2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,
  	7,158,2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
  	7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,
  	7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,
  	7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,2,181,7,181,2,182,
  	7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,7,186,2,187,7,187,2,188,
  	7,188,2,189,7,189,2,190,7,190,2,191,7,191,2,192,7,192,2,193,7,193,2,194,
  	7,194,2,195,7,195,2,196,7,196,2,197,7,197,2,198,7,198,2,199,7,199,2,200,
  	7,200,2,201,7,201,2,202,7,202,2,203,7,203,2,204,7,204,2,205,7,205,2,206,
  	7,206,2,207,7,207,2,208,7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,
  	7,212,2,213,7,213,2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,
  	7,218,2,219,7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,
  	7,224,2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
  	7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,2,236,
  	7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,7,241,2,242,
  	7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,2,247,7,247,2,248,
  	7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,7,252,2,253,7,253,2,254,
  	7,254,2,255,7,255,2,256,7,256,2,257,7,257,2,258,7,258,2,259,7,259,2,260,
  	7,260,2,261,7,261,2,262,7,262,2,263,7,263,2,264,7,264,2,265,7,265,2,266,
  	7,266,2,267,7,267,2,268,7,268,2,269,7,269,2,270,7,270,2,271,7,271,2,272,
  	7,272,2,273,7,273,2,274,7,274,2,275,7,275,2,276,7,276,2,277,7,277,2,278,
  	7,278,2,279,7,279,2,280,7,280,2,281,7,281,2,282,7,282,2,283,7,283,2,284,
  	7,284,2,285,7,285,2,286,7,286,2,287,7,287,2,288,7,288,2,289,7,289,2,290,
  	7,290,2,291,7,291,2,292,7,292,2,293,7,293,2,294,7,294,2,295,7,295,2,296,
  	7,296,2,297,7,297,2,298,7,298,2,299,7,299,2,300,7,300,2,301,7,301,2,302,
  	7,302,2,303,7,303,2,304,7,304,2,305,7,305,2,306,7,306,2,307,7,307,2,308,
  	7,308,2,309,7,309,2,310,7,310,2,311,7,311,2,312,7,312,2,313,7,313,2,314,
  	7,314,2,315,7,315,2,316,7,316,2,317,7,317,2,318,7,318,2,319,7,319,2,320,
  	7,320,2,321,7,321,2,322,7,322,2,323,7,323,2,324,7,324,2,325,7,325,2,326,
  	7,326,2,327,7,327,2,328,7,328,2,329,7,329,2,330,7,330,2,331,7,331,2,332,
  	7,332,2,333,7,333,2,334,7,334,2,335,7,335,2,336,7,336,2,337,7,337,2,338,
  	7,338,2,339,7,339,2,340,7,340,2,341,7,341,2,342,7,342,2,343,7,343,2,344,
  	7,344,2,345,7,345,2,346,7,346,2,347,7,347,2,348,7,348,2,349,7,349,2,350,
  	7,350,2,351,7,351,2,352,7,352,2,353,7,353,2,354,7,354,1,0,3,0,712,8,0,
  	1,0,1,0,3,0,716,8,0,1,0,1,0,1,1,1,1,1,1,3,1,723,8,1,1,1,3,1,726,8,1,1,
  	1,5,1,729,8,1,10,1,12,1,732,9,1,1,1,1,1,1,1,3,1,737,8,1,1,1,3,1,740,8,
  	1,1,1,3,1,743,8,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,752,8,2,1,3,1,3,1,4,
  	1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,
  	4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,
  	1,4,1,4,3,4,794,8,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,
  	5,3,5,809,8,5,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,3,6,820,8,6,1,7,1,7,
  	1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,837,8,7,1,8,1,
  	8,1,8,3,8,842,8,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,3,9,854,8,9,
  	1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,
  	1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,3,10,881,8,10,
  	1,11,1,11,1,11,1,11,1,11,1,11,1,11,3,11,890,8,11,1,12,1,12,1,12,3,12,
  	895,8,12,1,12,1,12,5,12,899,8,12,10,12,12,12,902,9,12,1,13,1,13,3,13,
  	906,8,13,1,13,1,13,3,13,910,8,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,3,
  	13,919,8,13,1,13,3,13,922,8,13,1,13,3,13,925,8,13,1,13,1,13,3,13,929,
  	8,13,1,13,1,13,1,13,1,14,1,14,3,14,936,8,14,1,14,3,14,939,8,14,1,14,1,
  	14,1,14,3,14,944,8,14,1,14,1,14,1,14,1,14,5,14,950,8,14,10,14,12,14,953,
  	9,14,1,14,1,14,3,14,957,8,14,1,14,1,14,1,14,3,14,962,8,14,1,14,5,14,965,
  	8,14,10,14,12,14,968,9,14,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,
  	3,15,979,8,15,1,15,3,15,982,8,15,1,15,1,15,3,15,986,8,15,1,15,3,15,989,
  	8,15,1,15,1,15,3,15,993,8,15,1,15,3,15,996,8,15,1,15,1,15,3,15,1000,8,
  	15,1,15,3,15,1003,8,15,1,15,3,15,1006,8,15,1,15,1,15,3,15,1010,8,15,1,
  	15,3,15,1013,8,15,1,15,1,15,3,15,1017,8,15,1,15,1,15,1,16,1,16,3,16,1023,
  	8,16,1,16,1,16,1,16,1,16,3,16,1029,8,16,1,16,1,16,5,16,1033,8,16,10,16,
  	12,16,1036,9,16,1,16,1,16,5,16,1040,8,16,10,16,12,16,1043,9,16,1,16,1,
  	16,1,17,1,17,3,17,1049,8,17,1,17,3,17,1052,8,17,1,17,1,17,3,17,1056,8,
  	17,1,17,1,17,1,17,3,17,1061,8,17,1,17,1,17,5,17,1065,8,17,10,17,12,17,
  	1068,9,17,1,17,1,17,1,17,1,17,5,17,1074,8,17,10,17,12,17,1077,9,17,1,
  	17,1,17,3,17,1081,8,17,1,18,1,18,1,18,3,18,1086,8,18,1,18,1,18,1,18,5,
  	18,1091,8,18,10,18,12,18,1094,9,18,1,19,1,19,1,19,1,19,1,19,1,19,1,19,
  	1,19,1,19,1,19,1,19,1,19,5,19,1108,8,19,10,19,12,19,1111,9,19,1,19,1,
  	19,1,20,1,20,3,20,1117,8,20,1,20,1,20,3,20,1121,8,20,1,20,1,20,1,20,1,
  	20,1,20,1,20,1,20,1,20,3,20,1131,8,20,1,20,1,20,3,20,1135,8,20,1,20,1,
  	20,3,20,1139,8,20,1,20,1,20,3,20,1143,8,20,1,20,1,20,3,20,1147,8,20,1,
  	20,5,20,1150,8,20,10,20,12,20,1153,9,20,3,20,1155,8,20,1,20,3,20,1158,
  	8,20,1,20,3,20,1161,8,20,1,20,3,20,1164,8,20,1,20,1,20,1,20,1,20,3,20,
  	1170,8,20,1,20,1,20,3,20,1174,8,20,1,20,1,20,1,20,1,20,3,20,1180,8,20,
  	1,20,5,20,1183,8,20,10,20,12,20,1186,9,20,3,20,1188,8,20,1,20,3,20,1191,
  	8,20,3,20,1193,8,20,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,
  	1204,8,21,1,21,1,21,3,21,1208,8,21,1,21,3,21,1211,8,21,1,22,1,22,1,22,
  	1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,3,22,1225,8,22,1,22,3,22,
  	1228,8,22,1,22,1,22,3,22,1232,8,22,1,22,3,22,1235,8,22,1,22,1,22,3,22,
  	1239,8,22,1,22,3,22,1242,8,22,1,22,1,22,3,22,1246,8,22,1,22,3,22,1249,
  	8,22,1,22,1,22,3,22,1253,8,22,1,22,3,22,1256,8,22,1,22,3,22,1259,8,22,
  	1,22,1,22,3,22,1263,8,22,1,22,3,22,1266,8,22,1,22,1,22,3,22,1270,8,22,
  	1,22,1,22,1,23,1,23,3,23,1276,8,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,
  	1,23,1,23,1,23,1,23,3,23,1289,8,23,1,23,1,23,1,24,1,24,3,24,1295,8,24,
  	1,24,1,24,1,25,1,25,1,25,1,25,1,25,5,25,1304,8,25,10,25,12,25,1307,9,
  	25,1,25,1,25,3,25,1311,8,25,1,25,1,25,1,25,1,25,1,25,1,25,3,25,1319,8,
  	25,1,26,1,26,1,27,1,27,1,28,1,28,3,28,1327,8,28,1,28,1,28,1,28,3,28,1332,
  	8,28,1,28,3,28,1335,8,28,1,28,1,28,1,28,3,28,1340,8,28,1,28,1,28,1,28,
  	1,28,1,28,1,28,3,28,1348,8,28,1,28,1,28,1,28,3,28,1353,8,28,1,28,1,28,
  	1,28,1,28,3,28,1359,8,28,1,28,1,28,1,28,3,28,1364,8,28,1,28,1,28,3,28,
  	1368,8,28,3,28,1370,8,28,1,29,3,29,1373,8,29,1,29,1,29,3,29,1377,8,29,
  	1,29,1,29,3,29,1381,8,29,1,29,3,29,1384,8,29,1,29,1,29,3,29,1388,8,29,
  	1,29,1,29,3,29,1392,8,29,1,29,1,29,3,29,1396,8,29,1,29,1,29,1,29,1,29,
  	3,29,1402,8,29,1,29,3,29,1405,8,29,1,30,1,30,1,30,1,30,1,30,3,30,1412,
  	8,30,1,31,1,31,1,31,1,31,1,31,1,31,3,31,1420,8,31,3,31,1422,8,31,1,32,
  	1,32,1,32,5,32,1427,8,32,10,32,12,32,1430,9,32,1,32,1,32,1,32,3,32,1435,
  	8,32,1,32,1,32,1,32,1,32,5,32,1441,8,32,10,32,12,32,1444,9,32,3,32,1446,
  	8,32,1,32,1,32,1,32,5,32,1451,8,32,10,32,12,32,1454,9,32,3,32,1456,8,
  	32,3,32,1458,8,32,1,33,1,33,1,33,1,33,3,33,1464,8,33,1,34,1,34,1,34,1,
  	34,3,34,1470,8,34,1,34,1,34,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,
  	35,1,35,1,35,1,35,1,35,3,35,1487,8,35,1,36,1,36,1,36,1,36,1,36,3,36,1494,
  	8,36,1,37,1,37,1,37,1,38,1,38,3,38,1501,8,38,1,38,1,38,1,38,1,38,1,38,
  	1,38,1,38,1,38,1,38,1,38,3,38,1513,8,38,1,38,1,38,1,38,3,38,1518,8,38,
  	1,38,3,38,1521,8,38,1,39,3,39,1524,8,39,1,39,1,39,1,39,1,40,1,40,1,40,
  	1,41,1,41,1,41,1,41,1,41,3,41,1537,8,41,1,41,1,41,1,41,1,41,1,41,1,41,
  	1,41,1,41,1,41,1,41,1,41,3,41,1550,8,41,1,41,1,41,1,41,3,41,1555,8,41,
  	1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,
  	3,42,1571,8,42,1,43,1,43,1,43,1,43,5,43,1577,8,43,10,43,12,43,1580,9,
  	43,1,43,1,43,1,44,1,44,1,44,1,44,1,44,3,44,1589,8,44,1,44,3,44,1592,8,
  	44,1,44,3,44,1595,8,44,1,45,1,45,5,45,1599,8,45,10,45,12,45,1602,9,45,
  	1,45,3,45,1605,8,45,1,45,3,45,1608,8,45,1,46,1,46,1,46,1,46,1,46,1,46,
  	1,46,1,46,1,46,3,46,1619,8,46,1,46,3,46,1622,8,46,1,46,1,46,1,46,3,46,
  	1627,8,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,3,46,
  	1640,8,46,1,46,1,46,1,46,1,46,1,46,3,46,1647,8,46,1,46,1,46,1,46,1,46,
  	1,46,3,46,1654,8,46,3,46,1656,8,46,1,46,1,46,1,46,1,46,1,46,3,46,1663,
  	8,46,1,47,1,47,3,47,1667,8,47,3,47,1669,8,47,1,47,1,47,1,47,3,47,1674,
  	8,47,1,47,3,47,1677,8,47,1,47,1,47,5,47,1681,8,47,10,47,12,47,1684,9,
  	47,1,47,1,47,3,47,1688,8,47,3,47,1690,8,47,1,47,1,47,3,47,1694,8,47,1,
  	47,3,47,1697,8,47,1,47,3,47,1700,8,47,1,47,1,47,5,47,1704,8,47,10,47,
  	12,47,1707,9,47,1,47,1,47,3,47,1711,8,47,3,47,1713,8,47,1,47,1,47,1,47,
  	3,47,1718,8,47,1,47,1,47,1,47,1,47,1,47,3,47,1725,8,47,3,47,1727,8,47,
  	1,47,1,47,1,47,1,47,1,47,3,47,1734,8,47,1,48,1,48,1,48,3,48,1739,8,48,
  	1,48,1,48,3,48,1743,8,48,1,48,3,48,1746,8,48,1,49,1,49,1,49,1,49,1,49,
  	1,49,3,49,1754,8,49,1,49,1,49,1,49,1,49,1,49,1,49,3,49,1762,8,49,3,49,
  	1764,8,49,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,3,50,1774,8,50,1,51,
  	1,51,3,51,1778,8,51,1,51,3,51,1781,8,51,1,51,1,51,5,51,1785,8,51,10,51,
  	12,51,1788,9,51,1,51,1,51,3,51,1792,8,51,1,51,3,51,1795,8,51,1,51,1,51,
  	5,51,1799,8,51,10,51,12,51,1802,9,51,3,51,1804,8,51,1,52,1,52,3,52,1808,
  	8,52,1,52,3,52,1811,8,52,1,52,1,52,3,52,1815,8,52,1,52,1,52,1,52,3,52,
  	1820,8,52,1,52,1,52,1,52,3,52,1825,8,52,1,52,1,52,1,52,3,52,1830,8,52,
  	1,52,1,52,3,52,1834,8,52,1,52,1,52,3,52,1838,8,52,1,52,1,52,3,52,1842,
  	8,52,1,52,1,52,3,52,1846,8,52,1,52,1,52,3,52,1850,8,52,1,52,1,52,3,52,
  	1854,8,52,1,52,1,52,1,52,3,52,1859,8,52,1,52,1,52,1,52,3,52,1864,8,52,
  	1,52,1,52,1,52,3,52,1869,8,52,1,52,1,52,1,52,1,52,3,52,1875,8,52,1,52,
  	1,52,1,52,3,52,1880,8,52,1,52,1,52,1,52,3,52,1885,8,52,1,52,1,52,1,52,
  	3,52,1890,8,52,1,52,1,52,1,52,3,52,1895,8,52,1,52,1,52,1,52,3,52,1900,
  	8,52,1,52,1,52,1,52,1,52,3,52,1906,8,52,1,52,1,52,1,52,3,52,1911,8,52,
  	1,52,1,52,1,52,3,52,1916,8,52,1,52,1,52,1,52,3,52,1921,8,52,1,52,1,52,
  	1,52,3,52,1926,8,52,1,52,1,52,1,52,3,52,1931,8,52,1,52,1,52,1,52,3,52,
  	1936,8,52,1,52,1,52,1,52,3,52,1941,8,52,1,52,1,52,1,52,1,52,1,52,3,52,
  	1948,8,52,1,52,1,52,1,52,3,52,1953,8,52,1,52,1,52,1,52,3,52,1958,8,52,
  	1,52,1,52,1,52,3,52,1963,8,52,1,52,1,52,3,52,1967,8,52,1,52,1,52,1,52,
  	3,52,1972,8,52,1,52,1,52,1,52,1,52,1,52,1,52,3,52,1980,8,52,1,52,1,52,
  	1,52,3,52,1985,8,52,1,52,1,52,1,52,1,52,3,52,1991,8,52,1,53,1,53,1,54,
  	1,54,1,54,1,55,1,55,1,55,1,55,1,55,3,55,2003,8,55,1,55,1,55,1,55,1,55,
  	1,55,3,55,2010,8,55,3,55,2012,8,55,1,55,1,55,1,55,1,55,5,55,2018,8,55,
  	10,55,12,55,2021,9,55,1,55,1,55,3,55,2025,8,55,1,56,3,56,2028,8,56,1,
  	56,1,56,1,56,1,56,1,56,1,56,3,56,2036,8,56,1,56,1,56,1,56,1,56,3,56,2042,
  	8,56,1,56,1,56,3,56,2046,8,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,
  	1,56,1,56,1,56,3,56,2059,8,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,56,
  	1,56,1,56,3,56,2071,8,56,3,56,2073,8,56,1,57,3,57,2076,8,57,1,57,1,57,
  	1,57,1,57,1,57,1,57,3,57,2084,8,57,1,57,1,57,1,57,1,57,3,57,2090,8,57,
  	1,57,1,57,1,57,1,57,3,57,2096,8,57,1,58,1,58,1,58,1,58,1,58,1,58,1,58,
  	1,58,1,58,5,58,2107,8,58,10,58,12,58,2110,9,58,1,58,1,58,5,58,2114,8,
  	58,10,58,12,58,2117,9,58,1,58,1,58,1,58,1,58,5,58,2123,8,58,10,58,12,
  	58,2126,9,58,1,58,1,58,3,58,2130,8,58,1,58,1,58,1,58,1,58,1,58,1,58,1,
  	58,5,58,2139,8,58,10,58,12,58,2142,9,58,1,58,1,58,1,58,1,58,5,58,2148,
  	8,58,10,58,12,58,2151,9,58,1,58,1,58,3,58,2155,8,58,1,58,1,58,1,58,1,
  	58,1,58,1,58,1,58,1,58,5,58,2165,8,58,10,58,12,58,2168,9,58,1,58,1,58,
  	5,58,2172,8,58,10,58,12,58,2175,9,58,1,58,1,58,1,58,1,58,5,58,2181,8,
  	58,10,58,12,58,2184,9,58,1,58,1,58,3,58,2188,8,58,1,58,1,58,1,58,1,58,
  	1,58,1,58,1,58,1,58,5,58,2198,8,58,10,58,12,58,2201,9,58,1,58,1,58,5,
  	58,2205,8,58,10,58,12,58,2208,9,58,1,58,1,58,1,58,1,58,5,58,2214,8,58,
  	10,58,12,58,2217,9,58,1,58,1,58,3,58,2221,8,58,1,58,1,58,1,58,5,58,2226,
  	8,58,10,58,12,58,2229,9,58,1,58,1,58,1,58,1,58,5,58,2235,8,58,10,58,12,
  	58,2238,9,58,1,58,1,58,3,58,2242,8,58,3,58,2244,8,58,1,59,1,59,1,59,3,
  	59,2249,8,59,1,60,1,60,1,60,1,60,4,60,2255,8,60,11,60,12,60,2256,1,60,
  	1,60,1,61,1,61,1,61,5,61,2264,8,61,10,61,12,61,2267,9,61,1,62,3,62,2270,
  	8,62,1,62,3,62,2273,8,62,1,62,1,62,3,62,2277,8,62,1,62,1,62,1,62,3,62,
  	2282,8,62,1,62,1,62,1,62,1,62,3,62,2288,8,62,1,62,1,62,1,62,1,62,3,62,
  	2294,8,62,1,62,1,62,1,62,3,62,2299,8,62,1,62,1,62,1,62,3,62,2304,8,62,
  	1,62,1,62,1,62,3,62,2309,8,62,1,62,1,62,1,62,3,62,2314,8,62,1,62,3,62,
  	2317,8,62,1,63,1,63,1,63,3,63,2322,8,63,1,63,4,63,2325,8,63,11,63,12,
  	63,2326,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,3,63,2337,8,63,1,64,1,
  	64,3,64,2341,8,64,1,64,1,64,1,64,1,64,1,64,3,64,2348,8,64,1,64,1,64,1,
  	64,3,64,2353,8,64,1,64,3,64,2356,8,64,1,64,1,64,1,64,3,64,2361,8,64,1,
  	64,3,64,2364,8,64,1,64,1,64,3,64,2368,8,64,1,64,1,64,3,64,2372,8,64,1,
  	65,1,65,1,65,1,65,5,65,2378,8,65,10,65,12,65,2381,9,65,1,66,1,66,1,66,
  	1,66,1,66,1,66,1,66,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,3,67,
  	2399,8,67,1,67,3,67,2402,8,67,1,67,3,67,2405,8,67,1,67,1,67,3,67,2409,
  	8,67,1,67,1,67,1,68,1,68,1,68,1,68,5,68,2417,8,68,10,68,12,68,2420,9,
  	68,1,69,1,69,1,69,1,69,1,69,1,69,1,69,1,69,5,69,2430,8,69,10,69,12,69,
  	2433,9,69,1,69,1,69,1,70,1,70,3,70,2439,8,70,1,70,3,70,2442,8,70,1,70,
  	1,70,1,70,3,70,2447,8,70,1,70,1,70,1,70,5,70,2452,8,70,10,70,12,70,2455,
  	9,70,3,70,2457,8,70,1,70,3,70,2460,8,70,1,71,1,71,1,71,1,71,1,71,1,71,
  	1,71,1,71,1,71,3,71,2471,8,71,1,71,3,71,2474,8,71,1,71,1,71,3,71,2478,
  	8,71,1,71,1,71,1,72,1,72,1,72,1,72,3,72,2486,8,72,1,72,3,72,2489,8,72,
  	1,72,1,72,1,72,3,72,2494,8,72,1,72,1,72,1,72,1,72,1,72,1,72,3,72,2502,
  	8,72,1,72,1,72,1,72,1,72,3,72,2508,8,72,1,72,1,72,3,72,2512,8,72,1,73,
  	1,73,3,73,2516,8,73,1,73,5,73,2519,8,73,10,73,12,73,2522,9,73,1,73,1,
  	73,3,73,2526,8,73,1,73,1,73,1,73,1,73,1,73,3,73,2533,8,73,1,73,1,73,3,
  	73,2537,8,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,5,73,2546,8,73,10,73,
  	12,73,2549,9,73,1,73,1,73,1,73,1,73,1,73,3,73,2556,8,73,1,73,3,73,2559,
  	8,73,1,73,1,73,5,73,2563,8,73,10,73,12,73,2566,9,73,1,73,1,73,1,73,3,
  	73,2571,8,73,3,73,2573,8,73,1,73,1,73,1,73,3,73,2578,8,73,1,73,3,73,2581,
  	8,73,1,73,1,73,5,73,2585,8,73,10,73,12,73,2588,9,73,1,73,1,73,1,73,3,
  	73,2593,8,73,3,73,2595,8,73,1,73,1,73,3,73,2599,8,73,1,73,3,73,2602,8,
  	73,1,73,3,73,2605,8,73,1,73,1,73,5,73,2609,8,73,10,73,12,73,2612,9,73,
  	1,73,1,73,1,73,3,73,2617,8,73,1,73,3,73,2620,8,73,1,73,1,73,5,73,2624,
  	8,73,10,73,12,73,2627,9,73,1,73,1,73,1,73,3,73,2632,8,73,3,73,2634,8,
  	73,1,73,1,73,1,73,3,73,2639,8,73,1,73,1,73,1,73,1,73,1,73,1,73,3,73,2647,
  	8,73,3,73,2649,8,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,3,73,2658,8,73,
  	1,73,3,73,2661,8,73,1,73,3,73,2664,8,73,1,73,1,73,1,73,3,73,2669,8,73,
  	3,73,2671,8,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,3,73,2680,8,73,1,73,
  	3,73,2683,8,73,1,73,3,73,2686,8,73,1,73,1,73,1,73,3,73,2691,8,73,3,73,
  	2693,8,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,3,73,2702,8,73,1,73,1,73,
  	1,73,3,73,2707,8,73,1,73,1,73,1,73,1,73,1,73,1,73,3,73,2715,8,73,1,73,
  	1,73,3,73,2719,8,73,1,73,1,73,1,73,1,73,1,73,1,73,3,73,2727,8,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,1,73,1,73,3,73,2737,8,73,1,73,1,73,1,73,3,73,
  	2742,8,73,1,73,1,73,1,73,1,73,1,73,3,73,2749,8,73,1,73,1,73,3,73,2753,
  	8,73,1,73,1,73,3,73,2757,8,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,3,73,2776,8,73,1,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,1,73,3,73,2786,8,73,1,73,1,73,1,73,1,73,3,73,
  	2792,8,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,3,73,2809,8,73,1,73,1,73,3,73,2813,8,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,1,73,1,73,3,73,2823,8,73,1,73,1,73,1,73,3,73,2828,8,73,
  	1,73,3,73,2831,8,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,3,73,2840,8,73,
  	1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,3,73,2851,8,73,1,73,1,73,
  	1,73,1,73,5,73,2857,8,73,10,73,12,73,2860,9,73,1,73,1,73,1,73,3,73,2865,
  	8,73,1,74,1,74,1,74,1,74,1,74,1,74,5,74,2873,8,74,10,74,12,74,2876,9,
  	74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,2887,8,74,1,74,1,
  	74,1,74,1,74,1,74,3,74,2894,8,74,1,74,1,74,1,74,1,74,1,74,3,74,2901,8,
  	74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,5,74,2914,8,
  	74,10,74,12,74,2917,9,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,
  	1,74,3,74,2929,8,74,1,74,1,74,1,74,1,74,3,74,2935,8,74,1,74,1,74,1,74,
  	1,74,3,74,2941,8,74,1,74,1,74,1,74,1,74,3,74,2947,8,74,1,74,1,74,1,74,
  	1,74,3,74,2953,8,74,1,74,1,74,1,74,1,74,3,74,2959,8,74,1,74,1,74,1,74,
  	1,74,3,74,2965,8,74,1,75,1,75,1,75,3,75,2970,8,75,1,75,1,75,1,76,1,76,
  	1,76,3,76,2977,8,76,1,76,1,76,1,77,1,77,1,77,3,77,2984,8,77,1,77,1,77,
  	1,77,1,77,1,77,3,77,2991,8,77,1,77,1,77,1,77,3,77,2996,8,77,1,77,5,77,
  	2999,8,77,10,77,12,77,3002,9,77,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,
  	78,1,79,1,79,1,79,3,79,3015,8,79,1,79,1,79,1,80,1,80,1,80,3,80,3022,8,
  	80,1,80,1,80,1,81,1,81,1,81,3,81,3029,8,81,1,81,1,81,1,82,1,82,3,82,3035,
  	8,82,1,82,1,82,3,82,3039,8,82,1,82,1,82,3,82,3043,8,82,1,83,1,83,1,83,
  	1,83,1,83,3,83,3050,8,83,1,83,3,83,3053,8,83,1,84,1,84,1,84,3,84,3058,
  	8,84,1,84,1,84,1,85,1,85,1,85,3,85,3065,8,85,1,85,1,85,1,85,5,85,3070,
  	8,85,10,85,12,85,3073,9,85,1,85,3,85,3076,8,85,1,86,1,86,1,86,3,86,3081,
  	8,86,1,86,1,86,1,86,5,86,3086,8,86,10,86,12,86,3089,9,86,1,87,1,87,1,
  	87,1,87,1,87,1,87,1,87,1,87,5,87,3099,8,87,10,87,12,87,3102,9,87,3,87,
  	3104,8,87,1,87,1,87,1,87,3,87,3109,8,87,1,87,1,87,1,87,3,87,3114,8,87,
  	5,87,3116,8,87,10,87,12,87,3119,9,87,1,87,1,87,1,87,3,87,3124,8,87,1,
  	88,1,88,1,88,1,88,1,88,5,88,3131,8,88,10,88,12,88,3134,9,88,1,89,1,89,
  	1,89,1,89,1,90,1,90,3,90,3142,8,90,1,90,1,90,1,91,1,91,1,91,1,91,1,91,
  	3,91,3151,8,91,1,91,3,91,3154,8,91,1,92,1,92,3,92,3158,8,92,1,93,1,93,
  	1,93,1,94,1,94,1,94,1,94,3,94,3167,8,94,1,95,1,95,3,95,3171,8,95,1,95,
  	3,95,3174,8,95,1,95,3,95,3177,8,95,1,95,1,95,1,95,1,95,3,95,3183,8,95,
  	1,95,3,95,3186,8,95,1,95,1,95,1,95,1,95,3,95,3192,8,95,1,95,1,95,3,95,
  	3196,8,95,1,95,3,95,3199,8,95,1,95,1,95,1,95,1,95,5,95,3205,8,95,10,95,
  	12,95,3208,9,95,3,95,3210,8,95,1,95,1,95,1,95,1,95,1,95,1,95,1,95,5,95,
  	3219,8,95,10,95,12,95,3222,9,95,3,95,3224,8,95,1,96,1,96,1,96,3,96,3229,
  	8,96,1,96,3,96,3232,8,96,1,96,1,96,1,96,3,96,3237,8,96,1,96,1,96,1,96,
  	1,96,1,96,1,96,1,96,1,96,3,96,3247,8,96,1,96,1,96,1,96,3,96,3252,8,96,
  	1,96,1,96,4,96,3256,8,96,11,96,12,96,3257,3,96,3260,8,96,1,96,1,96,4,
  	96,3264,8,96,11,96,12,96,3265,3,96,3268,8,96,1,96,1,96,1,96,1,96,3,96,
  	3274,8,96,1,96,1,96,1,96,1,96,5,96,3280,8,96,10,96,12,96,3283,9,96,1,
  	96,1,96,3,96,3287,8,96,1,96,1,96,1,96,1,96,5,96,3293,8,96,10,96,12,96,
  	3296,9,96,3,96,3298,8,96,1,97,1,97,1,97,3,97,3303,8,97,1,97,3,97,3306,
  	8,97,1,97,1,97,1,97,3,97,3311,8,97,1,97,1,97,1,97,1,97,1,97,1,97,3,97,
  	3319,8,97,1,97,1,97,1,97,1,97,1,97,1,97,3,97,3327,8,97,1,97,1,97,1,97,
  	1,97,3,97,3333,8,97,1,97,1,97,1,97,1,97,5,97,3339,8,97,10,97,12,97,3342,
  	9,97,1,97,1,97,3,97,3346,8,97,1,97,1,97,1,97,1,97,5,97,3352,8,97,10,97,
  	12,97,3355,9,97,3,97,3357,8,97,1,98,1,98,3,98,3361,8,98,1,98,3,98,3364,
  	8,98,1,98,1,98,1,98,1,98,1,98,1,98,3,98,3372,8,98,1,98,1,98,1,98,1,98,
  	3,98,3378,8,98,1,98,1,98,1,98,1,98,1,98,5,98,3385,8,98,10,98,12,98,3388,
  	9,98,3,98,3390,8,98,1,99,1,99,3,99,3394,8,99,1,99,1,99,3,99,3398,8,99,
  	1,99,1,99,4,99,3402,8,99,11,99,12,99,3403,1,99,1,99,3,99,3408,8,99,1,
  	99,1,99,3,99,3412,8,99,3,99,3414,8,99,1,99,3,99,3417,8,99,1,99,3,99,3420,
  	8,99,1,99,3,99,3423,8,99,1,99,1,99,4,99,3427,8,99,11,99,12,99,3428,1,
  	99,1,99,3,99,3433,8,99,1,99,3,99,3436,8,99,1,99,3,99,3439,8,99,1,99,3,
  	99,3442,8,99,1,99,3,99,3445,8,99,1,99,1,99,1,99,4,99,3450,8,99,11,99,
  	12,99,3451,3,99,3454,8,99,1,100,1,100,3,100,3458,8,100,1,101,1,101,1,
  	101,3,101,3463,8,101,1,101,1,101,1,101,1,101,3,101,3469,8,101,1,101,5,
  	101,3472,8,101,10,101,12,101,3475,9,101,1,102,1,102,1,102,1,102,3,102,
  	3481,8,102,1,102,1,102,1,102,1,102,3,102,3487,8,102,1,102,5,102,3490,
  	8,102,10,102,12,102,3493,9,102,3,102,3495,8,102,1,103,1,103,1,103,1,103,
  	3,103,3501,8,103,1,104,1,104,3,104,3505,8,104,1,105,1,105,1,105,1,105,
  	1,105,1,105,3,105,3513,8,105,1,106,1,106,3,106,3517,8,106,1,106,3,106,
  	3520,8,106,1,106,3,106,3523,8,106,1,106,1,106,1,106,3,106,3528,8,106,
  	1,106,3,106,3531,8,106,1,106,1,106,1,106,1,106,1,106,3,106,3538,8,106,
  	1,106,1,106,3,106,3542,8,106,1,106,3,106,3545,8,106,1,106,1,106,3,106,
  	3549,8,106,1,107,1,107,3,107,3553,8,107,1,107,3,107,3556,8,107,1,107,
  	3,107,3559,8,107,1,107,1,107,1,107,3,107,3564,8,107,1,107,1,107,1,107,
  	1,107,3,107,3570,8,107,5,107,3572,8,107,10,107,12,107,3575,9,107,1,107,
  	1,107,1,107,1,107,1,107,1,107,1,107,3,107,3584,8,107,1,107,1,107,1,107,
  	1,107,3,107,3590,8,107,5,107,3592,8,107,10,107,12,107,3595,9,107,1,107,
  	1,107,1,107,3,107,3600,8,107,1,107,1,107,3,107,3604,8,107,1,108,1,108,
  	1,108,1,108,3,108,3610,8,108,1,108,3,108,3613,8,108,1,109,1,109,1,109,
  	1,109,1,109,1,109,1,109,1,109,1,109,1,109,3,109,3625,8,109,1,109,1,109,
  	3,109,3629,8,109,1,109,1,109,3,109,3633,8,109,1,110,1,110,1,110,1,110,
  	1,110,1,110,3,110,3641,8,110,1,110,1,110,3,110,3645,8,110,1,111,1,111,
  	1,111,1,111,1,112,1,112,3,112,3653,8,112,1,112,3,112,3656,8,112,1,112,
  	1,112,3,112,3660,8,112,1,112,3,112,3663,8,112,1,112,1,112,1,112,1,112,
  	5,112,3669,8,112,10,112,12,112,3672,9,112,1,112,1,112,3,112,3676,8,112,
  	1,112,3,112,3679,8,112,1,112,3,112,3682,8,112,1,113,1,113,3,113,3686,
  	8,113,1,113,3,113,3689,8,113,1,113,1,113,1,113,1,113,1,113,5,113,3696,
  	8,113,10,113,12,113,3699,9,113,1,113,1,113,3,113,3703,8,113,1,114,1,114,
  	1,114,1,114,1,114,5,114,3710,8,114,10,114,12,114,3713,9,114,1,115,1,115,
  	3,115,3717,8,115,1,116,1,116,1,116,5,116,3722,8,116,10,116,12,116,3725,
  	9,116,1,117,1,117,5,117,3729,8,117,10,117,12,117,3732,9,117,1,117,1,117,
  	1,117,5,117,3737,8,117,10,117,12,117,3740,9,117,1,117,1,117,1,117,3,117,
  	3745,8,117,1,118,1,118,1,118,1,118,1,118,1,118,3,118,3753,8,118,1,118,
  	3,118,3756,8,118,1,118,3,118,3759,8,118,1,118,1,118,1,118,5,118,3764,
  	8,118,10,118,12,118,3767,9,118,3,118,3769,8,118,1,118,1,118,1,118,1,118,
  	1,118,3,118,3776,8,118,1,118,3,118,3779,8,118,1,118,1,118,1,118,1,118,
  	1,118,1,118,3,118,3787,8,118,1,119,1,119,1,119,1,119,3,119,3793,8,119,
  	1,119,1,119,1,119,1,119,1,120,1,120,1,120,1,120,1,120,3,120,3804,8,120,
  	1,121,3,121,3807,8,121,1,121,1,121,3,121,3811,8,121,1,121,1,121,1,121,
  	1,121,1,121,1,121,1,121,1,121,3,121,3821,8,121,1,121,1,121,1,121,1,121,
  	3,121,3827,8,121,1,121,1,121,3,121,3831,8,121,1,121,1,121,3,121,3835,
  	8,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,1,121,3,121,3845,8,121,
  	1,121,1,121,1,121,3,121,3850,8,121,3,121,3852,8,121,1,121,1,121,3,121,
  	3856,8,121,1,122,1,122,1,122,1,122,1,122,1,122,1,122,1,122,3,122,3866,
  	8,122,1,123,1,123,1,123,1,123,1,123,1,123,1,123,1,123,3,123,3876,8,123,
  	1,124,1,124,5,124,3880,8,124,10,124,12,124,3883,9,124,1,124,1,124,3,124,
  	3887,8,124,1,124,1,124,3,124,3891,8,124,1,124,3,124,3894,8,124,1,124,
  	3,124,3897,8,124,1,124,3,124,3900,8,124,1,124,3,124,3903,8,124,1,124,
  	1,124,5,124,3907,8,124,10,124,12,124,3910,9,124,1,124,1,124,1,124,3,124,
  	3915,8,124,1,124,3,124,3918,8,124,1,124,3,124,3921,8,124,1,124,3,124,
  	3924,8,124,1,124,3,124,3927,8,124,1,124,3,124,3930,8,124,3,124,3932,8,
  	124,1,125,1,125,5,125,3936,8,125,10,125,12,125,3939,9,125,1,125,1,125,
  	1,125,3,125,3944,8,125,1,125,3,125,3947,8,125,1,125,3,125,3950,8,125,
  	1,125,3,125,3953,8,125,1,125,3,125,3956,8,125,1,126,1,126,3,126,3960,
  	8,126,1,126,1,126,1,127,1,127,3,127,3966,8,127,1,127,1,127,3,127,3970,
  	8,127,1,128,1,128,1,128,1,128,1,128,1,128,3,128,3978,8,128,1,128,1,128,
  	3,128,3982,8,128,1,128,3,128,3985,8,128,3,128,3987,8,128,1,129,1,129,
  	1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,1,129,3,129,4000,8,129,
  	1,129,3,129,4003,8,129,1,130,1,130,1,130,5,130,4008,8,130,10,130,12,130,
  	4011,9,130,1,131,1,131,1,131,1,131,1,131,1,131,1,131,3,131,4020,8,131,
  	1,131,3,131,4023,8,131,1,131,1,131,1,131,3,131,4028,8,131,3,131,4030,
  	8,131,1,131,1,131,3,131,4034,8,131,1,131,1,131,1,131,1,131,1,131,1,131,
  	3,131,4042,8,131,1,132,1,132,1,132,1,132,3,132,4048,8,132,1,132,1,132,
  	1,132,1,133,1,133,1,133,1,133,3,133,4057,8,133,1,133,1,133,1,133,1,134,
  	1,134,1,134,1,134,1,134,1,134,1,134,1,134,3,134,4070,8,134,1,135,1,135,
  	3,135,4074,8,135,1,135,1,135,5,135,4078,8,135,10,135,12,135,4081,9,135,
  	1,136,1,136,1,136,1,136,1,136,1,136,3,136,4089,8,136,1,136,3,136,4092,
  	8,136,1,136,1,136,3,136,4096,8,136,1,136,3,136,4099,8,136,1,136,1,136,
  	3,136,4103,8,136,1,136,1,136,3,136,4107,8,136,1,136,3,136,4110,8,136,
  	3,136,4112,8,136,1,137,1,137,1,137,1,137,5,137,4118,8,137,10,137,12,137,
  	4121,9,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,1,137,3,137,
  	4132,8,137,1,137,1,137,4,137,4136,8,137,11,137,12,137,4137,3,137,4140,
  	8,137,1,137,1,137,4,137,4144,8,137,11,137,12,137,4145,3,137,4148,8,137,
  	3,137,4150,8,137,1,138,1,138,1,138,1,138,3,138,4156,8,138,1,138,1,138,
  	1,138,1,138,1,138,1,138,3,138,4164,8,138,1,139,1,139,1,139,1,139,1,139,
  	1,139,3,139,4172,8,139,1,140,1,140,3,140,4176,8,140,1,140,1,140,3,140,
  	4180,8,140,1,141,1,141,1,141,1,141,1,141,5,141,4187,8,141,10,141,12,141,
  	4190,9,141,1,141,1,141,3,141,4194,8,141,1,142,1,142,1,142,1,143,1,143,
  	1,143,1,143,1,143,1,143,1,143,1,143,1,143,1,143,1,143,1,143,1,143,5,143,
  	4212,8,143,10,143,12,143,4215,9,143,1,144,1,144,3,144,4219,8,144,1,145,
  	1,145,1,145,1,145,3,145,4225,8,145,1,145,1,145,1,145,1,145,1,145,3,145,
  	4232,8,145,1,146,1,146,1,146,3,146,4237,8,146,1,147,1,147,1,147,1,147,
  	1,147,5,147,4244,8,147,10,147,12,147,4247,9,147,3,147,4249,8,147,1,148,
  	1,148,3,148,4253,8,148,1,149,1,149,3,149,4257,8,149,1,149,1,149,3,149,
  	4261,8,149,1,149,3,149,4264,8,149,1,149,3,149,4267,8,149,1,149,3,149,
  	4270,8,149,1,150,1,150,3,150,4274,8,150,1,150,1,150,3,150,4278,8,150,
  	1,150,3,150,4281,8,150,1,150,3,150,4284,8,150,1,150,3,150,4287,8,150,
  	1,151,1,151,1,151,1,152,1,152,3,152,4294,8,152,1,152,1,152,3,152,4298,
  	8,152,1,152,1,152,1,153,1,153,1,153,1,153,1,154,1,154,1,154,1,154,1,154,
  	5,154,4311,8,154,10,154,12,154,4314,9,154,1,154,3,154,4317,8,154,1,155,
  	1,155,1,155,1,156,1,156,1,156,1,156,1,156,1,157,1,157,3,157,4329,8,157,
  	1,157,1,157,1,157,1,157,5,157,4335,8,157,10,157,12,157,4338,9,157,1,158,
  	1,158,1,158,1,158,1,158,1,158,1,158,3,158,4347,8,158,1,159,1,159,3,159,
  	4351,8,159,1,159,3,159,4354,8,159,1,159,1,159,1,160,1,160,3,160,4360,
  	8,160,1,160,3,160,4363,8,160,1,160,3,160,4366,8,160,1,161,1,161,1,161,
  	1,161,1,161,1,161,1,161,3,161,4375,8,161,1,162,1,162,1,162,1,162,1,162,
  	1,162,1,162,3,162,4384,8,162,1,163,1,163,1,163,1,163,1,163,1,163,5,163,
  	4392,8,163,10,163,12,163,4395,9,163,1,163,3,163,4398,8,163,1,164,1,164,
  	1,164,1,164,1,164,1,164,5,164,4406,8,164,10,164,12,164,4409,9,164,1,165,
  	1,165,1,165,1,165,1,165,1,165,1,165,3,165,4418,8,165,1,166,1,166,1,166,
  	1,167,1,167,1,167,3,167,4426,8,167,1,167,3,167,4429,8,167,1,168,1,168,
  	1,168,1,168,1,168,5,168,4436,8,168,10,168,12,168,4439,9,168,3,168,4441,
  	8,168,1,168,1,168,3,168,4445,8,168,1,168,5,168,4448,8,168,10,168,12,168,
  	4451,9,168,1,168,3,168,4454,8,168,1,169,1,169,1,169,1,169,1,169,5,169,
  	4461,8,169,10,169,12,169,4464,9,169,3,169,4466,8,169,1,170,1,170,1,170,
  	1,171,1,171,1,171,1,172,1,172,1,172,1,172,1,172,1,172,1,172,1,172,1,172,
  	1,172,1,172,1,172,1,172,1,172,1,172,1,172,1,172,1,172,1,172,1,172,1,172,
  	5,172,4495,8,172,10,172,12,172,4498,9,172,3,172,4500,8,172,1,172,3,172,
  	4503,8,172,1,173,1,173,1,174,1,174,1,175,1,175,1,176,1,176,1,176,1,176,
  	1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,
  	1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,
  	1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,1,177,
  	1,177,1,177,1,177,1,177,1,177,1,177,5,177,4557,8,177,10,177,12,177,4560,
  	9,177,1,177,1,177,3,177,4564,8,177,1,178,1,178,1,178,1,178,1,178,1,178,
  	1,179,1,179,1,180,1,180,1,180,1,180,1,180,1,180,1,180,1,180,1,180,1,180,
  	1,180,1,180,1,180,1,180,1,180,1,180,1,180,1,180,3,180,4592,8,180,1,181,
  	1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,1,181,3,181,
  	4606,8,181,1,182,1,182,1,182,5,182,4611,8,182,10,182,12,182,4614,9,182,
  	1,182,3,182,4617,8,182,1,183,1,183,1,183,1,183,3,183,4623,8,183,1,184,
  	1,184,1,184,1,184,1,184,1,184,3,184,4631,8,184,3,184,4633,8,184,1,185,
  	1,185,1,185,1,185,1,186,1,186,1,186,1,186,1,186,3,186,4644,8,186,1,187,
  	1,187,1,187,1,187,1,188,1,188,1,188,1,188,3,188,4654,8,188,1,189,1,189,
  	1,189,1,189,1,189,3,189,4661,8,189,1,190,1,190,1,190,1,190,3,190,4667,
  	8,190,1,191,1,191,1,191,1,191,1,192,1,192,3,192,4675,8,192,1,193,1,193,
  	1,193,3,193,4680,8,193,1,193,1,193,1,193,1,193,5,193,4686,8,193,10,193,
  	12,193,4689,9,193,1,193,1,193,1,193,5,193,4694,8,193,10,193,12,193,4697,
  	9,193,1,193,1,193,1,193,5,193,4702,8,193,10,193,12,193,4705,9,193,1,193,
  	1,193,1,193,5,193,4710,8,193,10,193,12,193,4713,9,193,1,193,5,193,4716,
  	8,193,10,193,12,193,4719,9,193,1,193,1,193,3,193,4723,8,193,1,194,1,194,
  	1,194,3,194,4728,8,194,1,194,4,194,4731,8,194,11,194,12,194,4732,1,194,
  	1,194,4,194,4737,8,194,11,194,12,194,4738,3,194,4741,8,194,1,194,1,194,
  	1,194,1,195,1,195,1,195,1,195,4,195,4750,8,195,11,195,12,195,4751,1,195,
  	5,195,4755,8,195,10,195,12,195,4758,9,195,1,195,1,195,4,195,4762,8,195,
  	11,195,12,195,4763,3,195,4766,8,195,1,195,1,195,1,195,1,196,1,196,1,196,
  	1,197,1,197,1,197,1,198,1,198,1,198,3,198,4780,8,198,1,198,1,198,4,198,
  	4784,8,198,11,198,12,198,4785,1,198,1,198,1,198,3,198,4791,8,198,1,199,
  	1,199,1,199,3,199,4796,8,199,1,199,1,199,4,199,4800,8,199,11,199,12,199,
  	4801,1,199,1,199,1,199,1,199,1,199,3,199,4809,8,199,1,200,1,200,1,200,
  	1,201,1,201,1,201,3,201,4817,8,201,1,201,1,201,1,201,1,201,4,201,4823,
  	8,201,11,201,12,201,4824,1,201,1,201,1,201,3,201,4830,8,201,1,202,1,202,
  	1,202,1,202,3,202,4836,8,202,1,202,3,202,4839,8,202,1,202,1,202,1,202,
  	1,202,1,202,1,202,3,202,4847,8,202,1,203,1,203,1,203,1,203,1,203,3,203,
  	4854,8,203,1,204,1,204,1,204,1,204,1,204,1,204,1,204,3,204,4863,8,204,
  	1,204,3,204,4866,8,204,1,205,1,205,1,205,1,205,1,205,1,205,1,206,1,206,
  	1,206,1,206,1,206,1,206,1,206,5,206,4881,8,206,10,206,12,206,4884,9,206,
  	1,206,1,206,1,207,1,207,1,207,3,207,4891,8,207,1,207,1,207,1,207,1,207,
  	1,207,1,207,3,207,4899,8,207,1,208,1,208,3,208,4903,8,208,1,208,1,208,
  	1,209,1,209,1,209,3,209,4910,8,209,1,209,1,209,4,209,4914,8,209,11,209,
  	12,209,4915,1,210,1,210,1,210,1,210,4,210,4922,8,210,11,210,12,210,4923,
  	1,211,1,211,1,211,1,211,1,211,5,211,4931,8,211,10,211,12,211,4934,9,211,
  	1,211,1,211,1,211,3,211,4939,8,211,1,211,1,211,1,211,5,211,4944,8,211,
  	10,211,12,211,4947,9,211,1,211,1,211,1,211,1,211,3,211,4953,8,211,1,211,
  	5,211,4956,8,211,10,211,12,211,4959,9,211,3,211,4961,8,211,3,211,4963,
  	8,211,1,211,1,211,4,211,4967,8,211,11,211,12,211,4968,3,211,4971,8,211,
  	1,211,1,211,5,211,4975,8,211,10,211,12,211,4978,9,211,1,211,1,211,1,211,
  	1,211,3,211,4984,8,211,1,211,1,211,1,211,3,211,4989,8,211,1,211,1,211,
  	3,211,4993,8,211,1,211,1,211,1,211,1,211,3,211,4999,8,211,1,212,1,212,
  	1,212,1,212,1,212,5,212,5006,8,212,10,212,12,212,5009,9,212,1,212,1,212,
  	1,212,3,212,5014,8,212,1,212,1,212,1,212,5,212,5019,8,212,10,212,12,212,
  	5022,9,212,1,212,1,212,1,212,3,212,5027,8,212,1,212,1,212,1,212,1,212,
  	3,212,5033,8,212,1,212,5,212,5036,8,212,10,212,12,212,5039,9,212,3,212,
  	5041,8,212,3,212,5043,8,212,1,212,1,212,4,212,5047,8,212,11,212,12,212,
  	5048,3,212,5051,8,212,1,212,1,212,5,212,5055,8,212,10,212,12,212,5058,
  	9,212,1,212,1,212,1,212,1,212,3,212,5064,8,212,3,212,5066,8,212,1,213,
  	1,213,1,213,3,213,5071,8,213,1,213,1,213,1,213,5,213,5076,8,213,10,213,
  	12,213,5079,9,213,1,214,1,214,1,214,1,214,5,214,5085,8,214,10,214,12,
  	214,5088,9,214,1,214,1,214,3,214,5092,8,214,1,214,1,214,1,214,1,214,1,
  	214,5,214,5099,8,214,10,214,12,214,5102,9,214,1,214,1,214,1,214,1,214,
  	3,214,5108,8,214,1,214,5,214,5111,8,214,10,214,12,214,5114,9,214,3,214,
  	5116,8,214,3,214,5118,8,214,1,214,1,214,1,214,1,214,5,214,5124,8,214,
  	10,214,12,214,5127,9,214,3,214,5129,8,214,1,214,1,214,1,214,1,214,1,214,
  	1,214,3,214,5137,8,214,1,214,1,214,1,214,3,214,5142,8,214,1,214,1,214,
  	1,214,3,214,5147,8,214,5,214,5149,8,214,10,214,12,214,5152,9,214,1,214,
  	1,214,1,214,3,214,5157,8,214,1,214,1,214,1,214,3,214,5162,8,214,5,214,
  	5164,8,214,10,214,12,214,5167,9,214,1,214,1,214,1,214,3,214,5172,8,214,
  	3,214,5174,8,214,1,215,1,215,1,215,1,215,1,215,1,215,1,215,5,215,5183,
  	8,215,10,215,12,215,5186,9,215,3,215,5188,8,215,1,215,1,215,1,215,5,215,
  	5193,8,215,10,215,12,215,5196,9,215,3,215,5198,8,215,1,216,1,216,1,216,
  	1,216,1,216,1,216,1,216,1,216,5,216,5208,8,216,10,216,12,216,5211,9,216,
  	1,216,1,216,1,216,3,216,5216,8,216,1,217,1,217,1,217,1,217,1,217,5,217,
  	5223,8,217,10,217,12,217,5226,9,217,1,218,1,218,1,218,1,218,5,218,5232,
  	8,218,10,218,12,218,5235,9,218,1,218,1,218,3,218,5239,8,218,1,218,1,218,
  	1,218,1,218,1,218,5,218,5246,8,218,10,218,12,218,5249,9,218,1,218,1,218,
  	1,218,3,218,5254,8,218,1,218,1,218,1,218,1,218,1,218,1,218,1,218,5,218,
  	5263,8,218,10,218,12,218,5266,9,218,1,218,1,218,1,218,3,218,5271,8,218,
  	1,218,1,218,1,218,3,218,5276,8,218,5,218,5278,8,218,10,218,12,218,5281,
  	9,218,1,218,1,218,1,218,3,218,5286,8,218,1,218,1,218,1,218,3,218,5291,
  	8,218,5,218,5293,8,218,10,218,12,218,5296,9,218,3,218,5298,8,218,1,219,
  	1,219,1,219,1,219,1,219,1,219,1,219,1,219,5,219,5308,8,219,10,219,12,
  	219,5311,9,219,1,220,1,220,1,220,1,220,3,220,5317,8,220,1,220,1,220,1,
  	220,3,220,5322,8,220,1,221,1,221,1,221,1,222,1,222,1,222,1,222,1,222,
  	1,222,1,222,1,222,1,222,1,222,1,222,1,222,1,222,3,222,5340,8,222,1,222,
  	1,222,1,222,1,222,1,222,1,222,3,222,5348,8,222,1,223,1,223,1,223,3,223,
  	5353,8,223,1,223,1,223,1,223,1,223,3,223,5359,8,223,1,224,1,224,1,224,
  	1,224,1,224,1,224,1,224,1,224,3,224,5369,8,224,1,225,1,225,1,225,1,225,
  	1,225,1,225,1,225,1,225,3,225,5379,8,225,1,226,1,226,1,226,1,226,1,226,
  	1,226,1,226,1,226,3,226,5389,8,226,1,226,1,226,1,226,1,226,3,226,5395,
  	8,226,1,226,1,226,1,226,1,226,1,226,1,226,1,226,3,226,5404,8,226,1,226,
  	1,226,1,226,1,226,3,226,5410,8,226,1,226,1,226,1,226,1,226,1,226,3,226,
  	5417,8,226,3,226,5419,8,226,1,227,1,227,1,227,1,228,1,228,1,228,1,228,
  	1,228,3,228,5429,8,228,1,229,1,229,3,229,5433,8,229,1,229,1,229,3,229,
  	5437,8,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,3,229,5447,
  	8,229,1,229,1,229,1,229,3,229,5452,8,229,1,229,1,229,1,229,1,229,1,229,
  	1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,
  	1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,
  	1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,
  	1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,
  	1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,
  	1,229,1,229,1,229,1,229,1,229,3,229,5524,8,229,1,230,1,230,1,230,1,230,
  	1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,1,230,
  	3,230,5542,8,230,1,231,1,231,1,231,1,231,1,232,1,232,3,232,5550,8,232,
  	1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,5,232,5560,8,232,10,232,
  	12,232,5563,9,232,1,232,1,232,1,232,1,232,3,232,5569,8,232,3,232,5571,
  	8,232,1,232,1,232,1,232,1,232,1,232,1,232,5,232,5579,8,232,10,232,12,
  	232,5582,9,232,3,232,5584,8,232,1,233,1,233,1,233,1,233,5,233,5590,8,
  	233,10,233,12,233,5593,9,233,1,234,1,234,1,234,1,234,3,234,5599,8,234,
  	1,235,1,235,3,235,5603,8,235,1,235,1,235,1,235,1,236,1,236,3,236,5610,
  	8,236,1,236,1,236,1,236,3,236,5615,8,236,1,236,3,236,5618,8,236,1,236,
  	3,236,5621,8,236,1,237,1,237,1,237,1,237,1,237,1,237,1,237,3,237,5630,
  	8,237,1,238,1,238,3,238,5634,8,238,1,238,1,238,3,238,5638,8,238,1,238,
  	1,238,1,238,1,238,1,238,1,238,1,239,1,239,1,239,1,239,1,239,1,239,1,240,
  	1,240,1,240,1,240,1,241,1,241,1,241,1,241,1,241,3,241,5661,8,241,1,241,
  	1,241,1,241,1,241,1,241,3,241,5668,8,241,5,241,5670,8,241,10,241,12,241,
  	5673,9,241,1,241,1,241,1,241,1,241,3,241,5679,8,241,1,241,1,241,1,241,
  	1,241,1,241,3,241,5686,8,241,1,241,3,241,5689,8,241,1,241,1,241,1,241,
  	1,241,1,241,1,241,1,241,1,241,1,241,1,241,1,241,1,241,5,241,5703,8,241,
  	10,241,12,241,5706,9,241,3,241,5708,8,241,1,242,1,242,1,242,1,242,1,242,
  	1,242,1,242,1,242,3,242,5718,8,242,1,242,1,242,3,242,5722,8,242,1,242,
  	1,242,1,242,1,242,3,242,5728,8,242,1,242,3,242,5731,8,242,1,242,1,242,
  	1,242,3,242,5736,8,242,1,242,1,242,3,242,5740,8,242,1,242,1,242,1,242,
  	1,242,1,242,3,242,5747,8,242,1,242,3,242,5750,8,242,1,242,1,242,1,242,
  	1,242,3,242,5756,8,242,1,242,1,242,1,242,1,242,1,242,1,242,1,242,1,242,
  	1,242,1,242,1,242,1,242,1,242,1,242,1,242,1,242,1,242,1,242,1,242,1,242,
  	1,242,1,242,3,242,5780,8,242,1,242,3,242,5783,8,242,1,242,1,242,1,242,
  	1,242,1,242,1,242,1,242,1,242,1,242,1,242,3,242,5795,8,242,1,242,3,242,
  	5798,8,242,1,242,1,242,1,242,1,242,1,242,1,242,1,242,1,242,3,242,5808,
  	8,242,1,242,1,242,1,242,1,242,1,242,1,242,3,242,5816,8,242,1,242,1,242,
  	3,242,5820,8,242,1,242,1,242,1,242,1,242,1,242,3,242,5827,8,242,1,242,
  	3,242,5830,8,242,1,242,1,242,1,242,1,242,1,242,5,242,5837,8,242,10,242,
  	12,242,5840,9,242,1,242,1,242,1,242,3,242,5845,8,242,1,242,1,242,1,242,
  	1,242,3,242,5851,8,242,1,242,1,242,1,242,1,242,1,242,1,242,1,242,1,242,
  	3,242,5861,8,242,3,242,5863,8,242,1,243,1,243,1,243,1,243,3,243,5869,
  	8,243,1,243,3,243,5872,8,243,1,243,3,243,5875,8,243,1,244,1,244,1,244,
  	1,244,1,244,1,244,1,244,1,244,1,244,1,244,3,244,5887,8,244,1,244,3,244,
  	5890,8,244,1,245,1,245,1,245,1,245,3,245,5896,8,245,1,246,3,246,5899,
  	8,246,1,246,1,246,1,246,1,246,1,246,1,246,3,246,5907,8,246,1,246,1,246,
  	1,246,1,246,1,246,1,246,3,246,5915,8,246,1,247,1,247,1,247,1,247,3,247,
  	5921,8,247,1,247,1,247,3,247,5925,8,247,1,248,1,248,1,248,1,248,1,248,
  	1,248,1,248,1,248,1,248,1,248,1,248,1,248,3,248,5939,8,248,1,249,1,249,
  	1,249,1,250,1,250,1,250,1,250,1,250,5,250,5949,8,250,10,250,12,250,5952,
  	9,250,1,250,1,250,1,250,1,250,3,250,5958,8,250,1,250,3,250,5961,8,250,
  	1,250,1,250,1,250,1,251,1,251,3,251,5968,8,251,1,251,1,251,1,251,5,251,
  	5973,8,251,10,251,12,251,5976,9,251,1,252,1,252,3,252,5980,8,252,1,252,
  	1,252,1,253,1,253,1,253,1,253,1,253,1,253,1,253,5,253,5991,8,253,10,253,
  	12,253,5994,9,253,1,254,1,254,1,254,1,254,1,255,1,255,1,256,1,256,3,256,
  	6004,8,256,1,256,1,256,1,256,1,256,3,256,6010,8,256,1,257,1,257,1,257,
  	3,257,6015,8,257,1,257,1,257,1,257,1,257,1,257,1,257,1,257,1,257,1,257,
  	1,257,1,257,3,257,6028,8,257,3,257,6030,8,257,1,257,1,257,1,257,3,257,
  	6035,8,257,1,257,1,257,3,257,6039,8,257,1,257,3,257,6042,8,257,3,257,
  	6044,8,257,1,258,1,258,1,258,1,258,1,258,3,258,6051,8,258,1,259,1,259,
  	1,259,1,259,1,259,3,259,6058,8,259,1,259,3,259,6061,8,259,1,259,3,259,
  	6064,8,259,1,259,1,259,1,259,1,259,3,259,6070,8,259,1,259,1,259,3,259,
  	6074,8,259,1,260,1,260,1,260,1,260,3,260,6080,8,260,1,261,1,261,1,261,
  	1,261,3,261,6086,8,261,1,261,1,261,1,262,1,262,1,262,1,263,1,263,1,263,
  	1,264,1,264,1,264,3,264,6099,8,264,1,264,1,264,1,264,3,264,6104,8,264,
  	1,264,1,264,1,264,1,264,5,264,6110,8,264,10,264,12,264,6113,9,264,3,264,
  	6115,8,264,1,265,1,265,1,265,3,265,6120,8,265,1,265,1,265,1,265,3,265,
  	6125,8,265,1,265,1,265,1,265,1,265,5,265,6131,8,265,10,265,12,265,6134,
  	9,265,3,265,6136,8,265,1,266,1,266,1,266,1,266,1,266,1,266,3,266,6144,
  	8,266,1,267,1,267,3,267,6148,8,267,1,267,1,267,1,267,5,267,6153,8,267,
  	10,267,12,267,6156,9,267,1,268,1,268,1,268,3,268,6161,8,268,1,268,3,268,
  	6164,8,268,1,269,1,269,3,269,6168,8,269,1,269,1,269,1,269,1,269,1,269,
  	1,269,1,269,1,269,1,269,5,269,6179,8,269,10,269,12,269,6182,9,269,1,269,
  	1,269,1,269,3,269,6187,8,269,1,269,1,269,1,269,1,269,1,269,1,269,1,269,
  	1,269,5,269,6197,8,269,10,269,12,269,6200,9,269,3,269,6202,8,269,1,270,
  	1,270,1,271,1,271,1,271,1,271,1,271,3,271,6211,8,271,1,271,1,271,1,271,
  	3,271,6216,8,271,1,272,1,272,1,272,1,272,3,272,6222,8,272,1,273,1,273,
  	1,274,1,274,3,274,6228,8,274,1,275,1,275,1,275,3,275,6233,8,275,3,275,
  	6235,8,275,1,275,3,275,6238,8,275,1,275,1,275,3,275,6242,8,275,3,275,
  	6244,8,275,1,276,1,276,3,276,6248,8,276,1,276,1,276,1,276,1,276,3,276,
  	6254,8,276,1,276,3,276,6257,8,276,1,276,3,276,6260,8,276,1,277,1,277,
  	1,277,1,277,1,277,3,277,6267,8,277,1,278,1,278,1,279,1,279,1,279,1,279,
  	3,279,6275,8,279,1,280,1,280,3,280,6279,8,280,1,281,1,281,1,281,3,281,
  	6284,8,281,1,282,1,282,1,283,1,283,1,283,1,283,1,283,1,283,1,283,1,283,
  	1,283,1,283,1,283,1,283,1,283,1,283,4,283,6302,8,283,11,283,12,283,6303,
  	1,284,1,284,1,284,1,284,1,284,3,284,6311,8,284,3,284,6313,8,284,1,285,
  	1,285,1,285,4,285,6318,8,285,11,285,12,285,6319,3,285,6322,8,285,1,286,
  	1,286,3,286,6326,8,286,1,287,1,287,1,287,3,287,6331,8,287,1,288,1,288,
  	1,288,1,288,1,288,1,288,1,288,1,288,1,288,3,288,6342,8,288,1,289,1,289,
  	1,289,3,289,6347,8,289,1,290,1,290,1,291,1,291,3,291,6353,8,291,1,292,
  	3,292,6356,8,292,1,292,1,292,3,292,6360,8,292,1,292,4,292,6363,8,292,
  	11,292,12,292,6364,1,292,3,292,6368,8,292,1,292,1,292,3,292,6372,8,292,
  	1,292,1,292,3,292,6376,8,292,3,292,6378,8,292,1,293,1,293,1,294,3,294,
  	6383,8,294,1,294,1,294,1,295,3,295,6388,8,295,1,295,1,295,1,296,1,296,
  	1,296,1,296,1,296,1,296,1,296,1,296,1,296,3,296,6401,8,296,1,296,3,296,
  	6404,8,296,1,297,1,297,3,297,6408,8,297,1,297,3,297,6411,8,297,1,297,
  	3,297,6414,8,297,1,297,1,297,1,297,3,297,6419,8,297,1,297,1,297,1,297,
  	3,297,6424,8,297,1,297,1,297,1,297,1,297,3,297,6430,8,297,1,297,3,297,
  	6433,8,297,1,297,1,297,1,297,3,297,6438,8,297,1,297,3,297,6441,8,297,
  	1,297,1,297,1,297,3,297,6446,8,297,1,297,3,297,6449,8,297,1,297,1,297,
  	3,297,6453,8,297,1,297,5,297,6456,8,297,10,297,12,297,6459,9,297,1,297,
  	1,297,3,297,6463,8,297,1,297,5,297,6466,8,297,10,297,12,297,6469,9,297,
  	1,297,1,297,3,297,6473,8,297,1,297,3,297,6476,8,297,1,297,5,297,6479,
  	8,297,10,297,12,297,6482,9,297,1,297,1,297,3,297,6486,8,297,1,297,5,297,
  	6489,8,297,10,297,12,297,6492,9,297,1,297,1,297,1,297,3,297,6497,8,297,
  	1,297,1,297,1,297,3,297,6502,8,297,1,297,1,297,1,297,3,297,6507,8,297,
  	1,297,1,297,1,297,3,297,6512,8,297,1,297,1,297,3,297,6516,8,297,1,297,
  	3,297,6519,8,297,1,297,1,297,1,297,3,297,6524,8,297,1,297,1,297,3,297,
  	6528,8,297,1,297,1,297,3,297,6532,8,297,1,298,1,298,1,298,1,298,5,298,
  	6538,8,298,10,298,12,298,6541,9,298,1,298,1,298,1,299,1,299,3,299,6547,
  	8,299,1,299,1,299,3,299,6551,8,299,1,299,1,299,1,299,3,299,6556,8,299,
  	1,299,1,299,1,299,3,299,6561,8,299,1,299,1,299,3,299,6565,8,299,3,299,
  	6567,8,299,1,299,3,299,6570,8,299,1,300,1,300,1,300,1,300,1,301,1,301,
  	1,301,1,301,1,301,1,301,1,302,1,302,1,302,1,302,3,302,6586,8,302,1,302,
  	1,302,1,303,1,303,1,303,5,303,6593,8,303,10,303,12,303,6596,9,303,1,304,
  	1,304,1,304,5,304,6601,8,304,10,304,12,304,6604,9,304,1,305,1,305,1,305,
  	5,305,6609,8,305,10,305,12,305,6612,9,305,1,306,1,306,1,306,1,306,5,306,
  	6618,8,306,10,306,12,306,6621,9,306,1,306,1,306,1,307,1,307,1,307,5,307,
  	6628,8,307,10,307,12,307,6631,9,307,1,308,1,308,1,308,5,308,6636,8,308,
  	10,308,12,308,6639,9,308,1,309,1,309,1,309,5,309,6644,8,309,10,309,12,
  	309,6647,9,309,1,310,1,310,1,310,5,310,6652,8,310,10,310,12,310,6655,
  	9,310,1,311,1,311,1,311,5,311,6660,8,311,10,311,12,311,6663,9,311,1,312,
  	1,312,1,312,1,312,1,312,1,312,1,312,1,312,1,312,3,312,6674,8,312,1,312,
  	1,312,1,312,1,312,1,312,3,312,6681,8,312,1,312,1,312,1,312,1,312,1,312,
  	1,312,1,312,1,312,3,312,6691,8,312,1,313,1,313,1,313,3,313,6696,8,313,
  	1,313,3,313,6699,8,313,1,313,1,313,1,313,3,313,6704,8,313,1,313,3,313,
  	6707,8,313,1,314,1,314,3,314,6711,8,314,1,315,1,315,1,315,1,316,1,316,
  	1,316,1,316,1,317,1,317,1,317,1,318,1,318,1,318,3,318,6726,8,318,1,319,
  	1,319,1,319,1,319,1,319,1,319,3,319,6734,8,319,1,319,1,319,1,319,1,319,
  	1,319,3,319,6741,8,319,1,319,1,319,1,319,3,319,6746,8,319,1,320,1,320,
  	1,320,3,320,6751,8,320,1,320,1,320,1,320,1,320,1,320,1,320,1,320,1,320,
  	1,320,1,320,1,320,1,320,1,320,1,320,1,320,1,320,1,320,1,320,1,320,1,320,
  	1,320,1,320,1,320,1,320,1,320,1,320,1,320,1,320,1,320,4,320,6782,8,320,
  	11,320,12,320,6783,1,320,1,320,3,320,6788,8,320,1,320,1,320,1,320,1,320,
  	4,320,6794,8,320,11,320,12,320,6795,1,320,1,320,3,320,6800,8,320,1,320,
  	1,320,1,320,1,320,1,320,1,320,1,320,3,320,6809,8,320,1,320,1,320,1,320,
  	1,320,1,320,1,320,3,320,6817,8,320,1,320,1,320,1,320,3,320,6822,8,320,
  	1,320,1,320,1,320,1,320,1,320,1,320,3,320,6830,8,320,1,320,1,320,1,320,
  	3,320,6835,8,320,1,320,1,320,1,320,3,320,6840,8,320,3,320,6842,8,320,
  	1,320,1,320,1,320,1,320,1,320,1,320,1,320,3,320,6851,8,320,1,320,1,320,
  	1,320,3,320,6856,8,320,1,320,1,320,1,320,1,320,1,320,1,320,3,320,6864,
  	8,320,1,320,1,320,1,320,3,320,6869,8,320,1,320,1,320,1,320,1,320,1,320,
  	1,320,3,320,6877,8,320,1,320,1,320,1,320,1,320,1,320,1,320,3,320,6885,
  	8,320,1,320,3,320,6888,8,320,1,320,1,320,1,320,1,320,1,320,1,320,1,320,
  	1,320,3,320,6898,8,320,1,320,1,320,1,320,1,320,1,320,1,320,1,320,1,320,
  	1,320,1,320,1,320,1,320,1,320,1,320,1,320,1,320,3,320,6916,8,320,1,320,
  	3,320,6919,8,320,1,320,3,320,6922,8,320,1,320,1,320,3,320,6926,8,320,
  	1,321,1,321,1,321,1,321,1,321,1,322,1,322,1,322,1,322,5,322,6937,8,322,
  	10,322,12,322,6940,9,322,1,322,1,322,1,322,1,322,1,322,3,322,6947,8,322,
  	1,323,1,323,3,323,6951,8,323,1,324,1,324,1,324,3,324,6956,8,324,1,324,
  	1,324,1,324,3,324,6961,8,324,1,324,1,324,1,324,1,324,3,324,6967,8,324,
  	1,324,1,324,1,324,3,324,6972,8,324,1,324,1,324,3,324,6976,8,324,1,324,
  	1,324,1,324,3,324,6981,8,324,1,324,1,324,1,324,3,324,6986,8,324,1,324,
  	1,324,1,324,3,324,6991,8,324,1,324,1,324,1,324,1,324,1,324,1,324,5,324,
  	6999,8,324,10,324,12,324,7002,9,324,3,324,7004,8,324,1,324,1,324,3,324,
  	7008,8,324,1,324,1,324,3,324,7012,8,324,1,325,1,325,1,325,1,325,1,325,
  	3,325,7019,8,325,1,325,1,325,3,325,7023,8,325,1,325,1,325,1,325,1,325,
  	1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,
  	1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,3,325,
  	7052,8,325,1,326,1,326,1,326,1,326,1,326,1,326,3,326,7060,8,326,1,327,
  	3,327,7063,8,327,1,327,3,327,7066,8,327,1,327,3,327,7069,8,327,1,327,
  	3,327,7072,8,327,1,328,1,328,1,329,1,329,1,329,1,330,1,330,1,331,1,331,
  	3,331,7083,8,331,1,332,1,332,1,332,1,332,1,332,1,333,1,333,1,333,1,333,
  	1,333,1,333,1,333,3,333,7097,8,333,1,334,1,334,1,334,1,334,1,334,5,334,
  	7104,8,334,10,334,12,334,7107,9,334,1,335,1,335,1,335,1,335,1,335,1,335,
  	1,335,1,335,1,335,1,335,1,335,1,335,1,335,1,335,1,335,1,335,1,335,1,335,
  	1,335,1,335,1,335,1,335,1,335,3,335,7132,8,335,1,336,1,336,1,336,1,336,
  	1,336,1,337,1,337,1,337,1,337,3,337,7143,8,337,1,337,1,337,1,337,1,337,
  	1,337,3,337,7150,8,337,5,337,7152,8,337,10,337,12,337,7155,9,337,1,338,
  	1,338,1,338,1,338,3,338,7161,8,338,1,339,1,339,1,339,1,339,1,339,1,339,
  	3,339,7169,8,339,1,339,1,339,1,339,3,339,7174,8,339,1,339,1,339,1,339,
  	1,339,5,339,7180,8,339,10,339,12,339,7183,9,339,1,340,1,340,1,340,3,340,
  	7188,8,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,3,340,7198,
  	8,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,
  	3,340,7211,8,340,1,340,1,340,1,340,1,340,3,340,7217,8,340,1,340,1,340,
  	1,340,1,340,3,340,7223,8,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,
  	1,340,1,340,1,340,1,340,1,340,1,340,1,340,3,340,7239,8,340,1,340,1,340,
  	1,340,1,340,3,340,7245,8,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,
  	5,340,7254,8,340,10,340,12,340,7257,9,340,1,341,1,341,1,341,1,341,1,341,
  	1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,5,341,7273,8,341,
  	10,341,12,341,7276,9,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,4,
  	341,7285,8,341,11,341,12,341,7286,1,341,1,341,1,341,1,341,1,341,1,341,
  	1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,3,341,7304,8,341,
  	1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,1,341,
  	1,341,1,341,1,341,5,341,7321,8,341,10,341,12,341,7324,9,341,1,342,1,342,
  	1,343,1,343,1,343,1,343,1,343,1,343,1,343,1,343,1,343,1,343,1,343,1,343,
  	1,343,1,343,3,343,7342,8,343,1,344,1,344,1,344,1,344,1,344,1,344,1,344,
  	3,344,7351,8,344,1,345,1,345,1,345,1,345,1,345,1,345,1,345,3,345,7360,
  	8,345,1,346,1,346,1,347,1,347,1,347,1,347,1,347,3,347,7369,8,347,1,348,
  	1,348,1,349,1,349,1,350,1,350,1,351,1,351,1,352,1,352,1,353,1,353,1,354,
  	1,354,1,354,0,3,678,680,682,355,0,2,4,6,8,10,12,14,16,18,20,22,24,26,
  	28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,
  	74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,
  	116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,
  	152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,
  	188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,
  	224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,
  	260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,
  	296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,
  	332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,
  	368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,
  	404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,
  	440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,
  	476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,510,
  	512,514,516,518,520,522,524,526,528,530,532,534,536,538,540,542,544,546,
  	548,550,552,554,556,558,560,562,564,566,568,570,572,574,576,578,580,582,
  	584,586,588,590,592,594,596,598,600,602,604,606,608,610,612,614,616,618,
  	620,622,624,626,628,630,632,634,636,638,640,642,644,646,648,650,652,654,
  	656,658,660,662,664,666,668,670,672,674,676,678,680,682,684,686,688,690,
  	692,694,696,698,700,702,704,706,708,0,140,2,0,39,39,150,150,2,0,531,531,
  	537,537,3,0,69,69,159,159,181,181,3,0,42,42,384,384,454,454,4,0,42,42,
  	419,419,529,529,611,611,2,0,514,514,1147,1147,2,0,78,78,141,141,2,0,15,
  	15,334,334,3,0,44,44,85,85,184,184,2,0,434,434,558,558,3,0,506,506,650,
  	650,658,658,2,0,392,392,460,460,2,0,352,352,474,474,2,0,42,42,1137,1138,
  	2,0,350,350,443,443,2,0,459,459,673,673,3,0,80,80,84,84,125,125,3,0,42,
  	42,402,402,431,431,3,0,42,42,398,398,792,792,2,0,637,637,672,672,2,0,
  	81,81,91,91,3,0,436,436,548,548,613,613,2,0,69,69,159,159,1,0,356,357,
  	1,0,1137,1138,2,0,1147,1147,1155,1155,2,0,81,81,388,388,2,0,545,545,1147,
  	1147,2,0,546,546,1147,1147,3,0,430,430,469,469,521,521,7,0,42,42,370,
  	370,372,372,402,402,431,431,573,573,1155,1155,2,0,514,514,530,530,1,0,
  	1138,1139,2,0,5,5,51,51,4,0,42,42,384,384,454,454,458,458,2,0,26,26,30,
  	30,2,0,12,12,175,175,2,0,192,192,677,677,2,0,21,21,144,144,3,0,43,43,
  	75,75,106,106,2,0,106,106,374,374,2,0,365,365,427,427,2,0,101,101,601,
  	601,2,0,43,43,106,106,2,0,6,6,49,49,2,0,188,188,669,669,4,0,430,430,469,
  	469,520,520,562,562,2,0,430,430,520,520,2,0,13,13,45,45,3,0,66,66,78,
  	78,186,186,2,0,34,34,83,83,2,0,97,97,148,148,2,0,6,6,49,50,1,0,626,627,
  	2,0,172,172,742,742,2,0,439,439,609,609,2,0,226,226,477,477,5,0,107,107,
  	482,483,485,485,489,497,575,575,4,0,479,480,484,484,486,487,576,576,3,
  	0,108,108,478,478,488,488,2,0,462,462,628,628,2,0,622,622,624,624,2,0,
  	344,344,629,629,2,0,90,90,591,591,2,0,51,51,390,390,3,0,31,31,61,61,179,
  	179,3,0,131,131,172,172,437,437,3,0,12,12,19,19,187,187,2,0,42,42,121,
  	121,2,0,103,103,182,182,2,0,360,360,614,614,2,0,40,40,671,671,2,0,115,
  	115,474,474,2,0,422,422,568,568,4,0,206,206,208,208,214,214,638,638,2,
  	0,1107,1107,1123,1123,2,0,345,345,577,577,2,0,68,68,80,80,6,0,131,131,
  	172,172,177,177,415,415,437,437,671,671,2,0,513,513,634,634,2,0,412,412,
  	675,675,2,0,131,131,437,437,3,0,81,81,92,92,452,452,3,0,439,439,474,474,
  	609,609,2,0,634,634,670,670,2,0,376,376,567,567,6,0,226,226,409,409,411,
  	411,438,438,574,574,615,615,2,0,45,46,62,62,3,0,422,422,550,550,885,885,
  	2,0,466,466,652,652,10,0,359,359,367,367,378,380,387,387,507,507,515,
  	515,639,639,646,646,836,836,1004,1004,2,0,35,35,168,168,2,0,117,117,995,
  	995,11,0,359,359,367,367,378,380,387,387,507,507,515,515,592,592,639,
  	639,646,646,836,836,1004,1004,1,0,1159,1160,2,0,375,375,787,798,3,0,1137,
  	1139,1148,1148,1150,1150,2,0,63,63,178,178,2,0,116,116,1151,1151,5,0,
  	25,25,222,224,231,231,233,236,518,518,2,0,25,25,222,222,2,0,25,25,222,
  	223,1,0,196,207,3,0,183,183,195,195,612,612,2,0,211,216,431,431,6,0,217,
  	217,228,228,230,230,232,232,239,239,348,349,4,0,218,221,226,227,229,229,
  	346,346,2,0,153,153,237,237,2,0,466,466,803,811,2,0,226,226,518,518,5,
  	0,200,200,206,206,217,218,220,220,466,466,2,0,183,183,612,612,2,0,315,
  	316,322,322,4,0,37,37,150,150,313,316,331,331,1,0,325,326,3,0,17,17,95,
  	95,176,176,2,0,222,222,226,226,2,0,217,218,220,220,3,0,13,13,45,45,993,
  	993,3,0,286,286,298,299,309,309,3,0,287,289,305,308,310,312,2,0,295,295,
  	297,297,2,0,293,293,296,296,2,0,291,292,302,304,2,0,133,133,601,601,2,
  	0,433,433,559,559,2,0,535,535,551,551,2,0,114,114,1126,1126,3,0,63,63,
  	178,178,662,662,2,0,137,137,149,149,3,0,6,6,337,337,618,618,3,0,114,114,
  	1119,1120,1126,1127,1,0,1116,1122,2,0,226,226,746,786,1,0,799,802,5,0,
  	708,709,725,727,733,733,739,740,742,742,1,0,689,696,3,0,217,221,234,234,
  	237,237,58,0,14,14,18,18,29,29,35,35,37,37,42,42,48,48,55,55,57,57,59,
  	59,73,73,79,79,94,94,117,117,121,121,124,124,130,130,158,158,168,168,
  	239,239,283,290,294,294,298,299,305,312,332,385,387,403,405,405,407,432,
  	434,450,452,458,460,521,523,523,527,544,547,558,560,589,591,592,594,606,
  	608,636,638,672,674,675,677,682,684,688,697,697,699,707,710,712,717,718,
  	720,724,728,732,734,734,736,738,741,741,743,745,792,792,836,836,875,875,
  	999,999,1004,1004,1087,1087,23,0,39,39,97,97,148,148,150,150,217,219,
  	221,221,251,282,290,293,295,297,300,304,324,324,459,459,673,673,689,696,
  	736,736,803,803,806,835,837,874,876,998,1000,1003,1005,1086,1088,1106,
  	1122,1122,8700,0,711,1,0,0,0,2,730,1,0,0,0,4,751,1,0,0,0,6,753,1,0,0,
  	0,8,793,1,0,0,0,10,808,1,0,0,0,12,819,1,0,0,0,14,836,1,0,0,0,16,841,1,
  	0,0,0,18,853,1,0,0,0,20,880,1,0,0,0,22,889,1,0,0,0,24,891,1,0,0,0,26,
  	903,1,0,0,0,28,933,1,0,0,0,30,969,1,0,0,0,32,1020,1,0,0,0,34,1046,1,0,
  	0,0,36,1082,1,0,0,0,38,1095,1,0,0,0,40,1192,1,0,0,0,42,1194,1,0,0,0,44,
  	1212,1,0,0,0,46,1273,1,0,0,0,48,1292,1,0,0,0,50,1298,1,0,0,0,52,1320,
  	1,0,0,0,54,1322,1,0,0,0,56,1324,1,0,0,0,58,1404,1,0,0,0,60,1411,1,0,0,
  	0,62,1413,1,0,0,0,64,1457,1,0,0,0,66,1463,1,0,0,0,68,1465,1,0,0,0,70,
  	1486,1,0,0,0,72,1493,1,0,0,0,74,1495,1,0,0,0,76,1520,1,0,0,0,78,1523,
  	1,0,0,0,80,1528,1,0,0,0,82,1554,1,0,0,0,84,1570,1,0,0,0,86,1572,1,0,0,
  	0,88,1594,1,0,0,0,90,1596,1,0,0,0,92,1662,1,0,0,0,94,1733,1,0,0,0,96,
  	1735,1,0,0,0,98,1763,1,0,0,0,100,1773,1,0,0,0,102,1803,1,0,0,0,104,1990,
  	1,0,0,0,106,1992,1,0,0,0,108,1994,1,0,0,0,110,1997,1,0,0,0,112,2072,1,
  	0,0,0,114,2095,1,0,0,0,116,2243,1,0,0,0,118,2248,1,0,0,0,120,2250,1,0,
  	0,0,122,2260,1,0,0,0,124,2316,1,0,0,0,126,2336,1,0,0,0,128,2338,1,0,0,
  	0,130,2373,1,0,0,0,132,2382,1,0,0,0,134,2389,1,0,0,0,136,2412,1,0,0,0,
  	138,2421,1,0,0,0,140,2436,1,0,0,0,142,2461,1,0,0,0,144,2481,1,0,0,0,146,
  	2864,1,0,0,0,148,2964,1,0,0,0,150,2966,1,0,0,0,152,2973,1,0,0,0,154,2980,
  	1,0,0,0,156,3003,1,0,0,0,158,3011,1,0,0,0,160,3018,1,0,0,0,162,3025,1,
  	0,0,0,164,3032,1,0,0,0,166,3044,1,0,0,0,168,3054,1,0,0,0,170,3061,1,0,
  	0,0,172,3077,1,0,0,0,174,3123,1,0,0,0,176,3125,1,0,0,0,178,3135,1,0,0,
  	0,180,3139,1,0,0,0,182,3145,1,0,0,0,184,3157,1,0,0,0,186,3159,1,0,0,0,
  	188,3166,1,0,0,0,190,3168,1,0,0,0,192,3225,1,0,0,0,194,3299,1,0,0,0,196,
  	3358,1,0,0,0,198,3453,1,0,0,0,200,3457,1,0,0,0,202,3459,1,0,0,0,204,3494,
  	1,0,0,0,206,3496,1,0,0,0,208,3504,1,0,0,0,210,3512,1,0,0,0,212,3514,1,
  	0,0,0,214,3550,1,0,0,0,216,3605,1,0,0,0,218,3614,1,0,0,0,220,3634,1,0,
  	0,0,222,3646,1,0,0,0,224,3650,1,0,0,0,226,3683,1,0,0,0,228,3704,1,0,0,
  	0,230,3714,1,0,0,0,232,3718,1,0,0,0,234,3744,1,0,0,0,236,3786,1,0,0,0,
  	238,3788,1,0,0,0,240,3803,1,0,0,0,242,3855,1,0,0,0,244,3865,1,0,0,0,246,
  	3875,1,0,0,0,248,3931,1,0,0,0,250,3933,1,0,0,0,252,3957,1,0,0,0,254,3963,
  	1,0,0,0,256,3971,1,0,0,0,258,3988,1,0,0,0,260,4004,1,0,0,0,262,4041,1,
  	0,0,0,264,4047,1,0,0,0,266,4056,1,0,0,0,268,4069,1,0,0,0,270,4073,1,0,
  	0,0,272,4111,1,0,0,0,274,4149,1,0,0,0,276,4163,1,0,0,0,278,4171,1,0,0,
  	0,280,4175,1,0,0,0,282,4181,1,0,0,0,284,4195,1,0,0,0,286,4198,1,0,0,0,
  	288,4216,1,0,0,0,290,4220,1,0,0,0,292,4236,1,0,0,0,294,4238,1,0,0,0,296,
  	4250,1,0,0,0,298,4254,1,0,0,0,300,4271,1,0,0,0,302,4288,1,0,0,0,304,4291,
  	1,0,0,0,306,4301,1,0,0,0,308,4305,1,0,0,0,310,4318,1,0,0,0,312,4321,1,
  	0,0,0,314,4326,1,0,0,0,316,4346,1,0,0,0,318,4348,1,0,0,0,320,4365,1,0,
  	0,0,322,4374,1,0,0,0,324,4383,1,0,0,0,326,4385,1,0,0,0,328,4399,1,0,0,
  	0,330,4410,1,0,0,0,332,4419,1,0,0,0,334,4422,1,0,0,0,336,4430,1,0,0,0,
  	338,4455,1,0,0,0,340,4467,1,0,0,0,342,4470,1,0,0,0,344,4502,1,0,0,0,346,
  	4504,1,0,0,0,348,4506,1,0,0,0,350,4508,1,0,0,0,352,4510,1,0,0,0,354,4563,
  	1,0,0,0,356,4565,1,0,0,0,358,4571,1,0,0,0,360,4591,1,0,0,0,362,4605,1,
  	0,0,0,364,4616,1,0,0,0,366,4618,1,0,0,0,368,4624,1,0,0,0,370,4634,1,0,
  	0,0,372,4638,1,0,0,0,374,4645,1,0,0,0,376,4649,1,0,0,0,378,4655,1,0,0,
  	0,380,4662,1,0,0,0,382,4668,1,0,0,0,384,4674,1,0,0,0,386,4679,1,0,0,0,
  	388,4724,1,0,0,0,390,4745,1,0,0,0,392,4770,1,0,0,0,394,4773,1,0,0,0,396,
  	4779,1,0,0,0,398,4795,1,0,0,0,400,4810,1,0,0,0,402,4816,1,0,0,0,404,4846,
  	1,0,0,0,406,4848,1,0,0,0,408,4855,1,0,0,0,410,4867,1,0,0,0,412,4873,1,
  	0,0,0,414,4898,1,0,0,0,416,4902,1,0,0,0,418,4906,1,0,0,0,420,4917,1,0,
  	0,0,422,4998,1,0,0,0,424,5065,1,0,0,0,426,5067,1,0,0,0,428,5173,1,0,0,
  	0,430,5197,1,0,0,0,432,5199,1,0,0,0,434,5217,1,0,0,0,436,5297,1,0,0,0,
  	438,5299,1,0,0,0,440,5312,1,0,0,0,442,5323,1,0,0,0,444,5347,1,0,0,0,446,
  	5358,1,0,0,0,448,5368,1,0,0,0,450,5378,1,0,0,0,452,5418,1,0,0,0,454,5420,
  	1,0,0,0,456,5423,1,0,0,0,458,5523,1,0,0,0,460,5541,1,0,0,0,462,5543,1,
  	0,0,0,464,5547,1,0,0,0,466,5585,1,0,0,0,468,5594,1,0,0,0,470,5600,1,0,
  	0,0,472,5607,1,0,0,0,474,5629,1,0,0,0,476,5631,1,0,0,0,478,5645,1,0,0,
  	0,480,5651,1,0,0,0,482,5707,1,0,0,0,484,5862,1,0,0,0,486,5874,1,0,0,0,
  	488,5889,1,0,0,0,490,5895,1,0,0,0,492,5914,1,0,0,0,494,5924,1,0,0,0,496,
  	5938,1,0,0,0,498,5940,1,0,0,0,500,5943,1,0,0,0,502,5965,1,0,0,0,504,5977,
  	1,0,0,0,506,5983,1,0,0,0,508,5995,1,0,0,0,510,5999,1,0,0,0,512,6001,1,
  	0,0,0,514,6043,1,0,0,0,516,6050,1,0,0,0,518,6052,1,0,0,0,520,6075,1,0,
  	0,0,522,6081,1,0,0,0,524,6089,1,0,0,0,526,6092,1,0,0,0,528,6095,1,0,0,
  	0,530,6116,1,0,0,0,532,6137,1,0,0,0,534,6145,1,0,0,0,536,6157,1,0,0,0,
  	538,6165,1,0,0,0,540,6203,1,0,0,0,542,6215,1,0,0,0,544,6217,1,0,0,0,546,
  	6223,1,0,0,0,548,6227,1,0,0,0,550,6243,1,0,0,0,552,6256,1,0,0,0,554,6266,
  	1,0,0,0,556,6268,1,0,0,0,558,6274,1,0,0,0,560,6278,1,0,0,0,562,6283,1,
  	0,0,0,564,6285,1,0,0,0,566,6287,1,0,0,0,568,6305,1,0,0,0,570,6321,1,0,
  	0,0,572,6325,1,0,0,0,574,6330,1,0,0,0,576,6341,1,0,0,0,578,6346,1,0,0,
  	0,580,6348,1,0,0,0,582,6352,1,0,0,0,584,6377,1,0,0,0,586,6379,1,0,0,0,
  	588,6382,1,0,0,0,590,6387,1,0,0,0,592,6403,1,0,0,0,594,6531,1,0,0,0,596,
  	6533,1,0,0,0,598,6566,1,0,0,0,600,6571,1,0,0,0,602,6575,1,0,0,0,604,6581,
  	1,0,0,0,606,6589,1,0,0,0,608,6597,1,0,0,0,610,6605,1,0,0,0,612,6613,1,
  	0,0,0,614,6624,1,0,0,0,616,6632,1,0,0,0,618,6640,1,0,0,0,620,6648,1,0,
  	0,0,622,6656,1,0,0,0,624,6690,1,0,0,0,626,6706,1,0,0,0,628,6710,1,0,0,
  	0,630,6712,1,0,0,0,632,6715,1,0,0,0,634,6719,1,0,0,0,636,6725,1,0,0,0,
  	638,6745,1,0,0,0,640,6925,1,0,0,0,642,6927,1,0,0,0,644,6946,1,0,0,0,646,
  	6948,1,0,0,0,648,7011,1,0,0,0,650,7051,1,0,0,0,652,7053,1,0,0,0,654,7062,
  	1,0,0,0,656,7073,1,0,0,0,658,7075,1,0,0,0,660,7078,1,0,0,0,662,7082,1,
  	0,0,0,664,7084,1,0,0,0,666,7096,1,0,0,0,668,7098,1,0,0,0,670,7131,1,0,
  	0,0,672,7133,1,0,0,0,674,7142,1,0,0,0,676,7160,1,0,0,0,678,7173,1,0,0,
  	0,680,7184,1,0,0,0,682,7303,1,0,0,0,684,7325,1,0,0,0,686,7341,1,0,0,0,
  	688,7350,1,0,0,0,690,7359,1,0,0,0,692,7361,1,0,0,0,694,7368,1,0,0,0,696,
  	7370,1,0,0,0,698,7372,1,0,0,0,700,7374,1,0,0,0,702,7376,1,0,0,0,704,7378,
  	1,0,0,0,706,7380,1,0,0,0,708,7382,1,0,0,0,710,712,3,2,1,0,711,710,1,0,
  	0,0,711,712,1,0,0,0,712,715,1,0,0,0,713,714,5,1120,0,0,714,716,5,1120,
  	0,0,715,713,1,0,0,0,715,716,1,0,0,0,716,717,1,0,0,0,717,718,5,0,0,1,718,
  	1,1,0,0,0,719,722,3,4,2,0,720,721,5,1120,0,0,721,723,5,1120,0,0,722,720,
  	1,0,0,0,722,723,1,0,0,0,723,725,1,0,0,0,724,726,5,1135,0,0,725,724,1,
  	0,0,0,725,726,1,0,0,0,726,729,1,0,0,0,727,729,3,6,3,0,728,719,1,0,0,0,
  	728,727,1,0,0,0,729,732,1,0,0,0,730,728,1,0,0,0,730,731,1,0,0,0,731,742,
  	1,0,0,0,732,730,1,0,0,0,733,739,3,4,2,0,734,735,5,1120,0,0,735,737,5,
  	1120,0,0,736,734,1,0,0,0,736,737,1,0,0,0,737,738,1,0,0,0,738,740,5,1135,
  	0,0,739,736,1,0,0,0,739,740,1,0,0,0,740,743,1,0,0,0,741,743,3,6,3,0,742,
  	733,1,0,0,0,742,741,1,0,0,0,743,3,1,0,0,0,744,752,3,8,4,0,745,752,3,10,
  	5,0,746,752,3,12,6,0,747,752,3,14,7,0,748,752,3,16,8,0,749,752,3,20,10,
  	0,750,752,3,22,11,0,751,744,1,0,0,0,751,745,1,0,0,0,751,746,1,0,0,0,751,
  	747,1,0,0,0,751,748,1,0,0,0,751,749,1,0,0,0,751,750,1,0,0,0,752,5,1,0,
  	0,0,753,754,5,1135,0,0,754,7,1,0,0,0,755,794,3,24,12,0,756,794,3,26,13,
  	0,757,794,3,28,14,0,758,794,3,30,15,0,759,794,3,32,16,0,760,794,3,34,
  	17,0,761,794,3,38,19,0,762,794,3,40,20,0,763,794,3,42,21,0,764,794,3,
  	44,22,0,765,794,3,46,23,0,766,794,3,56,28,0,767,794,3,36,18,0,768,794,
  	3,126,63,0,769,794,3,128,64,0,770,794,3,130,65,0,771,794,3,132,66,0,772,
  	794,3,134,67,0,773,794,3,136,68,0,774,794,3,138,69,0,775,794,3,140,70,
  	0,776,794,3,142,71,0,777,794,3,144,72,0,778,794,3,150,75,0,779,794,3,
  	152,76,0,780,794,3,154,77,0,781,794,3,156,78,0,782,794,3,158,79,0,783,
  	794,3,160,80,0,784,794,3,162,81,0,785,794,3,164,82,0,786,794,3,166,83,
  	0,787,794,3,168,84,0,788,794,3,170,85,0,789,794,3,172,86,0,790,794,3,
  	174,87,0,791,794,3,176,88,0,792,794,3,180,90,0,793,755,1,0,0,0,793,756,
  	1,0,0,0,793,757,1,0,0,0,793,758,1,0,0,0,793,759,1,0,0,0,793,760,1,0,0,
  	0,793,761,1,0,0,0,793,762,1,0,0,0,793,763,1,0,0,0,793,764,1,0,0,0,793,
  	765,1,0,0,0,793,766,1,0,0,0,793,767,1,0,0,0,793,768,1,0,0,0,793,769,1,
  	0,0,0,793,770,1,0,0,0,793,771,1,0,0,0,793,772,1,0,0,0,793,773,1,0,0,0,
  	793,774,1,0,0,0,793,775,1,0,0,0,793,776,1,0,0,0,793,777,1,0,0,0,793,778,
  	1,0,0,0,793,779,1,0,0,0,793,780,1,0,0,0,793,781,1,0,0,0,793,782,1,0,0,
  	0,793,783,1,0,0,0,793,784,1,0,0,0,793,785,1,0,0,0,793,786,1,0,0,0,793,
  	787,1,0,0,0,793,788,1,0,0,0,793,789,1,0,0,0,793,790,1,0,0,0,793,791,1,
  	0,0,0,793,792,1,0,0,0,794,9,1,0,0,0,795,809,3,198,99,0,796,809,3,190,
  	95,0,797,809,3,200,100,0,798,809,3,184,92,0,799,809,3,196,98,0,800,809,
  	3,182,91,0,801,809,3,192,96,0,802,809,3,194,97,0,803,809,3,186,93,0,804,
  	809,3,188,94,0,805,809,3,202,101,0,806,809,3,534,267,0,807,809,3,536,
  	268,0,808,795,1,0,0,0,808,796,1,0,0,0,808,797,1,0,0,0,808,798,1,0,0,0,
  	808,799,1,0,0,0,808,800,1,0,0,0,808,801,1,0,0,0,808,802,1,0,0,0,808,803,
  	1,0,0,0,808,804,1,0,0,0,808,805,1,0,0,0,808,806,1,0,0,0,808,807,1,0,0,
  	0,809,11,1,0,0,0,810,820,3,294,147,0,811,820,3,296,148,0,812,820,3,298,
  	149,0,813,820,3,300,150,0,814,820,3,302,151,0,815,820,3,304,152,0,816,
  	820,3,306,153,0,817,820,3,308,154,0,818,820,3,310,155,0,819,810,1,0,0,
  	0,819,811,1,0,0,0,819,812,1,0,0,0,819,813,1,0,0,0,819,814,1,0,0,0,819,
  	815,1,0,0,0,819,816,1,0,0,0,819,817,1,0,0,0,819,818,1,0,0,0,820,13,1,
  	0,0,0,821,837,3,326,163,0,822,837,3,328,164,0,823,837,3,330,165,0,824,
  	837,3,332,166,0,825,837,3,334,167,0,826,837,3,336,168,0,827,837,3,338,
  	169,0,828,837,3,340,170,0,829,837,3,342,171,0,830,837,3,366,183,0,831,
  	837,3,368,184,0,832,837,3,370,185,0,833,837,3,372,186,0,834,837,3,374,
  	187,0,835,837,3,376,188,0,836,821,1,0,0,0,836,822,1,0,0,0,836,823,1,0,
  	0,0,836,824,1,0,0,0,836,825,1,0,0,0,836,826,1,0,0,0,836,827,1,0,0,0,836,
  	828,1,0,0,0,836,829,1,0,0,0,836,830,1,0,0,0,836,831,1,0,0,0,836,832,1,
  	0,0,0,836,833,1,0,0,0,836,834,1,0,0,0,836,835,1,0,0,0,837,15,1,0,0,0,
  	838,842,3,378,189,0,839,842,3,380,190,0,840,842,3,382,191,0,841,838,1,
  	0,0,0,841,839,1,0,0,0,841,840,1,0,0,0,842,17,1,0,0,0,843,854,3,386,193,
  	0,844,854,3,388,194,0,845,854,3,390,195,0,846,854,3,394,197,0,847,854,
  	3,396,198,0,848,854,3,398,199,0,849,854,3,402,201,0,850,854,3,392,196,
  	0,851,854,3,400,200,0,852,854,3,404,202,0,853,843,1,0,0,0,853,844,1,0,
  	0,0,853,845,1,0,0,0,853,846,1,0,0,0,853,847,1,0,0,0,853,848,1,0,0,0,853,
  	849,1,0,0,0,853,850,1,0,0,0,853,851,1,0,0,0,853,852,1,0,0,0,854,19,1,
  	0,0,0,855,881,3,422,211,0,856,881,3,424,212,0,857,881,3,426,213,0,858,
  	881,3,428,214,0,859,881,3,432,216,0,860,881,3,434,217,0,861,881,3,436,
  	218,0,862,881,3,438,219,0,863,881,3,464,232,0,864,881,3,466,233,0,865,
  	881,3,468,234,0,866,881,3,470,235,0,867,881,3,472,236,0,868,881,3,476,
  	238,0,869,881,3,478,239,0,870,881,3,480,240,0,871,881,3,482,241,0,872,
  	881,3,484,242,0,873,881,3,498,249,0,874,881,3,500,250,0,875,881,3,502,
  	251,0,876,881,3,504,252,0,877,881,3,506,253,0,878,881,3,508,254,0,879,
  	881,3,510,255,0,880,855,1,0,0,0,880,856,1,0,0,0,880,857,1,0,0,0,880,858,
  	1,0,0,0,880,859,1,0,0,0,880,860,1,0,0,0,880,861,1,0,0,0,880,862,1,0,0,
  	0,880,863,1,0,0,0,880,864,1,0,0,0,880,865,1,0,0,0,880,866,1,0,0,0,880,
  	867,1,0,0,0,880,868,1,0,0,0,880,869,1,0,0,0,880,870,1,0,0,0,880,871,1,
  	0,0,0,880,872,1,0,0,0,880,873,1,0,0,0,880,874,1,0,0,0,880,875,1,0,0,0,
  	880,876,1,0,0,0,880,877,1,0,0,0,880,878,1,0,0,0,880,879,1,0,0,0,881,21,
  	1,0,0,0,882,890,3,520,260,0,883,890,3,522,261,0,884,890,3,524,262,0,885,
  	890,3,526,263,0,886,890,3,528,264,0,887,890,3,530,265,0,888,890,3,538,
  	269,0,889,882,1,0,0,0,889,883,1,0,0,0,889,884,1,0,0,0,889,885,1,0,0,0,
  	889,886,1,0,0,0,889,887,1,0,0,0,889,888,1,0,0,0,890,23,1,0,0,0,891,892,
  	5,33,0,0,892,894,7,0,0,0,893,895,3,632,316,0,894,893,1,0,0,0,894,895,
  	1,0,0,0,895,896,1,0,0,0,896,900,3,574,287,0,897,899,3,58,29,0,898,897,
  	1,0,0,0,899,902,1,0,0,0,900,898,1,0,0,0,900,901,1,0,0,0,901,25,1,0,0,
  	0,902,900,1,0,0,0,903,905,5,33,0,0,904,906,3,62,31,0,905,904,1,0,0,0,
  	905,906,1,0,0,0,906,907,1,0,0,0,907,909,5,415,0,0,908,910,3,632,316,0,
  	909,908,1,0,0,0,909,910,1,0,0,0,910,911,1,0,0,0,911,912,3,544,272,0,912,
  	913,5,118,0,0,913,914,5,605,0,0,914,921,3,64,32,0,915,916,5,118,0,0,916,
  	918,5,371,0,0,917,919,5,114,0,0,918,917,1,0,0,0,918,919,1,0,0,0,919,920,
  	1,0,0,0,920,922,5,561,0,0,921,915,1,0,0,0,921,922,1,0,0,0,922,924,1,0,
  	0,0,923,925,3,72,36,0,924,923,1,0,0,0,924,925,1,0,0,0,925,928,1,0,0,0,
  	926,927,5,368,0,0,927,929,5,1147,0,0,928,926,1,0,0,0,928,929,1,0,0,0,
  	929,930,1,0,0,0,930,931,5,399,0,0,931,932,3,384,192,0,932,27,1,0,0,0,
  	933,935,5,33,0,0,934,936,7,1,0,0,935,934,1,0,0,0,935,936,1,0,0,0,936,
  	938,1,0,0,0,937,939,7,2,0,0,938,937,1,0,0,0,938,939,1,0,0,0,939,940,1,
  	0,0,0,940,941,5,81,0,0,941,943,3,574,287,0,942,944,3,74,37,0,943,942,
  	1,0,0,0,943,944,1,0,0,0,944,945,1,0,0,0,945,946,5,118,0,0,946,947,3,546,
  	273,0,947,951,3,612,306,0,948,950,3,76,38,0,949,948,1,0,0,0,950,953,1,
  	0,0,0,951,949,1,0,0,0,951,952,1,0,0,0,952,966,1,0,0,0,953,951,1,0,0,0,
  	954,956,5,336,0,0,955,957,5,1123,0,0,956,955,1,0,0,0,956,957,1,0,0,0,
  	957,958,1,0,0,0,958,965,7,3,0,0,959,961,5,103,0,0,960,962,5,1123,0,0,
  	961,960,1,0,0,0,961,962,1,0,0,0,962,963,1,0,0,0,963,965,7,4,0,0,964,954,
  	1,0,0,0,964,959,1,0,0,0,965,968,1,0,0,0,966,964,1,0,0,0,966,967,1,0,0,
  	0,967,29,1,0,0,0,968,966,1,0,0,0,969,970,5,33,0,0,970,971,5,475,0,0,971,
  	972,5,73,0,0,972,973,3,574,287,0,973,974,5,5,0,0,974,975,5,659,0,0,975,
  	981,5,1147,0,0,976,978,5,453,0,0,977,979,5,1123,0,0,978,977,1,0,0,0,978,
  	979,1,0,0,0,979,980,1,0,0,0,980,982,3,582,291,0,981,976,1,0,0,0,981,982,
  	1,0,0,0,982,988,1,0,0,0,983,985,5,660,0,0,984,986,5,1123,0,0,985,984,
  	1,0,0,0,985,986,1,0,0,0,986,987,1,0,0,0,987,989,3,582,291,0,988,983,1,
  	0,0,0,988,989,1,0,0,0,989,995,1,0,0,0,990,992,5,572,0,0,991,993,5,1123,
  	0,0,992,991,1,0,0,0,992,993,1,0,0,0,993,994,1,0,0,0,994,996,3,582,291,
  	0,995,990,1,0,0,0,995,996,1,0,0,0,996,1002,1,0,0,0,997,999,5,528,0,0,
  	998,1000,5,1123,0,0,999,998,1,0,0,0,999,1000,1,0,0,0,1000,1001,1,0,0,
  	0,1001,1003,3,574,287,0,1002,997,1,0,0,0,1002,1003,1,0,0,0,1003,1005,
  	1,0,0,0,1004,1006,5,674,0,0,1005,1004,1,0,0,0,1005,1006,1,0,0,0,1006,
  	1012,1,0,0,0,1007,1009,5,368,0,0,1008,1010,5,1123,0,0,1009,1008,1,0,0,
  	0,1009,1010,1,0,0,0,1010,1011,1,0,0,0,1011,1013,5,1147,0,0,1012,1007,
  	1,0,0,0,1012,1013,1,0,0,0,1013,1014,1,0,0,0,1014,1016,5,409,0,0,1015,
  	1017,5,1123,0,0,1016,1015,1,0,0,0,1016,1017,1,0,0,0,1017,1018,1,0,0,0,
  	1018,1019,3,562,281,0,1019,31,1,0,0,0,1020,1022,5,33,0,0,1021,1023,3,
  	62,31,0,1022,1021,1,0,0,0,1022,1023,1,0,0,0,1023,1024,1,0,0,0,1024,1025,
  	5,131,0,0,1025,1026,3,544,272,0,1026,1028,5,1132,0,0,1027,1029,3,78,39,
  	0,1028,1027,1,0,0,0,1028,1029,1,0,0,0,1029,1034,1,0,0,0,1030,1031,5,1134,
  	0,0,1031,1033,3,78,39,0,1032,1030,1,0,0,0,1033,1036,1,0,0,0,1034,1032,
  	1,0,0,0,1034,1035,1,0,0,0,1035,1037,1,0,0,0,1036,1034,1,0,0,0,1037,1041,
  	5,1133,0,0,1038,1040,3,82,41,0,1039,1038,1,0,0,0,1040,1043,1,0,0,0,1041,
  	1039,1,0,0,0,1041,1042,1,0,0,0,1042,1044,1,0,0,0,1043,1041,1,0,0,0,1044,
  	1045,3,384,192,0,1045,33,1,0,0,0,1046,1048,5,33,0,0,1047,1049,3,62,31,
  	0,1048,1047,1,0,0,0,1048,1049,1,0,0,0,1049,1051,1,0,0,0,1050,1052,5,335,
  	0,0,1051,1050,1,0,0,0,1051,1052,1,0,0,0,1052,1053,1,0,0,0,1053,1055,5,
  	437,0,0,1054,1056,3,632,316,0,1055,1054,1,0,0,0,1055,1056,1,0,0,0,1056,
  	1057,1,0,0,0,1057,1058,3,544,272,0,1058,1060,5,1132,0,0,1059,1061,3,80,
  	40,0,1060,1059,1,0,0,0,1060,1061,1,0,0,0,1061,1066,1,0,0,0,1062,1063,
  	5,1134,0,0,1063,1065,3,80,40,0,1064,1062,1,0,0,0,1065,1068,1,0,0,0,1066,
  	1064,1,0,0,0,1066,1067,1,0,0,0,1067,1069,1,0,0,0,1068,1066,1,0,0,0,1069,
  	1070,5,1133,0,0,1070,1071,5,594,0,0,1071,1075,3,594,297,0,1072,1074,3,
  	82,41,0,1073,1072,1,0,0,0,1074,1077,1,0,0,0,1075,1073,1,0,0,0,1075,1076,
  	1,0,0,0,1076,1080,1,0,0,0,1077,1075,1,0,0,0,1078,1081,3,384,192,0,1079,
  	1081,3,400,200,0,1080,1078,1,0,0,0,1080,1079,1,0,0,0,1081,35,1,0,0,0,
  	1082,1083,5,33,0,0,1083,1085,5,596,0,0,1084,1086,3,632,316,0,1085,1084,
  	1,0,0,0,1085,1086,1,0,0,0,1086,1087,1,0,0,0,1087,1092,3,548,274,0,1088,
  	1089,5,1134,0,0,1089,1091,3,548,274,0,1090,1088,1,0,0,0,1091,1094,1,0,
  	0,0,1092,1090,1,0,0,0,1092,1093,1,0,0,0,1093,37,1,0,0,0,1094,1092,1,0,
  	0,0,1095,1096,5,33,0,0,1096,1097,5,608,0,0,1097,1098,3,574,287,0,1098,
  	1099,5,67,0,0,1099,1100,5,388,0,0,1100,1101,5,679,0,0,1101,1102,7,5,0,
  	0,1102,1103,5,541,0,0,1103,1104,5,1132,0,0,1104,1109,3,84,42,0,1105,1106,
  	5,1134,0,0,1106,1108,3,84,42,0,1107,1105,1,0,0,0,1108,1111,1,0,0,0,1109,
  	1107,1,0,0,0,1109,1110,1,0,0,0,1110,1112,1,0,0,0,1111,1109,1,0,0,0,1112,
  	1113,5,1133,0,0,1113,39,1,0,0,0,1114,1116,5,33,0,0,1115,1117,5,649,0,
  	0,1116,1115,1,0,0,0,1116,1117,1,0,0,0,1117,1118,1,0,0,0,1118,1120,5,172,
  	0,0,1119,1121,3,632,316,0,1120,1119,1,0,0,0,1120,1121,1,0,0,0,1121,1122,
  	1,0,0,0,1122,1130,3,546,273,0,1123,1124,5,98,0,0,1124,1131,3,546,273,
  	0,1125,1126,5,1132,0,0,1126,1127,5,98,0,0,1127,1128,3,546,273,0,1128,
  	1129,5,1133,0,0,1129,1131,1,0,0,0,1130,1123,1,0,0,0,1130,1125,1,0,0,0,
  	1131,1193,1,0,0,0,1132,1134,5,33,0,0,1133,1135,5,649,0,0,1134,1133,1,
  	0,0,0,1134,1135,1,0,0,0,1135,1136,1,0,0,0,1136,1138,5,172,0,0,1137,1139,
  	3,632,316,0,1138,1137,1,0,0,0,1138,1139,1,0,0,0,1139,1140,1,0,0,0,1140,
  	1142,3,546,273,0,1141,1143,3,86,43,0,1142,1141,1,0,0,0,1142,1143,1,0,
  	0,0,1143,1154,1,0,0,0,1144,1151,3,104,52,0,1145,1147,5,1134,0,0,1146,
  	1145,1,0,0,0,1146,1147,1,0,0,0,1147,1148,1,0,0,0,1148,1150,3,104,52,0,
  	1149,1146,1,0,0,0,1150,1153,1,0,0,0,1151,1149,1,0,0,0,1151,1152,1,0,0,
  	0,1152,1155,1,0,0,0,1153,1151,1,0,0,0,1154,1144,1,0,0,0,1154,1155,1,0,
  	0,0,1155,1157,1,0,0,0,1156,1158,3,110,55,0,1157,1156,1,0,0,0,1157,1158,
  	1,0,0,0,1158,1160,1,0,0,0,1159,1161,7,6,0,0,1160,1159,1,0,0,0,1160,1161,
  	1,0,0,0,1161,1163,1,0,0,0,1162,1164,5,12,0,0,1163,1162,1,0,0,0,1163,1164,
  	1,0,0,0,1164,1165,1,0,0,0,1165,1166,3,198,99,0,1166,1193,1,0,0,0,1167,
  	1169,5,33,0,0,1168,1170,5,649,0,0,1169,1168,1,0,0,0,1169,1170,1,0,0,0,
  	1170,1171,1,0,0,0,1171,1173,5,172,0,0,1172,1174,3,632,316,0,1173,1172,
  	1,0,0,0,1173,1174,1,0,0,0,1174,1175,1,0,0,0,1175,1176,3,546,273,0,1176,
  	1187,3,86,43,0,1177,1184,3,104,52,0,1178,1180,5,1134,0,0,1179,1178,1,
  	0,0,0,1179,1180,1,0,0,0,1180,1181,1,0,0,0,1181,1183,3,104,52,0,1182,1179,
  	1,0,0,0,1183,1186,1,0,0,0,1184,1182,1,0,0,0,1184,1185,1,0,0,0,1185,1188,
  	1,0,0,0,1186,1184,1,0,0,0,1187,1177,1,0,0,0,1187,1188,1,0,0,0,1188,1190,
  	1,0,0,0,1189,1191,3,110,55,0,1190,1189,1,0,0,0,1190,1191,1,0,0,0,1191,
  	1193,1,0,0,0,1192,1114,1,0,0,0,1192,1132,1,0,0,0,1192,1167,1,0,0,0,1193,
  	41,1,0,0,0,1194,1195,5,33,0,0,1195,1196,5,647,0,0,1196,1197,3,574,287,
  	0,1197,1198,5,5,0,0,1198,1199,5,389,0,0,1199,1203,5,1147,0,0,1200,1201,
  	5,428,0,0,1201,1202,5,1123,0,0,1202,1204,3,582,291,0,1203,1200,1,0,0,
  	0,1203,1204,1,0,0,0,1204,1210,1,0,0,0,1205,1207,5,409,0,0,1206,1208,5,
  	1123,0,0,1207,1206,1,0,0,0,1207,1208,1,0,0,0,1208,1209,1,0,0,0,1209,1211,
  	3,562,281,0,1210,1205,1,0,0,0,1210,1211,1,0,0,0,1211,43,1,0,0,0,1212,
  	1213,5,33,0,0,1213,1214,5,647,0,0,1214,1215,3,574,287,0,1215,1216,5,5,
  	0,0,1216,1217,5,389,0,0,1217,1218,5,1147,0,0,1218,1219,5,186,0,0,1219,
  	1220,5,475,0,0,1220,1221,5,73,0,0,1221,1227,3,574,287,0,1222,1224,5,423,
  	0,0,1223,1225,5,1123,0,0,1224,1223,1,0,0,0,1224,1225,1,0,0,0,1225,1226,
  	1,0,0,0,1226,1228,3,582,291,0,1227,1222,1,0,0,0,1227,1228,1,0,0,0,1228,
  	1234,1,0,0,0,1229,1231,5,453,0,0,1230,1232,5,1123,0,0,1231,1230,1,0,0,
  	0,1231,1232,1,0,0,0,1232,1233,1,0,0,0,1233,1235,3,582,291,0,1234,1229,
  	1,0,0,0,1234,1235,1,0,0,0,1235,1241,1,0,0,0,1236,1238,5,341,0,0,1237,
  	1239,5,1123,0,0,1238,1237,1,0,0,0,1238,1239,1,0,0,0,1239,1240,1,0,0,0,
  	1240,1242,3,582,291,0,1241,1236,1,0,0,0,1241,1242,1,0,0,0,1242,1248,1,
  	0,0,0,1243,1245,5,501,0,0,1244,1246,5,1123,0,0,1245,1244,1,0,0,0,1245,
  	1246,1,0,0,0,1246,1247,1,0,0,0,1247,1249,3,582,291,0,1248,1243,1,0,0,
  	0,1248,1249,1,0,0,0,1249,1255,1,0,0,0,1250,1252,5,528,0,0,1251,1253,5,
  	1123,0,0,1252,1251,1,0,0,0,1252,1253,1,0,0,0,1253,1254,1,0,0,0,1254,1256,
  	3,574,287,0,1255,1250,1,0,0,0,1255,1256,1,0,0,0,1256,1258,1,0,0,0,1257,
  	1259,5,674,0,0,1258,1257,1,0,0,0,1258,1259,1,0,0,0,1259,1265,1,0,0,0,
  	1260,1262,5,368,0,0,1261,1263,5,1123,0,0,1262,1261,1,0,0,0,1262,1263,
  	1,0,0,0,1263,1264,1,0,0,0,1264,1266,5,1147,0,0,1265,1260,1,0,0,0,1265,
  	1266,1,0,0,0,1266,1267,1,0,0,0,1267,1269,5,409,0,0,1268,1270,5,1123,0,
  	0,1269,1268,1,0,0,0,1269,1270,1,0,0,0,1270,1271,1,0,0,0,1271,1272,3,562,
  	281,0,1272,45,1,0,0,0,1273,1275,5,33,0,0,1274,1276,3,62,31,0,1275,1274,
  	1,0,0,0,1275,1276,1,0,0,0,1276,1277,1,0,0,0,1277,1278,5,177,0,0,1278,
  	1279,3,544,272,0,1279,1280,7,7,0,0,1280,1281,7,8,0,0,1281,1282,5,118,
  	0,0,1282,1283,3,546,273,0,1283,1284,5,65,0,0,1284,1285,5,52,0,0,1285,
  	1288,5,600,0,0,1286,1287,7,9,0,0,1287,1289,3,544,272,0,1288,1286,1,0,
  	0,0,1288,1289,1,0,0,0,1289,1290,1,0,0,0,1290,1291,3,384,192,0,1291,47,
  	1,0,0,0,1292,1294,5,192,0,0,1293,1295,5,571,0,0,1294,1293,1,0,0,0,1294,
  	1295,1,0,0,0,1295,1296,1,0,0,0,1296,1297,3,50,25,0,1297,49,1,0,0,0,1298,
  	1310,3,52,26,0,1299,1300,5,1132,0,0,1300,1305,3,54,27,0,1301,1302,5,1134,
  	0,0,1302,1304,3,54,27,0,1303,1301,1,0,0,0,1304,1307,1,0,0,0,1305,1303,
  	1,0,0,0,1305,1306,1,0,0,0,1306,1308,1,0,0,0,1307,1305,1,0,0,0,1308,1309,
  	5,1133,0,0,1309,1311,1,0,0,0,1310,1299,1,0,0,0,1310,1311,1,0,0,0,1311,
  	1312,1,0,0,0,1312,1313,5,12,0,0,1313,1314,5,1132,0,0,1314,1315,3,10,5,
  	0,1315,1318,5,1133,0,0,1316,1317,5,1134,0,0,1317,1319,3,50,25,0,1318,
  	1316,1,0,0,0,1318,1319,1,0,0,0,1319,51,1,0,0,0,1320,1321,3,574,287,0,
  	1321,53,1,0,0,0,1322,1323,3,574,287,0,1323,55,1,0,0,0,1324,1326,5,33,
  	0,0,1325,1327,3,634,317,0,1326,1325,1,0,0,0,1326,1327,1,0,0,0,1327,1331,
  	1,0,0,0,1328,1329,5,336,0,0,1329,1330,5,1123,0,0,1330,1332,7,10,0,0,1331,
  	1328,1,0,0,0,1331,1332,1,0,0,0,1332,1334,1,0,0,0,1333,1335,3,62,31,0,
  	1334,1333,1,0,0,0,1334,1335,1,0,0,0,1335,1339,1,0,0,0,1336,1337,5,160,
  	0,0,1337,1338,5,606,0,0,1338,1340,7,11,0,0,1339,1336,1,0,0,0,1339,1340,
  	1,0,0,0,1340,1341,1,0,0,0,1341,1342,5,671,0,0,1342,1347,3,544,272,0,1343,
  	1344,5,1132,0,0,1344,1345,3,606,303,0,1345,1346,5,1133,0,0,1346,1348,
  	1,0,0,0,1347,1343,1,0,0,0,1347,1348,1,0,0,0,1348,1349,1,0,0,0,1349,1369,
  	5,12,0,0,1350,1352,5,1132,0,0,1351,1353,3,48,24,0,1352,1351,1,0,0,0,1352,
  	1353,1,0,0,0,1353,1354,1,0,0,0,1354,1355,3,198,99,0,1355,1356,5,1133,
  	0,0,1356,1370,1,0,0,0,1357,1359,3,48,24,0,1358,1357,1,0,0,0,1358,1359,
  	1,0,0,0,1359,1360,1,0,0,0,1360,1367,3,198,99,0,1361,1363,5,192,0,0,1362,
  	1364,7,12,0,0,1363,1362,1,0,0,0,1363,1364,1,0,0,0,1364,1365,1,0,0,0,1365,
  	1366,5,26,0,0,1366,1368,5,120,0,0,1367,1361,1,0,0,0,1367,1368,1,0,0,0,
  	1368,1370,1,0,0,0,1369,1350,1,0,0,0,1369,1358,1,0,0,0,1370,57,1,0,0,0,
  	1371,1373,5,42,0,0,1372,1371,1,0,0,0,1372,1373,1,0,0,0,1373,1374,1,0,
  	0,0,1374,1376,3,60,30,0,1375,1377,5,1123,0,0,1376,1375,1,0,0,0,1376,1377,
  	1,0,0,0,1377,1380,1,0,0,0,1378,1381,3,558,279,0,1379,1381,5,42,0,0,1380,
  	1378,1,0,0,0,1380,1379,1,0,0,0,1381,1405,1,0,0,0,1382,1384,5,42,0,0,1383,
  	1382,1,0,0,0,1383,1384,1,0,0,0,1384,1385,1,0,0,0,1385,1387,5,27,0,0,1386,
  	1388,5,1123,0,0,1387,1386,1,0,0,0,1387,1388,1,0,0,0,1388,1389,1,0,0,0,
  	1389,1405,3,560,280,0,1390,1392,5,42,0,0,1391,1390,1,0,0,0,1391,1392,
  	1,0,0,0,1392,1393,1,0,0,0,1393,1395,5,405,0,0,1394,1396,5,1123,0,0,1395,
  	1394,1,0,0,0,1395,1396,1,0,0,0,1396,1397,1,0,0,0,1397,1405,5,1147,0,0,
  	1398,1399,5,134,0,0,1399,1401,5,538,0,0,1400,1402,5,1123,0,0,1401,1400,
  	1,0,0,0,1401,1402,1,0,0,0,1402,1403,1,0,0,0,1403,1405,7,13,0,0,1404,1372,
  	1,0,0,0,1404,1383,1,0,0,0,1404,1391,1,0,0,0,1404,1398,1,0,0,0,1405,59,
  	1,0,0,0,1406,1407,5,25,0,0,1407,1412,5,153,0,0,1408,1412,5,841,0,0,1409,
  	1410,5,222,0,0,1410,1412,5,153,0,0,1411,1406,1,0,0,0,1411,1408,1,0,0,
  	0,1411,1409,1,0,0,0,1412,61,1,0,0,0,1413,1414,5,392,0,0,1414,1421,5,1123,
  	0,0,1415,1422,3,554,277,0,1416,1419,5,37,0,0,1417,1418,5,1132,0,0,1418,
  	1420,5,1133,0,0,1419,1417,1,0,0,0,1419,1420,1,0,0,0,1420,1422,1,0,0,0,
  	1421,1415,1,0,0,0,1421,1416,1,0,0,0,1422,63,1,0,0,0,1423,1424,5,338,0,
  	0,1424,1428,3,66,33,0,1425,1427,3,68,34,0,1426,1425,1,0,0,0,1427,1430,
  	1,0,0,0,1428,1426,1,0,0,0,1428,1429,1,0,0,0,1429,1458,1,0,0,0,1430,1428,
  	1,0,0,0,1431,1434,5,417,0,0,1432,1435,3,580,290,0,1433,1435,3,678,339,
  	0,1434,1432,1,0,0,0,1434,1433,1,0,0,0,1435,1436,1,0,0,0,1436,1445,3,70,
  	35,0,1437,1438,5,630,0,0,1438,1442,3,66,33,0,1439,1441,3,68,34,0,1440,
  	1439,1,0,0,0,1441,1444,1,0,0,0,1442,1440,1,0,0,0,1442,1443,1,0,0,0,1443,
  	1446,1,0,0,0,1444,1442,1,0,0,0,1445,1437,1,0,0,0,1445,1446,1,0,0,0,1446,
  	1455,1,0,0,0,1447,1448,5,408,0,0,1448,1452,3,66,33,0,1449,1451,3,68,34,
  	0,1450,1449,1,0,0,0,1451,1454,1,0,0,0,1452,1450,1,0,0,0,1452,1453,1,0,
  	0,0,1453,1456,1,0,0,0,1454,1452,1,0,0,0,1455,1447,1,0,0,0,1455,1456,1,
  	0,0,0,1456,1458,1,0,0,0,1457,1423,1,0,0,0,1457,1431,1,0,0,0,1458,65,1,
  	0,0,0,1459,1464,5,315,0,0,1460,1464,3,584,292,0,1461,1464,3,580,290,0,
  	1462,1464,3,678,339,0,1463,1459,1,0,0,0,1463,1460,1,0,0,0,1463,1461,1,
  	0,0,0,1463,1462,1,0,0,0,1464,67,1,0,0,0,1465,1466,5,1119,0,0,1466,1469,
  	5,86,0,0,1467,1470,3,580,290,0,1468,1470,3,678,339,0,1469,1467,1,0,0,
  	0,1469,1468,1,0,0,0,1470,1471,1,0,0,0,1471,1472,3,70,35,0,1472,69,1,0,
  	0,0,1473,1487,3,702,351,0,1474,1487,5,221,0,0,1475,1487,5,240,0,0,1476,
  	1487,5,241,0,0,1477,1487,5,242,0,0,1478,1487,5,243,0,0,1479,1487,5,244,
  	0,0,1480,1487,5,245,0,0,1481,1487,5,246,0,0,1482,1487,5,247,0,0,1483,
  	1487,5,248,0,0,1484,1487,5,249,0,0,1485,1487,5,250,0,0,1486,1473,1,0,
  	0,0,1486,1474,1,0,0,0,1486,1475,1,0,0,0,1486,1476,1,0,0,0,1486,1477,1,
  	0,0,0,1486,1478,1,0,0,0,1486,1479,1,0,0,0,1486,1480,1,0,0,0,1486,1481,
  	1,0,0,0,1486,1482,1,0,0,0,1486,1483,1,0,0,0,1486,1484,1,0,0,0,1486,1485,
  	1,0,0,0,1487,71,1,0,0,0,1488,1494,5,403,0,0,1489,1494,5,396,0,0,1490,
  	1491,5,396,0,0,1491,1492,5,118,0,0,1492,1494,5,614,0,0,1493,1488,1,0,
  	0,0,1493,1489,1,0,0,0,1493,1490,1,0,0,0,1494,73,1,0,0,0,1495,1496,5,187,
  	0,0,1496,1497,7,14,0,0,1497,75,1,0,0,0,1498,1500,5,467,0,0,1499,1501,
  	5,1123,0,0,1500,1499,1,0,0,0,1500,1501,1,0,0,0,1501,1502,1,0,0,0,1502,
  	1521,3,582,291,0,1503,1521,3,74,37,0,1504,1505,5,192,0,0,1505,1506,5,
  	547,0,0,1506,1521,3,574,287,0,1507,1508,5,368,0,0,1508,1521,5,1147,0,
  	0,1509,1521,7,15,0,0,1510,1512,5,875,0,0,1511,1513,5,1123,0,0,1512,1511,
  	1,0,0,0,1512,1513,1,0,0,0,1513,1514,1,0,0,0,1514,1521,5,1147,0,0,1515,
  	1517,5,999,0,0,1516,1518,5,1123,0,0,1517,1516,1,0,0,0,1517,1518,1,0,0,
  	0,1518,1519,1,0,0,0,1519,1521,5,1147,0,0,1520,1498,1,0,0,0,1520,1503,
  	1,0,0,0,1520,1504,1,0,0,0,1520,1507,1,0,0,0,1520,1509,1,0,0,0,1520,1510,
  	1,0,0,0,1520,1515,1,0,0,0,1521,77,1,0,0,0,1522,1524,7,16,0,0,1523,1522,
  	1,0,0,0,1523,1524,1,0,0,0,1524,1525,1,0,0,0,1525,1526,3,574,287,0,1526,
  	1527,3,594,297,0,1527,79,1,0,0,0,1528,1529,3,574,287,0,1529,1530,3,594,
  	297,0,1530,81,1,0,0,0,1531,1532,5,368,0,0,1532,1555,5,1147,0,0,1533,1534,
  	5,468,0,0,1534,1555,5,160,0,0,1535,1537,5,114,0,0,1536,1535,1,0,0,0,1536,
  	1537,1,0,0,0,1537,1538,1,0,0,0,1538,1555,5,47,0,0,1539,1540,5,381,0,0,
  	1540,1550,5,160,0,0,1541,1542,5,521,0,0,1542,1550,5,160,0,0,1543,1544,
  	5,135,0,0,1544,1545,5,160,0,0,1545,1550,5,388,0,0,1546,1547,5,112,0,0,
  	1547,1548,5,160,0,0,1548,1550,5,388,0,0,1549,1539,1,0,0,0,1549,1541,1,
  	0,0,0,1549,1543,1,0,0,0,1549,1546,1,0,0,0,1550,1555,1,0,0,0,1551,1552,
  	5,160,0,0,1552,1553,5,606,0,0,1553,1555,7,11,0,0,1554,1531,1,0,0,0,1554,
  	1533,1,0,0,0,1554,1536,1,0,0,0,1554,1549,1,0,0,0,1554,1551,1,0,0,0,1555,
  	83,1,0,0,0,1556,1557,5,446,0,0,1557,1571,5,1147,0,0,1558,1559,5,39,0,
  	0,1559,1571,5,1147,0,0,1560,1561,5,665,0,0,1561,1571,5,1147,0,0,1562,
  	1563,5,551,0,0,1563,1571,5,1147,0,0,1564,1565,5,617,0,0,1565,1571,5,1147,
  	0,0,1566,1567,5,542,0,0,1567,1571,5,1147,0,0,1568,1569,5,557,0,0,1569,
  	1571,3,580,290,0,1570,1556,1,0,0,0,1570,1558,1,0,0,0,1570,1560,1,0,0,
  	0,1570,1562,1,0,0,0,1570,1564,1,0,0,0,1570,1566,1,0,0,0,1570,1568,1,0,
  	0,0,1571,85,1,0,0,0,1572,1573,5,1132,0,0,1573,1578,3,88,44,0,1574,1575,
  	5,1134,0,0,1575,1577,3,88,44,0,1576,1574,1,0,0,0,1577,1580,1,0,0,0,1578,
  	1576,1,0,0,0,1578,1579,1,0,0,0,1579,1581,1,0,0,0,1580,1578,1,0,0,0,1581,
  	1582,5,1133,0,0,1582,87,1,0,0,0,1583,1584,3,550,275,0,1584,1585,3,90,
  	45,0,1585,1595,1,0,0,0,1586,1588,3,94,47,0,1587,1589,5,114,0,0,1588,1587,
  	1,0,0,0,1588,1589,1,0,0,0,1589,1591,1,0,0,0,1590,1592,5,57,0,0,1591,1590,
  	1,0,0,0,1591,1592,1,0,0,0,1592,1595,1,0,0,0,1593,1595,3,102,51,0,1594,
  	1583,1,0,0,0,1594,1586,1,0,0,0,1594,1593,1,0,0,0,1595,89,1,0,0,0,1596,
  	1600,3,594,297,0,1597,1599,3,92,46,0,1598,1597,1,0,0,0,1599,1602,1,0,
  	0,0,1600,1598,1,0,0,0,1600,1601,1,0,0,0,1601,1604,1,0,0,0,1602,1600,1,
  	0,0,0,1603,1605,5,114,0,0,1604,1603,1,0,0,0,1604,1605,1,0,0,0,1605,1607,
  	1,0,0,0,1606,1608,5,57,0,0,1607,1606,1,0,0,0,1607,1608,1,0,0,0,1608,91,
  	1,0,0,0,1609,1663,3,590,295,0,1610,1611,5,42,0,0,1611,1663,3,624,312,
  	0,1612,1663,5,673,0,0,1613,1663,5,459,0,0,1614,1619,5,342,0,0,1615,1616,
  	5,118,0,0,1616,1617,5,184,0,0,1617,1619,3,626,313,0,1618,1614,1,0,0,0,
  	1618,1615,1,0,0,0,1619,1663,1,0,0,0,1620,1622,5,130,0,0,1621,1620,1,0,
  	0,0,1621,1622,1,0,0,0,1622,1623,1,0,0,0,1623,1663,5,91,0,0,1624,1626,
  	5,181,0,0,1625,1627,5,91,0,0,1626,1625,1,0,0,0,1626,1627,1,0,0,0,1627,
  	1663,1,0,0,0,1628,1629,5,368,0,0,1629,1663,5,1147,0,0,1630,1631,5,366,
  	0,0,1631,1663,7,17,0,0,1632,1633,5,636,0,0,1633,1663,7,18,0,0,1634,1663,
  	3,96,48,0,1635,1636,5,27,0,0,1636,1663,3,560,280,0,1637,1638,5,70,0,0,
  	1638,1640,5,8,0,0,1639,1637,1,0,0,0,1639,1640,1,0,0,0,1640,1641,1,0,0,
  	0,1641,1642,5,12,0,0,1642,1643,5,1132,0,0,1643,1644,3,678,339,0,1644,
  	1646,5,1133,0,0,1645,1647,7,19,0,0,1646,1645,1,0,0,0,1646,1647,1,0,0,
  	0,1647,1663,1,0,0,0,1648,1649,5,239,0,0,1649,1650,5,42,0,0,1650,1663,
  	5,669,0,0,1651,1653,5,30,0,0,1652,1654,3,574,287,0,1653,1652,1,0,0,0,
  	1653,1654,1,0,0,0,1654,1656,1,0,0,0,1655,1651,1,0,0,0,1655,1656,1,0,0,
  	0,1656,1657,1,0,0,0,1657,1658,5,26,0,0,1658,1659,5,1132,0,0,1659,1660,
  	3,678,339,0,1660,1661,5,1133,0,0,1661,1663,1,0,0,0,1662,1609,1,0,0,0,
  	1662,1610,1,0,0,0,1662,1612,1,0,0,0,1662,1613,1,0,0,0,1662,1618,1,0,0,
  	0,1662,1621,1,0,0,0,1662,1624,1,0,0,0,1662,1628,1,0,0,0,1662,1630,1,0,
  	0,0,1662,1632,1,0,0,0,1662,1634,1,0,0,0,1662,1635,1,0,0,0,1662,1639,1,
  	0,0,0,1662,1648,1,0,0,0,1662,1655,1,0,0,0,1663,93,1,0,0,0,1664,1666,5,
  	30,0,0,1665,1667,3,574,287,0,1666,1665,1,0,0,0,1666,1667,1,0,0,0,1667,
  	1669,1,0,0,0,1668,1664,1,0,0,0,1668,1669,1,0,0,0,1669,1670,1,0,0,0,1670,
  	1671,5,130,0,0,1671,1673,5,91,0,0,1672,1674,3,574,287,0,1673,1672,1,0,
  	0,0,1673,1674,1,0,0,0,1674,1676,1,0,0,0,1675,1677,3,74,37,0,1676,1675,
  	1,0,0,0,1676,1677,1,0,0,0,1677,1678,1,0,0,0,1678,1682,3,612,306,0,1679,
  	1681,3,76,38,0,1680,1679,1,0,0,0,1681,1684,1,0,0,0,1682,1680,1,0,0,0,
  	1682,1683,1,0,0,0,1683,1734,1,0,0,0,1684,1682,1,0,0,0,1685,1687,5,30,
  	0,0,1686,1688,3,574,287,0,1687,1686,1,0,0,0,1687,1688,1,0,0,0,1688,1690,
  	1,0,0,0,1689,1685,1,0,0,0,1689,1690,1,0,0,0,1690,1691,1,0,0,0,1691,1693,
  	5,181,0,0,1692,1694,7,20,0,0,1693,1692,1,0,0,0,1693,1694,1,0,0,0,1694,
  	1696,1,0,0,0,1695,1697,3,574,287,0,1696,1695,1,0,0,0,1696,1697,1,0,0,
  	0,1697,1699,1,0,0,0,1698,1700,3,74,37,0,1699,1698,1,0,0,0,1699,1700,1,
  	0,0,0,1700,1701,1,0,0,0,1701,1705,3,612,306,0,1702,1704,3,76,38,0,1703,
  	1702,1,0,0,0,1704,1707,1,0,0,0,1705,1703,1,0,0,0,1705,1706,1,0,0,0,1706,
  	1734,1,0,0,0,1707,1705,1,0,0,0,1708,1710,5,30,0,0,1709,1711,3,574,287,
  	0,1710,1709,1,0,0,0,1710,1711,1,0,0,0,1711,1713,1,0,0,0,1712,1708,1,0,
  	0,0,1712,1713,1,0,0,0,1713,1714,1,0,0,0,1714,1715,5,67,0,0,1715,1717,
  	5,91,0,0,1716,1718,3,574,287,0,1717,1716,1,0,0,0,1717,1718,1,0,0,0,1718,
  	1719,1,0,0,0,1719,1720,3,612,306,0,1720,1721,3,96,48,0,1721,1734,1,0,
  	0,0,1722,1724,5,30,0,0,1723,1725,3,574,287,0,1724,1723,1,0,0,0,1724,1725,
  	1,0,0,0,1725,1727,1,0,0,0,1726,1722,1,0,0,0,1726,1727,1,0,0,0,1727,1728,
  	1,0,0,0,1728,1729,5,26,0,0,1729,1730,5,1132,0,0,1730,1731,3,678,339,0,
  	1731,1732,5,1133,0,0,1732,1734,1,0,0,0,1733,1668,1,0,0,0,1733,1689,1,
  	0,0,0,1733,1712,1,0,0,0,1733,1726,1,0,0,0,1734,95,1,0,0,0,1735,1736,5,
  	136,0,0,1736,1738,3,546,273,0,1737,1739,3,612,306,0,1738,1737,1,0,0,0,
  	1738,1739,1,0,0,0,1739,1742,1,0,0,0,1740,1741,5,109,0,0,1741,1743,7,21,
  	0,0,1742,1740,1,0,0,0,1742,1743,1,0,0,0,1743,1745,1,0,0,0,1744,1746,3,
  	98,49,0,1745,1744,1,0,0,0,1745,1746,1,0,0,0,1746,97,1,0,0,0,1747,1748,
  	5,118,0,0,1748,1749,5,44,0,0,1749,1753,3,100,50,0,1750,1751,5,118,0,0,
  	1751,1752,5,184,0,0,1752,1754,3,100,50,0,1753,1750,1,0,0,0,1753,1754,
  	1,0,0,0,1754,1764,1,0,0,0,1755,1756,5,118,0,0,1756,1757,5,184,0,0,1757,
  	1761,3,100,50,0,1758,1759,5,118,0,0,1759,1760,5,44,0,0,1760,1762,3,100,
  	50,0,1761,1758,1,0,0,0,1761,1762,1,0,0,0,1762,1764,1,0,0,0,1763,1747,
  	1,0,0,0,1763,1755,1,0,0,0,1764,99,1,0,0,0,1765,1774,5,144,0,0,1766,1774,
  	5,21,0,0,1767,1768,5,153,0,0,1768,1774,5,116,0,0,1769,1770,5,521,0,0,
  	1770,1774,5,333,0,0,1771,1772,5,153,0,0,1772,1774,5,42,0,0,1773,1765,
  	1,0,0,0,1773,1766,1,0,0,0,1773,1767,1,0,0,0,1773,1769,1,0,0,0,1773,1771,
  	1,0,0,0,1774,101,1,0,0,0,1775,1777,7,20,0,0,1776,1778,3,574,287,0,1777,
  	1776,1,0,0,0,1777,1778,1,0,0,0,1778,1780,1,0,0,0,1779,1781,3,74,37,0,
  	1780,1779,1,0,0,0,1780,1781,1,0,0,0,1781,1782,1,0,0,0,1782,1786,3,612,
  	306,0,1783,1785,3,76,38,0,1784,1783,1,0,0,0,1785,1788,1,0,0,0,1786,1784,
  	1,0,0,0,1786,1787,1,0,0,0,1787,1804,1,0,0,0,1788,1786,1,0,0,0,1789,1791,
  	7,22,0,0,1790,1792,7,20,0,0,1791,1790,1,0,0,0,1791,1792,1,0,0,0,1792,
  	1794,1,0,0,0,1793,1795,3,574,287,0,1794,1793,1,0,0,0,1794,1795,1,0,0,
  	0,1795,1796,1,0,0,0,1796,1800,3,612,306,0,1797,1799,3,76,38,0,1798,1797,
  	1,0,0,0,1799,1802,1,0,0,0,1800,1798,1,0,0,0,1800,1801,1,0,0,0,1801,1804,
  	1,0,0,0,1802,1800,1,0,0,0,1803,1775,1,0,0,0,1803,1789,1,0,0,0,1804,103,
  	1,0,0,0,1805,1807,5,409,0,0,1806,1808,5,1123,0,0,1807,1806,1,0,0,0,1807,
  	1808,1,0,0,0,1808,1810,1,0,0,0,1809,1811,3,562,281,0,1810,1809,1,0,0,
  	0,1810,1811,1,0,0,0,1811,1991,1,0,0,0,1812,1814,5,875,0,0,1813,1815,5,
  	1123,0,0,1814,1813,1,0,0,0,1814,1815,1,0,0,0,1815,1816,1,0,0,0,1816,1991,
  	5,1147,0,0,1817,1819,5,341,0,0,1818,1820,5,1123,0,0,1819,1818,1,0,0,0,
  	1819,1820,1,0,0,0,1820,1821,1,0,0,0,1821,1991,3,580,290,0,1822,1824,5,
  	342,0,0,1823,1825,5,1123,0,0,1824,1823,1,0,0,0,1824,1825,1,0,0,0,1825,
  	1826,1,0,0,0,1826,1991,3,580,290,0,1827,1829,5,343,0,0,1828,1830,5,1123,
  	0,0,1829,1828,1,0,0,0,1829,1830,1,0,0,0,1830,1831,1,0,0,0,1831,1991,3,
  	580,290,0,1832,1834,5,42,0,0,1833,1832,1,0,0,0,1833,1834,1,0,0,0,1834,
  	1835,1,0,0,0,1835,1837,3,60,30,0,1836,1838,5,1123,0,0,1837,1836,1,0,0,
  	0,1837,1838,1,0,0,0,1838,1841,1,0,0,0,1839,1842,3,558,279,0,1840,1842,
  	5,42,0,0,1841,1839,1,0,0,0,1841,1840,1,0,0,0,1842,1991,1,0,0,0,1843,1845,
  	7,23,0,0,1844,1846,5,1123,0,0,1845,1844,1,0,0,0,1845,1846,1,0,0,0,1846,
  	1847,1,0,0,0,1847,1991,7,24,0,0,1848,1850,5,42,0,0,1849,1848,1,0,0,0,
  	1849,1850,1,0,0,0,1850,1851,1,0,0,0,1851,1853,5,27,0,0,1852,1854,5,1123,
  	0,0,1853,1852,1,0,0,0,1853,1854,1,0,0,0,1854,1855,1,0,0,0,1855,1991,3,
  	560,280,0,1856,1858,5,368,0,0,1857,1859,5,1123,0,0,1858,1857,1,0,0,0,
  	1858,1859,1,0,0,0,1859,1860,1,0,0,0,1860,1991,5,1147,0,0,1861,1863,5,
  	373,0,0,1862,1864,5,1123,0,0,1863,1862,1,0,0,0,1863,1864,1,0,0,0,1864,
  	1865,1,0,0,0,1865,1991,7,25,0,0,1866,1868,5,376,0,0,1867,1869,5,1123,
  	0,0,1868,1867,1,0,0,0,1868,1869,1,0,0,0,1869,1870,1,0,0,0,1870,1991,5,
  	1147,0,0,1871,1872,7,26,0,0,1872,1874,5,395,0,0,1873,1875,5,1123,0,0,
  	1874,1873,1,0,0,0,1874,1875,1,0,0,0,1875,1876,1,0,0,0,1876,1991,5,1147,
  	0,0,1877,1879,5,393,0,0,1878,1880,5,1123,0,0,1879,1878,1,0,0,0,1879,1880,
  	1,0,0,0,1880,1881,1,0,0,0,1881,1991,7,24,0,0,1882,1884,5,405,0,0,1883,
  	1885,5,1123,0,0,1884,1883,1,0,0,0,1884,1885,1,0,0,0,1885,1886,1,0,0,0,
  	1886,1991,5,1147,0,0,1887,1889,7,27,0,0,1888,1890,5,1123,0,0,1889,1888,
  	1,0,0,0,1889,1890,1,0,0,0,1890,1891,1,0,0,0,1891,1991,7,24,0,0,1892,1894,
  	7,28,0,0,1893,1895,5,1123,0,0,1894,1893,1,0,0,0,1894,1895,1,0,0,0,1895,
  	1896,1,0,0,0,1896,1991,3,580,290,0,1897,1899,5,406,0,0,1898,1900,5,1123,
  	0,0,1899,1898,1,0,0,0,1899,1900,1,0,0,0,1900,1901,1,0,0,0,1901,1991,3,
  	580,290,0,1902,1903,5,81,0,0,1903,1905,5,395,0,0,1904,1906,5,1123,0,0,
  	1905,1904,1,0,0,0,1905,1906,1,0,0,0,1906,1907,1,0,0,0,1907,1991,5,1147,
  	0,0,1908,1910,5,455,0,0,1909,1911,5,1123,0,0,1910,1909,1,0,0,0,1910,1911,
  	1,0,0,0,1911,1912,1,0,0,0,1912,1991,7,29,0,0,1913,1915,5,467,0,0,1914,
  	1916,5,1123,0,0,1915,1914,1,0,0,0,1915,1916,1,0,0,0,1916,1917,1,0,0,0,
  	1917,1991,3,582,291,0,1918,1920,5,500,0,0,1919,1921,5,1123,0,0,1920,1919,
  	1,0,0,0,1920,1921,1,0,0,0,1921,1922,1,0,0,0,1922,1991,3,580,290,0,1923,
  	1925,5,510,0,0,1924,1926,5,1123,0,0,1925,1924,1,0,0,0,1925,1926,1,0,0,
  	0,1926,1927,1,0,0,0,1927,1991,3,580,290,0,1928,1930,5,543,0,0,1929,1931,
  	5,1123,0,0,1930,1929,1,0,0,0,1930,1931,1,0,0,0,1931,1932,1,0,0,0,1932,
  	1991,7,13,0,0,1933,1935,5,551,0,0,1934,1936,5,1123,0,0,1935,1934,1,0,
  	0,0,1935,1936,1,0,0,0,1936,1937,1,0,0,0,1937,1991,5,1147,0,0,1938,1940,
  	5,602,0,0,1939,1941,5,1123,0,0,1940,1939,1,0,0,0,1940,1941,1,0,0,0,1941,
  	1942,1,0,0,0,1942,1991,7,30,0,0,1943,1944,5,629,0,0,1944,1991,5,653,0,
  	0,1945,1947,5,999,0,0,1946,1948,5,1123,0,0,1947,1946,1,0,0,0,1947,1948,
  	1,0,0,0,1948,1949,1,0,0,0,1949,1991,5,1147,0,0,1950,1952,5,631,0,0,1951,
  	1953,5,1123,0,0,1952,1951,1,0,0,0,1952,1953,1,0,0,0,1953,1954,1,0,0,0,
  	1954,1991,7,13,0,0,1955,1957,5,632,0,0,1956,1958,5,1123,0,0,1957,1956,
  	1,0,0,0,1957,1958,1,0,0,0,1958,1959,1,0,0,0,1959,1991,7,13,0,0,1960,1962,
  	5,633,0,0,1961,1963,5,1123,0,0,1962,1961,1,0,0,0,1962,1963,1,0,0,0,1963,
  	1966,1,0,0,0,1964,1967,5,42,0,0,1965,1967,3,580,290,0,1966,1964,1,0,0,
  	0,1966,1965,1,0,0,0,1967,1991,1,0,0,0,1968,1969,5,647,0,0,1969,1971,3,
  	574,287,0,1970,1972,3,108,54,0,1971,1970,1,0,0,0,1971,1972,1,0,0,0,1972,
  	1991,1,0,0,0,1973,1974,5,648,0,0,1974,1975,5,1123,0,0,1975,1991,3,106,
  	53,0,1976,1991,3,108,54,0,1977,1979,5,654,0,0,1978,1980,5,1123,0,0,1979,
  	1978,1,0,0,0,1979,1980,1,0,0,0,1980,1981,1,0,0,0,1981,1991,7,24,0,0,1982,
  	1984,5,180,0,0,1983,1985,5,1123,0,0,1984,1983,1,0,0,0,1984,1985,1,0,0,
  	0,1985,1986,1,0,0,0,1986,1987,5,1132,0,0,1987,1988,3,610,305,0,1988,1989,
  	5,1133,0,0,1989,1991,1,0,0,0,1990,1805,1,0,0,0,1990,1812,1,0,0,0,1990,
  	1817,1,0,0,0,1990,1822,1,0,0,0,1990,1827,1,0,0,0,1990,1833,1,0,0,0,1990,
  	1843,1,0,0,0,1990,1849,1,0,0,0,1990,1856,1,0,0,0,1990,1861,1,0,0,0,1990,
  	1866,1,0,0,0,1990,1871,1,0,0,0,1990,1877,1,0,0,0,1990,1882,1,0,0,0,1990,
  	1887,1,0,0,0,1990,1892,1,0,0,0,1990,1897,1,0,0,0,1990,1902,1,0,0,0,1990,
  	1908,1,0,0,0,1990,1913,1,0,0,0,1990,1918,1,0,0,0,1990,1923,1,0,0,0,1990,
  	1928,1,0,0,0,1990,1933,1,0,0,0,1990,1938,1,0,0,0,1990,1943,1,0,0,0,1990,
  	1945,1,0,0,0,1990,1950,1,0,0,0,1990,1955,1,0,0,0,1990,1960,1,0,0,0,1990,
  	1968,1,0,0,0,1990,1973,1,0,0,0,1990,1976,1,0,0,0,1990,1977,1,0,0,0,1990,
  	1982,1,0,0,0,1991,105,1,0,0,0,1992,1993,7,31,0,0,1993,107,1,0,0,0,1994,
  	1995,5,636,0,0,1995,1996,7,18,0,0,1996,109,1,0,0,0,1997,1998,5,129,0,
  	0,1998,1999,5,19,0,0,1999,2002,3,112,56,0,2000,2001,5,550,0,0,2001,2003,
  	3,580,290,0,2002,2000,1,0,0,0,2002,2003,1,0,0,0,2003,2011,1,0,0,0,2004,
  	2005,5,641,0,0,2005,2006,5,19,0,0,2006,2009,3,114,57,0,2007,2008,5,642,
  	0,0,2008,2010,3,580,290,0,2009,2007,1,0,0,0,2009,2010,1,0,0,0,2010,2012,
  	1,0,0,0,2011,2004,1,0,0,0,2011,2012,1,0,0,0,2012,2024,1,0,0,0,2013,2014,
  	5,1132,0,0,2014,2019,3,116,58,0,2015,2016,5,1134,0,0,2016,2018,3,116,
  	58,0,2017,2015,1,0,0,0,2018,2021,1,0,0,0,2019,2017,1,0,0,0,2019,2020,
  	1,0,0,0,2020,2022,1,0,0,0,2021,2019,1,0,0,0,2022,2023,5,1133,0,0,2023,
  	2025,1,0,0,0,2024,2013,1,0,0,0,2024,2025,1,0,0,0,2025,111,1,0,0,0,2026,
  	2028,5,100,0,0,2027,2026,1,0,0,0,2027,2028,1,0,0,0,2028,2029,1,0,0,0,
  	2029,2030,5,443,0,0,2030,2031,5,1132,0,0,2031,2032,3,678,339,0,2032,2033,
  	5,1133,0,0,2033,2073,1,0,0,0,2034,2036,5,100,0,0,2035,2034,1,0,0,0,2035,
  	2036,1,0,0,0,2036,2037,1,0,0,0,2037,2041,5,91,0,0,2038,2039,5,336,0,0,
  	2039,2040,5,1123,0,0,2040,2042,7,32,0,0,2041,2038,1,0,0,0,2041,2042,1,
  	0,0,0,2042,2043,1,0,0,0,2043,2045,5,1132,0,0,2044,2046,3,606,303,0,2045,
  	2044,1,0,0,0,2045,2046,1,0,0,0,2046,2047,1,0,0,0,2047,2073,5,1133,0,0,
  	2048,2058,5,133,0,0,2049,2050,5,1132,0,0,2050,2051,3,678,339,0,2051,2052,
  	5,1133,0,0,2052,2059,1,0,0,0,2053,2054,5,365,0,0,2054,2055,5,1132,0,0,
  	2055,2056,3,606,303,0,2056,2057,5,1133,0,0,2057,2059,1,0,0,0,2058,2049,
  	1,0,0,0,2058,2053,1,0,0,0,2059,2073,1,0,0,0,2060,2070,5,473,0,0,2061,
  	2062,5,1132,0,0,2062,2063,3,678,339,0,2063,2064,5,1133,0,0,2064,2071,
  	1,0,0,0,2065,2066,5,365,0,0,2066,2067,5,1132,0,0,2067,2068,3,606,303,
  	0,2068,2069,5,1133,0,0,2069,2071,1,0,0,0,2070,2061,1,0,0,0,2070,2065,
  	1,0,0,0,2071,2073,1,0,0,0,2072,2027,1,0,0,0,2072,2035,1,0,0,0,2072,2048,
  	1,0,0,0,2072,2060,1,0,0,0,2073,113,1,0,0,0,2074,2076,5,100,0,0,2075,2074,
  	1,0,0,0,2075,2076,1,0,0,0,2076,2077,1,0,0,0,2077,2078,5,443,0,0,2078,
  	2079,5,1132,0,0,2079,2080,3,678,339,0,2080,2081,5,1133,0,0,2081,2096,
  	1,0,0,0,2082,2084,5,100,0,0,2083,2082,1,0,0,0,2083,2084,1,0,0,0,2084,
  	2085,1,0,0,0,2085,2089,5,91,0,0,2086,2087,5,336,0,0,2087,2088,5,1123,
  	0,0,2088,2090,7,32,0,0,2089,2086,1,0,0,0,2089,2090,1,0,0,0,2090,2091,
  	1,0,0,0,2091,2092,5,1132,0,0,2092,2093,3,606,303,0,2093,2094,5,1133,0,
  	0,2094,2096,1,0,0,0,2095,2075,1,0,0,0,2095,2083,1,0,0,0,2096,115,1,0,
  	0,0,2097,2098,5,129,0,0,2098,2099,3,574,287,0,2099,2100,5,188,0,0,2100,
  	2101,5,471,0,0,2101,2102,5,651,0,0,2102,2103,5,1132,0,0,2103,2108,3,118,
  	59,0,2104,2105,5,1134,0,0,2105,2107,3,118,59,0,2106,2104,1,0,0,0,2107,
  	2110,1,0,0,0,2108,2106,1,0,0,0,2108,2109,1,0,0,0,2109,2111,1,0,0,0,2110,
  	2108,1,0,0,0,2111,2115,5,1133,0,0,2112,2114,3,124,62,0,2113,2112,1,0,
  	0,0,2114,2117,1,0,0,0,2115,2113,1,0,0,0,2115,2116,1,0,0,0,2116,2129,1,
  	0,0,0,2117,2115,1,0,0,0,2118,2119,5,1132,0,0,2119,2124,3,122,61,0,2120,
  	2121,5,1134,0,0,2121,2123,3,122,61,0,2122,2120,1,0,0,0,2123,2126,1,0,
  	0,0,2124,2122,1,0,0,0,2124,2125,1,0,0,0,2125,2127,1,0,0,0,2126,2124,1,
  	0,0,0,2127,2128,5,1133,0,0,2128,2130,1,0,0,0,2129,2118,1,0,0,0,2129,2130,
  	1,0,0,0,2130,2244,1,0,0,0,2131,2132,5,129,0,0,2132,2133,3,574,287,0,2133,
  	2134,5,188,0,0,2134,2135,5,471,0,0,2135,2136,5,651,0,0,2136,2140,3,118,
  	59,0,2137,2139,3,124,62,0,2138,2137,1,0,0,0,2139,2142,1,0,0,0,2140,2138,
  	1,0,0,0,2140,2141,1,0,0,0,2141,2154,1,0,0,0,2142,2140,1,0,0,0,2143,2144,
  	5,1132,0,0,2144,2149,3,122,61,0,2145,2146,5,1134,0,0,2146,2148,3,122,
  	61,0,2147,2145,1,0,0,0,2148,2151,1,0,0,0,2149,2147,1,0,0,0,2149,2150,
  	1,0,0,0,2150,2152,1,0,0,0,2151,2149,1,0,0,0,2152,2153,5,1133,0,0,2153,
  	2155,1,0,0,0,2154,2143,1,0,0,0,2154,2155,1,0,0,0,2155,2244,1,0,0,0,2156,
  	2157,5,129,0,0,2157,2158,3,574,287,0,2158,2159,5,188,0,0,2159,2160,5,
  	80,0,0,2160,2161,5,1132,0,0,2161,2166,3,118,59,0,2162,2163,5,1134,0,0,
  	2163,2165,3,118,59,0,2164,2162,1,0,0,0,2165,2168,1,0,0,0,2166,2164,1,
  	0,0,0,2166,2167,1,0,0,0,2167,2169,1,0,0,0,2168,2166,1,0,0,0,2169,2173,
  	5,1133,0,0,2170,2172,3,124,62,0,2171,2170,1,0,0,0,2172,2175,1,0,0,0,2173,
  	2171,1,0,0,0,2173,2174,1,0,0,0,2174,2187,1,0,0,0,2175,2173,1,0,0,0,2176,
  	2177,5,1132,0,0,2177,2182,3,122,61,0,2178,2179,5,1134,0,0,2179,2181,3,
  	122,61,0,2180,2178,1,0,0,0,2181,2184,1,0,0,0,2182,2180,1,0,0,0,2182,2183,
  	1,0,0,0,2183,2185,1,0,0,0,2184,2182,1,0,0,0,2185,2186,5,1133,0,0,2186,
  	2188,1,0,0,0,2187,2176,1,0,0,0,2187,2188,1,0,0,0,2188,2244,1,0,0,0,2189,
  	2190,5,129,0,0,2190,2191,3,574,287,0,2191,2192,5,188,0,0,2192,2193,5,
  	80,0,0,2193,2194,5,1132,0,0,2194,2199,3,120,60,0,2195,2196,5,1134,0,0,
  	2196,2198,3,120,60,0,2197,2195,1,0,0,0,2198,2201,1,0,0,0,2199,2197,1,
  	0,0,0,2199,2200,1,0,0,0,2200,2202,1,0,0,0,2201,2199,1,0,0,0,2202,2206,
  	5,1133,0,0,2203,2205,3,124,62,0,2204,2203,1,0,0,0,2205,2208,1,0,0,0,2206,
  	2204,1,0,0,0,2206,2207,1,0,0,0,2207,2220,1,0,0,0,2208,2206,1,0,0,0,2209,
  	2210,5,1132,0,0,2210,2215,3,122,61,0,2211,2212,5,1134,0,0,2212,2214,3,
  	122,61,0,2213,2211,1,0,0,0,2214,2217,1,0,0,0,2215,2213,1,0,0,0,2215,2216,
  	1,0,0,0,2216,2218,1,0,0,0,2217,2215,1,0,0,0,2218,2219,5,1133,0,0,2219,
  	2221,1,0,0,0,2220,2209,1,0,0,0,2220,2221,1,0,0,0,2221,2244,1,0,0,0,2222,
  	2223,5,129,0,0,2223,2227,3,574,287,0,2224,2226,3,124,62,0,2225,2224,1,
  	0,0,0,2226,2229,1,0,0,0,2227,2225,1,0,0,0,2227,2228,1,0,0,0,2228,2241,
  	1,0,0,0,2229,2227,1,0,0,0,2230,2231,5,1132,0,0,2231,2236,3,122,61,0,2232,
  	2233,5,1134,0,0,2233,2235,3,122,61,0,2234,2232,1,0,0,0,2235,2238,1,0,
  	0,0,2236,2234,1,0,0,0,2236,2237,1,0,0,0,2237,2239,1,0,0,0,2238,2236,1,
  	0,0,0,2239,2240,5,1133,0,0,2240,2242,1,0,0,0,2241,2230,1,0,0,0,2241,2242,
  	1,0,0,0,2242,2244,1,0,0,0,2243,2097,1,0,0,0,2243,2131,1,0,0,0,2243,2156,
  	1,0,0,0,2243,2189,1,0,0,0,2243,2222,1,0,0,0,2244,117,1,0,0,0,2245,2249,
  	3,592,296,0,2246,2249,3,678,339,0,2247,2249,5,110,0,0,2248,2245,1,0,0,
  	0,2248,2246,1,0,0,0,2248,2247,1,0,0,0,2249,119,1,0,0,0,2250,2251,5,1132,
  	0,0,2251,2254,3,118,59,0,2252,2253,5,1134,0,0,2253,2255,3,118,59,0,2254,
  	2252,1,0,0,0,2255,2256,1,0,0,0,2256,2254,1,0,0,0,2256,2257,1,0,0,0,2257,
  	2258,1,0,0,0,2258,2259,5,1133,0,0,2259,121,1,0,0,0,2260,2261,5,641,0,
  	0,2261,2265,3,574,287,0,2262,2264,3,124,62,0,2263,2262,1,0,0,0,2264,2267,
  	1,0,0,0,2265,2263,1,0,0,0,2265,2266,1,0,0,0,2266,123,1,0,0,0,2267,2265,
  	1,0,0,0,2268,2270,5,42,0,0,2269,2268,1,0,0,0,2269,2270,1,0,0,0,2270,2272,
  	1,0,0,0,2271,2273,5,636,0,0,2272,2271,1,0,0,0,2272,2273,1,0,0,0,2273,
  	2274,1,0,0,0,2274,2276,5,409,0,0,2275,2277,5,1123,0,0,2276,2275,1,0,0,
  	0,2276,2277,1,0,0,0,2277,2278,1,0,0,0,2278,2317,3,562,281,0,2279,2281,
  	5,368,0,0,2280,2282,5,1123,0,0,2281,2280,1,0,0,0,2281,2282,1,0,0,0,2282,
  	2283,1,0,0,0,2283,2317,5,1147,0,0,2284,2285,5,388,0,0,2285,2287,5,395,
  	0,0,2286,2288,5,1123,0,0,2287,2286,1,0,0,0,2287,2288,1,0,0,0,2288,2289,
  	1,0,0,0,2289,2317,5,1147,0,0,2290,2291,5,81,0,0,2291,2293,5,395,0,0,2292,
  	2294,5,1123,0,0,2293,2292,1,0,0,0,2293,2294,1,0,0,0,2294,2295,1,0,0,0,
  	2295,2317,5,1147,0,0,2296,2298,5,500,0,0,2297,2299,5,1123,0,0,2298,2297,
  	1,0,0,0,2298,2299,1,0,0,0,2299,2300,1,0,0,0,2300,2317,3,580,290,0,2301,
  	2303,5,510,0,0,2302,2304,5,1123,0,0,2303,2302,1,0,0,0,2303,2304,1,0,0,
  	0,2304,2305,1,0,0,0,2305,2317,3,580,290,0,2306,2308,5,647,0,0,2307,2309,
  	5,1123,0,0,2308,2307,1,0,0,0,2308,2309,1,0,0,0,2309,2310,1,0,0,0,2310,
  	2317,3,574,287,0,2311,2313,5,528,0,0,2312,2314,5,1123,0,0,2313,2312,1,
  	0,0,0,2313,2314,1,0,0,0,2314,2315,1,0,0,0,2315,2317,3,574,287,0,2316,
  	2269,1,0,0,0,2316,2279,1,0,0,0,2316,2284,1,0,0,0,2316,2290,1,0,0,0,2316,
  	2296,1,0,0,0,2316,2301,1,0,0,0,2316,2306,1,0,0,0,2316,2311,1,0,0,0,2317,
  	125,1,0,0,0,2318,2319,5,7,0,0,2319,2321,7,0,0,0,2320,2322,3,574,287,0,
  	2321,2320,1,0,0,0,2321,2322,1,0,0,0,2322,2324,1,0,0,0,2323,2325,3,58,
  	29,0,2324,2323,1,0,0,0,2325,2326,1,0,0,0,2326,2324,1,0,0,0,2326,2327,
  	1,0,0,0,2327,2337,1,0,0,0,2328,2329,5,7,0,0,2329,2330,7,0,0,0,2330,2331,
  	3,574,287,0,2331,2332,5,664,0,0,2332,2333,5,388,0,0,2333,2334,5,395,0,
  	0,2334,2335,5,516,0,0,2335,2337,1,0,0,0,2336,2318,1,0,0,0,2336,2328,1,
  	0,0,0,2337,127,1,0,0,0,2338,2340,5,7,0,0,2339,2341,3,62,31,0,2340,2339,
  	1,0,0,0,2340,2341,1,0,0,0,2341,2342,1,0,0,0,2342,2343,5,415,0,0,2343,
  	2347,3,544,272,0,2344,2345,5,118,0,0,2345,2346,5,605,0,0,2346,2348,3,
  	64,32,0,2347,2344,1,0,0,0,2347,2348,1,0,0,0,2348,2355,1,0,0,0,2349,2350,
  	5,118,0,0,2350,2352,5,371,0,0,2351,2353,5,114,0,0,2352,2351,1,0,0,0,2352,
  	2353,1,0,0,0,2353,2354,1,0,0,0,2354,2356,5,561,0,0,2355,2349,1,0,0,0,
  	2355,2356,1,0,0,0,2356,2360,1,0,0,0,2357,2358,5,139,0,0,2358,2359,5,175,
  	0,0,2359,2361,3,544,272,0,2360,2357,1,0,0,0,2360,2361,1,0,0,0,2361,2363,
  	1,0,0,0,2362,2364,3,72,36,0,2363,2362,1,0,0,0,2363,2364,1,0,0,0,2364,
  	2367,1,0,0,0,2365,2366,5,368,0,0,2366,2368,5,1147,0,0,2367,2365,1,0,0,
  	0,2367,2368,1,0,0,0,2368,2371,1,0,0,0,2369,2370,5,399,0,0,2370,2372,3,
  	384,192,0,2371,2369,1,0,0,0,2371,2372,1,0,0,0,2372,129,1,0,0,0,2373,2374,
  	5,7,0,0,2374,2375,5,437,0,0,2375,2379,3,544,272,0,2376,2378,3,82,41,0,
  	2377,2376,1,0,0,0,2378,2381,1,0,0,0,2379,2377,1,0,0,0,2379,2380,1,0,0,
  	0,2380,131,1,0,0,0,2381,2379,1,0,0,0,2382,2383,5,7,0,0,2383,2384,5,457,
  	0,0,2384,2385,5,599,0,0,2385,2386,5,791,0,0,2386,2387,5,477,0,0,2387,
  	2388,5,91,0,0,2388,133,1,0,0,0,2389,2390,5,7,0,0,2390,2391,5,475,0,0,
  	2391,2392,5,73,0,0,2392,2393,3,574,287,0,2393,2394,5,5,0,0,2394,2395,
  	5,659,0,0,2395,2401,5,1147,0,0,2396,2398,5,453,0,0,2397,2399,5,1123,0,
  	0,2398,2397,1,0,0,0,2398,2399,1,0,0,0,2399,2400,1,0,0,0,2400,2402,3,582,
  	291,0,2401,2396,1,0,0,0,2401,2402,1,0,0,0,2402,2404,1,0,0,0,2403,2405,
  	5,674,0,0,2404,2403,1,0,0,0,2404,2405,1,0,0,0,2405,2406,1,0,0,0,2406,
  	2408,5,409,0,0,2407,2409,5,1123,0,0,2408,2407,1,0,0,0,2408,2409,1,0,0,
  	0,2409,2410,1,0,0,0,2410,2411,3,562,281,0,2411,135,1,0,0,0,2412,2413,
  	5,7,0,0,2413,2414,5,131,0,0,2414,2418,3,544,272,0,2415,2417,3,82,41,0,
  	2416,2415,1,0,0,0,2417,2420,1,0,0,0,2418,2416,1,0,0,0,2418,2419,1,0,0,
  	0,2419,137,1,0,0,0,2420,2418,1,0,0,0,2421,2422,5,7,0,0,2422,2423,5,608,
  	0,0,2423,2424,3,574,287,0,2424,2425,5,541,0,0,2425,2426,5,1132,0,0,2426,
  	2431,3,84,42,0,2427,2428,5,1134,0,0,2428,2430,3,84,42,0,2429,2427,1,0,
  	0,0,2430,2433,1,0,0,0,2431,2429,1,0,0,0,2431,2432,1,0,0,0,2432,2434,1,
  	0,0,0,2433,2431,1,0,0,0,2434,2435,5,1133,0,0,2435,139,1,0,0,0,2436,2438,
  	5,7,0,0,2437,2439,7,1,0,0,2438,2437,1,0,0,0,2438,2439,1,0,0,0,2439,2441,
  	1,0,0,0,2440,2442,5,78,0,0,2441,2440,1,0,0,0,2441,2442,1,0,0,0,2442,2443,
  	1,0,0,0,2443,2444,5,172,0,0,2444,2446,3,546,273,0,2445,2447,3,636,318,
  	0,2446,2445,1,0,0,0,2446,2447,1,0,0,0,2447,2456,1,0,0,0,2448,2453,3,146,
  	73,0,2449,2450,5,1134,0,0,2450,2452,3,146,73,0,2451,2449,1,0,0,0,2452,
  	2455,1,0,0,0,2453,2451,1,0,0,0,2453,2454,1,0,0,0,2454,2457,1,0,0,0,2455,
  	2453,1,0,0,0,2456,2448,1,0,0,0,2456,2457,1,0,0,0,2457,2459,1,0,0,0,2458,
  	2460,3,110,55,0,2459,2458,1,0,0,0,2459,2460,1,0,0,0,2460,141,1,0,0,0,
  	2461,2462,5,7,0,0,2462,2463,5,647,0,0,2463,2464,3,574,287,0,2464,2465,
  	7,33,0,0,2465,2466,5,389,0,0,2466,2470,5,1147,0,0,2467,2468,5,453,0,0,
  	2468,2469,5,1123,0,0,2469,2471,3,582,291,0,2470,2467,1,0,0,0,2470,2471,
  	1,0,0,0,2471,2473,1,0,0,0,2472,2474,5,674,0,0,2473,2472,1,0,0,0,2473,
  	2474,1,0,0,0,2474,2475,1,0,0,0,2475,2477,5,409,0,0,2476,2478,5,1123,0,
  	0,2477,2476,1,0,0,0,2477,2478,1,0,0,0,2478,2479,1,0,0,0,2479,2480,3,562,
  	281,0,2480,143,1,0,0,0,2481,2485,5,7,0,0,2482,2483,5,336,0,0,2483,2484,
  	5,1123,0,0,2484,2486,7,10,0,0,2485,2482,1,0,0,0,2485,2486,1,0,0,0,2486,
  	2488,1,0,0,0,2487,2489,3,62,31,0,2488,2487,1,0,0,0,2488,2489,1,0,0,0,
  	2489,2493,1,0,0,0,2490,2491,5,160,0,0,2491,2492,5,606,0,0,2492,2494,7,
  	11,0,0,2493,2490,1,0,0,0,2493,2494,1,0,0,0,2494,2495,1,0,0,0,2495,2496,
  	5,671,0,0,2496,2501,3,544,272,0,2497,2498,5,1132,0,0,2498,2499,3,606,
  	303,0,2499,2500,5,1133,0,0,2500,2502,1,0,0,0,2501,2497,1,0,0,0,2501,2502,
  	1,0,0,0,2502,2503,1,0,0,0,2503,2504,5,12,0,0,2504,2511,3,198,99,0,2505,
  	2507,5,192,0,0,2506,2508,7,12,0,0,2507,2506,1,0,0,0,2507,2508,1,0,0,0,
  	2508,2509,1,0,0,0,2509,2510,5,26,0,0,2510,2512,5,120,0,0,2511,2505,1,
  	0,0,0,2511,2512,1,0,0,0,2512,145,1,0,0,0,2513,2520,3,104,52,0,2514,2516,
  	5,1134,0,0,2515,2514,1,0,0,0,2515,2516,1,0,0,0,2516,2517,1,0,0,0,2517,
  	2519,3,104,52,0,2518,2515,1,0,0,0,2519,2522,1,0,0,0,2520,2518,1,0,0,0,
  	2520,2521,1,0,0,0,2521,2865,1,0,0,0,2522,2520,1,0,0,0,2523,2525,5,5,0,
  	0,2524,2526,5,28,0,0,2525,2524,1,0,0,0,2525,2526,1,0,0,0,2526,2527,1,
  	0,0,0,2527,2528,3,574,287,0,2528,2532,3,90,45,0,2529,2533,5,430,0,0,2530,
  	2531,5,334,0,0,2531,2533,3,574,287,0,2532,2529,1,0,0,0,2532,2530,1,0,
  	0,0,2532,2533,1,0,0,0,2533,2865,1,0,0,0,2534,2536,5,5,0,0,2535,2537,5,
  	28,0,0,2536,2535,1,0,0,0,2536,2537,1,0,0,0,2537,2538,1,0,0,0,2538,2539,
  	5,1132,0,0,2539,2540,3,574,287,0,2540,2547,3,90,45,0,2541,2542,5,1134,
  	0,0,2542,2543,3,574,287,0,2543,2544,3,90,45,0,2544,2546,1,0,0,0,2545,
  	2541,1,0,0,0,2546,2549,1,0,0,0,2547,2545,1,0,0,0,2547,2548,1,0,0,0,2548,
  	2550,1,0,0,0,2549,2547,1,0,0,0,2550,2551,5,1133,0,0,2551,2865,1,0,0,0,
  	2552,2553,5,5,0,0,2553,2555,7,20,0,0,2554,2556,3,574,287,0,2555,2554,
  	1,0,0,0,2555,2556,1,0,0,0,2556,2558,1,0,0,0,2557,2559,3,74,37,0,2558,
  	2557,1,0,0,0,2558,2559,1,0,0,0,2559,2560,1,0,0,0,2560,2564,3,612,306,
  	0,2561,2563,3,76,38,0,2562,2561,1,0,0,0,2563,2566,1,0,0,0,2564,2562,1,
  	0,0,0,2564,2565,1,0,0,0,2565,2865,1,0,0,0,2566,2564,1,0,0,0,2567,2572,
  	5,5,0,0,2568,2570,5,30,0,0,2569,2571,3,574,287,0,2570,2569,1,0,0,0,2570,
  	2571,1,0,0,0,2571,2573,1,0,0,0,2572,2568,1,0,0,0,2572,2573,1,0,0,0,2573,
  	2574,1,0,0,0,2574,2575,5,130,0,0,2575,2577,5,91,0,0,2576,2578,3,574,287,
  	0,2577,2576,1,0,0,0,2577,2578,1,0,0,0,2578,2580,1,0,0,0,2579,2581,3,74,
  	37,0,2580,2579,1,0,0,0,2580,2581,1,0,0,0,2581,2582,1,0,0,0,2582,2586,
  	3,612,306,0,2583,2585,3,76,38,0,2584,2583,1,0,0,0,2585,2588,1,0,0,0,2586,
  	2584,1,0,0,0,2586,2587,1,0,0,0,2587,2865,1,0,0,0,2588,2586,1,0,0,0,2589,
  	2594,5,5,0,0,2590,2592,5,30,0,0,2591,2593,3,574,287,0,2592,2591,1,0,0,
  	0,2592,2593,1,0,0,0,2593,2595,1,0,0,0,2594,2590,1,0,0,0,2594,2595,1,0,
  	0,0,2595,2596,1,0,0,0,2596,2598,5,181,0,0,2597,2599,7,20,0,0,2598,2597,
  	1,0,0,0,2598,2599,1,0,0,0,2599,2601,1,0,0,0,2600,2602,3,574,287,0,2601,
  	2600,1,0,0,0,2601,2602,1,0,0,0,2602,2604,1,0,0,0,2603,2605,3,74,37,0,
  	2604,2603,1,0,0,0,2604,2605,1,0,0,0,2605,2606,1,0,0,0,2606,2610,3,612,
  	306,0,2607,2609,3,76,38,0,2608,2607,1,0,0,0,2609,2612,1,0,0,0,2610,2608,
  	1,0,0,0,2610,2611,1,0,0,0,2611,2865,1,0,0,0,2612,2610,1,0,0,0,2613,2614,
  	5,5,0,0,2614,2616,7,22,0,0,2615,2617,7,20,0,0,2616,2615,1,0,0,0,2616,
  	2617,1,0,0,0,2617,2619,1,0,0,0,2618,2620,3,574,287,0,2619,2618,1,0,0,
  	0,2619,2620,1,0,0,0,2620,2621,1,0,0,0,2621,2625,3,612,306,0,2622,2624,
  	3,76,38,0,2623,2622,1,0,0,0,2624,2627,1,0,0,0,2625,2623,1,0,0,0,2625,
  	2626,1,0,0,0,2626,2865,1,0,0,0,2627,2625,1,0,0,0,2628,2633,5,5,0,0,2629,
  	2631,5,30,0,0,2630,2632,3,574,287,0,2631,2630,1,0,0,0,2631,2632,1,0,0,
  	0,2632,2634,1,0,0,0,2633,2629,1,0,0,0,2633,2634,1,0,0,0,2634,2635,1,0,
  	0,0,2635,2636,5,67,0,0,2636,2638,5,91,0,0,2637,2639,3,574,287,0,2638,
  	2637,1,0,0,0,2638,2639,1,0,0,0,2639,2640,1,0,0,0,2640,2641,3,612,306,
  	0,2641,2642,3,96,48,0,2642,2865,1,0,0,0,2643,2648,5,5,0,0,2644,2646,5,
  	30,0,0,2645,2647,3,574,287,0,2646,2645,1,0,0,0,2646,2647,1,0,0,0,2647,
  	2649,1,0,0,0,2648,2644,1,0,0,0,2648,2649,1,0,0,0,2649,2650,1,0,0,0,2650,
  	2657,5,26,0,0,2651,2658,3,574,287,0,2652,2658,3,584,292,0,2653,2654,5,
  	1132,0,0,2654,2655,3,678,339,0,2655,2656,5,1133,0,0,2656,2658,1,0,0,0,
  	2657,2651,1,0,0,0,2657,2652,1,0,0,0,2657,2653,1,0,0,0,2658,2660,1,0,0,
  	0,2659,2661,5,114,0,0,2660,2659,1,0,0,0,2660,2661,1,0,0,0,2661,2663,1,
  	0,0,0,2662,2664,5,57,0,0,2663,2662,1,0,0,0,2663,2664,1,0,0,0,2664,2865,
  	1,0,0,0,2665,2670,5,7,0,0,2666,2668,5,30,0,0,2667,2669,3,574,287,0,2668,
  	2667,1,0,0,0,2668,2669,1,0,0,0,2669,2671,1,0,0,0,2670,2666,1,0,0,0,2670,
  	2671,1,0,0,0,2671,2672,1,0,0,0,2672,2679,5,26,0,0,2673,2680,3,574,287,
  	0,2674,2680,3,584,292,0,2675,2676,5,1132,0,0,2676,2677,3,678,339,0,2677,
  	2678,5,1133,0,0,2678,2680,1,0,0,0,2679,2673,1,0,0,0,2679,2674,1,0,0,0,
  	2679,2675,1,0,0,0,2680,2682,1,0,0,0,2681,2683,5,114,0,0,2682,2681,1,0,
  	0,0,2682,2683,1,0,0,0,2683,2685,1,0,0,0,2684,2686,5,57,0,0,2685,2684,
  	1,0,0,0,2685,2686,1,0,0,0,2686,2865,1,0,0,0,2687,2692,5,5,0,0,2688,2690,
  	5,30,0,0,2689,2691,3,574,287,0,2690,2689,1,0,0,0,2690,2691,1,0,0,0,2691,
  	2693,1,0,0,0,2692,2688,1,0,0,0,2692,2693,1,0,0,0,2693,2694,1,0,0,0,2694,
  	2695,5,26,0,0,2695,2696,5,1132,0,0,2696,2697,3,678,339,0,2697,2698,5,
  	1133,0,0,2698,2865,1,0,0,0,2699,2701,5,336,0,0,2700,2702,5,1123,0,0,2701,
  	2700,1,0,0,0,2701,2702,1,0,0,0,2702,2703,1,0,0,0,2703,2865,7,34,0,0,2704,
  	2706,5,7,0,0,2705,2707,5,28,0,0,2706,2705,1,0,0,0,2706,2707,1,0,0,0,2707,
  	2708,1,0,0,0,2708,2714,3,574,287,0,2709,2710,5,153,0,0,2710,2711,5,42,
  	0,0,2711,2715,3,624,312,0,2712,2713,5,51,0,0,2713,2715,5,42,0,0,2714,
  	2709,1,0,0,0,2714,2712,1,0,0,0,2715,2865,1,0,0,0,2716,2718,5,24,0,0,2717,
  	2719,5,28,0,0,2718,2717,1,0,0,0,2718,2719,1,0,0,0,2719,2720,1,0,0,0,2720,
  	2721,3,574,287,0,2721,2722,3,574,287,0,2722,2726,3,90,45,0,2723,2727,
  	5,430,0,0,2724,2725,5,334,0,0,2725,2727,3,574,287,0,2726,2723,1,0,0,0,
  	2726,2724,1,0,0,0,2726,2727,1,0,0,0,2727,2865,1,0,0,0,2728,2729,5,139,
  	0,0,2729,2730,5,28,0,0,2730,2731,3,574,287,0,2731,2732,5,175,0,0,2732,
  	2733,3,574,287,0,2733,2865,1,0,0,0,2734,2736,5,103,0,0,2735,2737,5,1123,
  	0,0,2736,2735,1,0,0,0,2736,2737,1,0,0,0,2737,2738,1,0,0,0,2738,2865,7,
  	4,0,0,2739,2741,5,512,0,0,2740,2742,5,28,0,0,2741,2740,1,0,0,0,2741,2742,
  	1,0,0,0,2742,2743,1,0,0,0,2743,2744,3,574,287,0,2744,2748,3,90,45,0,2745,
  	2749,5,430,0,0,2746,2747,5,334,0,0,2747,2749,3,574,287,0,2748,2745,1,
  	0,0,0,2748,2746,1,0,0,0,2748,2749,1,0,0,0,2749,2865,1,0,0,0,2750,2752,
  	5,51,0,0,2751,2753,5,28,0,0,2752,2751,1,0,0,0,2752,2753,1,0,0,0,2753,
  	2754,1,0,0,0,2754,2756,3,574,287,0,2755,2757,5,144,0,0,2756,2755,1,0,
  	0,0,2756,2757,1,0,0,0,2757,2865,1,0,0,0,2758,2759,5,51,0,0,2759,2760,
  	7,35,0,0,2760,2865,3,574,287,0,2761,2762,5,51,0,0,2762,2763,5,130,0,0,
  	2763,2865,5,91,0,0,2764,2765,5,51,0,0,2765,2766,7,20,0,0,2766,2865,3,
  	574,287,0,2767,2768,5,139,0,0,2768,2769,7,20,0,0,2769,2770,3,574,287,
  	0,2770,2771,5,175,0,0,2771,2772,3,574,287,0,2772,2865,1,0,0,0,2773,2775,
  	5,7,0,0,2774,2776,5,28,0,0,2775,2774,1,0,0,0,2775,2776,1,0,0,0,2776,2777,
  	1,0,0,0,2777,2791,3,574,287,0,2778,2779,5,153,0,0,2779,2785,5,42,0,0,
  	2780,2786,3,584,292,0,2781,2782,5,1132,0,0,2782,2783,3,678,339,0,2783,
  	2784,5,1133,0,0,2784,2786,1,0,0,0,2785,2780,1,0,0,0,2785,2781,1,0,0,0,
  	2786,2792,1,0,0,0,2787,2788,5,153,0,0,2788,2792,7,15,0,0,2789,2790,5,
  	51,0,0,2790,2792,5,42,0,0,2791,2778,1,0,0,0,2791,2787,1,0,0,0,2791,2789,
  	1,0,0,0,2792,2865,1,0,0,0,2793,2794,5,7,0,0,2794,2795,5,81,0,0,2795,2796,
  	3,574,287,0,2796,2797,7,15,0,0,2797,2865,1,0,0,0,2798,2799,5,51,0,0,2799,
  	2800,5,67,0,0,2800,2801,5,91,0,0,2801,2865,3,574,287,0,2802,2803,5,396,
  	0,0,2803,2865,5,92,0,0,2804,2805,5,403,0,0,2805,2865,5,92,0,0,2806,2808,
  	5,139,0,0,2807,2809,7,36,0,0,2808,2807,1,0,0,0,2808,2809,1,0,0,0,2809,
  	2812,1,0,0,0,2810,2813,3,574,287,0,2811,2813,3,544,272,0,2812,2810,1,
  	0,0,0,2812,2811,1,0,0,0,2813,2865,1,0,0,0,2814,2815,5,124,0,0,2815,2816,
  	5,19,0,0,2816,2865,3,606,303,0,2817,2818,5,32,0,0,2818,2822,5,175,0,0,
  	2819,2823,5,841,0,0,2820,2821,5,25,0,0,2821,2823,5,153,0,0,2822,2819,
  	1,0,0,0,2822,2820,1,0,0,0,2823,2824,1,0,0,0,2824,2827,3,558,279,0,2825,
  	2826,5,27,0,0,2826,2828,3,560,280,0,2827,2825,1,0,0,0,2827,2828,1,0,0,
  	0,2828,2865,1,0,0,0,2829,2831,5,42,0,0,2830,2829,1,0,0,0,2830,2831,1,
  	0,0,0,2831,2832,1,0,0,0,2832,2833,5,25,0,0,2833,2834,5,153,0,0,2834,2835,
  	5,1123,0,0,2835,2839,3,558,279,0,2836,2837,5,27,0,0,2837,2838,5,1123,
  	0,0,2838,2840,3,560,280,0,2839,2836,1,0,0,0,2839,2840,1,0,0,0,2840,2865,
  	1,0,0,0,2841,2842,5,397,0,0,2842,2865,5,647,0,0,2843,2844,5,450,0,0,2844,
  	2865,5,647,0,0,2845,2865,5,66,0,0,2846,2847,7,37,0,0,2847,2865,5,668,
  	0,0,2848,2850,5,5,0,0,2849,2851,5,28,0,0,2850,2849,1,0,0,0,2850,2851,
  	1,0,0,0,2851,2852,1,0,0,0,2852,2853,5,1132,0,0,2853,2858,3,88,44,0,2854,
  	2855,5,1134,0,0,2855,2857,3,88,44,0,2856,2854,1,0,0,0,2857,2860,1,0,0,
  	0,2858,2856,1,0,0,0,2858,2859,1,0,0,0,2859,2861,1,0,0,0,2860,2858,1,0,
  	0,0,2861,2862,5,1133,0,0,2862,2865,1,0,0,0,2863,2865,3,148,74,0,2864,
  	2513,1,0,0,0,2864,2523,1,0,0,0,2864,2534,1,0,0,0,2864,2552,1,0,0,0,2864,
  	2567,1,0,0,0,2864,2589,1,0,0,0,2864,2613,1,0,0,0,2864,2628,1,0,0,0,2864,
  	2643,1,0,0,0,2864,2665,1,0,0,0,2864,2687,1,0,0,0,2864,2699,1,0,0,0,2864,
  	2704,1,0,0,0,2864,2716,1,0,0,0,2864,2728,1,0,0,0,2864,2734,1,0,0,0,2864,
  	2739,1,0,0,0,2864,2750,1,0,0,0,2864,2758,1,0,0,0,2864,2761,1,0,0,0,2864,
  	2764,1,0,0,0,2864,2767,1,0,0,0,2864,2773,1,0,0,0,2864,2793,1,0,0,0,2864,
  	2798,1,0,0,0,2864,2802,1,0,0,0,2864,2804,1,0,0,0,2864,2806,1,0,0,0,2864,
  	2814,1,0,0,0,2864,2817,1,0,0,0,2864,2830,1,0,0,0,2864,2841,1,0,0,0,2864,
  	2843,1,0,0,0,2864,2845,1,0,0,0,2864,2846,1,0,0,0,2864,2848,1,0,0,0,2864,
  	2863,1,0,0,0,2865,147,1,0,0,0,2866,2867,5,5,0,0,2867,2868,5,129,0,0,2868,
  	2869,5,1132,0,0,2869,2874,3,116,58,0,2870,2871,5,1134,0,0,2871,2873,3,
  	116,58,0,2872,2870,1,0,0,0,2873,2876,1,0,0,0,2874,2872,1,0,0,0,2874,2875,
  	1,0,0,0,2875,2877,1,0,0,0,2876,2874,1,0,0,0,2877,2878,5,1133,0,0,2878,
  	2965,1,0,0,0,2879,2880,5,51,0,0,2880,2881,5,129,0,0,2881,2965,3,606,303,
  	0,2882,2883,5,397,0,0,2883,2886,5,129,0,0,2884,2887,3,606,303,0,2885,
  	2887,5,6,0,0,2886,2884,1,0,0,0,2886,2885,1,0,0,0,2887,2888,1,0,0,0,2888,
  	2965,5,647,0,0,2889,2890,5,450,0,0,2890,2893,5,129,0,0,2891,2894,3,606,
  	303,0,2892,2894,5,6,0,0,2893,2891,1,0,0,0,2893,2892,1,0,0,0,2894,2895,
  	1,0,0,0,2895,2965,5,647,0,0,2896,2897,5,656,0,0,2897,2900,5,129,0,0,2898,
  	2901,3,606,303,0,2899,2901,5,6,0,0,2900,2898,1,0,0,0,2900,2899,1,0,0,
  	0,2901,2965,1,0,0,0,2902,2903,5,363,0,0,2903,2904,5,129,0,0,2904,2965,
  	3,580,290,0,2905,2906,5,579,0,0,2906,2907,5,129,0,0,2907,2908,3,606,303,
  	0,2908,2909,5,87,0,0,2909,2910,5,1132,0,0,2910,2915,3,116,58,0,2911,2912,
  	5,1134,0,0,2912,2914,3,116,58,0,2913,2911,1,0,0,0,2914,2917,1,0,0,0,2915,
  	2913,1,0,0,0,2915,2916,1,0,0,0,2916,2918,1,0,0,0,2917,2915,1,0,0,0,2918,
  	2919,5,1133,0,0,2919,2965,1,0,0,0,2920,2921,5,418,0,0,2921,2922,5,129,
  	0,0,2922,2923,3,574,287,0,2923,2924,5,192,0,0,2924,2925,5,172,0,0,2925,
  	2928,3,546,273,0,2926,2927,7,37,0,0,2927,2929,5,668,0,0,2928,2926,1,0,
  	0,0,2928,2929,1,0,0,0,2929,2965,1,0,0,0,2930,2931,5,9,0,0,2931,2934,5,
  	129,0,0,2932,2935,3,606,303,0,2933,2935,5,6,0,0,2934,2932,1,0,0,0,2934,
  	2933,1,0,0,0,2935,2965,1,0,0,0,2936,2937,5,26,0,0,2937,2940,5,129,0,0,
  	2938,2941,3,606,303,0,2939,2941,5,6,0,0,2940,2938,1,0,0,0,2940,2939,1,
  	0,0,0,2941,2965,1,0,0,0,2942,2943,5,119,0,0,2943,2946,5,129,0,0,2944,
  	2947,3,606,303,0,2945,2947,5,6,0,0,2946,2944,1,0,0,0,2946,2945,1,0,0,
  	0,2947,2965,1,0,0,0,2948,2949,5,569,0,0,2949,2952,5,129,0,0,2950,2953,
  	3,606,303,0,2951,2953,5,6,0,0,2952,2950,1,0,0,0,2952,2951,1,0,0,0,2953,
  	2965,1,0,0,0,2954,2955,5,580,0,0,2955,2958,5,129,0,0,2956,2959,3,606,
  	303,0,2957,2959,5,6,0,0,2958,2956,1,0,0,0,2958,2957,1,0,0,0,2959,2965,
  	1,0,0,0,2960,2961,5,578,0,0,2961,2965,5,549,0,0,2962,2963,5,664,0,0,2963,
  	2965,5,549,0,0,2964,2866,1,0,0,0,2964,2879,1,0,0,0,2964,2882,1,0,0,0,
  	2964,2889,1,0,0,0,2964,2896,1,0,0,0,2964,2902,1,0,0,0,2964,2905,1,0,0,
  	0,2964,2920,1,0,0,0,2964,2930,1,0,0,0,2964,2936,1,0,0,0,2964,2942,1,0,
  	0,0,2964,2948,1,0,0,0,2964,2954,1,0,0,0,2964,2960,1,0,0,0,2964,2962,1,
  	0,0,0,2965,149,1,0,0,0,2966,2967,5,51,0,0,2967,2969,7,0,0,0,2968,2970,
  	3,630,315,0,2969,2968,1,0,0,0,2969,2970,1,0,0,0,2970,2971,1,0,0,0,2971,
  	2972,3,574,287,0,2972,151,1,0,0,0,2973,2974,5,51,0,0,2974,2976,5,415,
  	0,0,2975,2977,3,630,315,0,2976,2975,1,0,0,0,2976,2977,1,0,0,0,2977,2978,
  	1,0,0,0,2978,2979,3,544,272,0,2979,153,1,0,0,0,2980,2981,5,51,0,0,2981,
  	2983,5,81,0,0,2982,2984,7,1,0,0,2983,2982,1,0,0,0,2983,2984,1,0,0,0,2984,
  	2985,1,0,0,0,2985,2986,3,574,287,0,2986,2987,5,118,0,0,2987,3000,3,546,
  	273,0,2988,2990,5,336,0,0,2989,2991,5,1123,0,0,2990,2989,1,0,0,0,2990,
  	2991,1,0,0,0,2991,2992,1,0,0,0,2992,2999,7,3,0,0,2993,2995,5,103,0,0,
  	2994,2996,5,1123,0,0,2995,2994,1,0,0,0,2995,2996,1,0,0,0,2996,2997,1,
  	0,0,0,2997,2999,7,4,0,0,2998,2988,1,0,0,0,2998,2993,1,0,0,0,2999,3002,
  	1,0,0,0,3000,2998,1,0,0,0,3000,3001,1,0,0,0,3001,155,1,0,0,0,3002,3000,
  	1,0,0,0,3003,3004,5,51,0,0,3004,3005,5,475,0,0,3005,3006,5,73,0,0,3006,
  	3007,3,574,287,0,3007,3008,5,409,0,0,3008,3009,5,1123,0,0,3009,3010,3,
  	562,281,0,3010,157,1,0,0,0,3011,3012,5,51,0,0,3012,3014,5,131,0,0,3013,
  	3015,3,630,315,0,3014,3013,1,0,0,0,3014,3015,1,0,0,0,3015,3016,1,0,0,
  	0,3016,3017,3,544,272,0,3017,159,1,0,0,0,3018,3019,5,51,0,0,3019,3021,
  	5,437,0,0,3020,3022,3,630,315,0,3021,3020,1,0,0,0,3021,3022,1,0,0,0,3022,
  	3023,1,0,0,0,3023,3024,3,544,272,0,3024,161,1,0,0,0,3025,3026,5,51,0,
  	0,3026,3028,5,608,0,0,3027,3029,3,630,315,0,3028,3027,1,0,0,0,3028,3029,
  	1,0,0,0,3029,3030,1,0,0,0,3030,3031,3,574,287,0,3031,163,1,0,0,0,3032,
  	3034,5,51,0,0,3033,3035,5,649,0,0,3034,3033,1,0,0,0,3034,3035,1,0,0,0,
  	3035,3036,1,0,0,0,3036,3038,5,172,0,0,3037,3039,3,630,315,0,3038,3037,
  	1,0,0,0,3038,3039,1,0,0,0,3039,3040,1,0,0,0,3040,3042,3,610,305,0,3041,
  	3043,7,38,0,0,3042,3041,1,0,0,0,3042,3043,1,0,0,0,3043,165,1,0,0,0,3044,
  	3045,5,51,0,0,3045,3046,5,647,0,0,3046,3052,3,574,287,0,3047,3049,5,409,
  	0,0,3048,3050,5,1123,0,0,3049,3048,1,0,0,0,3049,3050,1,0,0,0,3050,3051,
  	1,0,0,0,3051,3053,3,562,281,0,3052,3047,1,0,0,0,3052,3053,1,0,0,0,3053,
  	167,1,0,0,0,3054,3055,5,51,0,0,3055,3057,5,177,0,0,3056,3058,3,630,315,
  	0,3057,3056,1,0,0,0,3057,3058,1,0,0,0,3058,3059,1,0,0,0,3059,3060,3,544,
  	272,0,3060,169,1,0,0,0,3061,3062,5,51,0,0,3062,3064,5,671,0,0,3063,3065,
  	3,630,315,0,3064,3063,1,0,0,0,3064,3065,1,0,0,0,3065,3066,1,0,0,0,3066,
  	3071,3,544,272,0,3067,3068,5,1134,0,0,3068,3070,3,544,272,0,3069,3067,
  	1,0,0,0,3070,3073,1,0,0,0,3071,3069,1,0,0,0,3071,3072,1,0,0,0,3072,3075,
  	1,0,0,0,3073,3071,1,0,0,0,3074,3076,7,38,0,0,3075,3074,1,0,0,0,3075,3076,
  	1,0,0,0,3076,171,1,0,0,0,3077,3078,5,51,0,0,3078,3080,5,596,0,0,3079,
  	3081,3,630,315,0,3080,3079,1,0,0,0,3080,3081,1,0,0,0,3081,3082,1,0,0,
  	0,3082,3087,3,548,274,0,3083,3084,5,1134,0,0,3084,3086,3,548,274,0,3085,
  	3083,1,0,0,0,3086,3089,1,0,0,0,3087,3085,1,0,0,0,3087,3088,1,0,0,0,3088,
  	173,1,0,0,0,3089,3087,1,0,0,0,3090,3091,5,153,0,0,3091,3092,5,42,0,0,
  	3092,3103,5,596,0,0,3093,3104,5,529,0,0,3094,3104,5,6,0,0,3095,3100,3,
  	548,274,0,3096,3097,5,1134,0,0,3097,3099,3,548,274,0,3098,3096,1,0,0,
  	0,3099,3102,1,0,0,0,3100,3098,1,0,0,0,3100,3101,1,0,0,0,3101,3104,1,0,
  	0,0,3102,3100,1,0,0,0,3103,3093,1,0,0,0,3103,3094,1,0,0,0,3103,3095,1,
  	0,0,0,3104,3105,1,0,0,0,3105,3108,5,175,0,0,3106,3109,3,554,277,0,3107,
  	3109,3,574,287,0,3108,3106,1,0,0,0,3108,3107,1,0,0,0,3109,3117,1,0,0,
  	0,3110,3113,5,1134,0,0,3111,3114,3,554,277,0,3112,3114,3,574,287,0,3113,
  	3111,1,0,0,0,3113,3112,1,0,0,0,3114,3116,1,0,0,0,3115,3110,1,0,0,0,3116,
  	3119,1,0,0,0,3117,3115,1,0,0,0,3117,3118,1,0,0,0,3118,3124,1,0,0,0,3119,
  	3117,1,0,0,0,3120,3121,5,153,0,0,3121,3122,5,596,0,0,3122,3124,3,430,
  	215,0,3123,3090,1,0,0,0,3123,3120,1,0,0,0,3124,175,1,0,0,0,3125,3126,
  	5,139,0,0,3126,3127,5,172,0,0,3127,3132,3,178,89,0,3128,3129,5,1134,0,
  	0,3129,3131,3,178,89,0,3130,3128,1,0,0,0,3131,3134,1,0,0,0,3132,3130,
  	1,0,0,0,3132,3133,1,0,0,0,3133,177,1,0,0,0,3134,3132,1,0,0,0,3135,3136,
  	3,546,273,0,3136,3137,5,175,0,0,3137,3138,3,546,273,0,3138,179,1,0,0,
  	0,3139,3141,5,656,0,0,3140,3142,5,172,0,0,3141,3140,1,0,0,0,3141,3142,
  	1,0,0,0,3142,3143,1,0,0,0,3143,3144,3,546,273,0,3144,181,1,0,0,0,3145,
  	3146,5,20,0,0,3146,3153,3,544,272,0,3147,3150,5,1132,0,0,3148,3151,3,
  	618,309,0,3149,3151,3,614,307,0,3150,3148,1,0,0,0,3150,3149,1,0,0,0,3150,
  	3151,1,0,0,0,3151,3152,1,0,0,0,3152,3154,5,1133,0,0,3153,3147,1,0,0,0,
  	3153,3154,1,0,0,0,3154,183,1,0,0,0,3155,3158,3,212,106,0,3156,3158,3,
  	214,107,0,3157,3155,1,0,0,0,3157,3156,1,0,0,0,3158,185,1,0,0,0,3159,3160,
  	5,399,0,0,3160,3161,3,614,307,0,3161,187,1,0,0,0,3162,3167,3,216,108,
  	0,3163,3167,3,218,109,0,3164,3167,3,220,110,0,3165,3167,3,222,111,0,3166,
  	3162,1,0,0,0,3166,3163,1,0,0,0,3166,3164,1,0,0,0,3166,3165,1,0,0,0,3167,
  	189,1,0,0,0,3168,3170,5,85,0,0,3169,3171,7,39,0,0,3170,3169,1,0,0,0,3170,
  	3171,1,0,0,0,3171,3173,1,0,0,0,3172,3174,5,78,0,0,3173,3172,1,0,0,0,3173,
  	3174,1,0,0,0,3174,3176,1,0,0,0,3175,3177,5,87,0,0,3176,3175,1,0,0,0,3176,
  	3177,1,0,0,0,3177,3178,1,0,0,0,3178,3185,3,546,273,0,3179,3180,5,129,
  	0,0,3180,3182,5,1132,0,0,3181,3183,3,606,303,0,3182,3181,1,0,0,0,3182,
  	3183,1,0,0,0,3183,3184,1,0,0,0,3184,3186,5,1133,0,0,3185,3179,1,0,0,0,
  	3185,3186,1,0,0,0,3186,3209,1,0,0,0,3187,3188,5,1132,0,0,3188,3189,3,
  	608,304,0,3189,3190,5,1133,0,0,3190,3192,1,0,0,0,3191,3187,1,0,0,0,3191,
  	3192,1,0,0,0,3192,3193,1,0,0,0,3193,3198,3,204,102,0,3194,3196,5,12,0,
  	0,3195,3194,1,0,0,0,3195,3196,1,0,0,0,3196,3197,1,0,0,0,3197,3199,3,574,
  	287,0,3198,3195,1,0,0,0,3198,3199,1,0,0,0,3199,3210,1,0,0,0,3200,3201,
  	5,153,0,0,3201,3206,3,206,103,0,3202,3203,5,1134,0,0,3203,3205,3,206,
  	103,0,3204,3202,1,0,0,0,3205,3208,1,0,0,0,3206,3204,1,0,0,0,3206,3207,
  	1,0,0,0,3207,3210,1,0,0,0,3208,3206,1,0,0,0,3209,3191,1,0,0,0,3209,3200,
  	1,0,0,0,3210,3223,1,0,0,0,3211,3212,5,118,0,0,3212,3213,5,401,0,0,3213,
  	3214,5,91,0,0,3214,3215,5,184,0,0,3215,3220,3,206,103,0,3216,3217,5,1134,
  	0,0,3217,3219,3,206,103,0,3218,3216,1,0,0,0,3219,3222,1,0,0,0,3220,3218,
  	1,0,0,0,3220,3221,1,0,0,0,3221,3224,1,0,0,0,3222,3220,1,0,0,0,3223,3211,
  	1,0,0,0,3223,3224,1,0,0,0,3224,191,1,0,0,0,3225,3226,5,102,0,0,3226,3228,
  	5,388,0,0,3227,3229,7,40,0,0,3228,3227,1,0,0,0,3228,3229,1,0,0,0,3229,
  	3231,1,0,0,0,3230,3232,5,474,0,0,3231,3230,1,0,0,0,3231,3232,1,0,0,0,
  	3232,3233,1,0,0,0,3233,3234,5,82,0,0,3234,3236,5,1147,0,0,3235,3237,7,
  	6,0,0,3236,3235,1,0,0,0,3236,3237,1,0,0,0,3237,3238,1,0,0,0,3238,3239,
  	5,87,0,0,3239,3240,5,172,0,0,3240,3246,3,546,273,0,3241,3242,5,129,0,
  	0,3242,3243,5,1132,0,0,3243,3244,3,606,303,0,3244,3245,5,1133,0,0,3245,
  	3247,1,0,0,0,3246,3241,1,0,0,0,3246,3247,1,0,0,0,3247,3251,1,0,0,0,3248,
  	3249,5,25,0,0,3249,3250,5,153,0,0,3250,3252,3,558,279,0,3251,3248,1,0,
  	0,0,3251,3252,1,0,0,0,3252,3259,1,0,0,0,3253,3255,7,41,0,0,3254,3256,
  	3,276,138,0,3255,3254,1,0,0,0,3256,3257,1,0,0,0,3257,3255,1,0,0,0,3257,
  	3258,1,0,0,0,3258,3260,1,0,0,0,3259,3253,1,0,0,0,3259,3260,1,0,0,0,3260,
  	3267,1,0,0,0,3261,3263,5,101,0,0,3262,3264,3,278,139,0,3263,3262,1,0,
  	0,0,3264,3265,1,0,0,0,3265,3263,1,0,0,0,3265,3266,1,0,0,0,3266,3268,1,
  	0,0,0,3267,3261,1,0,0,0,3267,3268,1,0,0,0,3268,3273,1,0,0,0,3269,3270,
  	5,78,0,0,3270,3271,3,580,290,0,3271,3272,7,42,0,0,3272,3274,1,0,0,0,3273,
  	3269,1,0,0,0,3273,3274,1,0,0,0,3274,3286,1,0,0,0,3275,3276,5,1132,0,0,
  	3276,3281,3,208,104,0,3277,3278,5,1134,0,0,3278,3280,3,208,104,0,3279,
  	3277,1,0,0,0,3280,3283,1,0,0,0,3281,3279,1,0,0,0,3281,3282,1,0,0,0,3282,
  	3284,1,0,0,0,3283,3281,1,0,0,0,3284,3285,5,1133,0,0,3285,3287,1,0,0,0,
  	3286,3275,1,0,0,0,3286,3287,1,0,0,0,3287,3297,1,0,0,0,3288,3289,5,153,
  	0,0,3289,3294,3,206,103,0,3290,3291,5,1134,0,0,3291,3293,3,206,103,0,
  	3292,3290,1,0,0,0,3293,3296,1,0,0,0,3294,3292,1,0,0,0,3294,3295,1,0,0,
  	0,3295,3298,1,0,0,0,3296,3294,1,0,0,0,3297,3288,1,0,0,0,3297,3298,1,0,
  	0,0,3298,193,1,0,0,0,3299,3300,5,102,0,0,3300,3302,5,682,0,0,3301,3303,
  	7,40,0,0,3302,3301,1,0,0,0,3302,3303,1,0,0,0,3303,3305,1,0,0,0,3304,3306,
  	5,474,0,0,3305,3304,1,0,0,0,3305,3306,1,0,0,0,3306,3307,1,0,0,0,3307,
  	3308,5,82,0,0,3308,3310,5,1147,0,0,3309,3311,7,6,0,0,3310,3309,1,0,0,
  	0,3310,3311,1,0,0,0,3311,3312,1,0,0,0,3312,3313,5,87,0,0,3313,3314,5,
  	172,0,0,3314,3318,3,546,273,0,3315,3316,5,25,0,0,3316,3317,5,153,0,0,
  	3317,3319,3,558,279,0,3318,3315,1,0,0,0,3318,3319,1,0,0,0,3319,3326,1,
  	0,0,0,3320,3321,5,601,0,0,3321,3322,5,448,0,0,3322,3323,5,19,0,0,3323,
  	3324,5,1125,0,0,3324,3325,5,1147,0,0,3325,3327,5,1124,0,0,3326,3320,1,
  	0,0,0,3326,3327,1,0,0,0,3327,3332,1,0,0,0,3328,3329,5,78,0,0,3329,3330,
  	3,580,290,0,3330,3331,7,42,0,0,3331,3333,1,0,0,0,3332,3328,1,0,0,0,3332,
  	3333,1,0,0,0,3333,3345,1,0,0,0,3334,3335,5,1132,0,0,3335,3340,3,208,104,
  	0,3336,3337,5,1134,0,0,3337,3339,3,208,104,0,3338,3336,1,0,0,0,3339,3342,
  	1,0,0,0,3340,3338,1,0,0,0,3340,3341,1,0,0,0,3341,3343,1,0,0,0,3342,3340,
  	1,0,0,0,3343,3344,5,1133,0,0,3344,3346,1,0,0,0,3345,3334,1,0,0,0,3345,
  	3346,1,0,0,0,3346,3356,1,0,0,0,3347,3348,5,153,0,0,3348,3353,3,206,103,
  	0,3349,3350,5,1134,0,0,3350,3352,3,206,103,0,3351,3349,1,0,0,0,3352,3355,
  	1,0,0,0,3353,3351,1,0,0,0,3353,3354,1,0,0,0,3354,3357,1,0,0,0,3355,3353,
  	1,0,0,0,3356,3347,1,0,0,0,3356,3357,1,0,0,0,3357,195,1,0,0,0,3358,3360,
  	5,141,0,0,3359,3361,7,43,0,0,3360,3359,1,0,0,0,3360,3361,1,0,0,0,3361,
  	3363,1,0,0,0,3362,3364,5,87,0,0,3363,3362,1,0,0,0,3363,3364,1,0,0,0,3364,
  	3365,1,0,0,0,3365,3371,3,546,273,0,3366,3367,5,129,0,0,3367,3368,5,1132,
  	0,0,3368,3369,3,606,303,0,3369,3370,5,1133,0,0,3370,3372,1,0,0,0,3371,
  	3366,1,0,0,0,3371,3372,1,0,0,0,3372,3389,1,0,0,0,3373,3374,5,1132,0,0,
  	3374,3375,3,606,303,0,3375,3376,5,1133,0,0,3376,3378,1,0,0,0,3377,3373,
  	1,0,0,0,3377,3378,1,0,0,0,3378,3379,1,0,0,0,3379,3390,3,204,102,0,3380,
  	3381,5,153,0,0,3381,3386,3,206,103,0,3382,3383,5,1134,0,0,3383,3385,3,
  	206,103,0,3384,3382,1,0,0,0,3385,3388,1,0,0,0,3386,3384,1,0,0,0,3386,
  	3387,1,0,0,0,3387,3390,1,0,0,0,3388,3386,1,0,0,0,3389,3377,1,0,0,0,3389,
  	3380,1,0,0,0,3390,197,1,0,0,0,3391,3393,3,248,124,0,3392,3394,3,210,105,
  	0,3393,3392,1,0,0,0,3393,3394,1,0,0,0,3394,3454,1,0,0,0,3395,3397,3,244,
  	122,0,3396,3398,3,210,105,0,3397,3396,1,0,0,0,3397,3398,1,0,0,0,3398,
  	3454,1,0,0,0,3399,3401,3,250,125,0,3400,3402,3,254,127,0,3401,3400,1,
  	0,0,0,3402,3403,1,0,0,0,3403,3401,1,0,0,0,3403,3404,1,0,0,0,3404,3413,
  	1,0,0,0,3405,3407,5,180,0,0,3406,3408,7,44,0,0,3407,3406,1,0,0,0,3407,
  	3408,1,0,0,0,3408,3411,1,0,0,0,3409,3412,3,248,124,0,3410,3412,3,244,
  	122,0,3411,3409,1,0,0,0,3411,3410,1,0,0,0,3412,3414,1,0,0,0,3413,3405,
  	1,0,0,0,3413,3414,1,0,0,0,3414,3416,1,0,0,0,3415,3417,3,228,114,0,3416,
  	3415,1,0,0,0,3416,3417,1,0,0,0,3417,3419,1,0,0,0,3418,3420,3,290,145,
  	0,3419,3418,1,0,0,0,3419,3420,1,0,0,0,3420,3422,1,0,0,0,3421,3423,3,210,
  	105,0,3422,3421,1,0,0,0,3422,3423,1,0,0,0,3423,3454,1,0,0,0,3424,3426,
  	3,246,123,0,3425,3427,3,252,126,0,3426,3425,1,0,0,0,3427,3428,1,0,0,0,
  	3428,3426,1,0,0,0,3428,3429,1,0,0,0,3429,3435,1,0,0,0,3430,3432,5,180,
  	0,0,3431,3433,7,44,0,0,3432,3431,1,0,0,0,3432,3433,1,0,0,0,3433,3434,
  	1,0,0,0,3434,3436,3,244,122,0,3435,3430,1,0,0,0,3435,3436,1,0,0,0,3436,
  	3438,1,0,0,0,3437,3439,3,228,114,0,3438,3437,1,0,0,0,3438,3439,1,0,0,
  	0,3439,3441,1,0,0,0,3440,3442,3,290,145,0,3441,3440,1,0,0,0,3441,3442,
  	1,0,0,0,3442,3444,1,0,0,0,3443,3445,3,210,105,0,3444,3443,1,0,0,0,3444,
  	3445,1,0,0,0,3445,3454,1,0,0,0,3446,3449,3,250,125,0,3447,3448,5,1134,
  	0,0,3448,3450,3,256,128,0,3449,3447,1,0,0,0,3450,3451,1,0,0,0,3451,3449,
  	1,0,0,0,3451,3452,1,0,0,0,3452,3454,1,0,0,0,3453,3391,1,0,0,0,3453,3395,
  	1,0,0,0,3453,3399,1,0,0,0,3453,3424,1,0,0,0,3453,3446,1,0,0,0,3454,199,
  	1,0,0,0,3455,3458,3,224,112,0,3456,3458,3,226,113,0,3457,3455,1,0,0,0,
  	3457,3456,1,0,0,0,3458,201,1,0,0,0,3459,3460,5,188,0,0,3460,3462,5,1132,
  	0,0,3461,3463,3,616,308,0,3462,3461,1,0,0,0,3462,3463,1,0,0,0,3463,3464,
  	1,0,0,0,3464,3473,5,1133,0,0,3465,3466,5,1134,0,0,3466,3468,5,1132,0,
  	0,3467,3469,3,616,308,0,3468,3467,1,0,0,0,3468,3469,1,0,0,0,3469,3470,
  	1,0,0,0,3470,3472,5,1133,0,0,3471,3465,1,0,0,0,3472,3475,1,0,0,0,3473,
  	3471,1,0,0,0,3473,3474,1,0,0,0,3474,203,1,0,0,0,3475,3473,1,0,0,0,3476,
  	3495,3,198,99,0,3477,3478,7,45,0,0,3478,3480,5,1132,0,0,3479,3481,3,616,
  	308,0,3480,3479,1,0,0,0,3480,3481,1,0,0,0,3481,3482,1,0,0,0,3482,3491,
  	5,1133,0,0,3483,3484,5,1134,0,0,3484,3486,5,1132,0,0,3485,3487,3,616,
  	308,0,3486,3485,1,0,0,0,3486,3487,1,0,0,0,3487,3488,1,0,0,0,3488,3490,
  	5,1133,0,0,3489,3483,1,0,0,0,3490,3493,1,0,0,0,3491,3489,1,0,0,0,3491,
  	3492,1,0,0,0,3492,3495,1,0,0,0,3493,3491,1,0,0,0,3494,3476,1,0,0,0,3494,
  	3477,1,0,0,0,3495,205,1,0,0,0,3496,3497,3,550,275,0,3497,3500,5,1123,
  	0,0,3498,3501,3,678,339,0,3499,3501,5,42,0,0,3500,3498,1,0,0,0,3500,3499,
  	1,0,0,0,3501,207,1,0,0,0,3502,3505,3,574,287,0,3503,3505,5,1159,0,0,3504,
  	3502,1,0,0,0,3504,3503,1,0,0,0,3505,209,1,0,0,0,3506,3507,5,65,0,0,3507,
  	3513,5,184,0,0,3508,3509,5,103,0,0,3509,3510,5,80,0,0,3510,3511,5,610,
  	0,0,3511,3513,5,511,0,0,3512,3506,1,0,0,0,3512,3508,1,0,0,0,3513,211,
  	1,0,0,0,3514,3516,5,44,0,0,3515,3517,5,106,0,0,3516,3515,1,0,0,0,3516,
  	3517,1,0,0,0,3517,3519,1,0,0,0,3518,3520,5,568,0,0,3519,3518,1,0,0,0,
  	3519,3520,1,0,0,0,3520,3522,1,0,0,0,3521,3523,5,78,0,0,3522,3521,1,0,
  	0,0,3522,3523,1,0,0,0,3523,3524,1,0,0,0,3524,3525,5,68,0,0,3525,3530,
  	3,546,273,0,3526,3528,5,12,0,0,3527,3526,1,0,0,0,3527,3528,1,0,0,0,3528,
  	3529,1,0,0,0,3529,3531,3,574,287,0,3530,3527,1,0,0,0,3530,3531,1,0,0,
  	0,3531,3537,1,0,0,0,3532,3533,5,129,0,0,3533,3534,5,1132,0,0,3534,3535,
  	3,606,303,0,3535,3536,5,1133,0,0,3536,3538,1,0,0,0,3537,3532,1,0,0,0,
  	3537,3538,1,0,0,0,3538,3541,1,0,0,0,3539,3540,5,190,0,0,3540,3542,3,678,
  	339,0,3541,3539,1,0,0,0,3541,3542,1,0,0,0,3542,3544,1,0,0,0,3543,3545,
  	3,228,114,0,3544,3543,1,0,0,0,3544,3545,1,0,0,0,3545,3548,1,0,0,0,3546,
  	3547,5,99,0,0,3547,3549,3,292,146,0,3548,3546,1,0,0,0,3548,3549,1,0,0,
  	0,3549,213,1,0,0,0,3550,3552,5,44,0,0,3551,3553,5,106,0,0,3552,3551,1,
  	0,0,0,3552,3553,1,0,0,0,3553,3555,1,0,0,0,3554,3556,5,568,0,0,3555,3554,
  	1,0,0,0,3555,3556,1,0,0,0,3556,3558,1,0,0,0,3557,3559,5,78,0,0,3558,3557,
  	1,0,0,0,3558,3559,1,0,0,0,3559,3599,1,0,0,0,3560,3563,3,546,273,0,3561,
  	3562,5,1131,0,0,3562,3564,5,1116,0,0,3563,3561,1,0,0,0,3563,3564,1,0,
  	0,0,3564,3573,1,0,0,0,3565,3566,5,1134,0,0,3566,3569,3,546,273,0,3567,
  	3568,5,1131,0,0,3568,3570,5,1116,0,0,3569,3567,1,0,0,0,3569,3570,1,0,
  	0,0,3570,3572,1,0,0,0,3571,3565,1,0,0,0,3572,3575,1,0,0,0,3573,3571,1,
  	0,0,0,3573,3574,1,0,0,0,3574,3576,1,0,0,0,3575,3573,1,0,0,0,3576,3577,
  	5,68,0,0,3577,3578,3,232,116,0,3578,3600,1,0,0,0,3579,3580,5,68,0,0,3580,
  	3583,3,546,273,0,3581,3582,5,1131,0,0,3582,3584,5,1116,0,0,3583,3581,
  	1,0,0,0,3583,3584,1,0,0,0,3584,3593,1,0,0,0,3585,3586,5,1134,0,0,3586,
  	3589,3,546,273,0,3587,3588,5,1131,0,0,3588,3590,5,1116,0,0,3589,3587,
  	1,0,0,0,3589,3590,1,0,0,0,3590,3592,1,0,0,0,3591,3585,1,0,0,0,3592,3595,
  	1,0,0,0,3593,3591,1,0,0,0,3593,3594,1,0,0,0,3594,3596,1,0,0,0,3595,3593,
  	1,0,0,0,3596,3597,5,187,0,0,3597,3598,3,232,116,0,3598,3600,1,0,0,0,3599,
  	3560,1,0,0,0,3599,3579,1,0,0,0,3600,3603,1,0,0,0,3601,3602,5,190,0,0,
  	3602,3604,3,678,339,0,3603,3601,1,0,0,0,3603,3604,1,0,0,0,3604,215,1,
  	0,0,0,3605,3606,5,442,0,0,3606,3607,3,546,273,0,3607,3612,5,539,0,0,3608,
  	3610,5,12,0,0,3609,3608,1,0,0,0,3609,3610,1,0,0,0,3610,3611,1,0,0,0,3611,
  	3613,3,574,287,0,3612,3609,1,0,0,0,3612,3613,1,0,0,0,3613,217,1,0,0,0,
  	3614,3615,5,442,0,0,3615,3616,3,546,273,0,3616,3617,5,134,0,0,3617,3624,
  	3,574,287,0,3618,3619,3,686,343,0,3619,3620,5,1132,0,0,3620,3621,3,618,
  	309,0,3621,3622,5,1133,0,0,3622,3625,1,0,0,0,3623,3625,7,46,0,0,3624,
  	3618,1,0,0,0,3624,3623,1,0,0,0,3625,3628,1,0,0,0,3626,3627,5,190,0,0,
  	3627,3629,3,678,339,0,3628,3626,1,0,0,0,3628,3629,1,0,0,0,3629,3632,1,
  	0,0,0,3630,3631,5,99,0,0,3631,3633,3,292,146,0,3632,3630,1,0,0,0,3632,
  	3633,1,0,0,0,3633,219,1,0,0,0,3634,3635,5,442,0,0,3635,3636,3,546,273,
  	0,3636,3637,5,134,0,0,3637,3640,7,47,0,0,3638,3639,5,190,0,0,3639,3641,
  	3,678,339,0,3640,3638,1,0,0,0,3640,3641,1,0,0,0,3641,3644,1,0,0,0,3642,
  	3643,5,99,0,0,3643,3645,3,292,146,0,3644,3642,1,0,0,0,3644,3645,1,0,0,
  	0,3645,221,1,0,0,0,3646,3647,5,442,0,0,3647,3648,3,546,273,0,3648,3649,
  	5,361,0,0,3649,223,1,0,0,0,3650,3652,5,184,0,0,3651,3653,5,106,0,0,3652,
  	3651,1,0,0,0,3652,3653,1,0,0,0,3653,3655,1,0,0,0,3654,3656,5,78,0,0,3655,
  	3654,1,0,0,0,3655,3656,1,0,0,0,3656,3657,1,0,0,0,3657,3662,3,546,273,
  	0,3658,3660,5,12,0,0,3659,3658,1,0,0,0,3659,3660,1,0,0,0,3660,3661,1,
  	0,0,0,3661,3663,3,574,287,0,3662,3659,1,0,0,0,3662,3663,1,0,0,0,3663,
  	3664,1,0,0,0,3664,3665,5,153,0,0,3665,3670,3,206,103,0,3666,3667,5,1134,
  	0,0,3667,3669,3,206,103,0,3668,3666,1,0,0,0,3669,3672,1,0,0,0,3670,3668,
  	1,0,0,0,3670,3671,1,0,0,0,3671,3675,1,0,0,0,3672,3670,1,0,0,0,3673,3674,
  	5,190,0,0,3674,3676,3,678,339,0,3675,3673,1,0,0,0,3675,3676,1,0,0,0,3676,
  	3678,1,0,0,0,3677,3679,3,228,114,0,3678,3677,1,0,0,0,3678,3679,1,0,0,
  	0,3679,3681,1,0,0,0,3680,3682,3,290,145,0,3681,3680,1,0,0,0,3681,3682,
  	1,0,0,0,3682,225,1,0,0,0,3683,3685,5,184,0,0,3684,3686,5,106,0,0,3685,
  	3684,1,0,0,0,3685,3686,1,0,0,0,3686,3688,1,0,0,0,3687,3689,5,78,0,0,3688,
  	3687,1,0,0,0,3688,3689,1,0,0,0,3689,3690,1,0,0,0,3690,3691,3,232,116,
  	0,3691,3692,5,153,0,0,3692,3697,3,206,103,0,3693,3694,5,1134,0,0,3694,
  	3696,3,206,103,0,3695,3693,1,0,0,0,3696,3699,1,0,0,0,3697,3695,1,0,0,
  	0,3697,3698,1,0,0,0,3698,3702,1,0,0,0,3699,3697,1,0,0,0,3700,3701,5,190,
  	0,0,3701,3703,3,678,339,0,3702,3700,1,0,0,0,3702,3703,1,0,0,0,3703,227,
  	1,0,0,0,3704,3705,5,124,0,0,3705,3706,5,19,0,0,3706,3711,3,230,115,0,
  	3707,3708,5,1134,0,0,3708,3710,3,230,115,0,3709,3707,1,0,0,0,3710,3713,
  	1,0,0,0,3711,3709,1,0,0,0,3711,3712,1,0,0,0,3712,229,1,0,0,0,3713,3711,
  	1,0,0,0,3714,3716,3,678,339,0,3715,3717,7,48,0,0,3716,3715,1,0,0,0,3716,
  	3717,1,0,0,0,3717,231,1,0,0,0,3718,3723,3,234,117,0,3719,3720,5,1134,
  	0,0,3720,3722,3,234,117,0,3721,3719,1,0,0,0,3722,3725,1,0,0,0,3723,3721,
  	1,0,0,0,3723,3724,1,0,0,0,3724,233,1,0,0,0,3725,3723,1,0,0,0,3726,3730,
  	3,236,118,0,3727,3729,3,242,121,0,3728,3727,1,0,0,0,3729,3732,1,0,0,0,
  	3730,3728,1,0,0,0,3730,3731,1,0,0,0,3731,3745,1,0,0,0,3732,3730,1,0,0,
  	0,3733,3734,5,1132,0,0,3734,3738,3,236,118,0,3735,3737,3,242,121,0,3736,
  	3735,1,0,0,0,3737,3740,1,0,0,0,3738,3736,1,0,0,0,3738,3739,1,0,0,0,3739,
  	3741,1,0,0,0,3740,3738,1,0,0,0,3741,3742,5,1133,0,0,3742,3745,1,0,0,0,
  	3743,3745,3,258,129,0,3744,3726,1,0,0,0,3744,3733,1,0,0,0,3744,3743,1,
  	0,0,0,3745,235,1,0,0,0,3746,3752,3,546,273,0,3747,3748,5,129,0,0,3748,
  	3749,5,1132,0,0,3749,3750,3,606,303,0,3750,3751,5,1133,0,0,3751,3753,
  	1,0,0,0,3752,3747,1,0,0,0,3752,3753,1,0,0,0,3753,3758,1,0,0,0,3754,3756,
  	5,12,0,0,3755,3754,1,0,0,0,3755,3756,1,0,0,0,3756,3757,1,0,0,0,3757,3759,
  	3,574,287,0,3758,3755,1,0,0,0,3758,3759,1,0,0,0,3759,3768,1,0,0,0,3760,
  	3765,3,238,119,0,3761,3762,5,1134,0,0,3762,3764,3,238,119,0,3763,3761,
  	1,0,0,0,3764,3767,1,0,0,0,3765,3763,1,0,0,0,3765,3766,1,0,0,0,3766,3769,
  	1,0,0,0,3767,3765,1,0,0,0,3768,3760,1,0,0,0,3768,3769,1,0,0,0,3769,3787,
  	1,0,0,0,3770,3776,3,198,99,0,3771,3772,5,1132,0,0,3772,3773,3,198,99,
  	0,3773,3774,5,1133,0,0,3774,3776,1,0,0,0,3775,3770,1,0,0,0,3775,3771,
  	1,0,0,0,3776,3778,1,0,0,0,3777,3779,5,12,0,0,3778,3777,1,0,0,0,3778,3779,
  	1,0,0,0,3779,3780,1,0,0,0,3780,3781,3,574,287,0,3781,3787,1,0,0,0,3782,
  	3783,5,1132,0,0,3783,3784,3,232,116,0,3784,3785,5,1133,0,0,3785,3787,
  	1,0,0,0,3786,3746,1,0,0,0,3786,3775,1,0,0,0,3786,3782,1,0,0,0,3787,237,
  	1,0,0,0,3788,3789,7,49,0,0,3789,3792,7,20,0,0,3790,3791,5,65,0,0,3791,
  	3793,3,240,120,0,3792,3790,1,0,0,0,3792,3793,1,0,0,0,3793,3794,1,0,0,
  	0,3794,3795,5,1132,0,0,3795,3796,3,606,303,0,3796,3797,5,1133,0,0,3797,
  	239,1,0,0,0,3798,3804,5,90,0,0,3799,3800,5,124,0,0,3800,3804,5,19,0,0,
  	3801,3802,5,73,0,0,3802,3804,5,19,0,0,3803,3798,1,0,0,0,3803,3799,1,0,
  	0,0,3803,3801,1,0,0,0,3804,241,1,0,0,0,3805,3807,7,50,0,0,3806,3805,1,
  	0,0,0,3806,3807,1,0,0,0,3807,3808,1,0,0,0,3808,3810,5,90,0,0,3809,3811,
  	5,94,0,0,3810,3809,1,0,0,0,3810,3811,1,0,0,0,3811,3812,1,0,0,0,3812,3820,
  	3,236,118,0,3813,3814,5,118,0,0,3814,3821,3,678,339,0,3815,3816,5,187,
  	0,0,3816,3817,5,1132,0,0,3817,3818,3,606,303,0,3818,3819,5,1133,0,0,3819,
  	3821,1,0,0,0,3820,3813,1,0,0,0,3820,3815,1,0,0,0,3820,3821,1,0,0,0,3821,
  	3856,1,0,0,0,3822,3823,5,171,0,0,3823,3826,3,236,118,0,3824,3825,5,118,
  	0,0,3825,3827,3,678,339,0,3826,3824,1,0,0,0,3826,3827,1,0,0,0,3827,3856,
  	1,0,0,0,3828,3830,7,51,0,0,3829,3831,5,126,0,0,3830,3829,1,0,0,0,3830,
  	3831,1,0,0,0,3831,3832,1,0,0,0,3832,3834,5,90,0,0,3833,3835,5,94,0,0,
  	3834,3833,1,0,0,0,3834,3835,1,0,0,0,3835,3836,1,0,0,0,3836,3844,3,236,
  	118,0,3837,3838,5,118,0,0,3838,3845,3,678,339,0,3839,3840,5,187,0,0,3840,
  	3841,5,1132,0,0,3841,3842,3,606,303,0,3842,3843,5,1133,0,0,3843,3845,
  	1,0,0,0,3844,3837,1,0,0,0,3844,3839,1,0,0,0,3845,3856,1,0,0,0,3846,3851,
  	5,113,0,0,3847,3849,7,51,0,0,3848,3850,5,126,0,0,3849,3848,1,0,0,0,3849,
  	3850,1,0,0,0,3850,3852,1,0,0,0,3851,3847,1,0,0,0,3851,3852,1,0,0,0,3852,
  	3853,1,0,0,0,3853,3854,5,90,0,0,3854,3856,3,236,118,0,3855,3806,1,0,0,
  	0,3855,3822,1,0,0,0,3855,3828,1,0,0,0,3855,3846,1,0,0,0,3856,243,1,0,
  	0,0,3857,3858,5,1132,0,0,3858,3859,3,248,124,0,3859,3860,5,1133,0,0,3860,
  	3866,1,0,0,0,3861,3862,5,1132,0,0,3862,3863,3,244,122,0,3863,3864,5,1133,
  	0,0,3864,3866,1,0,0,0,3865,3857,1,0,0,0,3865,3861,1,0,0,0,3866,245,1,
  	0,0,0,3867,3868,5,1132,0,0,3868,3869,3,250,125,0,3869,3870,5,1133,0,0,
  	3870,3876,1,0,0,0,3871,3872,5,1132,0,0,3872,3873,3,246,123,0,3873,3874,
  	5,1133,0,0,3874,3876,1,0,0,0,3875,3867,1,0,0,0,3875,3871,1,0,0,0,3876,
  	247,1,0,0,0,3877,3881,5,152,0,0,3878,3880,3,268,134,0,3879,3878,1,0,0,
  	0,3880,3883,1,0,0,0,3881,3879,1,0,0,0,3881,3882,1,0,0,0,3882,3884,1,0,
  	0,0,3883,3881,1,0,0,0,3884,3886,3,270,135,0,3885,3887,3,274,137,0,3886,
  	3885,1,0,0,0,3886,3887,1,0,0,0,3887,3888,1,0,0,0,3888,3890,3,280,140,
  	0,3889,3891,3,282,141,0,3890,3889,1,0,0,0,3890,3891,1,0,0,0,3891,3893,
  	1,0,0,0,3892,3894,3,284,142,0,3893,3892,1,0,0,0,3893,3894,1,0,0,0,3894,
  	3896,1,0,0,0,3895,3897,3,286,143,0,3896,3895,1,0,0,0,3896,3897,1,0,0,
  	0,3897,3899,1,0,0,0,3898,3900,3,228,114,0,3899,3898,1,0,0,0,3899,3900,
  	1,0,0,0,3900,3902,1,0,0,0,3901,3903,3,290,145,0,3902,3901,1,0,0,0,3902,
  	3903,1,0,0,0,3903,3932,1,0,0,0,3904,3908,5,152,0,0,3905,3907,3,268,134,
  	0,3906,3905,1,0,0,0,3907,3910,1,0,0,0,3908,3906,1,0,0,0,3908,3909,1,0,
  	0,0,3909,3911,1,0,0,0,3910,3908,1,0,0,0,3911,3912,3,270,135,0,3912,3914,
  	3,280,140,0,3913,3915,3,282,141,0,3914,3913,1,0,0,0,3914,3915,1,0,0,0,
  	3915,3917,1,0,0,0,3916,3918,3,284,142,0,3917,3916,1,0,0,0,3917,3918,1,
  	0,0,0,3918,3920,1,0,0,0,3919,3921,3,286,143,0,3920,3919,1,0,0,0,3920,
  	3921,1,0,0,0,3921,3923,1,0,0,0,3922,3924,3,228,114,0,3923,3922,1,0,0,
  	0,3923,3924,1,0,0,0,3924,3926,1,0,0,0,3925,3927,3,290,145,0,3926,3925,
  	1,0,0,0,3926,3927,1,0,0,0,3927,3929,1,0,0,0,3928,3930,3,274,137,0,3929,
  	3928,1,0,0,0,3929,3930,1,0,0,0,3930,3932,1,0,0,0,3931,3877,1,0,0,0,3931,
  	3904,1,0,0,0,3932,249,1,0,0,0,3933,3937,5,152,0,0,3934,3936,3,268,134,
  	0,3935,3934,1,0,0,0,3936,3939,1,0,0,0,3937,3935,1,0,0,0,3937,3938,1,0,
  	0,0,3938,3940,1,0,0,0,3939,3937,1,0,0,0,3940,3941,3,270,135,0,3941,3943,
  	3,280,140,0,3942,3944,3,282,141,0,3943,3942,1,0,0,0,3943,3944,1,0,0,0,
  	3944,3946,1,0,0,0,3945,3947,3,284,142,0,3946,3945,1,0,0,0,3946,3947,1,
  	0,0,0,3947,3949,1,0,0,0,3948,3950,3,286,143,0,3949,3948,1,0,0,0,3949,
  	3950,1,0,0,0,3950,3952,1,0,0,0,3951,3953,3,228,114,0,3952,3951,1,0,0,
  	0,3952,3953,1,0,0,0,3953,3955,1,0,0,0,3954,3956,3,290,145,0,3955,3954,
  	1,0,0,0,3955,3956,1,0,0,0,3956,251,1,0,0,0,3957,3959,5,180,0,0,3958,3960,
  	7,44,0,0,3959,3958,1,0,0,0,3959,3960,1,0,0,0,3960,3961,1,0,0,0,3961,3962,
  	3,246,123,0,3962,253,1,0,0,0,3963,3965,5,180,0,0,3964,3966,7,44,0,0,3965,
  	3964,1,0,0,0,3965,3966,1,0,0,0,3966,3969,1,0,0,0,3967,3970,3,250,125,
  	0,3968,3970,3,246,123,0,3969,3967,1,0,0,0,3969,3968,1,0,0,0,3970,255,
  	1,0,0,0,3971,3986,5,94,0,0,3972,3987,3,250,125,0,3973,3987,3,246,123,
  	0,3974,3977,5,1132,0,0,3975,3978,3,250,125,0,3976,3978,3,246,123,0,3977,
  	3975,1,0,0,0,3977,3976,1,0,0,0,3978,3979,1,0,0,0,3979,3984,5,1133,0,0,
  	3980,3982,5,12,0,0,3981,3980,1,0,0,0,3981,3982,1,0,0,0,3982,3983,1,0,
  	0,0,3983,3985,3,574,287,0,3984,3981,1,0,0,0,3984,3985,1,0,0,0,3985,3987,
  	1,0,0,0,3986,3972,1,0,0,0,3986,3973,1,0,0,0,3986,3974,1,0,0,0,3987,257,
  	1,0,0,0,3988,3989,5,278,0,0,3989,3990,5,1132,0,0,3990,3991,5,1147,0,0,
  	3991,3992,5,1134,0,0,3992,3993,5,1147,0,0,3993,3994,5,365,0,0,3994,3995,
  	5,1132,0,0,3995,3996,3,260,130,0,3996,3997,5,1133,0,0,3997,4002,5,1133,
  	0,0,3998,4000,5,12,0,0,3999,3998,1,0,0,0,3999,4000,1,0,0,0,4000,4001,
  	1,0,0,0,4001,4003,3,574,287,0,4002,3999,1,0,0,0,4002,4003,1,0,0,0,4003,
  	259,1,0,0,0,4004,4009,3,262,131,0,4005,4006,5,1134,0,0,4006,4008,3,262,
  	131,0,4007,4005,1,0,0,0,4008,4011,1,0,0,0,4009,4007,1,0,0,0,4009,4010,
  	1,0,0,0,4010,261,1,0,0,0,4011,4009,1,0,0,0,4012,4029,3,550,275,0,4013,
  	4014,5,65,0,0,4014,4030,5,284,0,0,4015,4027,3,594,297,0,4016,4017,5,285,
  	0,0,4017,4019,5,1147,0,0,4018,4020,3,264,132,0,4019,4018,1,0,0,0,4019,
  	4020,1,0,0,0,4020,4022,1,0,0,0,4021,4023,3,266,133,0,4022,4021,1,0,0,
  	0,4022,4023,1,0,0,0,4023,4028,1,0,0,0,4024,4025,5,60,0,0,4025,4026,5,
  	285,0,0,4026,4028,5,1147,0,0,4027,4016,1,0,0,0,4027,4024,1,0,0,0,4028,
  	4030,1,0,0,0,4029,4013,1,0,0,0,4029,4015,1,0,0,0,4030,4042,1,0,0,0,4031,
  	4033,5,283,0,0,4032,4034,5,285,0,0,4033,4032,1,0,0,0,4033,4034,1,0,0,
  	0,4034,4035,1,0,0,0,4035,4036,5,1147,0,0,4036,4037,5,365,0,0,4037,4038,
  	5,1132,0,0,4038,4039,3,260,130,0,4039,4040,5,1133,0,0,4040,4042,1,0,0,
  	0,4041,4012,1,0,0,0,4041,4031,1,0,0,0,4042,263,1,0,0,0,4043,4048,5,116,
  	0,0,4044,4048,5,411,0,0,4045,4046,5,42,0,0,4046,4048,3,624,312,0,4047,
  	4043,1,0,0,0,4047,4044,1,0,0,0,4047,4045,1,0,0,0,4048,4049,1,0,0,0,4049,
  	4050,5,118,0,0,4050,4051,5,55,0,0,4051,265,1,0,0,0,4052,4057,5,116,0,
  	0,4053,4057,5,411,0,0,4054,4055,5,42,0,0,4055,4057,3,624,312,0,4056,4052,
  	1,0,0,0,4056,4053,1,0,0,0,4056,4054,1,0,0,0,4057,4058,1,0,0,0,4058,4059,
  	5,118,0,0,4059,4060,5,411,0,0,4060,267,1,0,0,0,4061,4070,7,52,0,0,4062,
  	4070,5,75,0,0,4063,4070,5,171,0,0,4064,4070,5,166,0,0,4065,4070,5,164,
  	0,0,4066,4070,5,625,0,0,4067,4070,7,53,0,0,4068,4070,5,165,0,0,4069,4061,
  	1,0,0,0,4069,4062,1,0,0,0,4069,4063,1,0,0,0,4069,4064,1,0,0,0,4069,4065,
  	1,0,0,0,4069,4066,1,0,0,0,4069,4067,1,0,0,0,4069,4068,1,0,0,0,4070,269,
  	1,0,0,0,4071,4074,5,1116,0,0,4072,4074,3,272,136,0,4073,4071,1,0,0,0,
  	4073,4072,1,0,0,0,4074,4079,1,0,0,0,4075,4076,5,1134,0,0,4076,4078,3,
  	272,136,0,4077,4075,1,0,0,0,4078,4081,1,0,0,0,4079,4077,1,0,0,0,4079,
  	4080,1,0,0,0,4080,271,1,0,0,0,4081,4079,1,0,0,0,4082,4083,3,544,272,0,
  	4083,4084,5,1131,0,0,4084,4085,5,1116,0,0,4085,4112,1,0,0,0,4086,4091,
  	3,550,275,0,4087,4089,5,12,0,0,4088,4087,1,0,0,0,4088,4089,1,0,0,0,4089,
  	4090,1,0,0,0,4090,4092,3,574,287,0,4091,4088,1,0,0,0,4091,4092,1,0,0,
  	0,4092,4112,1,0,0,0,4093,4098,3,638,319,0,4094,4096,5,12,0,0,4095,4094,
  	1,0,0,0,4095,4096,1,0,0,0,4096,4097,1,0,0,0,4097,4099,3,574,287,0,4098,
  	4095,1,0,0,0,4098,4099,1,0,0,0,4099,4112,1,0,0,0,4100,4101,5,1159,0,0,
  	4101,4103,5,1107,0,0,4102,4100,1,0,0,0,4102,4103,1,0,0,0,4103,4104,1,
  	0,0,0,4104,4109,3,678,339,0,4105,4107,5,12,0,0,4106,4105,1,0,0,0,4106,
  	4107,1,0,0,0,4107,4108,1,0,0,0,4108,4110,3,574,287,0,4109,4106,1,0,0,
  	0,4109,4110,1,0,0,0,4110,4112,1,0,0,0,4111,4082,1,0,0,0,4111,4086,1,0,
  	0,0,4111,4093,1,0,0,0,4111,4102,1,0,0,0,4112,273,1,0,0,0,4113,4114,5,
  	87,0,0,4114,4119,3,208,104,0,4115,4116,5,1134,0,0,4116,4118,3,208,104,
  	0,4117,4115,1,0,0,0,4118,4121,1,0,0,0,4119,4117,1,0,0,0,4119,4120,1,0,
  	0,0,4120,4150,1,0,0,0,4121,4119,1,0,0,0,4122,4123,5,87,0,0,4123,4124,
  	5,400,0,0,4124,4150,5,1147,0,0,4125,4126,5,87,0,0,4126,4127,5,127,0,0,
  	4127,4131,5,1147,0,0,4128,4129,5,25,0,0,4129,4130,5,153,0,0,4130,4132,
  	3,558,279,0,4131,4128,1,0,0,0,4131,4132,1,0,0,0,4132,4139,1,0,0,0,4133,
  	4135,7,41,0,0,4134,4136,3,276,138,0,4135,4134,1,0,0,0,4136,4137,1,0,0,
  	0,4137,4135,1,0,0,0,4137,4138,1,0,0,0,4138,4140,1,0,0,0,4139,4133,1,0,
  	0,0,4139,4140,1,0,0,0,4140,4147,1,0,0,0,4141,4143,5,101,0,0,4142,4144,
  	3,278,139,0,4143,4142,1,0,0,0,4144,4145,1,0,0,0,4145,4143,1,0,0,0,4145,
  	4146,1,0,0,0,4146,4148,1,0,0,0,4147,4141,1,0,0,0,4147,4148,1,0,0,0,4148,
  	4150,1,0,0,0,4149,4113,1,0,0,0,4149,4122,1,0,0,0,4149,4125,1,0,0,0,4150,
  	275,1,0,0,0,4151,4152,5,173,0,0,4152,4153,5,19,0,0,4153,4164,5,1147,0,
  	0,4154,4156,5,122,0,0,4155,4154,1,0,0,0,4155,4156,1,0,0,0,4156,4157,1,
  	0,0,0,4157,4158,5,56,0,0,4158,4159,5,19,0,0,4159,4164,5,1147,0,0,4160,
  	4161,5,58,0,0,4161,4162,5,19,0,0,4162,4164,5,1147,0,0,4163,4151,1,0,0,
  	0,4163,4155,1,0,0,0,4163,4160,1,0,0,0,4164,277,1,0,0,0,4165,4166,5,169,
  	0,0,4166,4167,5,19,0,0,4167,4172,5,1147,0,0,4168,4169,5,173,0,0,4169,
  	4170,5,19,0,0,4170,4172,5,1147,0,0,4171,4165,1,0,0,0,4171,4168,1,0,0,
  	0,4172,279,1,0,0,0,4173,4174,5,68,0,0,4174,4176,3,232,116,0,4175,4173,
  	1,0,0,0,4175,4176,1,0,0,0,4176,4179,1,0,0,0,4177,4178,5,190,0,0,4178,
  	4180,3,678,339,0,4179,4177,1,0,0,0,4179,4180,1,0,0,0,4180,281,1,0,0,0,
  	4181,4182,5,73,0,0,4182,4183,5,19,0,0,4183,4188,3,288,144,0,4184,4185,
  	5,1134,0,0,4185,4187,3,288,144,0,4186,4184,1,0,0,0,4187,4190,1,0,0,0,
  	4188,4186,1,0,0,0,4188,4189,1,0,0,0,4189,4193,1,0,0,0,4190,4188,1,0,0,
  	0,4191,4192,5,192,0,0,4192,4194,5,598,0,0,4193,4191,1,0,0,0,4193,4194,
  	1,0,0,0,4194,283,1,0,0,0,4195,4196,5,74,0,0,4196,4197,3,678,339,0,4197,
  	285,1,0,0,0,4198,4199,5,676,0,0,4199,4200,3,656,328,0,4200,4201,5,12,
  	0,0,4201,4202,5,1132,0,0,4202,4203,3,654,327,0,4203,4213,5,1133,0,0,4204,
  	4205,5,1134,0,0,4205,4206,3,656,328,0,4206,4207,5,12,0,0,4207,4208,5,
  	1132,0,0,4208,4209,3,654,327,0,4209,4210,5,1133,0,0,4210,4212,1,0,0,0,
  	4211,4204,1,0,0,0,4212,4215,1,0,0,0,4213,4211,1,0,0,0,4213,4214,1,0,0,
  	0,4214,287,1,0,0,0,4215,4213,1,0,0,0,4216,4218,3,678,339,0,4217,4219,
  	7,48,0,0,4218,4217,1,0,0,0,4218,4219,1,0,0,0,4219,289,1,0,0,0,4220,4231,
  	5,99,0,0,4221,4222,3,292,146,0,4222,4223,5,1134,0,0,4223,4225,1,0,0,0,
  	4224,4221,1,0,0,0,4224,4225,1,0,0,0,4225,4226,1,0,0,0,4226,4232,3,292,
  	146,0,4227,4228,3,292,146,0,4228,4229,5,532,0,0,4229,4230,3,292,146,0,
  	4230,4232,1,0,0,0,4231,4224,1,0,0,0,4231,4227,1,0,0,0,4232,291,1,0,0,
  	0,4233,4237,3,580,290,0,4234,4237,3,556,278,0,4235,4237,3,576,288,0,4236,
  	4233,1,0,0,0,4236,4234,1,0,0,0,4236,4235,1,0,0,0,4237,293,1,0,0,0,4238,
  	4239,5,629,0,0,4239,4248,5,653,0,0,4240,4245,3,316,158,0,4241,4242,5,
  	1134,0,0,4242,4244,3,316,158,0,4243,4241,1,0,0,0,4244,4247,1,0,0,0,4245,
  	4243,1,0,0,0,4245,4246,1,0,0,0,4246,4249,1,0,0,0,4247,4245,1,0,0,0,4248,
  	4240,1,0,0,0,4248,4249,1,0,0,0,4249,295,1,0,0,0,4250,4252,5,344,0,0,4251,
  	4253,5,678,0,0,4252,4251,1,0,0,0,4252,4253,1,0,0,0,4253,297,1,0,0,0,4254,
  	4256,5,369,0,0,4255,4257,5,678,0,0,4256,4255,1,0,0,0,4256,4257,1,0,0,
  	0,4257,4263,1,0,0,0,4258,4260,5,10,0,0,4259,4261,5,521,0,0,4260,4259,
  	1,0,0,0,4260,4261,1,0,0,0,4261,4262,1,0,0,0,4262,4264,5,353,0,0,4263,
  	4258,1,0,0,0,4263,4264,1,0,0,0,4264,4269,1,0,0,0,4265,4267,5,521,0,0,
  	4266,4265,1,0,0,0,4266,4267,1,0,0,0,4267,4268,1,0,0,0,4268,4270,5,138,
  	0,0,4269,4266,1,0,0,0,4269,4270,1,0,0,0,4270,299,1,0,0,0,4271,4273,5,
  	597,0,0,4272,4274,5,678,0,0,4273,4272,1,0,0,0,4273,4274,1,0,0,0,4274,
  	4280,1,0,0,0,4275,4277,5,10,0,0,4276,4278,5,521,0,0,4277,4276,1,0,0,0,
  	4277,4278,1,0,0,0,4278,4279,1,0,0,0,4279,4281,5,353,0,0,4280,4275,1,0,
  	0,0,4280,4281,1,0,0,0,4281,4286,1,0,0,0,4282,4284,5,521,0,0,4283,4282,
  	1,0,0,0,4283,4284,1,0,0,0,4284,4285,1,0,0,0,4285,4287,5,138,0,0,4286,
  	4283,1,0,0,0,4286,4287,1,0,0,0,4287,301,1,0,0,0,4288,4289,5,604,0,0,4289,
  	4290,3,574,287,0,4290,303,1,0,0,0,4291,4293,5,597,0,0,4292,4294,5,678,
  	0,0,4293,4292,1,0,0,0,4293,4294,1,0,0,0,4294,4295,1,0,0,0,4295,4297,5,
  	175,0,0,4296,4298,5,604,0,0,4297,4296,1,0,0,0,4297,4298,1,0,0,0,4298,
  	4299,1,0,0,0,4299,4300,3,574,287,0,4300,305,1,0,0,0,4301,4302,5,138,0,
  	0,4302,4303,5,604,0,0,4303,4304,3,574,287,0,4304,307,1,0,0,0,4305,4306,
  	5,103,0,0,4306,4307,7,54,0,0,4307,4312,3,318,159,0,4308,4309,5,1134,0,
  	0,4309,4311,3,318,159,0,4310,4308,1,0,0,0,4311,4314,1,0,0,0,4312,4310,
  	1,0,0,0,4312,4313,1,0,0,0,4313,4316,1,0,0,0,4314,4312,1,0,0,0,4315,4317,
  	3,636,318,0,4316,4315,1,0,0,0,4316,4317,1,0,0,0,4317,309,1,0,0,0,4318,
  	4319,5,182,0,0,4319,4320,5,742,0,0,4320,311,1,0,0,0,4321,4322,5,153,0,
  	0,4322,4323,5,340,0,0,4323,4324,5,1123,0,0,4324,4325,7,24,0,0,4325,313,
  	1,0,0,0,4326,4328,5,153,0,0,4327,4329,7,55,0,0,4328,4327,1,0,0,0,4328,
  	4329,1,0,0,0,4329,4330,1,0,0,0,4330,4331,5,653,0,0,4331,4336,3,322,161,
  	0,4332,4333,5,1134,0,0,4333,4335,3,322,161,0,4334,4332,1,0,0,0,4335,4338,
  	1,0,0,0,4336,4334,1,0,0,0,4336,4337,1,0,0,0,4337,315,1,0,0,0,4338,4336,
  	1,0,0,0,4339,4340,5,192,0,0,4340,4341,5,377,0,0,4341,4347,5,616,0,0,4342,
  	4343,5,134,0,0,4343,4347,5,193,0,0,4344,4345,5,134,0,0,4345,4347,5,538,
  	0,0,4346,4339,1,0,0,0,4346,4342,1,0,0,0,4346,4344,1,0,0,0,4347,317,1,
  	0,0,0,4348,4353,3,546,273,0,4349,4351,5,12,0,0,4350,4349,1,0,0,0,4350,
  	4351,1,0,0,0,4351,4352,1,0,0,0,4352,4354,3,574,287,0,4353,4350,1,0,0,
  	0,4353,4354,1,0,0,0,4354,4355,1,0,0,0,4355,4356,3,320,160,0,4356,319,
  	1,0,0,0,4357,4359,5,134,0,0,4358,4360,5,474,0,0,4359,4358,1,0,0,0,4359,
  	4360,1,0,0,0,4360,4366,1,0,0,0,4361,4363,5,106,0,0,4362,4361,1,0,0,0,
  	4362,4363,1,0,0,0,4363,4364,1,0,0,0,4364,4366,5,193,0,0,4365,4357,1,0,
  	0,0,4365,4362,1,0,0,0,4366,321,1,0,0,0,4367,4368,5,464,0,0,4368,4369,
  	5,472,0,0,4369,4375,3,324,162,0,4370,4371,5,134,0,0,4371,4375,5,193,0,
  	0,4372,4373,5,134,0,0,4373,4375,5,538,0,0,4374,4367,1,0,0,0,4374,4370,
  	1,0,0,0,4374,4372,1,0,0,0,4375,323,1,0,0,0,4376,4377,5,799,0,0,4377,4384,
  	5,134,0,0,4378,4379,5,134,0,0,4379,4384,5,800,0,0,4380,4381,5,134,0,0,
  	4381,4384,5,801,0,0,4382,4384,5,802,0,0,4383,4376,1,0,0,0,4383,4378,1,
  	0,0,0,4383,4380,1,0,0,0,4383,4382,1,0,0,0,4384,325,1,0,0,0,4385,4386,
  	5,24,0,0,4386,4387,5,477,0,0,4387,4388,5,175,0,0,4388,4393,3,344,172,
  	0,4389,4390,5,1134,0,0,4390,4392,3,344,172,0,4391,4389,1,0,0,0,4392,4395,
  	1,0,0,0,4393,4391,1,0,0,0,4393,4394,1,0,0,0,4394,4397,1,0,0,0,4395,4393,
  	1,0,0,0,4396,4398,3,352,176,0,4397,4396,1,0,0,0,4397,4398,1,0,0,0,4398,
  	327,1,0,0,0,4399,4400,5,24,0,0,4400,4401,5,588,0,0,4401,4402,5,429,0,
  	0,4402,4407,3,354,177,0,4403,4404,5,1134,0,0,4404,4406,3,354,177,0,4405,
  	4403,1,0,0,0,4406,4409,1,0,0,0,4407,4405,1,0,0,0,4407,4408,1,0,0,0,4408,
  	329,1,0,0,0,4409,4407,1,0,0,0,4410,4411,5,132,0,0,4411,4412,7,56,0,0,
  	4412,4417,5,476,0,0,4413,4414,5,175,0,0,4414,4418,5,1147,0,0,4415,4416,
  	5,15,0,0,4416,4418,5,1147,0,0,4417,4413,1,0,0,0,4417,4415,1,0,0,0,4418,
  	331,1,0,0,0,4419,4420,5,589,0,0,4420,4421,5,477,0,0,4421,333,1,0,0,0,
  	4422,4423,5,589,0,0,4423,4425,5,614,0,0,4424,4426,5,6,0,0,4425,4424,1,
  	0,0,0,4425,4426,1,0,0,0,4426,4428,1,0,0,0,4427,4429,3,352,176,0,4428,
  	4427,1,0,0,0,4428,4429,1,0,0,0,4429,335,1,0,0,0,4430,4431,5,629,0,0,4431,
  	4440,5,614,0,0,4432,4437,3,358,179,0,4433,4434,5,1134,0,0,4434,4436,3,
  	358,179,0,4435,4433,1,0,0,0,4436,4439,1,0,0,0,4437,4435,1,0,0,0,4437,
  	4438,1,0,0,0,4438,4441,1,0,0,0,4439,4437,1,0,0,0,4440,4432,1,0,0,0,4440,
  	4441,1,0,0,0,4441,4444,1,0,0,0,4442,4443,5,663,0,0,4443,4445,3,360,180,
  	0,4444,4442,1,0,0,0,4444,4445,1,0,0,0,4445,4449,1,0,0,0,4446,4448,3,362,
  	181,0,4447,4446,1,0,0,0,4448,4451,1,0,0,0,4449,4447,1,0,0,0,4449,4450,
  	1,0,0,0,4450,4453,1,0,0,0,4451,4449,1,0,0,0,4452,4454,3,352,176,0,4453,
  	4452,1,0,0,0,4453,4454,1,0,0,0,4454,337,1,0,0,0,4455,4456,5,635,0,0,4456,
  	4465,5,614,0,0,4457,4462,3,358,179,0,4458,4459,5,1134,0,0,4459,4461,3,
  	358,179,0,4460,4458,1,0,0,0,4461,4464,1,0,0,0,4462,4460,1,0,0,0,4462,
  	4463,1,0,0,0,4463,4466,1,0,0,0,4464,4462,1,0,0,0,4465,4457,1,0,0,0,4465,
  	4466,1,0,0,0,4466,339,1,0,0,0,4467,4468,5,629,0,0,4468,4469,5,441,0,0,
  	4469,341,1,0,0,0,4470,4471,5,635,0,0,4471,4472,5,441,0,0,4472,343,1,0,
  	0,0,4473,4474,3,346,173,0,4474,4475,5,1123,0,0,4475,4476,5,1147,0,0,4476,
  	4503,1,0,0,0,4477,4478,3,348,174,0,4478,4479,5,1123,0,0,4479,4480,3,580,
  	290,0,4480,4503,1,0,0,0,4481,4482,3,350,175,0,4482,4483,5,1123,0,0,4483,
  	4484,7,24,0,0,4484,4503,1,0,0,0,4485,4486,5,481,0,0,4486,4487,5,1123,
  	0,0,4487,4503,5,1150,0,0,4488,4489,5,449,0,0,4489,4490,5,1123,0,0,4490,
  	4499,5,1132,0,0,4491,4496,3,574,287,0,4492,4493,5,1134,0,0,4493,4495,
  	3,574,287,0,4494,4492,1,0,0,0,4495,4498,1,0,0,0,4496,4494,1,0,0,0,4496,
  	4497,1,0,0,0,4497,4500,1,0,0,0,4498,4496,1,0,0,0,4499,4491,1,0,0,0,4499,
  	4500,1,0,0,0,4500,4501,1,0,0,0,4501,4503,5,1133,0,0,4502,4473,1,0,0,0,
  	4502,4477,1,0,0,0,4502,4481,1,0,0,0,4502,4485,1,0,0,0,4502,4488,1,0,0,
  	0,4503,345,1,0,0,0,4504,4505,7,57,0,0,4505,347,1,0,0,0,4506,4507,7,58,
  	0,0,4507,349,1,0,0,0,4508,4509,7,59,0,0,4509,351,1,0,0,0,4510,4511,5,
  	65,0,0,4511,4512,5,355,0,0,4512,4513,5,1147,0,0,4513,353,1,0,0,0,4514,
  	4515,5,581,0,0,4515,4516,5,1123,0,0,4516,4517,5,1132,0,0,4517,4518,3,
  	606,303,0,4518,4519,5,1133,0,0,4519,4564,1,0,0,0,4520,4521,5,583,0,0,
  	4521,4522,5,1123,0,0,4522,4523,5,1132,0,0,4523,4524,3,606,303,0,4524,
  	4525,5,1133,0,0,4525,4564,1,0,0,0,4526,4527,5,582,0,0,4527,4528,5,1123,
  	0,0,4528,4529,5,1132,0,0,4529,4530,3,610,305,0,4530,4531,5,1133,0,0,4531,
  	4564,1,0,0,0,4532,4533,5,584,0,0,4533,4534,5,1123,0,0,4534,4535,5,1132,
  	0,0,4535,4536,3,610,305,0,4536,4537,5,1133,0,0,4537,4564,1,0,0,0,4538,
  	4539,5,586,0,0,4539,4540,5,1123,0,0,4540,4541,5,1132,0,0,4541,4542,3,
  	620,310,0,4542,4543,5,1133,0,0,4543,4564,1,0,0,0,4544,4545,5,587,0,0,
  	4545,4546,5,1123,0,0,4546,4547,5,1132,0,0,4547,4548,3,620,310,0,4548,
  	4549,5,1133,0,0,4549,4564,1,0,0,0,4550,4551,5,585,0,0,4551,4552,5,1123,
  	0,0,4552,4553,5,1132,0,0,4553,4558,3,356,178,0,4554,4555,5,1134,0,0,4555,
  	4557,3,356,178,0,4556,4554,1,0,0,0,4557,4560,1,0,0,0,4558,4556,1,0,0,
  	0,4558,4559,1,0,0,0,4559,4561,1,0,0,0,4560,4558,1,0,0,0,4561,4562,5,1133,
  	0,0,4562,4564,1,0,0,0,4563,4514,1,0,0,0,4563,4520,1,0,0,0,4563,4526,1,
  	0,0,0,4563,4532,1,0,0,0,4563,4538,1,0,0,0,4563,4544,1,0,0,0,4563,4550,
  	1,0,0,0,4564,355,1,0,0,0,4565,4566,5,1132,0,0,4566,4567,3,546,273,0,4567,
  	4568,5,1134,0,0,4568,4569,3,546,273,0,4569,4570,5,1133,0,0,4570,357,1,
  	0,0,0,4571,4572,7,60,0,0,4572,359,1,0,0,0,4573,4574,7,61,0,0,4574,4575,
  	5,1123,0,0,4575,4592,3,364,182,0,4576,4577,5,483,0,0,4577,4578,5,1123,
  	0,0,4578,4579,5,1147,0,0,4579,4580,5,1134,0,0,4580,4581,5,484,0,0,4581,
  	4582,5,1123,0,0,4582,4592,3,580,290,0,4583,4584,5,575,0,0,4584,4585,5,
  	1123,0,0,4585,4586,5,1147,0,0,4586,4587,5,1134,0,0,4587,4588,5,576,0,
  	0,4588,4589,5,1123,0,0,4589,4592,3,580,290,0,4590,4592,5,623,0,0,4591,
  	4573,1,0,0,0,4591,4576,1,0,0,0,4591,4583,1,0,0,0,4591,4590,1,0,0,0,4592,
  	361,1,0,0,0,4593,4594,5,665,0,0,4594,4595,5,1123,0,0,4595,4606,5,1147,
  	0,0,4596,4597,5,551,0,0,4597,4598,5,1123,0,0,4598,4606,5,1147,0,0,4599,
  	4600,5,391,0,0,4600,4601,5,1123,0,0,4601,4606,5,1147,0,0,4602,4603,5,
  	555,0,0,4603,4604,5,1123,0,0,4604,4606,5,1147,0,0,4605,4593,1,0,0,0,4605,
  	4596,1,0,0,0,4605,4599,1,0,0,0,4605,4602,1,0,0,0,4606,363,1,0,0,0,4607,
  	4612,3,566,283,0,4608,4609,5,1134,0,0,4609,4611,3,566,283,0,4610,4608,
  	1,0,0,0,4611,4614,1,0,0,0,4612,4610,1,0,0,0,4612,4613,1,0,0,0,4613,4617,
  	1,0,0,0,4614,4612,1,0,0,0,4615,4617,5,1147,0,0,4616,4607,1,0,0,0,4616,
  	4615,1,0,0,0,4617,365,1,0,0,0,4618,4619,5,681,0,0,4619,4620,7,62,0,0,
  	4620,4622,3,568,284,0,4621,4623,7,63,0,0,4622,4621,1,0,0,0,4622,4623,
  	1,0,0,0,4623,367,1,0,0,0,4624,4625,5,681,0,0,4625,4626,5,407,0,0,4626,
  	4632,3,568,284,0,4627,4630,5,643,0,0,4628,4629,5,65,0,0,4629,4631,5,509,
  	0,0,4630,4628,1,0,0,0,4630,4631,1,0,0,0,4631,4633,1,0,0,0,4632,4627,1,
  	0,0,0,4632,4633,1,0,0,0,4633,369,1,0,0,0,4634,4635,5,681,0,0,4635,4636,
  	5,560,0,0,4636,4637,3,568,284,0,4637,371,1,0,0,0,4638,4639,5,681,0,0,
  	4639,4640,5,369,0,0,4640,4643,3,568,284,0,4641,4642,5,536,0,0,4642,4644,
  	5,553,0,0,4643,4641,1,0,0,0,4643,4644,1,0,0,0,4644,373,1,0,0,0,4645,4646,
  	5,681,0,0,4646,4647,5,597,0,0,4647,4648,3,568,284,0,4648,375,1,0,0,0,
  	4649,4650,5,681,0,0,4650,4653,5,570,0,0,4651,4652,5,32,0,0,4652,4654,
  	3,568,284,0,4653,4651,1,0,0,0,4653,4654,1,0,0,0,4654,377,1,0,0,0,4655,
  	4656,5,560,0,0,4656,4657,3,574,287,0,4657,4660,5,68,0,0,4658,4661,5,1147,
  	0,0,4659,4661,5,1159,0,0,4660,4658,1,0,0,0,4660,4659,1,0,0,0,4661,379,
  	1,0,0,0,4662,4663,5,708,0,0,4663,4666,3,574,287,0,4664,4665,5,187,0,0,
  	4665,4667,3,622,311,0,4666,4664,1,0,0,0,4666,4667,1,0,0,0,4667,381,1,
  	0,0,0,4668,4669,7,64,0,0,4669,4670,5,560,0,0,4670,4671,3,574,287,0,4671,
  	383,1,0,0,0,4672,4675,3,386,193,0,4673,4675,3,4,2,0,4674,4672,1,0,0,0,
  	4674,4673,1,0,0,0,4675,385,1,0,0,0,4676,4677,3,574,287,0,4677,4678,5,
  	1143,0,0,4678,4680,1,0,0,0,4679,4676,1,0,0,0,4679,4680,1,0,0,0,4680,4681,
  	1,0,0,0,4681,4687,5,344,0,0,4682,4683,3,406,203,0,4683,4684,5,1135,0,
  	0,4684,4686,1,0,0,0,4685,4682,1,0,0,0,4686,4689,1,0,0,0,4687,4685,1,0,
  	0,0,4687,4688,1,0,0,0,4688,4695,1,0,0,0,4689,4687,1,0,0,0,4690,4691,3,
  	408,204,0,4691,4692,5,1135,0,0,4692,4694,1,0,0,0,4693,4690,1,0,0,0,4694,
  	4697,1,0,0,0,4695,4693,1,0,0,0,4695,4696,1,0,0,0,4696,4703,1,0,0,0,4697,
  	4695,1,0,0,0,4698,4699,3,410,205,0,4699,4700,5,1135,0,0,4700,4702,1,0,
  	0,0,4701,4698,1,0,0,0,4702,4705,1,0,0,0,4703,4701,1,0,0,0,4703,4704,1,
  	0,0,0,4704,4711,1,0,0,0,4705,4703,1,0,0,0,4706,4707,3,412,206,0,4707,
  	4708,5,1135,0,0,4708,4710,1,0,0,0,4709,4706,1,0,0,0,4710,4713,1,0,0,0,
  	4711,4709,1,0,0,0,4711,4712,1,0,0,0,4712,4717,1,0,0,0,4713,4711,1,0,0,
  	0,4714,4716,3,416,208,0,4715,4714,1,0,0,0,4716,4719,1,0,0,0,4717,4715,
  	1,0,0,0,4717,4718,1,0,0,0,4718,4720,1,0,0,0,4719,4717,1,0,0,0,4720,4722,
  	5,407,0,0,4721,4723,3,574,287,0,4722,4721,1,0,0,0,4722,4723,1,0,0,0,4723,
  	387,1,0,0,0,4724,4727,5,22,0,0,4725,4728,3,574,287,0,4726,4728,3,678,
  	339,0,4727,4725,1,0,0,0,4727,4726,1,0,0,0,4727,4728,1,0,0,0,4728,4730,
  	1,0,0,0,4729,4731,3,418,209,0,4730,4729,1,0,0,0,4731,4732,1,0,0,0,4732,
  	4730,1,0,0,0,4732,4733,1,0,0,0,4733,4740,1,0,0,0,4734,4736,5,53,0,0,4735,
  	4737,3,416,208,0,4736,4735,1,0,0,0,4737,4738,1,0,0,0,4738,4736,1,0,0,
  	0,4738,4739,1,0,0,0,4739,4741,1,0,0,0,4740,4734,1,0,0,0,4740,4741,1,0,
  	0,0,4741,4742,1,0,0,0,4742,4743,5,407,0,0,4743,4744,5,22,0,0,4744,389,
  	1,0,0,0,4745,4746,5,77,0,0,4746,4747,3,678,339,0,4747,4749,5,174,0,0,
  	4748,4750,3,416,208,0,4749,4748,1,0,0,0,4750,4751,1,0,0,0,4751,4749,1,
  	0,0,0,4751,4752,1,0,0,0,4752,4756,1,0,0,0,4753,4755,3,420,210,0,4754,
  	4753,1,0,0,0,4755,4758,1,0,0,0,4756,4754,1,0,0,0,4756,4757,1,0,0,0,4757,
  	4765,1,0,0,0,4758,4756,1,0,0,0,4759,4761,5,53,0,0,4760,4762,3,416,208,
  	0,4761,4760,1,0,0,0,4762,4763,1,0,0,0,4763,4761,1,0,0,0,4763,4764,1,0,
  	0,0,4764,4766,1,0,0,0,4765,4759,1,0,0,0,4765,4766,1,0,0,0,4766,4767,1,
  	0,0,0,4767,4768,5,407,0,0,4768,4769,5,77,0,0,4769,391,1,0,0,0,4770,4771,
  	5,89,0,0,4771,4772,3,574,287,0,4772,393,1,0,0,0,4773,4774,5,96,0,0,4774,
  	4775,3,574,287,0,4775,395,1,0,0,0,4776,4777,3,574,287,0,4777,4778,5,1143,
  	0,0,4778,4780,1,0,0,0,4779,4776,1,0,0,0,4779,4780,1,0,0,0,4780,4781,1,
  	0,0,0,4781,4783,5,105,0,0,4782,4784,3,416,208,0,4783,4782,1,0,0,0,4784,
  	4785,1,0,0,0,4785,4783,1,0,0,0,4785,4786,1,0,0,0,4786,4787,1,0,0,0,4787,
  	4788,5,407,0,0,4788,4790,5,105,0,0,4789,4791,3,574,287,0,4790,4789,1,
  	0,0,0,4790,4791,1,0,0,0,4791,397,1,0,0,0,4792,4793,3,574,287,0,4793,4794,
  	5,1143,0,0,4794,4796,1,0,0,0,4795,4792,1,0,0,0,4795,4796,1,0,0,0,4796,
  	4797,1,0,0,0,4797,4799,5,140,0,0,4798,4800,3,416,208,0,4799,4798,1,0,
  	0,0,4800,4801,1,0,0,0,4801,4799,1,0,0,0,4801,4802,1,0,0,0,4802,4803,1,
  	0,0,0,4803,4804,5,663,0,0,4804,4805,3,678,339,0,4805,4806,5,407,0,0,4806,
  	4808,5,140,0,0,4807,4809,3,574,287,0,4808,4807,1,0,0,0,4808,4809,1,0,
  	0,0,4809,399,1,0,0,0,4810,4811,5,146,0,0,4811,4812,3,678,339,0,4812,401,
  	1,0,0,0,4813,4814,3,574,287,0,4814,4815,5,1143,0,0,4815,4817,1,0,0,0,
  	4816,4813,1,0,0,0,4816,4817,1,0,0,0,4817,4818,1,0,0,0,4818,4819,5,191,
  	0,0,4819,4820,3,678,339,0,4820,4822,5,399,0,0,4821,4823,3,416,208,0,4822,
  	4821,1,0,0,0,4823,4824,1,0,0,0,4824,4822,1,0,0,0,4824,4825,1,0,0,0,4825,
  	4826,1,0,0,0,4826,4827,5,407,0,0,4827,4829,5,191,0,0,4828,4830,3,574,
  	287,0,4829,4828,1,0,0,0,4829,4830,1,0,0,0,4830,403,1,0,0,0,4831,4832,
  	5,361,0,0,4832,4847,3,574,287,0,4833,4838,5,64,0,0,4834,4836,5,520,0,
  	0,4835,4834,1,0,0,0,4835,4836,1,0,0,0,4836,4837,1,0,0,0,4837,4839,5,68,
  	0,0,4838,4835,1,0,0,0,4838,4839,1,0,0,0,4839,4840,1,0,0,0,4840,4841,3,
  	574,287,0,4841,4842,5,87,0,0,4842,4843,3,606,303,0,4843,4847,1,0,0,0,
  	4844,4845,5,539,0,0,4845,4847,3,574,287,0,4846,4831,1,0,0,0,4846,4833,
  	1,0,0,0,4846,4844,1,0,0,0,4847,405,1,0,0,0,4848,4849,5,41,0,0,4849,4850,
  	3,606,303,0,4850,4853,3,594,297,0,4851,4852,5,42,0,0,4852,4854,3,678,
  	339,0,4853,4851,1,0,0,0,4853,4854,1,0,0,0,4854,407,1,0,0,0,4855,4856,
  	5,41,0,0,4856,4857,3,574,287,0,4857,4858,5,29,0,0,4858,4865,5,65,0,0,
  	4859,4866,3,580,290,0,4860,4862,5,162,0,0,4861,4863,5,669,0,0,4862,4861,
  	1,0,0,0,4862,4863,1,0,0,0,4863,4864,1,0,0,0,4864,4866,5,1147,0,0,4865,
  	4859,1,0,0,0,4865,4860,1,0,0,0,4866,409,1,0,0,0,4867,4868,5,41,0,0,4868,
  	4869,3,574,287,0,4869,4870,5,38,0,0,4870,4871,5,65,0,0,4871,4872,3,198,
  	99,0,4872,411,1,0,0,0,4873,4874,5,41,0,0,4874,4875,7,65,0,0,4875,4876,
  	5,442,0,0,4876,4877,5,65,0,0,4877,4882,3,414,207,0,4878,4879,5,1134,0,
  	0,4879,4881,3,414,207,0,4880,4878,1,0,0,0,4881,4884,1,0,0,0,4882,4880,
  	1,0,0,0,4882,4883,1,0,0,0,4883,4885,1,0,0,0,4884,4882,1,0,0,0,4885,4886,
  	3,384,192,0,4886,413,1,0,0,0,4887,4899,3,580,290,0,4888,4890,5,162,0,
  	0,4889,4891,5,669,0,0,4890,4889,1,0,0,0,4890,4891,1,0,0,0,4891,4892,1,
  	0,0,0,4892,4899,5,1147,0,0,4893,4899,3,574,287,0,4894,4899,5,163,0,0,
  	4895,4896,5,114,0,0,4896,4899,5,435,0,0,4897,4899,5,161,0,0,4898,4887,
  	1,0,0,0,4898,4888,1,0,0,0,4898,4893,1,0,0,0,4898,4894,1,0,0,0,4898,4895,
  	1,0,0,0,4898,4897,1,0,0,0,4899,415,1,0,0,0,4900,4903,3,18,9,0,4901,4903,
  	3,4,2,0,4902,4900,1,0,0,0,4902,4901,1,0,0,0,4903,4904,1,0,0,0,4904,4905,
  	5,1135,0,0,4905,417,1,0,0,0,4906,4909,5,189,0,0,4907,4910,3,592,296,0,
  	4908,4910,3,678,339,0,4909,4907,1,0,0,0,4909,4908,1,0,0,0,4910,4911,1,
  	0,0,0,4911,4913,5,174,0,0,4912,4914,3,416,208,0,4913,4912,1,0,0,0,4914,
  	4915,1,0,0,0,4915,4913,1,0,0,0,4915,4916,1,0,0,0,4916,419,1,0,0,0,4917,
  	4918,5,54,0,0,4918,4919,3,678,339,0,4919,4921,5,174,0,0,4920,4922,3,416,
  	208,0,4921,4920,1,0,0,0,4922,4923,1,0,0,0,4923,4921,1,0,0,0,4923,4924,
  	1,0,0,0,4924,421,1,0,0,0,4925,4926,5,7,0,0,4926,4927,5,665,0,0,4927,4932,
  	3,442,221,0,4928,4929,5,1134,0,0,4929,4931,3,442,221,0,4930,4928,1,0,
  	0,0,4931,4934,1,0,0,0,4932,4930,1,0,0,0,4932,4933,1,0,0,0,4933,4999,1,
  	0,0,0,4934,4932,1,0,0,0,4935,4936,5,7,0,0,4936,4938,5,665,0,0,4937,4939,
  	3,630,315,0,4938,4937,1,0,0,0,4938,4939,1,0,0,0,4939,4940,1,0,0,0,4940,
  	4945,3,444,222,0,4941,4942,5,1134,0,0,4942,4944,3,444,222,0,4943,4941,
  	1,0,0,0,4944,4947,1,0,0,0,4945,4943,1,0,0,0,4945,4946,1,0,0,0,4946,4962,
  	1,0,0,0,4947,4945,1,0,0,0,4948,4960,5,142,0,0,4949,4961,5,529,0,0,4950,
  	4957,3,448,224,0,4951,4953,5,10,0,0,4952,4951,1,0,0,0,4952,4953,1,0,0,
  	0,4953,4954,1,0,0,0,4954,4956,3,448,224,0,4955,4952,1,0,0,0,4956,4959,
  	1,0,0,0,4957,4955,1,0,0,0,4957,4958,1,0,0,0,4958,4961,1,0,0,0,4959,4957,
  	1,0,0,0,4960,4949,1,0,0,0,4960,4950,1,0,0,0,4961,4963,1,0,0,0,4962,4948,
  	1,0,0,0,4962,4963,1,0,0,0,4963,4970,1,0,0,0,4964,4966,5,192,0,0,4965,
  	4967,3,450,225,0,4966,4965,1,0,0,0,4967,4968,1,0,0,0,4968,4966,1,0,0,
  	0,4968,4969,1,0,0,0,4969,4971,1,0,0,0,4970,4964,1,0,0,0,4970,4971,1,0,
  	0,0,4971,4976,1,0,0,0,4972,4975,3,452,226,0,4973,4975,3,454,227,0,4974,
  	4972,1,0,0,0,4974,4973,1,0,0,0,4975,4978,1,0,0,0,4976,4974,1,0,0,0,4976,
  	4977,1,0,0,0,4977,4983,1,0,0,0,4978,4976,1,0,0,0,4979,4980,5,368,0,0,
  	4980,4984,5,1147,0,0,4981,4982,5,14,0,0,4982,4984,5,1147,0,0,4983,4979,
  	1,0,0,0,4983,4981,1,0,0,0,4983,4984,1,0,0,0,4984,4999,1,0,0,0,4985,4986,
  	5,7,0,0,4986,4988,5,665,0,0,4987,4989,3,630,315,0,4988,4987,1,0,0,0,4988,
  	4989,1,0,0,0,4989,4992,1,0,0,0,4990,4993,3,554,277,0,4991,4993,3,574,
  	287,0,4992,4990,1,0,0,0,4992,4991,1,0,0,0,4993,4994,1,0,0,0,4994,4995,
  	5,42,0,0,4995,4996,5,596,0,0,4996,4997,3,430,215,0,4997,4999,1,0,0,0,
  	4998,4925,1,0,0,0,4998,4935,1,0,0,0,4998,4985,1,0,0,0,4999,423,1,0,0,
  	0,5000,5001,5,33,0,0,5001,5002,5,665,0,0,5002,5007,3,444,222,0,5003,5004,
  	5,1134,0,0,5004,5006,3,444,222,0,5005,5003,1,0,0,0,5006,5009,1,0,0,0,
  	5007,5005,1,0,0,0,5007,5008,1,0,0,0,5008,5066,1,0,0,0,5009,5007,1,0,0,
  	0,5010,5011,5,33,0,0,5011,5013,5,665,0,0,5012,5014,3,632,316,0,5013,5012,
  	1,0,0,0,5013,5014,1,0,0,0,5014,5015,1,0,0,0,5015,5020,3,444,222,0,5016,
  	5017,5,1134,0,0,5017,5019,3,444,222,0,5018,5016,1,0,0,0,5019,5022,1,0,
  	0,0,5020,5018,1,0,0,0,5020,5021,1,0,0,0,5021,5026,1,0,0,0,5022,5020,1,
  	0,0,0,5023,5024,5,42,0,0,5024,5025,5,596,0,0,5025,5027,3,430,215,0,5026,
  	5023,1,0,0,0,5026,5027,1,0,0,0,5027,5042,1,0,0,0,5028,5040,5,142,0,0,
  	5029,5041,5,529,0,0,5030,5037,3,448,224,0,5031,5033,5,10,0,0,5032,5031,
  	1,0,0,0,5032,5033,1,0,0,0,5033,5034,1,0,0,0,5034,5036,3,448,224,0,5035,
  	5032,1,0,0,0,5036,5039,1,0,0,0,5037,5035,1,0,0,0,5037,5038,1,0,0,0,5038,
  	5041,1,0,0,0,5039,5037,1,0,0,0,5040,5029,1,0,0,0,5040,5030,1,0,0,0,5041,
  	5043,1,0,0,0,5042,5028,1,0,0,0,5042,5043,1,0,0,0,5043,5050,1,0,0,0,5044,
  	5046,5,192,0,0,5045,5047,3,450,225,0,5046,5045,1,0,0,0,5047,5048,1,0,
  	0,0,5048,5046,1,0,0,0,5048,5049,1,0,0,0,5049,5051,1,0,0,0,5050,5044,1,
  	0,0,0,5050,5051,1,0,0,0,5051,5056,1,0,0,0,5052,5055,3,452,226,0,5053,
  	5055,3,454,227,0,5054,5052,1,0,0,0,5054,5053,1,0,0,0,5055,5058,1,0,0,
  	0,5056,5054,1,0,0,0,5056,5057,1,0,0,0,5057,5063,1,0,0,0,5058,5056,1,0,
  	0,0,5059,5060,5,368,0,0,5060,5064,5,1147,0,0,5061,5062,5,14,0,0,5062,
  	5064,5,1147,0,0,5063,5059,1,0,0,0,5063,5061,1,0,0,0,5063,5064,1,0,0,0,
  	5064,5066,1,0,0,0,5065,5000,1,0,0,0,5065,5010,1,0,0,0,5066,425,1,0,0,
  	0,5067,5068,5,51,0,0,5068,5070,5,665,0,0,5069,5071,3,630,315,0,5070,5069,
  	1,0,0,0,5070,5071,1,0,0,0,5071,5072,1,0,0,0,5072,5077,3,554,277,0,5073,
  	5074,5,1134,0,0,5074,5076,3,554,277,0,5075,5073,1,0,0,0,5076,5079,1,0,
  	0,0,5077,5075,1,0,0,0,5077,5078,1,0,0,0,5078,427,1,0,0,0,5079,5077,1,
  	0,0,0,5080,5081,5,72,0,0,5081,5086,3,456,228,0,5082,5083,5,1134,0,0,5083,
  	5085,3,456,228,0,5084,5082,1,0,0,0,5085,5088,1,0,0,0,5086,5084,1,0,0,
  	0,5086,5087,1,0,0,0,5087,5089,1,0,0,0,5088,5086,1,0,0,0,5089,5091,5,118,
  	0,0,5090,5092,7,66,0,0,5091,5090,1,0,0,0,5091,5092,1,0,0,0,5092,5093,
  	1,0,0,0,5093,5094,3,460,230,0,5094,5095,5,175,0,0,5095,5100,3,444,222,
  	0,5096,5097,5,1134,0,0,5097,5099,3,444,222,0,5098,5096,1,0,0,0,5099,5102,
  	1,0,0,0,5100,5098,1,0,0,0,5100,5101,1,0,0,0,5101,5117,1,0,0,0,5102,5100,
  	1,0,0,0,5103,5115,5,142,0,0,5104,5116,5,529,0,0,5105,5112,3,448,224,0,
  	5106,5108,5,10,0,0,5107,5106,1,0,0,0,5107,5108,1,0,0,0,5108,5109,1,0,
  	0,0,5109,5111,3,448,224,0,5110,5107,1,0,0,0,5111,5114,1,0,0,0,5112,5110,
  	1,0,0,0,5112,5113,1,0,0,0,5113,5116,1,0,0,0,5114,5112,1,0,0,0,5115,5104,
  	1,0,0,0,5115,5105,1,0,0,0,5116,5118,1,0,0,0,5117,5103,1,0,0,0,5117,5118,
  	1,0,0,0,5118,5128,1,0,0,0,5119,5125,5,192,0,0,5120,5121,5,72,0,0,5121,
  	5124,5,120,0,0,5122,5124,3,450,225,0,5123,5120,1,0,0,0,5123,5122,1,0,
  	0,0,5124,5127,1,0,0,0,5125,5123,1,0,0,0,5125,5126,1,0,0,0,5126,5129,1,
  	0,0,0,5127,5125,1,0,0,0,5128,5119,1,0,0,0,5128,5129,1,0,0,0,5129,5136,
  	1,0,0,0,5130,5131,5,12,0,0,5131,5132,3,554,277,0,5132,5133,5,192,0,0,
  	5133,5134,5,596,0,0,5134,5135,3,430,215,0,5135,5137,1,0,0,0,5136,5130,
  	1,0,0,0,5136,5137,1,0,0,0,5137,5174,1,0,0,0,5138,5141,5,72,0,0,5139,5142,
  	3,554,277,0,5140,5142,3,574,287,0,5141,5139,1,0,0,0,5141,5140,1,0,0,0,
  	5142,5150,1,0,0,0,5143,5146,5,1134,0,0,5144,5147,3,554,277,0,5145,5147,
  	3,574,287,0,5146,5144,1,0,0,0,5146,5145,1,0,0,0,5147,5149,1,0,0,0,5148,
  	5143,1,0,0,0,5149,5152,1,0,0,0,5150,5148,1,0,0,0,5150,5151,1,0,0,0,5151,
  	5153,1,0,0,0,5152,5150,1,0,0,0,5153,5156,5,175,0,0,5154,5157,3,554,277,
  	0,5155,5157,3,574,287,0,5156,5154,1,0,0,0,5156,5155,1,0,0,0,5157,5165,
  	1,0,0,0,5158,5161,5,1134,0,0,5159,5162,3,554,277,0,5160,5162,3,574,287,
  	0,5161,5159,1,0,0,0,5161,5160,1,0,0,0,5162,5164,1,0,0,0,5163,5158,1,0,
  	0,0,5164,5167,1,0,0,0,5165,5163,1,0,0,0,5165,5166,1,0,0,0,5166,5171,1,
  	0,0,0,5167,5165,1,0,0,0,5168,5169,5,192,0,0,5169,5170,5,697,0,0,5170,
  	5172,5,120,0,0,5171,5168,1,0,0,0,5171,5172,1,0,0,0,5172,5174,1,0,0,0,
  	5173,5080,1,0,0,0,5173,5138,1,0,0,0,5174,429,1,0,0,0,5175,5198,5,42,0,
  	0,5176,5198,5,529,0,0,5177,5187,5,6,0,0,5178,5179,5,59,0,0,5179,5184,
  	3,554,277,0,5180,5181,5,1134,0,0,5181,5183,3,554,277,0,5182,5180,1,0,
  	0,0,5183,5186,1,0,0,0,5184,5182,1,0,0,0,5184,5185,1,0,0,0,5185,5188,1,
  	0,0,0,5186,5184,1,0,0,0,5187,5178,1,0,0,0,5187,5188,1,0,0,0,5188,5198,
  	1,0,0,0,5189,5194,3,554,277,0,5190,5191,5,1134,0,0,5191,5193,3,554,277,
  	0,5192,5190,1,0,0,0,5193,5196,1,0,0,0,5194,5192,1,0,0,0,5194,5195,1,0,
  	0,0,5195,5198,1,0,0,0,5196,5194,1,0,0,0,5197,5175,1,0,0,0,5197,5176,1,
  	0,0,0,5197,5177,1,0,0,0,5197,5189,1,0,0,0,5198,431,1,0,0,0,5199,5200,
  	5,72,0,0,5200,5201,5,566,0,0,5201,5202,5,118,0,0,5202,5203,3,554,277,
  	0,5203,5204,5,175,0,0,5204,5209,3,554,277,0,5205,5206,5,1134,0,0,5206,
  	5208,3,554,277,0,5207,5205,1,0,0,0,5208,5211,1,0,0,0,5209,5207,1,0,0,
  	0,5209,5210,1,0,0,0,5210,5215,1,0,0,0,5211,5209,1,0,0,0,5212,5213,5,192,
  	0,0,5213,5214,5,72,0,0,5214,5216,5,120,0,0,5215,5212,1,0,0,0,5215,5216,
  	1,0,0,0,5216,433,1,0,0,0,5217,5218,5,139,0,0,5218,5219,5,665,0,0,5219,
  	5224,3,462,231,0,5220,5221,5,1134,0,0,5221,5223,3,462,231,0,5222,5220,
  	1,0,0,0,5223,5226,1,0,0,0,5224,5222,1,0,0,0,5224,5225,1,0,0,0,5225,435,
  	1,0,0,0,5226,5224,1,0,0,0,5227,5228,5,147,0,0,5228,5233,3,456,228,0,5229,
  	5230,5,1134,0,0,5230,5232,3,456,228,0,5231,5229,1,0,0,0,5232,5235,1,0,
  	0,0,5233,5231,1,0,0,0,5233,5234,1,0,0,0,5234,5236,1,0,0,0,5235,5233,1,
  	0,0,0,5236,5238,5,118,0,0,5237,5239,7,66,0,0,5238,5237,1,0,0,0,5238,5239,
  	1,0,0,0,5239,5240,1,0,0,0,5240,5241,3,460,230,0,5241,5242,5,68,0,0,5242,
  	5247,3,554,277,0,5243,5244,5,1134,0,0,5244,5246,3,554,277,0,5245,5243,
  	1,0,0,0,5246,5249,1,0,0,0,5247,5245,1,0,0,0,5247,5248,1,0,0,0,5248,5298,
  	1,0,0,0,5249,5247,1,0,0,0,5250,5251,5,147,0,0,5251,5253,5,6,0,0,5252,
  	5254,5,725,0,0,5253,5252,1,0,0,0,5253,5254,1,0,0,0,5254,5255,1,0,0,0,
  	5255,5256,5,1134,0,0,5256,5257,5,72,0,0,5257,5258,5,120,0,0,5258,5259,
  	5,68,0,0,5259,5264,3,554,277,0,5260,5261,5,1134,0,0,5261,5263,3,554,277,
  	0,5262,5260,1,0,0,0,5263,5266,1,0,0,0,5264,5262,1,0,0,0,5264,5265,1,0,
  	0,0,5265,5298,1,0,0,0,5266,5264,1,0,0,0,5267,5270,5,147,0,0,5268,5271,
  	3,554,277,0,5269,5271,3,574,287,0,5270,5268,1,0,0,0,5270,5269,1,0,0,0,
  	5271,5279,1,0,0,0,5272,5275,5,1134,0,0,5273,5276,3,554,277,0,5274,5276,
  	3,574,287,0,5275,5273,1,0,0,0,5275,5274,1,0,0,0,5276,5278,1,0,0,0,5277,
  	5272,1,0,0,0,5278,5281,1,0,0,0,5279,5277,1,0,0,0,5279,5280,1,0,0,0,5280,
  	5282,1,0,0,0,5281,5279,1,0,0,0,5282,5285,5,68,0,0,5283,5286,3,554,277,
  	0,5284,5286,3,574,287,0,5285,5283,1,0,0,0,5285,5284,1,0,0,0,5286,5294,
  	1,0,0,0,5287,5290,5,1134,0,0,5288,5291,3,554,277,0,5289,5291,3,574,287,
  	0,5290,5288,1,0,0,0,5290,5289,1,0,0,0,5291,5293,1,0,0,0,5292,5287,1,0,
  	0,0,5293,5296,1,0,0,0,5294,5292,1,0,0,0,5294,5295,1,0,0,0,5295,5298,1,
  	0,0,0,5296,5294,1,0,0,0,5297,5227,1,0,0,0,5297,5250,1,0,0,0,5297,5267,
  	1,0,0,0,5298,437,1,0,0,0,5299,5300,5,147,0,0,5300,5301,5,566,0,0,5301,
  	5302,5,118,0,0,5302,5303,3,554,277,0,5303,5304,5,68,0,0,5304,5309,3,554,
  	277,0,5305,5306,5,1134,0,0,5306,5308,3,554,277,0,5307,5305,1,0,0,0,5308,
  	5311,1,0,0,0,5309,5307,1,0,0,0,5309,5310,1,0,0,0,5310,439,1,0,0,0,5311,
  	5309,1,0,0,0,5312,5313,5,153,0,0,5313,5316,5,551,0,0,5314,5315,5,65,0,
  	0,5315,5317,3,554,277,0,5316,5314,1,0,0,0,5316,5317,1,0,0,0,5317,5318,
  	1,0,0,0,5318,5321,5,1123,0,0,5319,5322,3,672,336,0,5320,5322,5,1147,0,
  	0,5321,5319,1,0,0,0,5321,5320,1,0,0,0,5322,441,1,0,0,0,5323,5324,3,554,
  	277,0,5324,5325,3,452,226,0,5325,443,1,0,0,0,5326,5327,3,554,277,0,5327,
  	5328,5,448,0,0,5328,5329,5,19,0,0,5329,5330,5,551,0,0,5330,5331,5,1147,
  	0,0,5331,5348,1,0,0,0,5332,5333,3,554,277,0,5333,5334,5,448,0,0,5334,
  	5335,5,19,0,0,5335,5339,5,1147,0,0,5336,5337,5,145,0,0,5337,5338,5,35,
  	0,0,5338,5340,5,551,0,0,5339,5336,1,0,0,0,5339,5340,1,0,0,0,5340,5348,
  	1,0,0,0,5341,5342,3,554,277,0,5342,5343,5,448,0,0,5343,5344,5,192,0,0,
  	5344,5345,3,446,223,0,5345,5348,1,0,0,0,5346,5348,3,554,277,0,5347,5326,
  	1,0,0,0,5347,5332,1,0,0,0,5347,5341,1,0,0,0,5347,5346,1,0,0,0,5348,445,
  	1,0,0,0,5349,5352,3,572,286,0,5350,5351,7,67,0,0,5351,5353,5,1147,0,0,
  	5352,5350,1,0,0,0,5352,5353,1,0,0,0,5353,5359,1,0,0,0,5354,5355,3,572,
  	286,0,5355,5356,5,187,0,0,5356,5357,3,672,336,0,5357,5359,1,0,0,0,5358,
  	5349,1,0,0,0,5358,5354,1,0,0,0,5359,447,1,0,0,0,5360,5369,5,167,0,0,5361,
  	5369,5,680,0,0,5362,5363,5,358,0,0,5363,5369,5,1147,0,0,5364,5365,5,465,
  	0,0,5365,5369,5,1147,0,0,5366,5367,5,640,0,0,5367,5369,5,1147,0,0,5368,
  	5360,1,0,0,0,5368,5361,1,0,0,0,5368,5362,1,0,0,0,5368,5364,1,0,0,0,5368,
  	5366,1,0,0,0,5369,449,1,0,0,0,5370,5371,5,499,0,0,5371,5379,3,580,290,
  	0,5372,5373,5,502,0,0,5373,5379,3,580,290,0,5374,5375,5,498,0,0,5375,
  	5379,3,580,290,0,5376,5377,5,503,0,0,5377,5379,3,580,290,0,5378,5370,
  	1,0,0,0,5378,5372,1,0,0,0,5378,5374,1,0,0,0,5378,5376,1,0,0,0,5379,451,
  	1,0,0,0,5380,5381,5,551,0,0,5381,5388,5,420,0,0,5382,5389,5,42,0,0,5383,
  	5389,5,519,0,0,5384,5385,5,86,0,0,5385,5386,3,580,290,0,5386,5387,5,691,
  	0,0,5387,5389,1,0,0,0,5388,5382,1,0,0,0,5388,5383,1,0,0,0,5388,5384,1,
  	0,0,0,5388,5389,1,0,0,0,5389,5419,1,0,0,0,5390,5391,5,551,0,0,5391,5394,
  	5,445,0,0,5392,5395,5,42,0,0,5393,5395,3,580,290,0,5394,5392,1,0,0,0,
  	5394,5393,1,0,0,0,5395,5419,1,0,0,0,5396,5397,5,551,0,0,5397,5398,5,595,
  	0,0,5398,5403,5,86,0,0,5399,5404,5,42,0,0,5400,5401,3,580,290,0,5401,
  	5402,5,691,0,0,5402,5404,1,0,0,0,5403,5399,1,0,0,0,5403,5400,1,0,0,0,
  	5404,5419,1,0,0,0,5405,5406,5,551,0,0,5406,5407,5,142,0,0,5407,5409,5,
  	35,0,0,5408,5410,7,68,0,0,5409,5408,1,0,0,0,5409,5410,1,0,0,0,5410,5419,
  	1,0,0,0,5411,5412,5,424,0,0,5412,5419,3,580,290,0,5413,5416,5,552,0,0,
  	5414,5417,3,580,290,0,5415,5417,5,657,0,0,5416,5414,1,0,0,0,5416,5415,
  	1,0,0,0,5417,5419,1,0,0,0,5418,5380,1,0,0,0,5418,5390,1,0,0,0,5418,5396,
  	1,0,0,0,5418,5405,1,0,0,0,5418,5411,1,0,0,0,5418,5413,1,0,0,0,5419,453,
  	1,0,0,0,5420,5421,5,332,0,0,5421,5422,7,69,0,0,5422,455,1,0,0,0,5423,
  	5428,3,458,229,0,5424,5425,5,1132,0,0,5425,5426,3,606,303,0,5426,5427,
  	5,1133,0,0,5427,5429,1,0,0,0,5428,5424,1,0,0,0,5428,5429,1,0,0,0,5429,
  	457,1,0,0,0,5430,5432,5,6,0,0,5431,5433,5,725,0,0,5432,5431,1,0,0,0,5432,
  	5433,1,0,0,0,5433,5524,1,0,0,0,5434,5436,5,7,0,0,5435,5437,5,733,0,0,
  	5436,5435,1,0,0,0,5436,5437,1,0,0,0,5437,5524,1,0,0,0,5438,5446,5,33,
  	0,0,5439,5440,5,649,0,0,5440,5447,5,742,0,0,5441,5447,5,733,0,0,5442,
  	5447,5,671,0,0,5443,5447,5,665,0,0,5444,5447,5,647,0,0,5445,5447,5,596,
  	0,0,5446,5439,1,0,0,0,5446,5441,1,0,0,0,5446,5442,1,0,0,0,5446,5443,1,
  	0,0,0,5446,5444,1,0,0,0,5446,5445,1,0,0,0,5446,5447,1,0,0,0,5447,5524,
  	1,0,0,0,5448,5524,5,44,0,0,5449,5451,5,51,0,0,5450,5452,5,596,0,0,5451,
  	5450,1,0,0,0,5451,5452,1,0,0,0,5452,5524,1,0,0,0,5453,5524,5,415,0,0,
  	5454,5524,5,708,0,0,5455,5524,5,709,0,0,5456,5457,5,72,0,0,5457,5524,
  	5,120,0,0,5458,5524,5,81,0,0,5459,5524,5,85,0,0,5460,5461,5,103,0,0,5461,
  	5524,5,742,0,0,5462,5524,5,726,0,0,5463,5524,5,566,0,0,5464,5524,5,136,
  	0,0,5465,5524,5,727,0,0,5466,5467,5,588,0,0,5467,5524,7,70,0,0,5468,5524,
  	5,152,0,0,5469,5470,5,155,0,0,5470,5524,7,71,0,0,5471,5524,5,739,0,0,
  	5472,5524,5,740,0,0,5473,5524,5,177,0,0,5474,5524,5,184,0,0,5475,5524,
  	5,185,0,0,5476,5524,5,698,0,0,5477,5524,5,699,0,0,5478,5524,5,700,0,0,
  	5479,5524,5,701,0,0,5480,5524,5,702,0,0,5481,5524,5,703,0,0,5482,5524,
  	5,704,0,0,5483,5524,5,705,0,0,5484,5524,5,706,0,0,5485,5524,5,707,0,0,
  	5486,5524,5,710,0,0,5487,5524,5,711,0,0,5488,5524,5,712,0,0,5489,5524,
  	5,713,0,0,5490,5524,5,714,0,0,5491,5524,5,715,0,0,5492,5524,5,716,0,0,
  	5493,5524,5,717,0,0,5494,5524,5,718,0,0,5495,5524,5,719,0,0,5496,5524,
  	5,722,0,0,5497,5524,5,723,0,0,5498,5524,5,724,0,0,5499,5524,5,728,0,0,
  	5500,5524,5,729,0,0,5501,5524,5,730,0,0,5502,5524,5,731,0,0,5503,5524,
  	5,732,0,0,5504,5524,5,735,0,0,5505,5524,5,736,0,0,5506,5524,5,737,0,0,
  	5507,5524,5,158,0,0,5508,5524,5,738,0,0,5509,5524,5,1076,0,0,5510,5524,
  	5,741,0,0,5511,5524,5,743,0,0,5512,5524,5,1087,0,0,5513,5524,5,744,0,
  	0,5514,5524,5,745,0,0,5515,5516,5,102,0,0,5516,5517,5,68,0,0,5517,5524,
  	5,734,0,0,5518,5519,5,152,0,0,5519,5520,5,87,0,0,5520,5524,5,734,0,0,
  	5521,5522,5,720,0,0,5522,5524,5,721,0,0,5523,5430,1,0,0,0,5523,5434,1,
  	0,0,0,5523,5438,1,0,0,0,5523,5448,1,0,0,0,5523,5449,1,0,0,0,5523,5453,
  	1,0,0,0,5523,5454,1,0,0,0,5523,5455,1,0,0,0,5523,5456,1,0,0,0,5523,5458,
  	1,0,0,0,5523,5459,1,0,0,0,5523,5460,1,0,0,0,5523,5462,1,0,0,0,5523,5463,
  	1,0,0,0,5523,5464,1,0,0,0,5523,5465,1,0,0,0,5523,5466,1,0,0,0,5523,5468,
  	1,0,0,0,5523,5469,1,0,0,0,5523,5471,1,0,0,0,5523,5472,1,0,0,0,5523,5473,
  	1,0,0,0,5523,5474,1,0,0,0,5523,5475,1,0,0,0,5523,5476,1,0,0,0,5523,5477,
  	1,0,0,0,5523,5478,1,0,0,0,5523,5479,1,0,0,0,5523,5480,1,0,0,0,5523,5481,
  	1,0,0,0,5523,5482,1,0,0,0,5523,5483,1,0,0,0,5523,5484,1,0,0,0,5523,5485,
  	1,0,0,0,5523,5486,1,0,0,0,5523,5487,1,0,0,0,5523,5488,1,0,0,0,5523,5489,
  	1,0,0,0,5523,5490,1,0,0,0,5523,5491,1,0,0,0,5523,5492,1,0,0,0,5523,5493,
  	1,0,0,0,5523,5494,1,0,0,0,5523,5495,1,0,0,0,5523,5496,1,0,0,0,5523,5497,
  	1,0,0,0,5523,5498,1,0,0,0,5523,5499,1,0,0,0,5523,5500,1,0,0,0,5523,5501,
  	1,0,0,0,5523,5502,1,0,0,0,5523,5503,1,0,0,0,5523,5504,1,0,0,0,5523,5505,
  	1,0,0,0,5523,5506,1,0,0,0,5523,5507,1,0,0,0,5523,5508,1,0,0,0,5523,5509,
  	1,0,0,0,5523,5510,1,0,0,0,5523,5511,1,0,0,0,5523,5512,1,0,0,0,5523,5513,
  	1,0,0,0,5523,5514,1,0,0,0,5523,5515,1,0,0,0,5523,5518,1,0,0,0,5523,5521,
  	1,0,0,0,5524,459,1,0,0,0,5525,5542,5,1116,0,0,5526,5527,5,1116,0,0,5527,
  	5528,5,1131,0,0,5528,5542,5,1116,0,0,5529,5530,3,574,287,0,5530,5531,
  	5,1131,0,0,5531,5532,5,1116,0,0,5532,5542,1,0,0,0,5533,5534,3,574,287,
  	0,5534,5535,5,1131,0,0,5535,5536,3,574,287,0,5536,5542,1,0,0,0,5537,5538,
  	3,574,287,0,5538,5539,3,578,289,0,5539,5542,1,0,0,0,5540,5542,3,574,287,
  	0,5541,5525,1,0,0,0,5541,5526,1,0,0,0,5541,5529,1,0,0,0,5541,5533,1,0,
  	0,0,5541,5537,1,0,0,0,5541,5540,1,0,0,0,5542,461,1,0,0,0,5543,5544,3,
  	554,277,0,5544,5545,5,175,0,0,5545,5546,3,554,277,0,5546,463,1,0,0,0,
  	5547,5549,5,9,0,0,5548,5550,7,72,0,0,5549,5548,1,0,0,0,5549,5550,1,0,
  	0,0,5550,5551,1,0,0,0,5551,5552,7,54,0,0,5552,5570,3,610,305,0,5553,5554,
  	5,184,0,0,5554,5555,5,76,0,0,5555,5556,5,118,0,0,5556,5561,3,550,275,
  	0,5557,5558,5,1134,0,0,5558,5560,3,550,275,0,5559,5557,1,0,0,0,5560,5563,
  	1,0,0,0,5561,5559,1,0,0,0,5561,5562,1,0,0,0,5562,5568,1,0,0,0,5563,5561,
  	1,0,0,0,5564,5565,5,192,0,0,5565,5566,3,580,290,0,5566,5567,5,18,0,0,
  	5567,5569,1,0,0,0,5568,5564,1,0,0,0,5568,5569,1,0,0,0,5569,5571,1,0,0,
  	0,5570,5553,1,0,0,0,5570,5571,1,0,0,0,5571,5583,1,0,0,0,5572,5573,5,51,
  	0,0,5573,5574,5,76,0,0,5574,5575,5,118,0,0,5575,5580,3,550,275,0,5576,
  	5577,5,1134,0,0,5577,5579,3,550,275,0,5578,5576,1,0,0,0,5579,5582,1,0,
  	0,0,5580,5578,1,0,0,0,5580,5581,1,0,0,0,5581,5584,1,0,0,0,5582,5580,1,
  	0,0,0,5583,5572,1,0,0,0,5583,5584,1,0,0,0,5584,465,1,0,0,0,5585,5586,
  	5,26,0,0,5586,5587,5,172,0,0,5587,5591,3,610,305,0,5588,5590,3,474,237,
  	0,5589,5588,1,0,0,0,5590,5593,1,0,0,0,5591,5589,1,0,0,0,5591,5592,1,0,
  	0,0,5592,467,1,0,0,0,5593,5591,1,0,0,0,5594,5595,5,356,0,0,5595,5596,
  	5,172,0,0,5596,5598,3,610,305,0,5597,5599,7,73,0,0,5598,5597,1,0,0,0,
  	5598,5599,1,0,0,0,5599,469,1,0,0,0,5600,5602,5,119,0,0,5601,5603,7,72,
  	0,0,5602,5601,1,0,0,0,5602,5603,1,0,0,0,5603,5604,1,0,0,0,5604,5605,7,
  	54,0,0,5605,5606,3,610,305,0,5606,471,1,0,0,0,5607,5609,5,580,0,0,5608,
  	5610,7,72,0,0,5609,5608,1,0,0,0,5609,5610,1,0,0,0,5610,5611,1,0,0,0,5611,
  	5612,5,172,0,0,5612,5614,3,610,305,0,5613,5615,5,568,0,0,5614,5613,1,
  	0,0,0,5614,5615,1,0,0,0,5615,5617,1,0,0,0,5616,5618,5,422,0,0,5617,5616,
  	1,0,0,0,5617,5618,1,0,0,0,5618,5620,1,0,0,0,5619,5621,5,666,0,0,5620,
  	5619,1,0,0,0,5620,5621,1,0,0,0,5621,473,1,0,0,0,5622,5623,5,65,0,0,5623,
  	5630,5,664,0,0,5624,5630,5,568,0,0,5625,5630,5,425,0,0,5626,5630,5,504,
  	0,0,5627,5630,5,422,0,0,5628,5630,5,354,0,0,5629,5622,1,0,0,0,5629,5624,
  	1,0,0,0,5629,5625,1,0,0,0,5629,5626,1,0,0,0,5629,5627,1,0,0,0,5629,5628,
  	1,0,0,0,5630,475,1,0,0,0,5631,5633,5,33,0,0,5632,5634,5,335,0,0,5633,
  	5632,1,0,0,0,5633,5634,1,0,0,0,5634,5635,1,0,0,0,5635,5637,5,437,0,0,
  	5636,5638,3,632,316,0,5637,5636,1,0,0,0,5637,5638,1,0,0,0,5638,5639,1,
  	0,0,0,5639,5640,3,574,287,0,5640,5641,5,594,0,0,5641,5642,7,74,0,0,5642,
  	5643,5,619,0,0,5643,5644,5,1147,0,0,5644,477,1,0,0,0,5645,5646,5,456,
  	0,0,5646,5647,5,554,0,0,5647,5648,3,574,287,0,5648,5649,5,619,0,0,5649,
  	5650,5,1147,0,0,5650,479,1,0,0,0,5651,5652,5,661,0,0,5652,5653,5,554,
  	0,0,5653,5654,3,574,287,0,5654,481,1,0,0,0,5655,5656,5,153,0,0,5656,5657,
  	3,486,243,0,5657,5660,7,75,0,0,5658,5661,3,678,339,0,5659,5661,5,118,
  	0,0,5660,5658,1,0,0,0,5660,5659,1,0,0,0,5661,5671,1,0,0,0,5662,5663,5,
  	1134,0,0,5663,5664,3,486,243,0,5664,5667,7,75,0,0,5665,5668,3,678,339,
  	0,5666,5668,5,118,0,0,5667,5665,1,0,0,0,5667,5666,1,0,0,0,5668,5670,1,
  	0,0,0,5669,5662,1,0,0,0,5670,5673,1,0,0,0,5671,5669,1,0,0,0,5671,5672,
  	1,0,0,0,5672,5708,1,0,0,0,5673,5671,1,0,0,0,5674,5675,5,153,0,0,5675,
  	5678,3,60,30,0,5676,5679,3,558,279,0,5677,5679,5,42,0,0,5678,5676,1,0,
  	0,0,5678,5677,1,0,0,0,5679,5708,1,0,0,0,5680,5681,5,153,0,0,5681,5688,
  	5,517,0,0,5682,5685,3,558,279,0,5683,5684,5,27,0,0,5684,5686,3,560,280,
  	0,5685,5683,1,0,0,0,5685,5686,1,0,0,0,5686,5689,1,0,0,0,5687,5689,5,42,
  	0,0,5688,5682,1,0,0,0,5688,5687,1,0,0,0,5689,5708,1,0,0,0,5690,5708,3,
  	440,220,0,5691,5708,3,314,157,0,5692,5708,3,312,156,0,5693,5694,5,153,
  	0,0,5694,5695,3,544,272,0,5695,5696,7,75,0,0,5696,5704,3,678,339,0,5697,
  	5698,5,1134,0,0,5698,5699,3,544,272,0,5699,5700,7,75,0,0,5700,5701,3,
  	678,339,0,5701,5703,1,0,0,0,5702,5697,1,0,0,0,5703,5706,1,0,0,0,5704,
  	5702,1,0,0,0,5704,5705,1,0,0,0,5705,5708,1,0,0,0,5706,5704,1,0,0,0,5707,
  	5655,1,0,0,0,5707,5674,1,0,0,0,5707,5680,1,0,0,0,5707,5690,1,0,0,0,5707,
  	5691,1,0,0,0,5707,5692,1,0,0,0,5707,5693,1,0,0,0,5708,483,1,0,0,0,5709,
  	5710,5,155,0,0,5710,5711,7,56,0,0,5711,5863,5,476,0,0,5712,5713,5,155,
  	0,0,5713,5714,7,76,0,0,5714,5717,5,416,0,0,5715,5716,5,80,0,0,5716,5718,
  	5,1147,0,0,5717,5715,1,0,0,0,5717,5718,1,0,0,0,5718,5721,1,0,0,0,5719,
  	5720,5,68,0,0,5720,5722,3,580,290,0,5721,5719,1,0,0,0,5721,5722,1,0,0,
  	0,5722,5730,1,0,0,0,5723,5727,5,99,0,0,5724,5725,3,580,290,0,5725,5726,
  	5,1134,0,0,5726,5728,1,0,0,0,5727,5724,1,0,0,0,5727,5728,1,0,0,0,5728,
  	5729,1,0,0,0,5729,5731,3,580,290,0,5730,5723,1,0,0,0,5730,5731,1,0,0,
  	0,5731,5863,1,0,0,0,5732,5733,5,155,0,0,5733,5735,3,488,244,0,5734,5736,
  	3,490,245,0,5735,5734,1,0,0,0,5735,5736,1,0,0,0,5736,5863,1,0,0,0,5737,
  	5739,5,155,0,0,5738,5740,5,436,0,0,5739,5738,1,0,0,0,5739,5740,1,0,0,
  	0,5740,5741,1,0,0,0,5741,5742,7,41,0,0,5742,5743,7,77,0,0,5743,5746,3,
  	546,273,0,5744,5745,7,77,0,0,5745,5747,3,574,287,0,5746,5744,1,0,0,0,
  	5746,5747,1,0,0,0,5747,5749,1,0,0,0,5748,5750,3,490,245,0,5749,5748,1,
  	0,0,0,5749,5750,1,0,0,0,5750,5863,1,0,0,0,5751,5752,5,155,0,0,5752,5753,
  	5,33,0,0,5753,5755,7,0,0,0,5754,5756,3,632,316,0,5755,5754,1,0,0,0,5755,
  	5756,1,0,0,0,5756,5757,1,0,0,0,5757,5863,3,574,287,0,5758,5759,5,155,
  	0,0,5759,5760,5,33,0,0,5760,5761,7,78,0,0,5761,5863,3,544,272,0,5762,
  	5763,5,155,0,0,5763,5764,5,33,0,0,5764,5765,5,665,0,0,5765,5863,3,554,
  	277,0,5766,5767,5,155,0,0,5767,5768,5,409,0,0,5768,5769,3,562,281,0,5769,
  	5770,7,79,0,0,5770,5863,1,0,0,0,5771,5772,5,155,0,0,5772,5863,3,492,246,
  	0,5773,5774,5,155,0,0,5774,5782,7,80,0,0,5775,5779,5,99,0,0,5776,5777,
  	3,580,290,0,5777,5778,5,1134,0,0,5778,5780,1,0,0,0,5779,5776,1,0,0,0,
  	5779,5780,1,0,0,0,5780,5781,1,0,0,0,5781,5783,3,580,290,0,5782,5775,1,
  	0,0,0,5782,5783,1,0,0,0,5783,5863,1,0,0,0,5784,5785,5,155,0,0,5785,5786,
  	5,290,0,0,5786,5787,5,1132,0,0,5787,5788,5,1116,0,0,5788,5789,5,1133,
  	0,0,5789,5863,7,80,0,0,5790,5791,5,155,0,0,5791,5794,3,494,247,0,5792,
  	5793,7,77,0,0,5793,5795,3,574,287,0,5794,5792,1,0,0,0,5794,5795,1,0,0,
  	0,5795,5797,1,0,0,0,5796,5798,3,490,245,0,5797,5796,1,0,0,0,5797,5798,
  	1,0,0,0,5798,5863,1,0,0,0,5799,5800,5,155,0,0,5800,5801,7,81,0,0,5801,
  	5802,5,364,0,0,5802,5863,3,544,272,0,5803,5804,5,155,0,0,5804,5807,5,
  	440,0,0,5805,5806,5,65,0,0,5806,5808,3,554,277,0,5807,5805,1,0,0,0,5807,
  	5808,1,0,0,0,5808,5863,1,0,0,0,5809,5810,5,155,0,0,5810,5811,7,82,0,0,
  	5811,5812,7,77,0,0,5812,5815,3,546,273,0,5813,5814,7,77,0,0,5814,5816,
  	3,574,287,0,5815,5813,1,0,0,0,5815,5816,1,0,0,0,5816,5819,1,0,0,0,5817,
  	5818,5,190,0,0,5818,5820,3,678,339,0,5819,5817,1,0,0,0,5819,5820,1,0,
  	0,0,5820,5863,1,0,0,0,5821,5822,5,155,0,0,5822,5823,5,539,0,0,5823,5826,
  	5,742,0,0,5824,5825,7,77,0,0,5825,5827,3,574,287,0,5826,5824,1,0,0,0,
  	5826,5827,1,0,0,0,5827,5829,1,0,0,0,5828,5830,3,490,245,0,5829,5828,1,
  	0,0,0,5829,5830,1,0,0,0,5830,5863,1,0,0,0,5831,5832,5,155,0,0,5832,5833,
  	5,564,0,0,5833,5838,3,496,248,0,5834,5835,5,1134,0,0,5835,5837,3,496,
  	248,0,5836,5834,1,0,0,0,5837,5840,1,0,0,0,5838,5836,1,0,0,0,5838,5839,
  	1,0,0,0,5839,5844,1,0,0,0,5840,5838,1,0,0,0,5841,5842,5,65,0,0,5842,5843,
  	5,567,0,0,5843,5845,3,580,290,0,5844,5841,1,0,0,0,5844,5845,1,0,0,0,5845,
  	5846,1,0,0,0,5846,5850,5,99,0,0,5847,5848,3,580,290,0,5848,5849,5,1134,
  	0,0,5849,5851,1,0,0,0,5850,5847,1,0,0,0,5850,5851,1,0,0,0,5851,5852,1,
  	0,0,0,5852,5853,3,580,290,0,5853,5863,1,0,0,0,5854,5855,5,155,0,0,5855,
  	5856,5,614,0,0,5856,5860,5,634,0,0,5857,5858,5,65,0,0,5858,5859,5,355,
  	0,0,5859,5861,5,1147,0,0,5860,5857,1,0,0,0,5860,5861,1,0,0,0,5861,5863,
  	1,0,0,0,5862,5709,1,0,0,0,5862,5712,1,0,0,0,5862,5732,1,0,0,0,5862,5737,
  	1,0,0,0,5862,5751,1,0,0,0,5862,5758,1,0,0,0,5862,5762,1,0,0,0,5862,5766,
  	1,0,0,0,5862,5771,1,0,0,0,5862,5773,1,0,0,0,5862,5784,1,0,0,0,5862,5790,
  	1,0,0,0,5862,5799,1,0,0,0,5862,5803,1,0,0,0,5862,5809,1,0,0,0,5862,5821,
  	1,0,0,0,5862,5831,1,0,0,0,5862,5854,1,0,0,0,5863,485,1,0,0,0,5864,5875,
  	5,1159,0,0,5865,5875,5,1160,0,0,5866,5867,5,1136,0,0,5867,5869,5,1136,
  	0,0,5868,5866,1,0,0,0,5868,5869,1,0,0,0,5869,5870,1,0,0,0,5870,5872,7,
  	83,0,0,5871,5868,1,0,0,0,5871,5872,1,0,0,0,5872,5873,1,0,0,0,5873,5875,
  	3,574,287,0,5874,5864,1,0,0,0,5874,5865,1,0,0,0,5874,5871,1,0,0,0,5875,
  	487,1,0,0,0,5876,5877,5,25,0,0,5877,5890,5,153,0,0,5878,5890,5,844,0,
  	0,5879,5890,5,40,0,0,5880,5890,5,151,0,0,5881,5882,5,437,0,0,5882,5890,
  	5,634,0,0,5883,5884,5,131,0,0,5884,5890,5,634,0,0,5885,5887,7,55,0,0,
  	5886,5885,1,0,0,0,5886,5887,1,0,0,0,5887,5888,1,0,0,0,5888,5890,7,84,
  	0,0,5889,5876,1,0,0,0,5889,5878,1,0,0,0,5889,5879,1,0,0,0,5889,5880,1,
  	0,0,0,5889,5881,1,0,0,0,5889,5883,1,0,0,0,5889,5886,1,0,0,0,5890,489,
  	1,0,0,0,5891,5892,5,98,0,0,5892,5896,5,1147,0,0,5893,5894,5,190,0,0,5894,
  	5896,3,678,339,0,5895,5891,1,0,0,0,5895,5893,1,0,0,0,5896,491,1,0,0,0,
  	5897,5899,5,636,0,0,5898,5897,1,0,0,0,5898,5899,1,0,0,0,5899,5900,1,0,
  	0,0,5900,5915,5,410,0,0,5901,5902,5,477,0,0,5902,5915,5,634,0,0,5903,
  	5915,5,556,0,0,5904,5915,5,725,0,0,5905,5907,5,436,0,0,5906,5905,1,0,
  	0,0,5906,5907,1,0,0,0,5907,5908,1,0,0,0,5908,5915,5,563,0,0,5909,5915,
  	5,565,0,0,5910,5911,5,614,0,0,5911,5915,5,447,0,0,5912,5915,5,339,0,0,
  	5913,5915,5,383,0,0,5914,5898,1,0,0,0,5914,5901,1,0,0,0,5914,5903,1,0,
  	0,0,5914,5904,1,0,0,0,5914,5906,1,0,0,0,5914,5909,1,0,0,0,5914,5910,1,
  	0,0,0,5914,5912,1,0,0,0,5914,5913,1,0,0,0,5915,493,1,0,0,0,5916,5925,
  	5,416,0,0,5917,5918,5,172,0,0,5918,5925,5,634,0,0,5919,5921,5,436,0,0,
  	5920,5919,1,0,0,0,5920,5921,1,0,0,0,5921,5922,1,0,0,0,5922,5925,5,742,
  	0,0,5923,5925,5,655,0,0,5924,5916,1,0,0,0,5924,5917,1,0,0,0,5924,5920,
  	1,0,0,0,5924,5923,1,0,0,0,5925,495,1,0,0,0,5926,5939,5,6,0,0,5927,5928,
  	5,347,0,0,5928,5939,5,461,0,0,5929,5930,5,382,0,0,5930,5939,5,645,0,0,
  	5931,5939,5,385,0,0,5932,5939,5,463,0,0,5933,5939,5,792,0,0,5934,5935,
  	5,544,0,0,5935,5939,5,426,0,0,5936,5939,5,621,0,0,5937,5939,5,644,0,0,
  	5938,5926,1,0,0,0,5938,5927,1,0,0,0,5938,5929,1,0,0,0,5938,5931,1,0,0,
  	0,5938,5932,1,0,0,0,5938,5933,1,0,0,0,5938,5934,1,0,0,0,5938,5936,1,0,
  	0,0,5938,5937,1,0,0,0,5939,497,1,0,0,0,5940,5941,5,345,0,0,5941,5942,
  	5,1147,0,0,5942,499,1,0,0,0,5943,5944,5,351,0,0,5944,5945,5,81,0,0,5945,
  	5950,3,512,256,0,5946,5947,5,1134,0,0,5947,5949,3,512,256,0,5948,5946,
  	1,0,0,0,5949,5952,1,0,0,0,5950,5948,1,0,0,0,5950,5951,1,0,0,0,5951,5960,
  	1,0,0,0,5952,5950,1,0,0,0,5953,5954,5,129,0,0,5954,5957,5,1132,0,0,5955,
  	5958,3,606,303,0,5956,5958,5,6,0,0,5957,5955,1,0,0,0,5957,5956,1,0,0,
  	0,5958,5959,1,0,0,0,5959,5961,5,1133,0,0,5960,5953,1,0,0,0,5960,5961,
  	1,0,0,0,5961,5962,1,0,0,0,5962,5963,5,80,0,0,5963,5964,3,574,287,0,5964,
  	501,1,0,0,0,5965,5967,5,432,0,0,5966,5968,7,72,0,0,5967,5966,1,0,0,0,
  	5967,5968,1,0,0,0,5968,5969,1,0,0,0,5969,5974,3,514,257,0,5970,5971,5,
  	1134,0,0,5971,5973,3,514,257,0,5972,5970,1,0,0,0,5973,5976,1,0,0,0,5974,
  	5972,1,0,0,0,5974,5975,1,0,0,0,5975,503,1,0,0,0,5976,5974,1,0,0,0,5977,
  	5979,5,93,0,0,5978,5980,7,85,0,0,5979,5978,1,0,0,0,5979,5980,1,0,0,0,
  	5980,5981,1,0,0,0,5981,5982,3,678,339,0,5982,505,1,0,0,0,5983,5984,5,
  	102,0,0,5984,5985,5,81,0,0,5985,5986,5,87,0,0,5986,5987,5,351,0,0,5987,
  	5992,3,518,259,0,5988,5989,5,1134,0,0,5989,5991,3,518,259,0,5990,5988,
  	1,0,0,0,5991,5994,1,0,0,0,5992,5990,1,0,0,0,5992,5993,1,0,0,0,5993,507,
  	1,0,0,0,5994,5992,1,0,0,0,5995,5996,5,589,0,0,5996,5997,5,567,0,0,5997,
  	5998,5,351,0,0,5998,509,1,0,0,0,5999,6000,5,739,0,0,6000,511,1,0,0,0,
  	6001,6009,3,546,273,0,6002,6004,7,20,0,0,6003,6002,1,0,0,0,6003,6004,
  	1,0,0,0,6004,6005,1,0,0,0,6005,6006,5,1132,0,0,6006,6007,3,606,303,0,
  	6007,6008,5,1133,0,0,6008,6010,1,0,0,0,6009,6003,1,0,0,0,6009,6010,1,
  	0,0,0,6010,513,1,0,0,0,6011,6030,5,394,0,0,6012,6030,5,447,0,0,6013,6015,
  	7,86,0,0,6014,6013,1,0,0,0,6014,6015,1,0,0,0,6015,6016,1,0,0,0,6016,6030,
  	5,476,0,0,6017,6030,5,540,0,0,6018,6030,5,725,0,0,6019,6020,5,567,0,0,
  	6020,6030,5,351,0,0,6021,6030,5,634,0,0,6022,6030,5,667,0,0,6023,6027,
  	5,742,0,0,6024,6025,5,192,0,0,6025,6026,5,134,0,0,6026,6028,5,103,0,0,
  	6027,6024,1,0,0,0,6027,6028,1,0,0,0,6028,6030,1,0,0,0,6029,6011,1,0,0,
  	0,6029,6012,1,0,0,0,6029,6014,1,0,0,0,6029,6017,1,0,0,0,6029,6018,1,0,
  	0,0,6029,6019,1,0,0,0,6029,6021,1,0,0,0,6029,6022,1,0,0,0,6029,6023,1,
  	0,0,0,6030,6044,1,0,0,0,6031,6032,5,574,0,0,6032,6034,5,476,0,0,6033,
  	6035,3,352,176,0,6034,6033,1,0,0,0,6034,6035,1,0,0,0,6035,6044,1,0,0,
  	0,6036,6038,7,54,0,0,6037,6039,3,610,305,0,6038,6037,1,0,0,0,6038,6039,
  	1,0,0,0,6039,6041,1,0,0,0,6040,6042,3,516,258,0,6041,6040,1,0,0,0,6041,
  	6042,1,0,0,0,6042,6044,1,0,0,0,6043,6029,1,0,0,0,6043,6031,1,0,0,0,6043,
  	6036,1,0,0,0,6044,515,1,0,0,0,6045,6046,5,192,0,0,6046,6047,5,134,0,0,
  	6047,6051,5,103,0,0,6048,6049,5,65,0,0,6049,6051,5,421,0,0,6050,6045,
  	1,0,0,0,6050,6048,1,0,0,0,6051,517,1,0,0,0,6052,6060,3,546,273,0,6053,
  	6054,5,129,0,0,6054,6057,5,1132,0,0,6055,6058,3,606,303,0,6056,6058,5,
  	6,0,0,6057,6055,1,0,0,0,6057,6056,1,0,0,0,6058,6059,1,0,0,0,6059,6061,
  	5,1133,0,0,6060,6053,1,0,0,0,6060,6061,1,0,0,0,6061,6069,1,0,0,0,6062,
  	6064,7,20,0,0,6063,6062,1,0,0,0,6063,6064,1,0,0,0,6064,6065,1,0,0,0,6065,
  	6066,5,1132,0,0,6066,6067,3,606,303,0,6067,6068,5,1133,0,0,6068,6070,
  	1,0,0,0,6069,6063,1,0,0,0,6069,6070,1,0,0,0,6070,6073,1,0,0,0,6071,6072,
  	5,78,0,0,6072,6074,5,470,0,0,6073,6071,1,0,0,0,6073,6074,1,0,0,0,6074,
  	519,1,0,0,0,6075,6076,7,87,0,0,6076,6079,3,546,273,0,6077,6080,3,574,
  	287,0,6078,6080,5,1147,0,0,6079,6077,1,0,0,0,6079,6078,1,0,0,0,6079,6080,
  	1,0,0,0,6080,521,1,0,0,0,6081,6085,7,87,0,0,6082,6083,7,88,0,0,6083,6084,
  	5,1123,0,0,6084,6086,7,89,0,0,6085,6082,1,0,0,0,6085,6086,1,0,0,0,6086,
  	6087,1,0,0,0,6087,6088,3,542,271,0,6088,523,1,0,0,0,6089,6090,5,444,0,
  	0,6090,6091,5,1147,0,0,6091,525,1,0,0,0,6092,6093,5,186,0,0,6093,6094,
  	3,574,287,0,6094,527,1,0,0,0,6095,6103,5,156,0,0,6096,6098,5,162,0,0,
  	6097,6099,5,669,0,0,6098,6097,1,0,0,0,6098,6099,1,0,0,0,6099,6100,1,0,
  	0,0,6100,6104,3,584,292,0,6101,6104,5,1155,0,0,6102,6104,5,1156,0,0,6103,
  	6096,1,0,0,0,6103,6101,1,0,0,0,6103,6102,1,0,0,0,6104,6114,1,0,0,0,6105,
  	6106,5,153,0,0,6106,6111,3,532,266,0,6107,6108,5,1134,0,0,6108,6110,3,
  	532,266,0,6109,6107,1,0,0,0,6110,6113,1,0,0,0,6111,6109,1,0,0,0,6111,
  	6112,1,0,0,0,6112,6115,1,0,0,0,6113,6111,1,0,0,0,6114,6105,1,0,0,0,6114,
  	6115,1,0,0,0,6115,529,1,0,0,0,6116,6124,5,143,0,0,6117,6119,5,162,0,0,
  	6118,6120,5,669,0,0,6119,6118,1,0,0,0,6119,6120,1,0,0,0,6120,6121,1,0,
  	0,0,6121,6125,3,584,292,0,6122,6125,5,1155,0,0,6123,6125,5,1156,0,0,6124,
  	6117,1,0,0,0,6124,6122,1,0,0,0,6124,6123,1,0,0,0,6124,6125,1,0,0,0,6125,
  	6135,1,0,0,0,6126,6127,5,153,0,0,6127,6132,3,532,266,0,6128,6129,5,1134,
  	0,0,6129,6131,3,532,266,0,6130,6128,1,0,0,0,6131,6134,1,0,0,0,6132,6130,
  	1,0,0,0,6132,6133,1,0,0,0,6133,6136,1,0,0,0,6134,6132,1,0,0,0,6135,6126,
  	1,0,0,0,6135,6136,1,0,0,0,6136,531,1,0,0,0,6137,6138,7,90,0,0,6138,6143,
  	5,1123,0,0,6139,6144,3,584,292,0,6140,6144,5,1148,0,0,6141,6144,3,556,
  	278,0,6142,6144,3,576,288,0,6143,6139,1,0,0,0,6143,6140,1,0,0,0,6143,
  	6141,1,0,0,0,6143,6142,1,0,0,0,6144,533,1,0,0,0,6145,6147,5,192,0,0,6146,
  	6148,5,571,0,0,6147,6146,1,0,0,0,6147,6148,1,0,0,0,6148,6149,1,0,0,0,
  	6149,6154,3,50,25,0,6150,6151,5,1134,0,0,6151,6153,3,50,25,0,6152,6150,
  	1,0,0,0,6153,6156,1,0,0,0,6154,6152,1,0,0,0,6154,6155,1,0,0,0,6155,535,
  	1,0,0,0,6156,6154,1,0,0,0,6157,6158,5,172,0,0,6158,6160,3,546,273,0,6159,
  	6161,3,228,114,0,6160,6159,1,0,0,0,6160,6161,1,0,0,0,6161,6163,1,0,0,
  	0,6162,6164,3,290,145,0,6163,6162,1,0,0,0,6163,6164,1,0,0,0,6164,537,
  	1,0,0,0,6165,6167,5,71,0,0,6166,6168,7,91,0,0,6167,6166,1,0,0,0,6167,
  	6168,1,0,0,0,6168,6169,1,0,0,0,6169,6201,5,48,0,0,6170,6171,3,486,243,
  	0,6171,6172,5,1123,0,0,6172,6180,7,92,0,0,6173,6174,5,1134,0,0,6174,6175,
  	3,486,243,0,6175,6176,5,1123,0,0,6176,6177,7,92,0,0,6177,6179,1,0,0,0,
  	6178,6173,1,0,0,0,6179,6182,1,0,0,0,6180,6178,1,0,0,0,6180,6181,1,0,0,
  	0,6181,6202,1,0,0,0,6182,6180,1,0,0,0,6183,6186,5,29,0,0,6184,6187,3,
  	580,290,0,6185,6187,3,486,243,0,6186,6184,1,0,0,0,6186,6185,1,0,0,0,6187,
  	6188,1,0,0,0,6188,6189,3,486,243,0,6189,6190,5,1123,0,0,6190,6198,3,540,
  	270,0,6191,6192,5,1134,0,0,6192,6193,3,486,243,0,6193,6194,5,1123,0,0,
  	6194,6195,3,540,270,0,6195,6197,1,0,0,0,6196,6191,1,0,0,0,6197,6200,1,
  	0,0,0,6198,6196,1,0,0,0,6198,6199,1,0,0,0,6199,6202,1,0,0,0,6200,6198,
  	1,0,0,0,6201,6170,1,0,0,0,6201,6183,1,0,0,0,6202,539,1,0,0,0,6203,6204,
  	7,93,0,0,6204,541,1,0,0,0,6205,6211,3,198,99,0,6206,6211,3,184,92,0,6207,
  	6211,3,190,95,0,6208,6211,3,196,98,0,6209,6211,3,200,100,0,6210,6205,
  	1,0,0,0,6210,6206,1,0,0,0,6210,6207,1,0,0,0,6210,6208,1,0,0,0,6210,6209,
  	1,0,0,0,6211,6216,1,0,0,0,6212,6213,5,65,0,0,6213,6214,5,376,0,0,6214,
  	6216,3,574,287,0,6215,6210,1,0,0,0,6215,6212,1,0,0,0,6216,543,1,0,0,0,
  	6217,6221,3,574,287,0,6218,6222,5,1154,0,0,6219,6220,5,1131,0,0,6220,
  	6222,3,574,287,0,6221,6218,1,0,0,0,6221,6219,1,0,0,0,6221,6222,1,0,0,
  	0,6222,545,1,0,0,0,6223,6224,3,544,272,0,6224,547,1,0,0,0,6225,6228,3,
  	554,277,0,6226,6228,3,574,287,0,6227,6225,1,0,0,0,6227,6226,1,0,0,0,6228,
  	549,1,0,0,0,6229,6234,3,574,287,0,6230,6232,3,578,289,0,6231,6233,3,578,
  	289,0,6232,6231,1,0,0,0,6232,6233,1,0,0,0,6233,6235,1,0,0,0,6234,6230,
  	1,0,0,0,6234,6235,1,0,0,0,6235,6244,1,0,0,0,6236,6238,9,0,0,0,6237,6236,
  	1,0,0,0,6237,6238,1,0,0,0,6238,6239,1,0,0,0,6239,6241,3,578,289,0,6240,
  	6242,3,578,289,0,6241,6240,1,0,0,0,6241,6242,1,0,0,0,6242,6244,1,0,0,
  	0,6243,6229,1,0,0,0,6243,6237,1,0,0,0,6244,551,1,0,0,0,6245,6248,3,574,
  	287,0,6246,6248,5,1147,0,0,6247,6245,1,0,0,0,6247,6246,1,0,0,0,6248,6253,
  	1,0,0,0,6249,6250,5,1132,0,0,6250,6251,3,580,290,0,6251,6252,5,1133,0,
  	0,6252,6254,1,0,0,0,6253,6249,1,0,0,0,6253,6254,1,0,0,0,6254,6257,1,0,
  	0,0,6255,6257,3,678,339,0,6256,6247,1,0,0,0,6256,6255,1,0,0,0,6257,6259,
  	1,0,0,0,6258,6260,7,48,0,0,6259,6258,1,0,0,0,6259,6260,1,0,0,0,6260,553,
  	1,0,0,0,6261,6267,5,1157,0,0,6262,6267,5,1155,0,0,6263,6267,5,1147,0,
  	0,6264,6267,5,697,0,0,6265,6267,3,706,353,0,6266,6261,1,0,0,0,6266,6262,
  	1,0,0,0,6266,6263,1,0,0,0,6266,6264,1,0,0,0,6266,6265,1,0,0,0,6267,555,
  	1,0,0,0,6268,6269,7,94,0,0,6269,557,1,0,0,0,6270,6275,5,226,0,0,6271,
  	6275,3,696,348,0,6272,6275,5,1147,0,0,6273,6275,5,1144,0,0,6274,6270,
  	1,0,0,0,6274,6271,1,0,0,0,6274,6272,1,0,0,0,6274,6273,1,0,0,0,6275,559,
  	1,0,0,0,6276,6279,3,574,287,0,6277,6279,5,1147,0,0,6278,6276,1,0,0,0,
  	6278,6277,1,0,0,0,6279,561,1,0,0,0,6280,6284,3,564,282,0,6281,6284,5,
  	1155,0,0,6282,6284,5,1147,0,0,6283,6280,1,0,0,0,6283,6281,1,0,0,0,6283,
  	6282,1,0,0,0,6284,563,1,0,0,0,6285,6286,7,95,0,0,6286,565,1,0,0,0,6287,
  	6288,3,580,290,0,6288,6289,5,1120,0,0,6289,6290,3,580,290,0,6290,6291,
  	5,1120,0,0,6291,6292,3,580,290,0,6292,6293,5,1120,0,0,6293,6294,3,580,
  	290,0,6294,6295,5,1120,0,0,6295,6301,3,580,290,0,6296,6297,5,1143,0,0,
  	6297,6298,3,580,290,0,6298,6299,5,1120,0,0,6299,6300,3,580,290,0,6300,
  	6302,1,0,0,0,6301,6296,1,0,0,0,6302,6303,1,0,0,0,6303,6301,1,0,0,0,6303,
  	6304,1,0,0,0,6304,567,1,0,0,0,6305,6312,3,570,285,0,6306,6307,5,1134,
  	0,0,6307,6310,3,570,285,0,6308,6309,5,1134,0,0,6309,6311,3,580,290,0,
  	6310,6308,1,0,0,0,6310,6311,1,0,0,0,6311,6313,1,0,0,0,6312,6306,1,0,0,
  	0,6312,6313,1,0,0,0,6313,569,1,0,0,0,6314,6322,5,1147,0,0,6315,6322,5,
  	1152,0,0,6316,6318,5,1149,0,0,6317,6316,1,0,0,0,6318,6319,1,0,0,0,6319,
  	6317,1,0,0,0,6319,6320,1,0,0,0,6320,6322,1,0,0,0,6321,6314,1,0,0,0,6321,
  	6315,1,0,0,0,6321,6317,1,0,0,0,6322,571,1,0,0,0,6323,6326,3,574,287,0,
  	6324,6326,5,1147,0,0,6325,6323,1,0,0,0,6325,6324,1,0,0,0,6326,573,1,0,
  	0,0,6327,6331,3,576,288,0,6328,6331,5,1144,0,0,6329,6331,5,1147,0,0,6330,
  	6327,1,0,0,0,6330,6328,1,0,0,0,6330,6329,1,0,0,0,6331,575,1,0,0,0,6332,
  	6342,5,1155,0,0,6333,6342,3,696,348,0,6334,6342,3,698,349,0,6335,6342,
  	3,564,282,0,6336,6342,3,700,350,0,6337,6342,3,702,351,0,6338,6342,3,704,
  	352,0,6339,6342,3,706,353,0,6340,6342,3,670,335,0,6341,6332,1,0,0,0,6341,
  	6333,1,0,0,0,6341,6334,1,0,0,0,6341,6335,1,0,0,0,6341,6336,1,0,0,0,6341,
  	6337,1,0,0,0,6341,6338,1,0,0,0,6341,6339,1,0,0,0,6341,6340,1,0,0,0,6342,
  	577,1,0,0,0,6343,6347,5,1154,0,0,6344,6345,5,1131,0,0,6345,6347,3,574,
  	287,0,6346,6343,1,0,0,0,6346,6344,1,0,0,0,6347,579,1,0,0,0,6348,6349,
  	7,96,0,0,6349,581,1,0,0,0,6350,6353,5,1145,0,0,6351,6353,3,580,290,0,
  	6352,6350,1,0,0,0,6352,6351,1,0,0,0,6353,583,1,0,0,0,6354,6356,5,1153,
  	0,0,6355,6354,1,0,0,0,6355,6356,1,0,0,0,6356,6357,1,0,0,0,6357,6360,5,
  	1147,0,0,6358,6360,5,1146,0,0,6359,6355,1,0,0,0,6359,6358,1,0,0,0,6360,
  	6362,1,0,0,0,6361,6363,5,1147,0,0,6362,6361,1,0,0,0,6363,6364,1,0,0,0,
  	6364,6362,1,0,0,0,6364,6365,1,0,0,0,6365,6378,1,0,0,0,6366,6368,5,1153,
  	0,0,6367,6366,1,0,0,0,6367,6368,1,0,0,0,6368,6369,1,0,0,0,6369,6372,5,
  	1147,0,0,6370,6372,5,1146,0,0,6371,6367,1,0,0,0,6371,6370,1,0,0,0,6372,
  	6375,1,0,0,0,6373,6374,5,27,0,0,6374,6376,3,560,280,0,6375,6373,1,0,0,
  	0,6375,6376,1,0,0,0,6376,6378,1,0,0,0,6377,6359,1,0,0,0,6377,6371,1,0,
  	0,0,6378,585,1,0,0,0,6379,6380,7,97,0,0,6380,587,1,0,0,0,6381,6383,5,
  	1153,0,0,6382,6381,1,0,0,0,6382,6383,1,0,0,0,6383,6384,1,0,0,0,6384,6385,
  	5,1149,0,0,6385,589,1,0,0,0,6386,6388,5,114,0,0,6387,6386,1,0,0,0,6387,
  	6388,1,0,0,0,6388,6389,1,0,0,0,6389,6390,7,98,0,0,6390,591,1,0,0,0,6391,
  	6404,3,584,292,0,6392,6404,3,580,290,0,6393,6394,5,1120,0,0,6394,6404,
  	3,580,290,0,6395,6404,3,588,294,0,6396,6404,3,586,293,0,6397,6404,5,1150,
  	0,0,6398,6404,5,1152,0,0,6399,6401,5,114,0,0,6400,6399,1,0,0,0,6400,6401,
  	1,0,0,0,6401,6402,1,0,0,0,6402,6404,7,98,0,0,6403,6391,1,0,0,0,6403,6392,
  	1,0,0,0,6403,6393,1,0,0,0,6403,6395,1,0,0,0,6403,6396,1,0,0,0,6403,6397,
  	1,0,0,0,6403,6398,1,0,0,0,6403,6400,1,0,0,0,6404,593,1,0,0,0,6405,6407,
  	7,99,0,0,6406,6408,5,238,0,0,6407,6406,1,0,0,0,6407,6408,1,0,0,0,6408,
  	6410,1,0,0,0,6409,6411,3,600,300,0,6410,6409,1,0,0,0,6410,6411,1,0,0,
  	0,6411,6413,1,0,0,0,6412,6414,5,226,0,0,6413,6412,1,0,0,0,6413,6414,1,
  	0,0,0,6414,6418,1,0,0,0,6415,6416,3,60,30,0,6416,6417,3,558,279,0,6417,
  	6419,1,0,0,0,6418,6415,1,0,0,0,6418,6419,1,0,0,0,6419,6423,1,0,0,0,6420,
  	6421,5,27,0,0,6421,6424,3,560,280,0,6422,6424,5,226,0,0,6423,6420,1,0,
  	0,0,6423,6422,1,0,0,0,6423,6424,1,0,0,0,6424,6532,1,0,0,0,6425,6426,5,
  	225,0,0,6426,6427,7,100,0,0,6427,6429,5,238,0,0,6428,6430,3,600,300,0,
  	6429,6428,1,0,0,0,6429,6430,1,0,0,0,6430,6432,1,0,0,0,6431,6433,5,226,
  	0,0,6432,6431,1,0,0,0,6432,6433,1,0,0,0,6433,6532,1,0,0,0,6434,6435,5,
  	225,0,0,6435,6437,7,101,0,0,6436,6438,3,600,300,0,6437,6436,1,0,0,0,6437,
  	6438,1,0,0,0,6438,6440,1,0,0,0,6439,6441,5,226,0,0,6440,6439,1,0,0,0,
  	6440,6441,1,0,0,0,6441,6532,1,0,0,0,6442,6443,5,518,0,0,6443,6445,5,223,
  	0,0,6444,6446,3,600,300,0,6445,6444,1,0,0,0,6445,6446,1,0,0,0,6446,6448,
  	1,0,0,0,6447,6449,5,226,0,0,6448,6447,1,0,0,0,6448,6449,1,0,0,0,6449,
  	6532,1,0,0,0,6450,6452,7,102,0,0,6451,6453,3,600,300,0,6452,6451,1,0,
  	0,0,6452,6453,1,0,0,0,6453,6457,1,0,0,0,6454,6456,7,103,0,0,6455,6454,
  	1,0,0,0,6456,6459,1,0,0,0,6457,6455,1,0,0,0,6457,6458,1,0,0,0,6458,6532,
  	1,0,0,0,6459,6457,1,0,0,0,6460,6462,5,208,0,0,6461,6463,3,602,301,0,6462,
  	6461,1,0,0,0,6462,6463,1,0,0,0,6463,6467,1,0,0,0,6464,6466,7,103,0,0,
  	6465,6464,1,0,0,0,6466,6469,1,0,0,0,6467,6465,1,0,0,0,6467,6468,1,0,0,
  	0,6468,6532,1,0,0,0,6469,6467,1,0,0,0,6470,6472,5,209,0,0,6471,6473,5,
  	210,0,0,6472,6471,1,0,0,0,6472,6473,1,0,0,0,6473,6475,1,0,0,0,6474,6476,
  	3,602,301,0,6475,6474,1,0,0,0,6475,6476,1,0,0,0,6476,6480,1,0,0,0,6477,
  	6479,7,103,0,0,6478,6477,1,0,0,0,6479,6482,1,0,0,0,6480,6478,1,0,0,0,
  	6480,6481,1,0,0,0,6481,6532,1,0,0,0,6482,6480,1,0,0,0,6483,6485,7,104,
  	0,0,6484,6486,3,604,302,0,6485,6484,1,0,0,0,6485,6486,1,0,0,0,6486,6490,
  	1,0,0,0,6487,6489,7,103,0,0,6488,6487,1,0,0,0,6489,6492,1,0,0,0,6490,
  	6488,1,0,0,0,6490,6491,1,0,0,0,6491,6532,1,0,0,0,6492,6490,1,0,0,0,6493,
  	6532,7,105,0,0,6494,6496,7,106,0,0,6495,6497,3,600,300,0,6496,6495,1,
  	0,0,0,6496,6497,1,0,0,0,6497,6532,1,0,0,0,6498,6499,7,107,0,0,6499,6501,
  	3,596,298,0,6500,6502,5,226,0,0,6501,6500,1,0,0,0,6501,6502,1,0,0,0,6502,
  	6506,1,0,0,0,6503,6504,3,60,30,0,6504,6505,3,558,279,0,6505,6507,1,0,
  	0,0,6506,6503,1,0,0,0,6506,6507,1,0,0,0,6507,6532,1,0,0,0,6508,6511,7,
  	108,0,0,6509,6510,5,1011,0,0,6510,6512,3,580,290,0,6511,6509,1,0,0,0,
  	6511,6512,1,0,0,0,6512,6532,1,0,0,0,6513,6515,5,231,0,0,6514,6516,5,223,
  	0,0,6515,6514,1,0,0,0,6515,6516,1,0,0,0,6516,6518,1,0,0,0,6517,6519,5,
  	226,0,0,6518,6517,1,0,0,0,6518,6519,1,0,0,0,6519,6523,1,0,0,0,6520,6521,
  	3,60,30,0,6521,6522,3,558,279,0,6522,6524,1,0,0,0,6523,6520,1,0,0,0,6523,
  	6524,1,0,0,0,6524,6527,1,0,0,0,6525,6526,5,27,0,0,6526,6528,3,560,280,
  	0,6527,6525,1,0,0,0,6527,6528,1,0,0,0,6528,6532,1,0,0,0,6529,6530,5,231,
  	0,0,6530,6532,5,227,0,0,6531,6405,1,0,0,0,6531,6425,1,0,0,0,6531,6434,
  	1,0,0,0,6531,6442,1,0,0,0,6531,6450,1,0,0,0,6531,6460,1,0,0,0,6531,6470,
  	1,0,0,0,6531,6483,1,0,0,0,6531,6493,1,0,0,0,6531,6494,1,0,0,0,6531,6498,
  	1,0,0,0,6531,6508,1,0,0,0,6531,6513,1,0,0,0,6531,6529,1,0,0,0,6532,595,
  	1,0,0,0,6533,6534,5,1132,0,0,6534,6539,5,1147,0,0,6535,6536,5,1134,0,
  	0,6536,6538,5,1147,0,0,6537,6535,1,0,0,0,6538,6541,1,0,0,0,6539,6537,
  	1,0,0,0,6539,6540,1,0,0,0,6540,6542,1,0,0,0,6541,6539,1,0,0,0,6542,6543,
  	5,1133,0,0,6543,597,1,0,0,0,6544,6546,7,109,0,0,6545,6547,3,600,300,0,
  	6546,6545,1,0,0,0,6546,6547,1,0,0,0,6547,6567,1,0,0,0,6548,6550,5,222,
  	0,0,6549,6551,3,600,300,0,6550,6549,1,0,0,0,6550,6551,1,0,0,0,6551,6555,
  	1,0,0,0,6552,6553,3,60,30,0,6553,6554,3,558,279,0,6554,6556,1,0,0,0,6555,
  	6552,1,0,0,0,6555,6556,1,0,0,0,6556,6567,1,0,0,0,6557,6567,7,110,0,0,
  	6558,6560,5,214,0,0,6559,6561,3,604,302,0,6560,6559,1,0,0,0,6560,6561,
  	1,0,0,0,6561,6567,1,0,0,0,6562,6564,7,111,0,0,6563,6565,5,206,0,0,6564,
  	6563,1,0,0,0,6564,6565,1,0,0,0,6565,6567,1,0,0,0,6566,6544,1,0,0,0,6566,
  	6548,1,0,0,0,6566,6557,1,0,0,0,6566,6558,1,0,0,0,6566,6562,1,0,0,0,6567,
  	6569,1,0,0,0,6568,6570,5,11,0,0,6569,6568,1,0,0,0,6569,6570,1,0,0,0,6570,
  	599,1,0,0,0,6571,6572,5,1132,0,0,6572,6573,3,580,290,0,6573,6574,5,1133,
  	0,0,6574,601,1,0,0,0,6575,6576,5,1132,0,0,6576,6577,3,580,290,0,6577,
  	6578,5,1134,0,0,6578,6579,3,580,290,0,6579,6580,5,1133,0,0,6580,603,1,
  	0,0,0,6581,6582,5,1132,0,0,6582,6585,3,580,290,0,6583,6584,5,1134,0,0,
  	6584,6586,3,580,290,0,6585,6583,1,0,0,0,6585,6586,1,0,0,0,6586,6587,1,
  	0,0,0,6587,6588,5,1133,0,0,6588,605,1,0,0,0,6589,6594,3,574,287,0,6590,
  	6591,5,1134,0,0,6591,6593,3,574,287,0,6592,6590,1,0,0,0,6593,6596,1,0,
  	0,0,6594,6592,1,0,0,0,6594,6595,1,0,0,0,6595,607,1,0,0,0,6596,6594,1,
  	0,0,0,6597,6602,3,550,275,0,6598,6599,5,1134,0,0,6599,6601,3,550,275,
  	0,6600,6598,1,0,0,0,6601,6604,1,0,0,0,6602,6600,1,0,0,0,6602,6603,1,0,
  	0,0,6603,609,1,0,0,0,6604,6602,1,0,0,0,6605,6610,3,546,273,0,6606,6607,
  	5,1134,0,0,6607,6609,3,546,273,0,6608,6606,1,0,0,0,6609,6612,1,0,0,0,
  	6610,6608,1,0,0,0,6610,6611,1,0,0,0,6611,611,1,0,0,0,6612,6610,1,0,0,
  	0,6613,6614,5,1132,0,0,6614,6619,3,552,276,0,6615,6616,5,1134,0,0,6616,
  	6618,3,552,276,0,6617,6615,1,0,0,0,6618,6621,1,0,0,0,6619,6617,1,0,0,
  	0,6619,6620,1,0,0,0,6620,6622,1,0,0,0,6621,6619,1,0,0,0,6622,6623,5,1133,
  	0,0,6623,613,1,0,0,0,6624,6629,3,678,339,0,6625,6626,5,1134,0,0,6626,
  	6628,3,678,339,0,6627,6625,1,0,0,0,6628,6631,1,0,0,0,6629,6627,1,0,0,
  	0,6629,6630,1,0,0,0,6630,615,1,0,0,0,6631,6629,1,0,0,0,6632,6637,3,628,
  	314,0,6633,6634,5,1134,0,0,6634,6636,3,628,314,0,6635,6633,1,0,0,0,6636,
  	6639,1,0,0,0,6637,6635,1,0,0,0,6637,6638,1,0,0,0,6638,617,1,0,0,0,6639,
  	6637,1,0,0,0,6640,6645,3,592,296,0,6641,6642,5,1134,0,0,6642,6644,3,592,
  	296,0,6643,6641,1,0,0,0,6644,6647,1,0,0,0,6645,6643,1,0,0,0,6645,6646,
  	1,0,0,0,6646,619,1,0,0,0,6647,6645,1,0,0,0,6648,6653,5,1147,0,0,6649,
  	6650,5,1134,0,0,6650,6652,5,1147,0,0,6651,6649,1,0,0,0,6652,6655,1,0,
  	0,0,6653,6651,1,0,0,0,6653,6654,1,0,0,0,6654,621,1,0,0,0,6655,6653,1,
  	0,0,0,6656,6661,5,1159,0,0,6657,6658,5,1134,0,0,6658,6660,5,1159,0,0,
  	6659,6657,1,0,0,0,6660,6663,1,0,0,0,6661,6659,1,0,0,0,6661,6662,1,0,0,
  	0,6662,623,1,0,0,0,6663,6661,1,0,0,0,6664,6691,5,116,0,0,6665,6666,5,
  	23,0,0,6666,6667,5,1132,0,0,6667,6668,3,678,339,0,6668,6669,5,12,0,0,
  	6669,6670,3,598,299,0,6670,6671,5,1133,0,0,6671,6691,1,0,0,0,6672,6674,
  	3,684,342,0,6673,6672,1,0,0,0,6673,6674,1,0,0,0,6674,6675,1,0,0,0,6675,
  	6691,3,592,296,0,6676,6680,3,626,313,0,6677,6678,5,118,0,0,6678,6679,
  	5,184,0,0,6679,6681,3,626,313,0,6680,6677,1,0,0,0,6680,6681,1,0,0,0,6681,
  	6691,1,0,0,0,6682,6683,5,1132,0,0,6683,6684,3,678,339,0,6684,6685,5,1133,
  	0,0,6685,6691,1,0,0,0,6686,6687,5,1132,0,0,6687,6688,3,544,272,0,6688,
  	6689,5,1133,0,0,6689,6691,1,0,0,0,6690,6664,1,0,0,0,6690,6665,1,0,0,0,
  	6690,6673,1,0,0,0,6690,6676,1,0,0,0,6690,6682,1,0,0,0,6690,6686,1,0,0,
  	0,6691,625,1,0,0,0,6692,6698,7,112,0,0,6693,6695,5,1132,0,0,6694,6696,
  	3,580,290,0,6695,6694,1,0,0,0,6695,6696,1,0,0,0,6696,6697,1,0,0,0,6697,
  	6699,5,1133,0,0,6698,6693,1,0,0,0,6698,6699,1,0,0,0,6699,6707,1,0,0,0,
  	6700,6701,5,323,0,0,6701,6703,5,1132,0,0,6702,6704,3,580,290,0,6703,6702,
  	1,0,0,0,6703,6704,1,0,0,0,6704,6705,1,0,0,0,6705,6707,5,1133,0,0,6706,
  	6692,1,0,0,0,6706,6700,1,0,0,0,6707,627,1,0,0,0,6708,6711,3,678,339,0,
  	6709,6711,5,42,0,0,6710,6708,1,0,0,0,6710,6709,1,0,0,0,6711,629,1,0,0,
  	0,6712,6713,5,77,0,0,6713,6714,5,60,0,0,6714,631,1,0,0,0,6715,6716,5,
  	77,0,0,6716,6717,5,114,0,0,6717,6718,5,60,0,0,6718,633,1,0,0,0,6719,6720,
  	5,123,0,0,6720,6721,5,141,0,0,6721,635,1,0,0,0,6722,6723,5,674,0,0,6723,
  	6726,3,580,290,0,6724,6726,5,527,0,0,6725,6722,1,0,0,0,6725,6724,1,0,
  	0,0,6726,637,1,0,0,0,6727,6746,3,640,320,0,6728,6746,3,648,324,0,6729,
  	6746,3,650,325,0,6730,6731,3,670,335,0,6731,6733,5,1132,0,0,6732,6734,
  	3,674,337,0,6733,6732,1,0,0,0,6733,6734,1,0,0,0,6734,6735,1,0,0,0,6735,
  	6736,5,1133,0,0,6736,6746,1,0,0,0,6737,6738,3,544,272,0,6738,6740,5,1132,
  	0,0,6739,6741,3,674,337,0,6740,6739,1,0,0,0,6740,6741,1,0,0,0,6741,6742,
  	1,0,0,0,6742,6743,5,1133,0,0,6743,6746,1,0,0,0,6744,6746,3,672,336,0,
  	6745,6727,1,0,0,0,6745,6728,1,0,0,0,6745,6729,1,0,0,0,6745,6730,1,0,0,
  	0,6745,6737,1,0,0,0,6745,6744,1,0,0,0,6746,639,1,0,0,0,6747,6750,7,113,
  	0,0,6748,6749,5,1132,0,0,6749,6751,5,1133,0,0,6750,6748,1,0,0,0,6750,
  	6751,1,0,0,0,6751,6926,1,0,0,0,6752,6753,5,32,0,0,6753,6754,5,1132,0,
  	0,6754,6755,3,678,339,0,6755,6756,5,1134,0,0,6756,6757,3,598,299,0,6757,
  	6758,5,1133,0,0,6758,6926,1,0,0,0,6759,6760,5,32,0,0,6760,6761,5,1132,
  	0,0,6761,6762,3,678,339,0,6762,6763,5,187,0,0,6763,6764,3,558,279,0,6764,
  	6765,5,1133,0,0,6765,6926,1,0,0,0,6766,6767,5,23,0,0,6767,6768,5,1132,
  	0,0,6768,6769,3,678,339,0,6769,6770,5,12,0,0,6770,6771,3,598,299,0,6771,
  	6772,5,1133,0,0,6772,6926,1,0,0,0,6773,6774,5,188,0,0,6774,6775,5,1132,
  	0,0,6775,6776,3,550,275,0,6776,6777,5,1133,0,0,6777,6926,1,0,0,0,6778,
  	6779,5,22,0,0,6779,6781,3,678,339,0,6780,6782,3,642,321,0,6781,6780,1,
  	0,0,0,6782,6783,1,0,0,0,6783,6781,1,0,0,0,6783,6784,1,0,0,0,6784,6787,
  	1,0,0,0,6785,6786,5,53,0,0,6786,6788,3,676,338,0,6787,6785,1,0,0,0,6787,
  	6788,1,0,0,0,6788,6789,1,0,0,0,6789,6790,5,407,0,0,6790,6926,1,0,0,0,
  	6791,6793,5,22,0,0,6792,6794,3,642,321,0,6793,6792,1,0,0,0,6794,6795,
  	1,0,0,0,6795,6793,1,0,0,0,6795,6796,1,0,0,0,6796,6799,1,0,0,0,6797,6798,
  	5,53,0,0,6798,6800,3,676,338,0,6799,6797,1,0,0,0,6799,6800,1,0,0,0,6800,
  	6801,1,0,0,0,6801,6802,5,407,0,0,6802,6926,1,0,0,0,6803,6804,5,222,0,
  	0,6804,6805,5,1132,0,0,6805,6808,3,674,337,0,6806,6807,5,187,0,0,6807,
  	6809,3,558,279,0,6808,6806,1,0,0,0,6808,6809,1,0,0,0,6809,6810,1,0,0,
  	0,6810,6811,5,1133,0,0,6811,6926,1,0,0,0,6812,6813,5,324,0,0,6813,6816,
  	5,1132,0,0,6814,6817,3,584,292,0,6815,6817,3,678,339,0,6816,6814,1,0,
  	0,0,6816,6815,1,0,0,0,6817,6818,1,0,0,0,6818,6821,5,80,0,0,6819,6822,
  	3,584,292,0,6820,6822,3,678,339,0,6821,6819,1,0,0,0,6821,6820,1,0,0,0,
  	6822,6823,1,0,0,0,6823,6824,5,1133,0,0,6824,6926,1,0,0,0,6825,6826,7,
  	114,0,0,6826,6829,5,1132,0,0,6827,6830,3,584,292,0,6828,6830,3,678,339,
  	0,6829,6827,1,0,0,0,6829,6828,1,0,0,0,6830,6831,1,0,0,0,6831,6834,5,68,
  	0,0,6832,6835,3,580,290,0,6833,6835,3,678,339,0,6834,6832,1,0,0,0,6834,
  	6833,1,0,0,0,6835,6841,1,0,0,0,6836,6839,5,65,0,0,6837,6840,3,580,290,
  	0,6838,6840,3,678,339,0,6839,6837,1,0,0,0,6839,6838,1,0,0,0,6840,6842,
  	1,0,0,0,6841,6836,1,0,0,0,6841,6842,1,0,0,0,6842,6843,1,0,0,0,6843,6844,
  	5,1133,0,0,6844,6926,1,0,0,0,6845,6846,5,328,0,0,6846,6847,5,1132,0,0,
  	6847,6850,7,115,0,0,6848,6851,3,584,292,0,6849,6851,3,678,339,0,6850,
  	6848,1,0,0,0,6850,6849,1,0,0,0,6850,6851,1,0,0,0,6851,6852,1,0,0,0,6852,
  	6855,5,68,0,0,6853,6856,3,584,292,0,6854,6856,3,678,339,0,6855,6853,1,
  	0,0,0,6855,6854,1,0,0,0,6856,6857,1,0,0,0,6857,6858,5,1133,0,0,6858,6926,
  	1,0,0,0,6859,6860,5,328,0,0,6860,6863,5,1132,0,0,6861,6864,3,584,292,
  	0,6862,6864,3,678,339,0,6863,6861,1,0,0,0,6863,6862,1,0,0,0,6864,6865,
  	1,0,0,0,6865,6868,5,68,0,0,6866,6869,3,584,292,0,6867,6869,3,678,339,
  	0,6868,6866,1,0,0,0,6868,6867,1,0,0,0,6869,6870,1,0,0,0,6870,6871,5,1133,
  	0,0,6871,6926,1,0,0,0,6872,6873,5,1102,0,0,6873,6876,5,1132,0,0,6874,
  	6877,3,584,292,0,6875,6877,3,678,339,0,6876,6874,1,0,0,0,6876,6875,1,
  	0,0,0,6877,6884,1,0,0,0,6878,6879,5,12,0,0,6879,6880,7,116,0,0,6880,6881,
  	5,1132,0,0,6881,6882,3,580,290,0,6882,6883,5,1133,0,0,6883,6885,1,0,0,
  	0,6884,6878,1,0,0,0,6884,6885,1,0,0,0,6885,6887,1,0,0,0,6886,6888,3,644,
  	322,0,6887,6886,1,0,0,0,6887,6888,1,0,0,0,6888,6889,1,0,0,0,6889,6890,
  	5,1133,0,0,6890,6926,1,0,0,0,6891,6892,5,321,0,0,6892,6893,5,1132,0,0,
  	6893,6894,3,70,35,0,6894,6897,5,68,0,0,6895,6898,3,584,292,0,6896,6898,
  	3,678,339,0,6897,6895,1,0,0,0,6897,6896,1,0,0,0,6898,6899,1,0,0,0,6899,
  	6900,5,1133,0,0,6900,6926,1,0,0,0,6901,6902,5,900,0,0,6902,6903,5,1132,
  	0,0,6903,6904,7,117,0,0,6904,6905,5,1134,0,0,6905,6906,3,584,292,0,6906,
  	6907,5,1133,0,0,6907,6926,1,0,0,0,6908,6909,5,282,0,0,6909,6910,5,1132,
  	0,0,6910,6911,3,678,339,0,6911,6912,5,1134,0,0,6912,6915,3,678,339,0,
  	6913,6914,5,593,0,0,6914,6916,3,598,299,0,6915,6913,1,0,0,0,6915,6916,
  	1,0,0,0,6916,6918,1,0,0,0,6917,6919,3,264,132,0,6918,6917,1,0,0,0,6918,
  	6919,1,0,0,0,6919,6921,1,0,0,0,6920,6922,3,266,133,0,6921,6920,1,0,0,
  	0,6921,6922,1,0,0,0,6922,6923,1,0,0,0,6923,6924,5,1133,0,0,6924,6926,
  	1,0,0,0,6925,6747,1,0,0,0,6925,6752,1,0,0,0,6925,6759,1,0,0,0,6925,6766,
  	1,0,0,0,6925,6773,1,0,0,0,6925,6778,1,0,0,0,6925,6791,1,0,0,0,6925,6803,
  	1,0,0,0,6925,6812,1,0,0,0,6925,6825,1,0,0,0,6925,6845,1,0,0,0,6925,6859,
  	1,0,0,0,6925,6872,1,0,0,0,6925,6891,1,0,0,0,6925,6901,1,0,0,0,6925,6908,
  	1,0,0,0,6926,641,1,0,0,0,6927,6928,5,189,0,0,6928,6929,3,676,338,0,6929,
  	6930,5,174,0,0,6930,6931,3,676,338,0,6931,643,1,0,0,0,6932,6933,5,472,
  	0,0,6933,6938,3,646,323,0,6934,6935,5,1134,0,0,6935,6937,3,646,323,0,
  	6936,6934,1,0,0,0,6937,6940,1,0,0,0,6938,6936,1,0,0,0,6938,6939,1,0,0,
  	0,6939,6947,1,0,0,0,6940,6938,1,0,0,0,6941,6942,5,472,0,0,6942,6943,3,
  	580,290,0,6943,6944,5,1120,0,0,6944,6945,3,580,290,0,6945,6947,1,0,0,
  	0,6946,6932,1,0,0,0,6946,6941,1,0,0,0,6947,645,1,0,0,0,6948,6950,3,580,
  	290,0,6949,6951,7,118,0,0,6950,6949,1,0,0,0,6950,6951,1,0,0,0,6951,647,
  	1,0,0,0,6952,6953,7,119,0,0,6953,6955,5,1132,0,0,6954,6956,7,44,0,0,6955,
  	6954,1,0,0,0,6955,6956,1,0,0,0,6956,6957,1,0,0,0,6957,6958,3,676,338,
  	0,6958,6960,5,1133,0,0,6959,6961,3,652,326,0,6960,6959,1,0,0,0,6960,6961,
  	1,0,0,0,6961,7012,1,0,0,0,6962,6963,5,290,0,0,6963,6971,5,1132,0,0,6964,
  	6972,5,1116,0,0,6965,6967,5,6,0,0,6966,6965,1,0,0,0,6966,6967,1,0,0,0,
  	6967,6968,1,0,0,0,6968,6972,3,676,338,0,6969,6970,5,49,0,0,6970,6972,
  	3,674,337,0,6971,6964,1,0,0,0,6971,6966,1,0,0,0,6971,6969,1,0,0,0,6972,
  	6973,1,0,0,0,6973,6975,5,1133,0,0,6974,6976,3,652,326,0,6975,6974,1,0,
  	0,0,6975,6976,1,0,0,0,6976,7012,1,0,0,0,6977,6978,7,120,0,0,6978,6980,
  	5,1132,0,0,6979,6981,5,6,0,0,6980,6979,1,0,0,0,6980,6981,1,0,0,0,6981,
  	6982,1,0,0,0,6982,6983,3,676,338,0,6983,6985,5,1133,0,0,6984,6986,3,652,
  	326,0,6985,6984,1,0,0,0,6985,6986,1,0,0,0,6986,7012,1,0,0,0,6987,6988,
  	5,294,0,0,6988,6990,5,1132,0,0,6989,6991,5,49,0,0,6990,6989,1,0,0,0,6990,
  	6991,1,0,0,0,6991,6992,1,0,0,0,6992,7003,3,674,337,0,6993,6994,5,124,
  	0,0,6994,6995,5,19,0,0,6995,7000,3,230,115,0,6996,6997,5,1134,0,0,6997,
  	6999,3,230,115,0,6998,6996,1,0,0,0,6999,7002,1,0,0,0,7000,6998,1,0,0,
  	0,7000,7001,1,0,0,0,7001,7004,1,0,0,0,7002,7000,1,0,0,0,7003,6993,1,0,
  	0,0,7003,7004,1,0,0,0,7004,7007,1,0,0,0,7005,7006,5,154,0,0,7006,7008,
  	5,1147,0,0,7007,7005,1,0,0,0,7007,7008,1,0,0,0,7008,7009,1,0,0,0,7009,
  	7010,5,1133,0,0,7010,7012,1,0,0,0,7011,6952,1,0,0,0,7011,6962,1,0,0,0,
  	7011,6977,1,0,0,0,7011,6987,1,0,0,0,7012,649,1,0,0,0,7013,7014,7,121,
  	0,0,7014,7015,5,1132,0,0,7015,7018,3,678,339,0,7016,7017,5,1134,0,0,7017,
  	7019,3,580,290,0,7018,7016,1,0,0,0,7018,7019,1,0,0,0,7019,7022,1,0,0,
  	0,7020,7021,5,1134,0,0,7021,7023,3,580,290,0,7022,7020,1,0,0,0,7022,7023,
  	1,0,0,0,7023,7024,1,0,0,0,7024,7025,5,1133,0,0,7025,7026,3,652,326,0,
  	7026,7052,1,0,0,0,7027,7028,7,122,0,0,7028,7029,5,1132,0,0,7029,7030,
  	3,678,339,0,7030,7031,5,1133,0,0,7031,7032,3,652,326,0,7032,7052,1,0,
  	0,0,7033,7034,7,123,0,0,7034,7035,5,1132,0,0,7035,7036,5,1133,0,0,7036,
  	7052,3,652,326,0,7037,7038,5,301,0,0,7038,7039,5,1132,0,0,7039,7040,3,
  	678,339,0,7040,7041,5,1134,0,0,7041,7042,3,580,290,0,7042,7043,5,1133,
  	0,0,7043,7044,3,652,326,0,7044,7052,1,0,0,0,7045,7046,5,300,0,0,7046,
  	7047,5,1132,0,0,7047,7048,3,580,290,0,7048,7049,5,1133,0,0,7049,7050,
  	3,652,326,0,7050,7052,1,0,0,0,7051,7013,1,0,0,0,7051,7027,1,0,0,0,7051,
  	7033,1,0,0,0,7051,7037,1,0,0,0,7051,7045,1,0,0,0,7052,651,1,0,0,0,7053,
  	7059,5,128,0,0,7054,7055,5,1132,0,0,7055,7056,3,654,327,0,7056,7057,5,
  	1133,0,0,7057,7060,1,0,0,0,7058,7060,3,656,328,0,7059,7054,1,0,0,0,7059,
  	7058,1,0,0,0,7060,653,1,0,0,0,7061,7063,3,656,328,0,7062,7061,1,0,0,0,
  	7062,7063,1,0,0,0,7063,7065,1,0,0,0,7064,7066,3,668,334,0,7065,7064,1,
  	0,0,0,7065,7066,1,0,0,0,7066,7068,1,0,0,0,7067,7069,3,228,114,0,7068,
  	7067,1,0,0,0,7068,7069,1,0,0,0,7069,7071,1,0,0,0,7070,7072,3,658,329,
  	0,7071,7070,1,0,0,0,7071,7072,1,0,0,0,7072,655,1,0,0,0,7073,7074,3,574,
  	287,0,7074,657,1,0,0,0,7075,7076,3,660,330,0,7076,7077,3,662,331,0,7077,
  	659,1,0,0,0,7078,7079,7,124,0,0,7079,661,1,0,0,0,7080,7083,3,666,333,
  	0,7081,7083,3,664,332,0,7082,7080,1,0,0,0,7082,7081,1,0,0,0,7083,663,
  	1,0,0,0,7084,7085,5,16,0,0,7085,7086,3,666,333,0,7086,7087,5,10,0,0,7087,
  	7088,3,666,333,0,7088,665,1,0,0,0,7089,7090,5,35,0,0,7090,7097,5,600,
  	0,0,7091,7092,5,657,0,0,7092,7097,7,125,0,0,7093,7094,3,678,339,0,7094,
  	7095,7,125,0,0,7095,7097,1,0,0,0,7096,7089,1,0,0,0,7096,7091,1,0,0,0,
  	7096,7093,1,0,0,0,7097,667,1,0,0,0,7098,7099,5,129,0,0,7099,7100,5,19,
  	0,0,7100,7105,3,678,339,0,7101,7102,5,1134,0,0,7102,7104,3,678,339,0,
  	7103,7101,1,0,0,0,7104,7107,1,0,0,0,7105,7103,1,0,0,0,7105,7106,1,0,0,
  	0,7106,669,1,0,0,0,7107,7105,1,0,0,0,7108,7132,3,708,354,0,7109,7132,
  	5,747,0,0,7110,7132,5,317,0,0,7111,7132,5,313,0,0,7112,7132,5,314,0,0,
  	7113,7132,5,315,0,0,7114,7132,5,318,0,0,7115,7132,5,319,0,0,7116,7132,
  	5,320,0,0,7117,7132,5,77,0,0,7118,7132,5,85,0,0,7119,7132,5,316,0,0,7120,
  	7132,5,322,0,0,7121,7132,5,508,0,0,7122,7132,5,323,0,0,7123,7132,5,141,
  	0,0,7124,7132,5,325,0,0,7125,7132,5,326,0,0,7126,7132,5,327,0,0,7127,
  	7132,5,328,0,0,7128,7132,5,329,0,0,7129,7132,5,330,0,0,7130,7132,5,331,
  	0,0,7131,7108,1,0,0,0,7131,7109,1,0,0,0,7131,7110,1,0,0,0,7131,7111,1,
  	0,0,0,7131,7112,1,0,0,0,7131,7113,1,0,0,0,7131,7114,1,0,0,0,7131,7115,
  	1,0,0,0,7131,7116,1,0,0,0,7131,7117,1,0,0,0,7131,7118,1,0,0,0,7131,7119,
  	1,0,0,0,7131,7120,1,0,0,0,7131,7121,1,0,0,0,7131,7122,1,0,0,0,7131,7123,
  	1,0,0,0,7131,7124,1,0,0,0,7131,7125,1,0,0,0,7131,7126,1,0,0,0,7131,7127,
  	1,0,0,0,7131,7128,1,0,0,0,7131,7129,1,0,0,0,7131,7130,1,0,0,0,7132,671,
  	1,0,0,0,7133,7134,7,126,0,0,7134,7135,5,1132,0,0,7135,7136,3,676,338,
  	0,7136,7137,5,1133,0,0,7137,673,1,0,0,0,7138,7143,3,592,296,0,7139,7143,
  	3,550,275,0,7140,7143,3,638,319,0,7141,7143,3,678,339,0,7142,7138,1,0,
  	0,0,7142,7139,1,0,0,0,7142,7140,1,0,0,0,7142,7141,1,0,0,0,7143,7153,1,
  	0,0,0,7144,7149,5,1134,0,0,7145,7150,3,592,296,0,7146,7150,3,550,275,
  	0,7147,7150,3,638,319,0,7148,7150,3,678,339,0,7149,7145,1,0,0,0,7149,
  	7146,1,0,0,0,7149,7147,1,0,0,0,7149,7148,1,0,0,0,7150,7152,1,0,0,0,7151,
  	7144,1,0,0,0,7152,7155,1,0,0,0,7153,7151,1,0,0,0,7153,7154,1,0,0,0,7154,
  	675,1,0,0,0,7155,7153,1,0,0,0,7156,7161,3,592,296,0,7157,7161,3,550,275,
  	0,7158,7161,3,638,319,0,7159,7161,3,678,339,0,7160,7156,1,0,0,0,7160,
  	7157,1,0,0,0,7160,7158,1,0,0,0,7160,7159,1,0,0,0,7161,677,1,0,0,0,7162,
  	7163,6,339,-1,0,7163,7164,7,127,0,0,7164,7174,3,678,339,4,7165,7166,3,
  	680,340,0,7166,7168,5,88,0,0,7167,7169,5,114,0,0,7168,7167,1,0,0,0,7168,
  	7169,1,0,0,0,7169,7170,1,0,0,0,7170,7171,7,128,0,0,7171,7174,1,0,0,0,
  	7172,7174,3,680,340,0,7173,7162,1,0,0,0,7173,7165,1,0,0,0,7173,7172,1,
  	0,0,0,7174,7181,1,0,0,0,7175,7176,10,3,0,0,7176,7177,3,688,344,0,7177,
  	7178,3,678,339,4,7178,7180,1,0,0,0,7179,7175,1,0,0,0,7180,7183,1,0,0,
  	0,7181,7179,1,0,0,0,7181,7182,1,0,0,0,7182,679,1,0,0,0,7183,7181,1,0,
  	0,0,7184,7187,6,340,-1,0,7185,7186,5,1159,0,0,7186,7188,5,1107,0,0,7187,
  	7185,1,0,0,0,7187,7188,1,0,0,0,7188,7189,1,0,0,0,7189,7190,3,682,341,
  	0,7190,7255,1,0,0,0,7191,7192,10,8,0,0,7192,7193,3,686,343,0,7193,7194,
  	3,680,340,9,7194,7254,1,0,0,0,7195,7197,10,6,0,0,7196,7198,5,114,0,0,
  	7197,7196,1,0,0,0,7197,7198,1,0,0,0,7198,7199,1,0,0,0,7199,7200,5,16,
  	0,0,7200,7201,3,680,340,0,7201,7202,5,10,0,0,7202,7203,3,680,340,7,7203,
  	7254,1,0,0,0,7204,7205,10,5,0,0,7205,7206,5,620,0,0,7206,7207,5,98,0,
  	0,7207,7254,3,680,340,6,7208,7210,10,3,0,0,7209,7211,5,114,0,0,7210,7209,
  	1,0,0,0,7210,7211,1,0,0,0,7211,7212,1,0,0,0,7212,7213,7,129,0,0,7213,
  	7254,3,680,340,4,7214,7216,10,10,0,0,7215,7217,5,114,0,0,7216,7215,1,
  	0,0,0,7216,7217,1,0,0,0,7217,7218,1,0,0,0,7218,7219,5,80,0,0,7219,7222,
  	5,1132,0,0,7220,7223,3,198,99,0,7221,7223,3,614,307,0,7222,7220,1,0,0,
  	0,7222,7221,1,0,0,0,7223,7224,1,0,0,0,7224,7225,5,1133,0,0,7225,7254,
  	1,0,0,0,7226,7227,10,9,0,0,7227,7228,5,88,0,0,7228,7254,3,590,295,0,7229,
  	7230,10,7,0,0,7230,7231,3,686,343,0,7231,7232,7,130,0,0,7232,7233,5,1132,
  	0,0,7233,7234,3,198,99,0,7234,7235,5,1133,0,0,7235,7254,1,0,0,0,7236,
  	7238,10,4,0,0,7237,7239,5,114,0,0,7238,7237,1,0,0,0,7238,7239,1,0,0,0,
  	7239,7240,1,0,0,0,7240,7241,5,98,0,0,7241,7244,3,680,340,0,7242,7243,
  	5,413,0,0,7243,7245,5,1147,0,0,7244,7242,1,0,0,0,7244,7245,1,0,0,0,7245,
  	7254,1,0,0,0,7246,7247,10,1,0,0,7247,7248,5,505,0,0,7248,7249,5,533,0,
  	0,7249,7250,5,1132,0,0,7250,7251,3,680,340,0,7251,7252,5,1133,0,0,7252,
  	7254,1,0,0,0,7253,7191,1,0,0,0,7253,7195,1,0,0,0,7253,7204,1,0,0,0,7253,
  	7208,1,0,0,0,7253,7214,1,0,0,0,7253,7226,1,0,0,0,7253,7229,1,0,0,0,7253,
  	7236,1,0,0,0,7253,7246,1,0,0,0,7254,7257,1,0,0,0,7255,7253,1,0,0,0,7255,
  	7256,1,0,0,0,7256,681,1,0,0,0,7257,7255,1,0,0,0,7258,7259,6,341,-1,0,
  	7259,7304,3,592,296,0,7260,7304,3,550,275,0,7261,7304,3,638,319,0,7262,
  	7304,3,556,278,0,7263,7264,3,684,342,0,7264,7265,3,682,341,10,7265,7304,
  	1,0,0,0,7266,7267,5,226,0,0,7267,7304,3,682,341,9,7268,7269,5,1132,0,
  	0,7269,7274,3,678,339,0,7270,7271,5,1134,0,0,7271,7273,3,678,339,0,7272,
  	7270,1,0,0,0,7273,7276,1,0,0,0,7274,7272,1,0,0,0,7274,7275,1,0,0,0,7275,
  	7277,1,0,0,0,7276,7274,1,0,0,0,7277,7278,5,1133,0,0,7278,7304,1,0,0,0,
  	7279,7280,5,600,0,0,7280,7281,5,1132,0,0,7281,7284,3,678,339,0,7282,7283,
  	5,1134,0,0,7283,7285,3,678,339,0,7284,7282,1,0,0,0,7285,7286,1,0,0,0,
  	7286,7284,1,0,0,0,7286,7287,1,0,0,0,7287,7288,1,0,0,0,7288,7289,5,1133,
  	0,0,7289,7304,1,0,0,0,7290,7291,5,60,0,0,7291,7292,5,1132,0,0,7292,7293,
  	3,198,99,0,7293,7294,5,1133,0,0,7294,7304,1,0,0,0,7295,7296,5,1132,0,
  	0,7296,7297,3,198,99,0,7297,7298,5,1133,0,0,7298,7304,1,0,0,0,7299,7300,
  	5,86,0,0,7300,7301,3,678,339,0,7301,7302,3,70,35,0,7302,7304,1,0,0,0,
  	7303,7258,1,0,0,0,7303,7260,1,0,0,0,7303,7261,1,0,0,0,7303,7262,1,0,0,
  	0,7303,7263,1,0,0,0,7303,7266,1,0,0,0,7303,7268,1,0,0,0,7303,7279,1,0,
  	0,0,7303,7290,1,0,0,0,7303,7295,1,0,0,0,7303,7299,1,0,0,0,7304,7322,1,
  	0,0,0,7305,7306,10,3,0,0,7306,7307,3,690,345,0,7307,7308,3,682,341,4,
  	7308,7321,1,0,0,0,7309,7310,10,2,0,0,7310,7311,3,692,346,0,7311,7312,
  	3,682,341,3,7312,7321,1,0,0,0,7313,7314,10,1,0,0,7314,7315,3,694,347,
  	0,7315,7316,3,682,341,2,7316,7321,1,0,0,0,7317,7318,10,12,0,0,7318,7319,
  	5,27,0,0,7319,7321,3,560,280,0,7320,7305,1,0,0,0,7320,7309,1,0,0,0,7320,
  	7313,1,0,0,0,7320,7317,1,0,0,0,7321,7324,1,0,0,0,7322,7320,1,0,0,0,7322,
  	7323,1,0,0,0,7323,683,1,0,0,0,7324,7322,1,0,0,0,7325,7326,7,131,0,0,7326,
  	685,1,0,0,0,7327,7342,5,1123,0,0,7328,7342,5,1124,0,0,7329,7342,5,1125,
  	0,0,7330,7331,5,1125,0,0,7331,7342,5,1123,0,0,7332,7333,5,1124,0,0,7333,
  	7342,5,1123,0,0,7334,7335,5,1125,0,0,7335,7342,5,1124,0,0,7336,7337,5,
  	1126,0,0,7337,7342,5,1123,0,0,7338,7339,5,1125,0,0,7339,7340,5,1123,0,
  	0,7340,7342,5,1124,0,0,7341,7327,1,0,0,0,7341,7328,1,0,0,0,7341,7329,
  	1,0,0,0,7341,7330,1,0,0,0,7341,7332,1,0,0,0,7341,7334,1,0,0,0,7341,7336,
  	1,0,0,0,7341,7338,1,0,0,0,7342,687,1,0,0,0,7343,7351,5,10,0,0,7344,7345,
  	5,1129,0,0,7345,7351,5,1129,0,0,7346,7351,5,194,0,0,7347,7351,5,123,0,
  	0,7348,7349,5,1128,0,0,7349,7351,5,1128,0,0,7350,7343,1,0,0,0,7350,7344,
  	1,0,0,0,7350,7346,1,0,0,0,7350,7347,1,0,0,0,7350,7348,1,0,0,0,7351,689,
  	1,0,0,0,7352,7353,5,1125,0,0,7353,7360,5,1125,0,0,7354,7355,5,1124,0,
  	0,7355,7360,5,1124,0,0,7356,7360,5,1129,0,0,7357,7360,5,1130,0,0,7358,
  	7360,5,1128,0,0,7359,7352,1,0,0,0,7359,7354,1,0,0,0,7359,7356,1,0,0,0,
  	7359,7357,1,0,0,0,7359,7358,1,0,0,0,7360,691,1,0,0,0,7361,7362,7,132,
  	0,0,7362,693,1,0,0,0,7363,7364,5,1120,0,0,7364,7369,5,1124,0,0,7365,7366,
  	5,1120,0,0,7366,7367,5,1124,0,0,7367,7369,5,1124,0,0,7368,7363,1,0,0,
  	0,7368,7365,1,0,0,0,7369,695,1,0,0,0,7370,7371,7,133,0,0,7371,697,1,0,
  	0,0,7372,7373,7,134,0,0,7373,699,1,0,0,0,7374,7375,7,135,0,0,7375,701,
  	1,0,0,0,7376,7377,7,136,0,0,7377,703,1,0,0,0,7378,7379,7,137,0,0,7379,
  	705,1,0,0,0,7380,7381,7,138,0,0,7381,707,1,0,0,0,7382,7383,7,139,0,0,
  	7383,709,1,0,0,0,1080,711,715,722,725,728,730,736,739,742,751,793,808,
  	819,836,841,853,880,889,894,900,905,909,918,921,924,928,935,938,943,951,
  	956,961,964,966,978,981,985,988,992,995,999,1002,1005,1009,1012,1016,
  	1022,1028,1034,1041,1048,1051,1055,1060,1066,1075,1080,1085,1092,1109,
  	1116,1120,1130,1134,1138,1142,1146,1151,1154,1157,1160,1163,1169,1173,
  	1179,1184,1187,1190,1192,1203,1207,1210,1224,1227,1231,1234,1238,1241,
  	1245,1248,1252,1255,1258,1262,1265,1269,1275,1288,1294,1305,1310,1318,
  	1326,1331,1334,1339,1347,1352,1358,1363,1367,1369,1372,1376,1380,1383,
  	1387,1391,1395,1401,1404,1411,1419,1421,1428,1434,1442,1445,1452,1455,
  	1457,1463,1469,1486,1493,1500,1512,1517,1520,1523,1536,1549,1554,1570,
  	1578,1588,1591,1594,1600,1604,1607,1618,1621,1626,1639,1646,1653,1655,
  	1662,1666,1668,1673,1676,1682,1687,1689,1693,1696,1699,1705,1710,1712,
  	1717,1724,1726,1733,1738,1742,1745,1753,1761,1763,1773,1777,1780,1786,
  	1791,1794,1800,1803,1807,1810,1814,1819,1824,1829,1833,1837,1841,1845,
  	1849,1853,1858,1863,1868,1874,1879,1884,1889,1894,1899,1905,1910,1915,
  	1920,1925,1930,1935,1940,1947,1952,1957,1962,1966,1971,1979,1984,1990,
  	2002,2009,2011,2019,2024,2027,2035,2041,2045,2058,2070,2072,2075,2083,
  	2089,2095,2108,2115,2124,2129,2140,2149,2154,2166,2173,2182,2187,2199,
  	2206,2215,2220,2227,2236,2241,2243,2248,2256,2265,2269,2272,2276,2281,
  	2287,2293,2298,2303,2308,2313,2316,2321,2326,2336,2340,2347,2352,2355,
  	2360,2363,2367,2371,2379,2398,2401,2404,2408,2418,2431,2438,2441,2446,
  	2453,2456,2459,2470,2473,2477,2485,2488,2493,2501,2507,2511,2515,2520,
  	2525,2532,2536,2547,2555,2558,2564,2570,2572,2577,2580,2586,2592,2594,
  	2598,2601,2604,2610,2616,2619,2625,2631,2633,2638,2646,2648,2657,2660,
  	2663,2668,2670,2679,2682,2685,2690,2692,2701,2706,2714,2718,2726,2736,
  	2741,2748,2752,2756,2775,2785,2791,2808,2812,2822,2827,2830,2839,2850,
  	2858,2864,2874,2886,2893,2900,2915,2928,2934,2940,2946,2952,2958,2964,
  	2969,2976,2983,2990,2995,2998,3000,3014,3021,3028,3034,3038,3042,3049,
  	3052,3057,3064,3071,3075,3080,3087,3100,3103,3108,3113,3117,3123,3132,
  	3141,3150,3153,3157,3166,3170,3173,3176,3182,3185,3191,3195,3198,3206,
  	3209,3220,3223,3228,3231,3236,3246,3251,3257,3259,3265,3267,3273,3281,
  	3286,3294,3297,3302,3305,3310,3318,3326,3332,3340,3345,3353,3356,3360,
  	3363,3371,3377,3386,3389,3393,3397,3403,3407,3411,3413,3416,3419,3422,
  	3428,3432,3435,3438,3441,3444,3451,3453,3457,3462,3468,3473,3480,3486,
  	3491,3494,3500,3504,3512,3516,3519,3522,3527,3530,3537,3541,3544,3548,
  	3552,3555,3558,3563,3569,3573,3583,3589,3593,3599,3603,3609,3612,3624,
  	3628,3632,3640,3644,3652,3655,3659,3662,3670,3675,3678,3681,3685,3688,
  	3697,3702,3711,3716,3723,3730,3738,3744,3752,3755,3758,3765,3768,3775,
  	3778,3786,3792,3803,3806,3810,3820,3826,3830,3834,3844,3849,3851,3855,
  	3865,3875,3881,3886,3890,3893,3896,3899,3902,3908,3914,3917,3920,3923,
  	3926,3929,3931,3937,3943,3946,3949,3952,3955,3959,3965,3969,3977,3981,
  	3984,3986,3999,4002,4009,4019,4022,4027,4029,4033,4041,4047,4056,4069,
  	4073,4079,4088,4091,4095,4098,4102,4106,4109,4111,4119,4131,4137,4139,
  	4145,4147,4149,4155,4163,4171,4175,4179,4188,4193,4213,4218,4224,4231,
  	4236,4245,4248,4252,4256,4260,4263,4266,4269,4273,4277,4280,4283,4286,
  	4293,4297,4312,4316,4328,4336,4346,4350,4353,4359,4362,4365,4374,4383,
  	4393,4397,4407,4417,4425,4428,4437,4440,4444,4449,4453,4462,4465,4496,
  	4499,4502,4558,4563,4591,4605,4612,4616,4622,4630,4632,4643,4653,4660,
  	4666,4674,4679,4687,4695,4703,4711,4717,4722,4727,4732,4738,4740,4751,
  	4756,4763,4765,4779,4785,4790,4795,4801,4808,4816,4824,4829,4835,4838,
  	4846,4853,4862,4865,4882,4890,4898,4902,4909,4915,4923,4932,4938,4945,
  	4952,4957,4960,4962,4968,4970,4974,4976,4983,4988,4992,4998,5007,5013,
  	5020,5026,5032,5037,5040,5042,5048,5050,5054,5056,5063,5065,5070,5077,
  	5086,5091,5100,5107,5112,5115,5117,5123,5125,5128,5136,5141,5146,5150,
  	5156,5161,5165,5171,5173,5184,5187,5194,5197,5209,5215,5224,5233,5238,
  	5247,5253,5264,5270,5275,5279,5285,5290,5294,5297,5309,5316,5321,5339,
  	5347,5352,5358,5368,5378,5388,5394,5403,5409,5416,5418,5428,5432,5436,
  	5446,5451,5523,5541,5549,5561,5568,5570,5580,5583,5591,5598,5602,5609,
  	5614,5617,5620,5629,5633,5637,5660,5667,5671,5678,5685,5688,5704,5707,
  	5717,5721,5727,5730,5735,5739,5746,5749,5755,5779,5782,5794,5797,5807,
  	5815,5819,5826,5829,5838,5844,5850,5860,5862,5868,5871,5874,5886,5889,
  	5895,5898,5906,5914,5920,5924,5938,5950,5957,5960,5967,5974,5979,5992,
  	6003,6009,6014,6027,6029,6034,6038,6041,6043,6050,6057,6060,6063,6069,
  	6073,6079,6085,6098,6103,6111,6114,6119,6124,6132,6135,6143,6147,6154,
  	6160,6163,6167,6180,6186,6198,6201,6210,6215,6221,6227,6232,6234,6237,
  	6241,6243,6247,6253,6256,6259,6266,6274,6278,6283,6303,6310,6312,6319,
  	6321,6325,6330,6341,6346,6352,6355,6359,6364,6367,6371,6375,6377,6382,
  	6387,6400,6403,6407,6410,6413,6418,6423,6429,6432,6437,6440,6445,6448,
  	6452,6457,6462,6467,6472,6475,6480,6485,6490,6496,6501,6506,6511,6515,
  	6518,6523,6527,6531,6539,6546,6550,6555,6560,6564,6566,6569,6585,6594,
  	6602,6610,6619,6629,6637,6645,6653,6661,6673,6680,6690,6695,6698,6703,
  	6706,6710,6725,6733,6740,6745,6750,6783,6787,6795,6799,6808,6816,6821,
  	6829,6834,6839,6841,6850,6855,6863,6868,6876,6884,6887,6897,6915,6918,
  	6921,6925,6938,6946,6950,6955,6960,6966,6971,6975,6980,6985,6990,7000,
  	7003,7007,7011,7018,7022,7051,7059,7062,7065,7068,7071,7082,7096,7105,
  	7131,7142,7149,7153,7160,7168,7173,7181,7187,7197,7210,7216,7222,7238,
  	7244,7253,7255,7274,7286,7303,7320,7322,7341,7350,7359,7368
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  mysqlparserParserStaticData = staticData.release();
}

}

MySqlParser::MySqlParser(TokenStream *input) : MySqlParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

MySqlParser::MySqlParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  MySqlParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *mysqlparserParserStaticData->atn, mysqlparserParserStaticData->decisionToDFA, mysqlparserParserStaticData->sharedContextCache, options);
}

MySqlParser::~MySqlParser() {
  delete _interpreter;
}

const atn::ATN& MySqlParser::getATN() const {
  return *mysqlparserParserStaticData->atn;
}

std::string MySqlParser::getGrammarFileName() const {
  return "MySqlParser.g4";
}

const std::vector<std::string>& MySqlParser::getRuleNames() const {
  return mysqlparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& MySqlParser::getVocabulary() const {
  return mysqlparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView MySqlParser::getSerializedATN() const {
  return mysqlparserParserStaticData->serializedATN;
}


//----------------- RootContext ------------------------------------------------------------------

MySqlParser::RootContext::RootContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::RootContext::EOF() {
  return getToken(MySqlParser::EOF, 0);
}

MySqlParser::SqlStatementsContext* MySqlParser::RootContext::sqlStatements() {
  return getRuleContext<MySqlParser::SqlStatementsContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::RootContext::MINUS() {
  return getTokens(MySqlParser::MINUS);
}

tree::TerminalNode* MySqlParser::RootContext::MINUS(size_t i) {
  return getToken(MySqlParser::MINUS, i);
}


size_t MySqlParser::RootContext::getRuleIndex() const {
  return MySqlParser::RuleRoot;
}

void MySqlParser::RootContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoot(this);
}

void MySqlParser::RootContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoot(this);
}


std::any MySqlParser::RootContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRoot(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::RootContext* MySqlParser::root() {
  RootContext *_localctx = _tracker.createInstance<RootContext>(_ctx, getState());
  enterRule(_localctx, 0, MySqlParser::RuleRoot);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(711);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4614060972218253952) != 0) || ((((_la - 71) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 71)) & 2306124490637066243) != 0) || ((((_la - 138) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 138)) & 19509751503569451) != 0) || ((((_la - 344) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 344)) & 36099165796700291) != 0) || ((((_la - 432) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 432)) & 16782337) != 0) || ((((_la - 560) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 560)) & 17730162917377) != 0) || ((((_la - 629) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 629)) & 4503604056555585) != 0) || _la == MySqlParser::EXECUTE

    || _la == MySqlParser::SHUTDOWN || _la == MySqlParser::LR_BRACKET

    || _la == MySqlParser::SEMI) {
      setState(710);
      sqlStatements();
    }
    setState(715);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::MINUS) {
      setState(713);
      match(MySqlParser::MINUS);
      setState(714);
      match(MySqlParser::MINUS);
    }
    setState(717);
    match(MySqlParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SqlStatementsContext ------------------------------------------------------------------

MySqlParser::SqlStatementsContext::SqlStatementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::SqlStatementContext *> MySqlParser::SqlStatementsContext::sqlStatement() {
  return getRuleContexts<MySqlParser::SqlStatementContext>();
}

MySqlParser::SqlStatementContext* MySqlParser::SqlStatementsContext::sqlStatement(size_t i) {
  return getRuleContext<MySqlParser::SqlStatementContext>(i);
}

std::vector<MySqlParser::EmptyStatement_Context *> MySqlParser::SqlStatementsContext::emptyStatement_() {
  return getRuleContexts<MySqlParser::EmptyStatement_Context>();
}

MySqlParser::EmptyStatement_Context* MySqlParser::SqlStatementsContext::emptyStatement_(size_t i) {
  return getRuleContext<MySqlParser::EmptyStatement_Context>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::SqlStatementsContext::SEMI() {
  return getTokens(MySqlParser::SEMI);
}

tree::TerminalNode* MySqlParser::SqlStatementsContext::SEMI(size_t i) {
  return getToken(MySqlParser::SEMI, i);
}

std::vector<tree::TerminalNode *> MySqlParser::SqlStatementsContext::MINUS() {
  return getTokens(MySqlParser::MINUS);
}

tree::TerminalNode* MySqlParser::SqlStatementsContext::MINUS(size_t i) {
  return getToken(MySqlParser::MINUS, i);
}


size_t MySqlParser::SqlStatementsContext::getRuleIndex() const {
  return MySqlParser::RuleSqlStatements;
}

void MySqlParser::SqlStatementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSqlStatements(this);
}

void MySqlParser::SqlStatementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSqlStatements(this);
}


std::any MySqlParser::SqlStatementsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSqlStatements(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SqlStatementsContext* MySqlParser::sqlStatements() {
  SqlStatementsContext *_localctx = _tracker.createInstance<SqlStatementsContext>(_ctx, getState());
  enterRule(_localctx, 2, MySqlParser::RuleSqlStatements);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(730);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(728);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::ALTER:
          case MySqlParser::ANALYZE:
          case MySqlParser::CALL:
          case MySqlParser::CHANGE:
          case MySqlParser::CHECK:
          case MySqlParser::CREATE:
          case MySqlParser::DELETE:
          case MySqlParser::DESC:
          case MySqlParser::DESCRIBE:
          case MySqlParser::DROP:
          case MySqlParser::EXPLAIN:
          case MySqlParser::GET:
          case MySqlParser::GRANT:
          case MySqlParser::INSERT:
          case MySqlParser::KILL:
          case MySqlParser::LOAD:
          case MySqlParser::LOCK:
          case MySqlParser::OPTIMIZE:
          case MySqlParser::PURGE:
          case MySqlParser::RELEASE:
          case MySqlParser::RENAME:
          case MySqlParser::REPLACE:
          case MySqlParser::RESIGNAL:
          case MySqlParser::REVOKE:
          case MySqlParser::SELECT:
          case MySqlParser::SET:
          case MySqlParser::SHOW:
          case MySqlParser::SIGNAL:
          case MySqlParser::TABLE:
          case MySqlParser::UNLOCK:
          case MySqlParser::UPDATE:
          case MySqlParser::USE:
          case MySqlParser::VALUES:
          case MySqlParser::WITH:
          case MySqlParser::BEGIN:
          case MySqlParser::BINLOG:
          case MySqlParser::CACHE:
          case MySqlParser::CHECKSUM:
          case MySqlParser::COMMIT:
          case MySqlParser::DEALLOCATE:
          case MySqlParser::DO:
          case MySqlParser::FLUSH:
          case MySqlParser::HANDLER:
          case MySqlParser::HELP:
          case MySqlParser::INSTALL:
          case MySqlParser::PREPARE:
          case MySqlParser::REPAIR:
          case MySqlParser::RESET:
          case MySqlParser::ROLLBACK:
          case MySqlParser::SAVEPOINT:
          case MySqlParser::START:
          case MySqlParser::STOP:
          case MySqlParser::TRUNCATE:
          case MySqlParser::UNINSTALL:
          case MySqlParser::XA:
          case MySqlParser::EXECUTE:
          case MySqlParser::SHUTDOWN:
          case MySqlParser::LR_BRACKET: {
            setState(719);
            sqlStatement();
            setState(722);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySqlParser::MINUS) {
              setState(720);
              match(MySqlParser::MINUS);
              setState(721);
              match(MySqlParser::MINUS);
            }
            setState(725);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
            case 1: {
              setState(724);
              match(MySqlParser::SEMI);
              break;
            }

            default:
              break;
            }
            break;
          }

          case MySqlParser::SEMI: {
            setState(727);
            emptyStatement_();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(732);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx);
    }
    setState(742);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::ALTER:
      case MySqlParser::ANALYZE:
      case MySqlParser::CALL:
      case MySqlParser::CHANGE:
      case MySqlParser::CHECK:
      case MySqlParser::CREATE:
      case MySqlParser::DELETE:
      case MySqlParser::DESC:
      case MySqlParser::DESCRIBE:
      case MySqlParser::DROP:
      case MySqlParser::EXPLAIN:
      case MySqlParser::GET:
      case MySqlParser::GRANT:
      case MySqlParser::INSERT:
      case MySqlParser::KILL:
      case MySqlParser::LOAD:
      case MySqlParser::LOCK:
      case MySqlParser::OPTIMIZE:
      case MySqlParser::PURGE:
      case MySqlParser::RELEASE:
      case MySqlParser::RENAME:
      case MySqlParser::REPLACE:
      case MySqlParser::RESIGNAL:
      case MySqlParser::REVOKE:
      case MySqlParser::SELECT:
      case MySqlParser::SET:
      case MySqlParser::SHOW:
      case MySqlParser::SIGNAL:
      case MySqlParser::TABLE:
      case MySqlParser::UNLOCK:
      case MySqlParser::UPDATE:
      case MySqlParser::USE:
      case MySqlParser::VALUES:
      case MySqlParser::WITH:
      case MySqlParser::BEGIN:
      case MySqlParser::BINLOG:
      case MySqlParser::CACHE:
      case MySqlParser::CHECKSUM:
      case MySqlParser::COMMIT:
      case MySqlParser::DEALLOCATE:
      case MySqlParser::DO:
      case MySqlParser::FLUSH:
      case MySqlParser::HANDLER:
      case MySqlParser::HELP:
      case MySqlParser::INSTALL:
      case MySqlParser::PREPARE:
      case MySqlParser::REPAIR:
      case MySqlParser::RESET:
      case MySqlParser::ROLLBACK:
      case MySqlParser::SAVEPOINT:
      case MySqlParser::START:
      case MySqlParser::STOP:
      case MySqlParser::TRUNCATE:
      case MySqlParser::UNINSTALL:
      case MySqlParser::XA:
      case MySqlParser::EXECUTE:
      case MySqlParser::SHUTDOWN:
      case MySqlParser::LR_BRACKET: {
        setState(733);
        sqlStatement();
        setState(739);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
        case 1: {
          setState(736);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::MINUS) {
            setState(734);
            match(MySqlParser::MINUS);
            setState(735);
            match(MySqlParser::MINUS);
          }
          setState(738);
          match(MySqlParser::SEMI);
          break;
        }

        default:
          break;
        }
        break;
      }

      case MySqlParser::SEMI: {
        setState(741);
        emptyStatement_();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SqlStatementContext ------------------------------------------------------------------

MySqlParser::SqlStatementContext::SqlStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::DdlStatementContext* MySqlParser::SqlStatementContext::ddlStatement() {
  return getRuleContext<MySqlParser::DdlStatementContext>(0);
}

MySqlParser::DmlStatementContext* MySqlParser::SqlStatementContext::dmlStatement() {
  return getRuleContext<MySqlParser::DmlStatementContext>(0);
}

MySqlParser::TransactionStatementContext* MySqlParser::SqlStatementContext::transactionStatement() {
  return getRuleContext<MySqlParser::TransactionStatementContext>(0);
}

MySqlParser::ReplicationStatementContext* MySqlParser::SqlStatementContext::replicationStatement() {
  return getRuleContext<MySqlParser::ReplicationStatementContext>(0);
}

MySqlParser::PreparedStatementContext* MySqlParser::SqlStatementContext::preparedStatement() {
  return getRuleContext<MySqlParser::PreparedStatementContext>(0);
}

MySqlParser::AdministrationStatementContext* MySqlParser::SqlStatementContext::administrationStatement() {
  return getRuleContext<MySqlParser::AdministrationStatementContext>(0);
}

MySqlParser::UtilityStatementContext* MySqlParser::SqlStatementContext::utilityStatement() {
  return getRuleContext<MySqlParser::UtilityStatementContext>(0);
}


size_t MySqlParser::SqlStatementContext::getRuleIndex() const {
  return MySqlParser::RuleSqlStatement;
}

void MySqlParser::SqlStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSqlStatement(this);
}

void MySqlParser::SqlStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSqlStatement(this);
}


std::any MySqlParser::SqlStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSqlStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SqlStatementContext* MySqlParser::sqlStatement() {
  SqlStatementContext *_localctx = _tracker.createInstance<SqlStatementContext>(_ctx, getState());
  enterRule(_localctx, 4, MySqlParser::RuleSqlStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(751);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(744);
      ddlStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(745);
      dmlStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(746);
      transactionStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(747);
      replicationStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(748);
      preparedStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(749);
      administrationStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(750);
      utilityStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyStatement_Context ------------------------------------------------------------------

MySqlParser::EmptyStatement_Context::EmptyStatement_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::EmptyStatement_Context::SEMI() {
  return getToken(MySqlParser::SEMI, 0);
}


size_t MySqlParser::EmptyStatement_Context::getRuleIndex() const {
  return MySqlParser::RuleEmptyStatement_;
}

void MySqlParser::EmptyStatement_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyStatement_(this);
}

void MySqlParser::EmptyStatement_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyStatement_(this);
}


std::any MySqlParser::EmptyStatement_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitEmptyStatement_(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::EmptyStatement_Context* MySqlParser::emptyStatement_() {
  EmptyStatement_Context *_localctx = _tracker.createInstance<EmptyStatement_Context>(_ctx, getState());
  enterRule(_localctx, 6, MySqlParser::RuleEmptyStatement_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(753);
    match(MySqlParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DdlStatementContext ------------------------------------------------------------------

MySqlParser::DdlStatementContext::DdlStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::CreateDatabaseContext* MySqlParser::DdlStatementContext::createDatabase() {
  return getRuleContext<MySqlParser::CreateDatabaseContext>(0);
}

MySqlParser::CreateEventContext* MySqlParser::DdlStatementContext::createEvent() {
  return getRuleContext<MySqlParser::CreateEventContext>(0);
}

MySqlParser::CreateIndexContext* MySqlParser::DdlStatementContext::createIndex() {
  return getRuleContext<MySqlParser::CreateIndexContext>(0);
}

MySqlParser::CreateLogfileGroupContext* MySqlParser::DdlStatementContext::createLogfileGroup() {
  return getRuleContext<MySqlParser::CreateLogfileGroupContext>(0);
}

MySqlParser::CreateProcedureContext* MySqlParser::DdlStatementContext::createProcedure() {
  return getRuleContext<MySqlParser::CreateProcedureContext>(0);
}

MySqlParser::CreateFunctionContext* MySqlParser::DdlStatementContext::createFunction() {
  return getRuleContext<MySqlParser::CreateFunctionContext>(0);
}

MySqlParser::CreateServerContext* MySqlParser::DdlStatementContext::createServer() {
  return getRuleContext<MySqlParser::CreateServerContext>(0);
}

MySqlParser::CreateTableContext* MySqlParser::DdlStatementContext::createTable() {
  return getRuleContext<MySqlParser::CreateTableContext>(0);
}

MySqlParser::CreateTablespaceInnodbContext* MySqlParser::DdlStatementContext::createTablespaceInnodb() {
  return getRuleContext<MySqlParser::CreateTablespaceInnodbContext>(0);
}

MySqlParser::CreateTablespaceNdbContext* MySqlParser::DdlStatementContext::createTablespaceNdb() {
  return getRuleContext<MySqlParser::CreateTablespaceNdbContext>(0);
}

MySqlParser::CreateTriggerContext* MySqlParser::DdlStatementContext::createTrigger() {
  return getRuleContext<MySqlParser::CreateTriggerContext>(0);
}

MySqlParser::CreateViewContext* MySqlParser::DdlStatementContext::createView() {
  return getRuleContext<MySqlParser::CreateViewContext>(0);
}

MySqlParser::CreateRoleContext* MySqlParser::DdlStatementContext::createRole() {
  return getRuleContext<MySqlParser::CreateRoleContext>(0);
}

MySqlParser::AlterDatabaseContext* MySqlParser::DdlStatementContext::alterDatabase() {
  return getRuleContext<MySqlParser::AlterDatabaseContext>(0);
}

MySqlParser::AlterEventContext* MySqlParser::DdlStatementContext::alterEvent() {
  return getRuleContext<MySqlParser::AlterEventContext>(0);
}

MySqlParser::AlterFunctionContext* MySqlParser::DdlStatementContext::alterFunction() {
  return getRuleContext<MySqlParser::AlterFunctionContext>(0);
}

MySqlParser::AlterInstanceContext* MySqlParser::DdlStatementContext::alterInstance() {
  return getRuleContext<MySqlParser::AlterInstanceContext>(0);
}

MySqlParser::AlterLogfileGroupContext* MySqlParser::DdlStatementContext::alterLogfileGroup() {
  return getRuleContext<MySqlParser::AlterLogfileGroupContext>(0);
}

MySqlParser::AlterProcedureContext* MySqlParser::DdlStatementContext::alterProcedure() {
  return getRuleContext<MySqlParser::AlterProcedureContext>(0);
}

MySqlParser::AlterServerContext* MySqlParser::DdlStatementContext::alterServer() {
  return getRuleContext<MySqlParser::AlterServerContext>(0);
}

MySqlParser::AlterTableContext* MySqlParser::DdlStatementContext::alterTable() {
  return getRuleContext<MySqlParser::AlterTableContext>(0);
}

MySqlParser::AlterTablespaceContext* MySqlParser::DdlStatementContext::alterTablespace() {
  return getRuleContext<MySqlParser::AlterTablespaceContext>(0);
}

MySqlParser::AlterViewContext* MySqlParser::DdlStatementContext::alterView() {
  return getRuleContext<MySqlParser::AlterViewContext>(0);
}

MySqlParser::DropDatabaseContext* MySqlParser::DdlStatementContext::dropDatabase() {
  return getRuleContext<MySqlParser::DropDatabaseContext>(0);
}

MySqlParser::DropEventContext* MySqlParser::DdlStatementContext::dropEvent() {
  return getRuleContext<MySqlParser::DropEventContext>(0);
}

MySqlParser::DropIndexContext* MySqlParser::DdlStatementContext::dropIndex() {
  return getRuleContext<MySqlParser::DropIndexContext>(0);
}

MySqlParser::DropLogfileGroupContext* MySqlParser::DdlStatementContext::dropLogfileGroup() {
  return getRuleContext<MySqlParser::DropLogfileGroupContext>(0);
}

MySqlParser::DropProcedureContext* MySqlParser::DdlStatementContext::dropProcedure() {
  return getRuleContext<MySqlParser::DropProcedureContext>(0);
}

MySqlParser::DropFunctionContext* MySqlParser::DdlStatementContext::dropFunction() {
  return getRuleContext<MySqlParser::DropFunctionContext>(0);
}

MySqlParser::DropServerContext* MySqlParser::DdlStatementContext::dropServer() {
  return getRuleContext<MySqlParser::DropServerContext>(0);
}

MySqlParser::DropTableContext* MySqlParser::DdlStatementContext::dropTable() {
  return getRuleContext<MySqlParser::DropTableContext>(0);
}

MySqlParser::DropTablespaceContext* MySqlParser::DdlStatementContext::dropTablespace() {
  return getRuleContext<MySqlParser::DropTablespaceContext>(0);
}

MySqlParser::DropTriggerContext* MySqlParser::DdlStatementContext::dropTrigger() {
  return getRuleContext<MySqlParser::DropTriggerContext>(0);
}

MySqlParser::DropViewContext* MySqlParser::DdlStatementContext::dropView() {
  return getRuleContext<MySqlParser::DropViewContext>(0);
}

MySqlParser::DropRoleContext* MySqlParser::DdlStatementContext::dropRole() {
  return getRuleContext<MySqlParser::DropRoleContext>(0);
}

MySqlParser::SetRoleContext* MySqlParser::DdlStatementContext::setRole() {
  return getRuleContext<MySqlParser::SetRoleContext>(0);
}

MySqlParser::RenameTableContext* MySqlParser::DdlStatementContext::renameTable() {
  return getRuleContext<MySqlParser::RenameTableContext>(0);
}

MySqlParser::TruncateTableContext* MySqlParser::DdlStatementContext::truncateTable() {
  return getRuleContext<MySqlParser::TruncateTableContext>(0);
}


size_t MySqlParser::DdlStatementContext::getRuleIndex() const {
  return MySqlParser::RuleDdlStatement;
}

void MySqlParser::DdlStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDdlStatement(this);
}

void MySqlParser::DdlStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDdlStatement(this);
}


std::any MySqlParser::DdlStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDdlStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DdlStatementContext* MySqlParser::ddlStatement() {
  DdlStatementContext *_localctx = _tracker.createInstance<DdlStatementContext>(_ctx, getState());
  enterRule(_localctx, 8, MySqlParser::RuleDdlStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(793);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(755);
      createDatabase();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(756);
      createEvent();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(757);
      createIndex();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(758);
      createLogfileGroup();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(759);
      createProcedure();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(760);
      createFunction();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(761);
      createServer();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(762);
      createTable();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(763);
      createTablespaceInnodb();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(764);
      createTablespaceNdb();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(765);
      createTrigger();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(766);
      createView();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(767);
      createRole();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(768);
      alterDatabase();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(769);
      alterEvent();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(770);
      alterFunction();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(771);
      alterInstance();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(772);
      alterLogfileGroup();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(773);
      alterProcedure();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(774);
      alterServer();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(775);
      alterTable();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(776);
      alterTablespace();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(777);
      alterView();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(778);
      dropDatabase();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(779);
      dropEvent();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(780);
      dropIndex();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(781);
      dropLogfileGroup();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(782);
      dropProcedure();
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(783);
      dropFunction();
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(784);
      dropServer();
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(785);
      dropTable();
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(786);
      dropTablespace();
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(787);
      dropTrigger();
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(788);
      dropView();
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(789);
      dropRole();
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(790);
      setRole();
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(791);
      renameTable();
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(792);
      truncateTable();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DmlStatementContext ------------------------------------------------------------------

MySqlParser::DmlStatementContext::DmlStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::SelectStatementContext* MySqlParser::DmlStatementContext::selectStatement() {
  return getRuleContext<MySqlParser::SelectStatementContext>(0);
}

MySqlParser::InsertStatementContext* MySqlParser::DmlStatementContext::insertStatement() {
  return getRuleContext<MySqlParser::InsertStatementContext>(0);
}

MySqlParser::UpdateStatementContext* MySqlParser::DmlStatementContext::updateStatement() {
  return getRuleContext<MySqlParser::UpdateStatementContext>(0);
}

MySqlParser::DeleteStatementContext* MySqlParser::DmlStatementContext::deleteStatement() {
  return getRuleContext<MySqlParser::DeleteStatementContext>(0);
}

MySqlParser::ReplaceStatementContext* MySqlParser::DmlStatementContext::replaceStatement() {
  return getRuleContext<MySqlParser::ReplaceStatementContext>(0);
}

MySqlParser::CallStatementContext* MySqlParser::DmlStatementContext::callStatement() {
  return getRuleContext<MySqlParser::CallStatementContext>(0);
}

MySqlParser::LoadDataStatementContext* MySqlParser::DmlStatementContext::loadDataStatement() {
  return getRuleContext<MySqlParser::LoadDataStatementContext>(0);
}

MySqlParser::LoadXmlStatementContext* MySqlParser::DmlStatementContext::loadXmlStatement() {
  return getRuleContext<MySqlParser::LoadXmlStatementContext>(0);
}

MySqlParser::DoStatementContext* MySqlParser::DmlStatementContext::doStatement() {
  return getRuleContext<MySqlParser::DoStatementContext>(0);
}

MySqlParser::HandlerStatementContext* MySqlParser::DmlStatementContext::handlerStatement() {
  return getRuleContext<MySqlParser::HandlerStatementContext>(0);
}

MySqlParser::ValuesStatementContext* MySqlParser::DmlStatementContext::valuesStatement() {
  return getRuleContext<MySqlParser::ValuesStatementContext>(0);
}

MySqlParser::WithStatementContext* MySqlParser::DmlStatementContext::withStatement() {
  return getRuleContext<MySqlParser::WithStatementContext>(0);
}

MySqlParser::TableStatementContext* MySqlParser::DmlStatementContext::tableStatement() {
  return getRuleContext<MySqlParser::TableStatementContext>(0);
}


size_t MySqlParser::DmlStatementContext::getRuleIndex() const {
  return MySqlParser::RuleDmlStatement;
}

void MySqlParser::DmlStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDmlStatement(this);
}

void MySqlParser::DmlStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDmlStatement(this);
}


std::any MySqlParser::DmlStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDmlStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DmlStatementContext* MySqlParser::dmlStatement() {
  DmlStatementContext *_localctx = _tracker.createInstance<DmlStatementContext>(_ctx, getState());
  enterRule(_localctx, 10, MySqlParser::RuleDmlStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(808);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(795);
      selectStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(796);
      insertStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(797);
      updateStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(798);
      deleteStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(799);
      replaceStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(800);
      callStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(801);
      loadDataStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(802);
      loadXmlStatement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(803);
      doStatement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(804);
      handlerStatement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(805);
      valuesStatement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(806);
      withStatement();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(807);
      tableStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionStatementContext ------------------------------------------------------------------

MySqlParser::TransactionStatementContext::TransactionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::StartTransactionContext* MySqlParser::TransactionStatementContext::startTransaction() {
  return getRuleContext<MySqlParser::StartTransactionContext>(0);
}

MySqlParser::BeginWorkContext* MySqlParser::TransactionStatementContext::beginWork() {
  return getRuleContext<MySqlParser::BeginWorkContext>(0);
}

MySqlParser::CommitWorkContext* MySqlParser::TransactionStatementContext::commitWork() {
  return getRuleContext<MySqlParser::CommitWorkContext>(0);
}

MySqlParser::RollbackWorkContext* MySqlParser::TransactionStatementContext::rollbackWork() {
  return getRuleContext<MySqlParser::RollbackWorkContext>(0);
}

MySqlParser::SavepointStatementContext* MySqlParser::TransactionStatementContext::savepointStatement() {
  return getRuleContext<MySqlParser::SavepointStatementContext>(0);
}

MySqlParser::RollbackStatementContext* MySqlParser::TransactionStatementContext::rollbackStatement() {
  return getRuleContext<MySqlParser::RollbackStatementContext>(0);
}

MySqlParser::ReleaseStatementContext* MySqlParser::TransactionStatementContext::releaseStatement() {
  return getRuleContext<MySqlParser::ReleaseStatementContext>(0);
}

MySqlParser::LockTablesContext* MySqlParser::TransactionStatementContext::lockTables() {
  return getRuleContext<MySqlParser::LockTablesContext>(0);
}

MySqlParser::UnlockTablesContext* MySqlParser::TransactionStatementContext::unlockTables() {
  return getRuleContext<MySqlParser::UnlockTablesContext>(0);
}


size_t MySqlParser::TransactionStatementContext::getRuleIndex() const {
  return MySqlParser::RuleTransactionStatement;
}

void MySqlParser::TransactionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionStatement(this);
}

void MySqlParser::TransactionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionStatement(this);
}


std::any MySqlParser::TransactionStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTransactionStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TransactionStatementContext* MySqlParser::transactionStatement() {
  TransactionStatementContext *_localctx = _tracker.createInstance<TransactionStatementContext>(_ctx, getState());
  enterRule(_localctx, 12, MySqlParser::RuleTransactionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(819);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(810);
      startTransaction();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(811);
      beginWork();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(812);
      commitWork();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(813);
      rollbackWork();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(814);
      savepointStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(815);
      rollbackStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(816);
      releaseStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(817);
      lockTables();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(818);
      unlockTables();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicationStatementContext ------------------------------------------------------------------

MySqlParser::ReplicationStatementContext::ReplicationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::ChangeMasterContext* MySqlParser::ReplicationStatementContext::changeMaster() {
  return getRuleContext<MySqlParser::ChangeMasterContext>(0);
}

MySqlParser::ChangeReplicationFilterContext* MySqlParser::ReplicationStatementContext::changeReplicationFilter() {
  return getRuleContext<MySqlParser::ChangeReplicationFilterContext>(0);
}

MySqlParser::PurgeBinaryLogsContext* MySqlParser::ReplicationStatementContext::purgeBinaryLogs() {
  return getRuleContext<MySqlParser::PurgeBinaryLogsContext>(0);
}

MySqlParser::ResetMasterContext* MySqlParser::ReplicationStatementContext::resetMaster() {
  return getRuleContext<MySqlParser::ResetMasterContext>(0);
}

MySqlParser::ResetSlaveContext* MySqlParser::ReplicationStatementContext::resetSlave() {
  return getRuleContext<MySqlParser::ResetSlaveContext>(0);
}

MySqlParser::StartSlaveContext* MySqlParser::ReplicationStatementContext::startSlave() {
  return getRuleContext<MySqlParser::StartSlaveContext>(0);
}

MySqlParser::StopSlaveContext* MySqlParser::ReplicationStatementContext::stopSlave() {
  return getRuleContext<MySqlParser::StopSlaveContext>(0);
}

MySqlParser::StartGroupReplicationContext* MySqlParser::ReplicationStatementContext::startGroupReplication() {
  return getRuleContext<MySqlParser::StartGroupReplicationContext>(0);
}

MySqlParser::StopGroupReplicationContext* MySqlParser::ReplicationStatementContext::stopGroupReplication() {
  return getRuleContext<MySqlParser::StopGroupReplicationContext>(0);
}

MySqlParser::XaStartTransactionContext* MySqlParser::ReplicationStatementContext::xaStartTransaction() {
  return getRuleContext<MySqlParser::XaStartTransactionContext>(0);
}

MySqlParser::XaEndTransactionContext* MySqlParser::ReplicationStatementContext::xaEndTransaction() {
  return getRuleContext<MySqlParser::XaEndTransactionContext>(0);
}

MySqlParser::XaPrepareStatementContext* MySqlParser::ReplicationStatementContext::xaPrepareStatement() {
  return getRuleContext<MySqlParser::XaPrepareStatementContext>(0);
}

MySqlParser::XaCommitWorkContext* MySqlParser::ReplicationStatementContext::xaCommitWork() {
  return getRuleContext<MySqlParser::XaCommitWorkContext>(0);
}

MySqlParser::XaRollbackWorkContext* MySqlParser::ReplicationStatementContext::xaRollbackWork() {
  return getRuleContext<MySqlParser::XaRollbackWorkContext>(0);
}

MySqlParser::XaRecoverWorkContext* MySqlParser::ReplicationStatementContext::xaRecoverWork() {
  return getRuleContext<MySqlParser::XaRecoverWorkContext>(0);
}


size_t MySqlParser::ReplicationStatementContext::getRuleIndex() const {
  return MySqlParser::RuleReplicationStatement;
}

void MySqlParser::ReplicationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplicationStatement(this);
}

void MySqlParser::ReplicationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplicationStatement(this);
}


std::any MySqlParser::ReplicationStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitReplicationStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ReplicationStatementContext* MySqlParser::replicationStatement() {
  ReplicationStatementContext *_localctx = _tracker.createInstance<ReplicationStatementContext>(_ctx, getState());
  enterRule(_localctx, 14, MySqlParser::RuleReplicationStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(836);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(821);
      changeMaster();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(822);
      changeReplicationFilter();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(823);
      purgeBinaryLogs();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(824);
      resetMaster();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(825);
      resetSlave();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(826);
      startSlave();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(827);
      stopSlave();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(828);
      startGroupReplication();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(829);
      stopGroupReplication();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(830);
      xaStartTransaction();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(831);
      xaEndTransaction();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(832);
      xaPrepareStatement();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(833);
      xaCommitWork();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(834);
      xaRollbackWork();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(835);
      xaRecoverWork();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreparedStatementContext ------------------------------------------------------------------

MySqlParser::PreparedStatementContext::PreparedStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::PrepareStatementContext* MySqlParser::PreparedStatementContext::prepareStatement() {
  return getRuleContext<MySqlParser::PrepareStatementContext>(0);
}

MySqlParser::ExecuteStatementContext* MySqlParser::PreparedStatementContext::executeStatement() {
  return getRuleContext<MySqlParser::ExecuteStatementContext>(0);
}

MySqlParser::DeallocatePrepareContext* MySqlParser::PreparedStatementContext::deallocatePrepare() {
  return getRuleContext<MySqlParser::DeallocatePrepareContext>(0);
}


size_t MySqlParser::PreparedStatementContext::getRuleIndex() const {
  return MySqlParser::RulePreparedStatement;
}

void MySqlParser::PreparedStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreparedStatement(this);
}

void MySqlParser::PreparedStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreparedStatement(this);
}


std::any MySqlParser::PreparedStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPreparedStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::PreparedStatementContext* MySqlParser::preparedStatement() {
  PreparedStatementContext *_localctx = _tracker.createInstance<PreparedStatementContext>(_ctx, getState());
  enterRule(_localctx, 16, MySqlParser::RulePreparedStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(841);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::PREPARE: {
        enterOuterAlt(_localctx, 1);
        setState(838);
        prepareStatement();
        break;
      }

      case MySqlParser::EXECUTE: {
        enterOuterAlt(_localctx, 2);
        setState(839);
        executeStatement();
        break;
      }

      case MySqlParser::DROP:
      case MySqlParser::DEALLOCATE: {
        enterOuterAlt(_localctx, 3);
        setState(840);
        deallocatePrepare();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundStatementContext ------------------------------------------------------------------

MySqlParser::CompoundStatementContext::CompoundStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::BlockStatementContext* MySqlParser::CompoundStatementContext::blockStatement() {
  return getRuleContext<MySqlParser::BlockStatementContext>(0);
}

MySqlParser::CaseStatementContext* MySqlParser::CompoundStatementContext::caseStatement() {
  return getRuleContext<MySqlParser::CaseStatementContext>(0);
}

MySqlParser::IfStatementContext* MySqlParser::CompoundStatementContext::ifStatement() {
  return getRuleContext<MySqlParser::IfStatementContext>(0);
}

MySqlParser::LeaveStatementContext* MySqlParser::CompoundStatementContext::leaveStatement() {
  return getRuleContext<MySqlParser::LeaveStatementContext>(0);
}

MySqlParser::LoopStatementContext* MySqlParser::CompoundStatementContext::loopStatement() {
  return getRuleContext<MySqlParser::LoopStatementContext>(0);
}

MySqlParser::RepeatStatementContext* MySqlParser::CompoundStatementContext::repeatStatement() {
  return getRuleContext<MySqlParser::RepeatStatementContext>(0);
}

MySqlParser::WhileStatementContext* MySqlParser::CompoundStatementContext::whileStatement() {
  return getRuleContext<MySqlParser::WhileStatementContext>(0);
}

MySqlParser::IterateStatementContext* MySqlParser::CompoundStatementContext::iterateStatement() {
  return getRuleContext<MySqlParser::IterateStatementContext>(0);
}

MySqlParser::ReturnStatementContext* MySqlParser::CompoundStatementContext::returnStatement() {
  return getRuleContext<MySqlParser::ReturnStatementContext>(0);
}

MySqlParser::CursorStatementContext* MySqlParser::CompoundStatementContext::cursorStatement() {
  return getRuleContext<MySqlParser::CursorStatementContext>(0);
}


size_t MySqlParser::CompoundStatementContext::getRuleIndex() const {
  return MySqlParser::RuleCompoundStatement;
}

void MySqlParser::CompoundStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundStatement(this);
}

void MySqlParser::CompoundStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundStatement(this);
}


std::any MySqlParser::CompoundStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCompoundStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CompoundStatementContext* MySqlParser::compoundStatement() {
  CompoundStatementContext *_localctx = _tracker.createInstance<CompoundStatementContext>(_ctx, getState());
  enterRule(_localctx, 18, MySqlParser::RuleCompoundStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(853);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(843);
      blockStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(844);
      caseStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(845);
      ifStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(846);
      leaveStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(847);
      loopStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(848);
      repeatStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(849);
      whileStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(850);
      iterateStatement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(851);
      returnStatement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(852);
      cursorStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdministrationStatementContext ------------------------------------------------------------------

MySqlParser::AdministrationStatementContext::AdministrationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::AlterUserContext* MySqlParser::AdministrationStatementContext::alterUser() {
  return getRuleContext<MySqlParser::AlterUserContext>(0);
}

MySqlParser::CreateUserContext* MySqlParser::AdministrationStatementContext::createUser() {
  return getRuleContext<MySqlParser::CreateUserContext>(0);
}

MySqlParser::DropUserContext* MySqlParser::AdministrationStatementContext::dropUser() {
  return getRuleContext<MySqlParser::DropUserContext>(0);
}

MySqlParser::GrantStatementContext* MySqlParser::AdministrationStatementContext::grantStatement() {
  return getRuleContext<MySqlParser::GrantStatementContext>(0);
}

MySqlParser::GrantProxyContext* MySqlParser::AdministrationStatementContext::grantProxy() {
  return getRuleContext<MySqlParser::GrantProxyContext>(0);
}

MySqlParser::RenameUserContext* MySqlParser::AdministrationStatementContext::renameUser() {
  return getRuleContext<MySqlParser::RenameUserContext>(0);
}

MySqlParser::RevokeStatementContext* MySqlParser::AdministrationStatementContext::revokeStatement() {
  return getRuleContext<MySqlParser::RevokeStatementContext>(0);
}

MySqlParser::RevokeProxyContext* MySqlParser::AdministrationStatementContext::revokeProxy() {
  return getRuleContext<MySqlParser::RevokeProxyContext>(0);
}

MySqlParser::AnalyzeTableContext* MySqlParser::AdministrationStatementContext::analyzeTable() {
  return getRuleContext<MySqlParser::AnalyzeTableContext>(0);
}

MySqlParser::CheckTableContext* MySqlParser::AdministrationStatementContext::checkTable() {
  return getRuleContext<MySqlParser::CheckTableContext>(0);
}

MySqlParser::ChecksumTableContext* MySqlParser::AdministrationStatementContext::checksumTable() {
  return getRuleContext<MySqlParser::ChecksumTableContext>(0);
}

MySqlParser::OptimizeTableContext* MySqlParser::AdministrationStatementContext::optimizeTable() {
  return getRuleContext<MySqlParser::OptimizeTableContext>(0);
}

MySqlParser::RepairTableContext* MySqlParser::AdministrationStatementContext::repairTable() {
  return getRuleContext<MySqlParser::RepairTableContext>(0);
}

MySqlParser::CreateUdfunctionContext* MySqlParser::AdministrationStatementContext::createUdfunction() {
  return getRuleContext<MySqlParser::CreateUdfunctionContext>(0);
}

MySqlParser::InstallPluginContext* MySqlParser::AdministrationStatementContext::installPlugin() {
  return getRuleContext<MySqlParser::InstallPluginContext>(0);
}

MySqlParser::UninstallPluginContext* MySqlParser::AdministrationStatementContext::uninstallPlugin() {
  return getRuleContext<MySqlParser::UninstallPluginContext>(0);
}

MySqlParser::SetStatementContext* MySqlParser::AdministrationStatementContext::setStatement() {
  return getRuleContext<MySqlParser::SetStatementContext>(0);
}

MySqlParser::ShowStatementContext* MySqlParser::AdministrationStatementContext::showStatement() {
  return getRuleContext<MySqlParser::ShowStatementContext>(0);
}

MySqlParser::BinlogStatementContext* MySqlParser::AdministrationStatementContext::binlogStatement() {
  return getRuleContext<MySqlParser::BinlogStatementContext>(0);
}

MySqlParser::CacheIndexStatementContext* MySqlParser::AdministrationStatementContext::cacheIndexStatement() {
  return getRuleContext<MySqlParser::CacheIndexStatementContext>(0);
}

MySqlParser::FlushStatementContext* MySqlParser::AdministrationStatementContext::flushStatement() {
  return getRuleContext<MySqlParser::FlushStatementContext>(0);
}

MySqlParser::KillStatementContext* MySqlParser::AdministrationStatementContext::killStatement() {
  return getRuleContext<MySqlParser::KillStatementContext>(0);
}

MySqlParser::LoadIndexIntoCacheContext* MySqlParser::AdministrationStatementContext::loadIndexIntoCache() {
  return getRuleContext<MySqlParser::LoadIndexIntoCacheContext>(0);
}

MySqlParser::ResetStatementContext* MySqlParser::AdministrationStatementContext::resetStatement() {
  return getRuleContext<MySqlParser::ResetStatementContext>(0);
}

MySqlParser::ShutdownStatementContext* MySqlParser::AdministrationStatementContext::shutdownStatement() {
  return getRuleContext<MySqlParser::ShutdownStatementContext>(0);
}


size_t MySqlParser::AdministrationStatementContext::getRuleIndex() const {
  return MySqlParser::RuleAdministrationStatement;
}

void MySqlParser::AdministrationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdministrationStatement(this);
}

void MySqlParser::AdministrationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdministrationStatement(this);
}


std::any MySqlParser::AdministrationStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAdministrationStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AdministrationStatementContext* MySqlParser::administrationStatement() {
  AdministrationStatementContext *_localctx = _tracker.createInstance<AdministrationStatementContext>(_ctx, getState());
  enterRule(_localctx, 20, MySqlParser::RuleAdministrationStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(880);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(855);
      alterUser();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(856);
      createUser();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(857);
      dropUser();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(858);
      grantStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(859);
      grantProxy();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(860);
      renameUser();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(861);
      revokeStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(862);
      revokeProxy();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(863);
      analyzeTable();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(864);
      checkTable();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(865);
      checksumTable();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(866);
      optimizeTable();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(867);
      repairTable();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(868);
      createUdfunction();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(869);
      installPlugin();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(870);
      uninstallPlugin();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(871);
      setStatement();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(872);
      showStatement();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(873);
      binlogStatement();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(874);
      cacheIndexStatement();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(875);
      flushStatement();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(876);
      killStatement();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(877);
      loadIndexIntoCache();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(878);
      resetStatement();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(879);
      shutdownStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UtilityStatementContext ------------------------------------------------------------------

MySqlParser::UtilityStatementContext::UtilityStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::SimpleDescribeStatementContext* MySqlParser::UtilityStatementContext::simpleDescribeStatement() {
  return getRuleContext<MySqlParser::SimpleDescribeStatementContext>(0);
}

MySqlParser::FullDescribeStatementContext* MySqlParser::UtilityStatementContext::fullDescribeStatement() {
  return getRuleContext<MySqlParser::FullDescribeStatementContext>(0);
}

MySqlParser::HelpStatementContext* MySqlParser::UtilityStatementContext::helpStatement() {
  return getRuleContext<MySqlParser::HelpStatementContext>(0);
}

MySqlParser::UseStatementContext* MySqlParser::UtilityStatementContext::useStatement() {
  return getRuleContext<MySqlParser::UseStatementContext>(0);
}

MySqlParser::SignalStatementContext* MySqlParser::UtilityStatementContext::signalStatement() {
  return getRuleContext<MySqlParser::SignalStatementContext>(0);
}

MySqlParser::ResignalStatementContext* MySqlParser::UtilityStatementContext::resignalStatement() {
  return getRuleContext<MySqlParser::ResignalStatementContext>(0);
}

MySqlParser::DiagnosticsStatementContext* MySqlParser::UtilityStatementContext::diagnosticsStatement() {
  return getRuleContext<MySqlParser::DiagnosticsStatementContext>(0);
}


size_t MySqlParser::UtilityStatementContext::getRuleIndex() const {
  return MySqlParser::RuleUtilityStatement;
}

void MySqlParser::UtilityStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUtilityStatement(this);
}

void MySqlParser::UtilityStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUtilityStatement(this);
}


std::any MySqlParser::UtilityStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUtilityStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UtilityStatementContext* MySqlParser::utilityStatement() {
  UtilityStatementContext *_localctx = _tracker.createInstance<UtilityStatementContext>(_ctx, getState());
  enterRule(_localctx, 22, MySqlParser::RuleUtilityStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(889);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(882);
      simpleDescribeStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(883);
      fullDescribeStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(884);
      helpStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(885);
      useStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(886);
      signalStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(887);
      resignalStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(888);
      diagnosticsStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateDatabaseContext ------------------------------------------------------------------

MySqlParser::CreateDatabaseContext::CreateDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateDatabaseContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

MySqlParser::UidContext* MySqlParser::CreateDatabaseContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::CreateDatabaseContext::DATABASE() {
  return getToken(MySqlParser::DATABASE, 0);
}

tree::TerminalNode* MySqlParser::CreateDatabaseContext::SCHEMA() {
  return getToken(MySqlParser::SCHEMA, 0);
}

MySqlParser::IfNotExistsContext* MySqlParser::CreateDatabaseContext::ifNotExists() {
  return getRuleContext<MySqlParser::IfNotExistsContext>(0);
}

std::vector<MySqlParser::CreateDatabaseOptionContext *> MySqlParser::CreateDatabaseContext::createDatabaseOption() {
  return getRuleContexts<MySqlParser::CreateDatabaseOptionContext>();
}

MySqlParser::CreateDatabaseOptionContext* MySqlParser::CreateDatabaseContext::createDatabaseOption(size_t i) {
  return getRuleContext<MySqlParser::CreateDatabaseOptionContext>(i);
}


size_t MySqlParser::CreateDatabaseContext::getRuleIndex() const {
  return MySqlParser::RuleCreateDatabase;
}

void MySqlParser::CreateDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateDatabase(this);
}

void MySqlParser::CreateDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateDatabase(this);
}


std::any MySqlParser::CreateDatabaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateDatabase(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateDatabaseContext* MySqlParser::createDatabase() {
  CreateDatabaseContext *_localctx = _tracker.createInstance<CreateDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 24, MySqlParser::RuleCreateDatabase);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(891);
    match(MySqlParser::CREATE);
    setState(892);
    antlrcpp::downCast<CreateDatabaseContext *>(_localctx)->dbFormat = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::DATABASE || _la == MySqlParser::SCHEMA)) {
      antlrcpp::downCast<CreateDatabaseContext *>(_localctx)->dbFormat = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(894);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      setState(893);
      ifNotExists();
      break;
    }

    default:
      break;
    }
    setState(896);
    uid();
    setState(900);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4398214283264) != 0) || _la == MySqlParser::READ || _la == MySqlParser::CHAR || _la == MySqlParser::ENCRYPTION || _la == MySqlParser::CHARSET) {
      setState(897);
      createDatabaseOption();
      setState(902);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateEventContext ------------------------------------------------------------------

MySqlParser::CreateEventContext::CreateEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateEventContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateEventContext::EVENT() {
  return getToken(MySqlParser::EVENT, 0);
}

MySqlParser::FullIdContext* MySqlParser::CreateEventContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateEventContext::ON() {
  return getTokens(MySqlParser::ON);
}

tree::TerminalNode* MySqlParser::CreateEventContext::ON(size_t i) {
  return getToken(MySqlParser::ON, i);
}

tree::TerminalNode* MySqlParser::CreateEventContext::SCHEDULE() {
  return getToken(MySqlParser::SCHEDULE, 0);
}

MySqlParser::ScheduleExpressionContext* MySqlParser::CreateEventContext::scheduleExpression() {
  return getRuleContext<MySqlParser::ScheduleExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::CreateEventContext::DO() {
  return getToken(MySqlParser::DO, 0);
}

MySqlParser::RoutineBodyContext* MySqlParser::CreateEventContext::routineBody() {
  return getRuleContext<MySqlParser::RoutineBodyContext>(0);
}

MySqlParser::OwnerStatementContext* MySqlParser::CreateEventContext::ownerStatement() {
  return getRuleContext<MySqlParser::OwnerStatementContext>(0);
}

MySqlParser::IfNotExistsContext* MySqlParser::CreateEventContext::ifNotExists() {
  return getRuleContext<MySqlParser::IfNotExistsContext>(0);
}

tree::TerminalNode* MySqlParser::CreateEventContext::COMPLETION() {
  return getToken(MySqlParser::COMPLETION, 0);
}

tree::TerminalNode* MySqlParser::CreateEventContext::PRESERVE() {
  return getToken(MySqlParser::PRESERVE, 0);
}

MySqlParser::EnableTypeContext* MySqlParser::CreateEventContext::enableType() {
  return getRuleContext<MySqlParser::EnableTypeContext>(0);
}

tree::TerminalNode* MySqlParser::CreateEventContext::COMMENT() {
  return getToken(MySqlParser::COMMENT, 0);
}

tree::TerminalNode* MySqlParser::CreateEventContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::CreateEventContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}


size_t MySqlParser::CreateEventContext::getRuleIndex() const {
  return MySqlParser::RuleCreateEvent;
}

void MySqlParser::CreateEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateEvent(this);
}

void MySqlParser::CreateEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateEvent(this);
}


std::any MySqlParser::CreateEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateEvent(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateEventContext* MySqlParser::createEvent() {
  CreateEventContext *_localctx = _tracker.createInstance<CreateEventContext>(_ctx, getState());
  enterRule(_localctx, 26, MySqlParser::RuleCreateEvent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(903);
    match(MySqlParser::CREATE);
    setState(905);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::DEFINER) {
      setState(904);
      ownerStatement();
    }
    setState(907);
    match(MySqlParser::EVENT);
    setState(909);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      setState(908);
      ifNotExists();
      break;
    }

    default:
      break;
    }
    setState(911);
    fullId();
    setState(912);
    match(MySqlParser::ON);
    setState(913);
    match(MySqlParser::SCHEDULE);
    setState(914);
    scheduleExpression();
    setState(921);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ON) {
      setState(915);
      match(MySqlParser::ON);
      setState(916);
      match(MySqlParser::COMPLETION);
      setState(918);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::NOT) {
        setState(917);
        match(MySqlParser::NOT);
      }
      setState(920);
      match(MySqlParser::PRESERVE);
    }
    setState(924);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::DISABLE

    || _la == MySqlParser::ENABLE) {
      setState(923);
      enableType();
    }
    setState(928);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::COMMENT) {
      setState(926);
      match(MySqlParser::COMMENT);
      setState(927);
      match(MySqlParser::STRING_LITERAL);
    }
    setState(930);
    match(MySqlParser::DO);
    setState(931);
    routineBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateIndexContext ------------------------------------------------------------------

MySqlParser::CreateIndexContext::CreateIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateIndexContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

MySqlParser::UidContext* MySqlParser::CreateIndexContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

MySqlParser::TableNameContext* MySqlParser::CreateIndexContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

MySqlParser::IndexColumnNamesContext* MySqlParser::CreateIndexContext::indexColumnNames() {
  return getRuleContext<MySqlParser::IndexColumnNamesContext>(0);
}

MySqlParser::IndexTypeContext* MySqlParser::CreateIndexContext::indexType() {
  return getRuleContext<MySqlParser::IndexTypeContext>(0);
}

std::vector<MySqlParser::IndexOptionContext *> MySqlParser::CreateIndexContext::indexOption() {
  return getRuleContexts<MySqlParser::IndexOptionContext>();
}

MySqlParser::IndexOptionContext* MySqlParser::CreateIndexContext::indexOption(size_t i) {
  return getRuleContext<MySqlParser::IndexOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateIndexContext::ALGORITHM() {
  return getTokens(MySqlParser::ALGORITHM);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::ALGORITHM(size_t i) {
  return getToken(MySqlParser::ALGORITHM, i);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateIndexContext::LOCK() {
  return getTokens(MySqlParser::LOCK);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::LOCK(size_t i) {
  return getToken(MySqlParser::LOCK, i);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::ONLINE() {
  return getToken(MySqlParser::ONLINE, 0);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::OFFLINE() {
  return getToken(MySqlParser::OFFLINE, 0);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::UNIQUE() {
  return getToken(MySqlParser::UNIQUE, 0);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::FULLTEXT() {
  return getToken(MySqlParser::FULLTEXT, 0);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::SPATIAL() {
  return getToken(MySqlParser::SPATIAL, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateIndexContext::DEFAULT() {
  return getTokens(MySqlParser::DEFAULT);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::DEFAULT(size_t i) {
  return getToken(MySqlParser::DEFAULT, i);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateIndexContext::INPLACE() {
  return getTokens(MySqlParser::INPLACE);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::INPLACE(size_t i) {
  return getToken(MySqlParser::INPLACE, i);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateIndexContext::COPY() {
  return getTokens(MySqlParser::COPY);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::COPY(size_t i) {
  return getToken(MySqlParser::COPY, i);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateIndexContext::NONE() {
  return getTokens(MySqlParser::NONE);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::NONE(size_t i) {
  return getToken(MySqlParser::NONE, i);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateIndexContext::SHARED() {
  return getTokens(MySqlParser::SHARED);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::SHARED(size_t i) {
  return getToken(MySqlParser::SHARED, i);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateIndexContext::EXCLUSIVE() {
  return getTokens(MySqlParser::EXCLUSIVE);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::EXCLUSIVE(size_t i) {
  return getToken(MySqlParser::EXCLUSIVE, i);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateIndexContext::EQUAL_SYMBOL() {
  return getTokens(MySqlParser::EQUAL_SYMBOL);
}

tree::TerminalNode* MySqlParser::CreateIndexContext::EQUAL_SYMBOL(size_t i) {
  return getToken(MySqlParser::EQUAL_SYMBOL, i);
}


size_t MySqlParser::CreateIndexContext::getRuleIndex() const {
  return MySqlParser::RuleCreateIndex;
}

void MySqlParser::CreateIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateIndex(this);
}

void MySqlParser::CreateIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateIndex(this);
}


std::any MySqlParser::CreateIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateIndex(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateIndexContext* MySqlParser::createIndex() {
  CreateIndexContext *_localctx = _tracker.createInstance<CreateIndexContext>(_ctx, getState());
  enterRule(_localctx, 28, MySqlParser::RuleCreateIndex);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(933);
    match(MySqlParser::CREATE);
    setState(935);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::OFFLINE

    || _la == MySqlParser::ONLINE) {
      setState(934);
      antlrcpp::downCast<CreateIndexContext *>(_localctx)->intimeAction = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::OFFLINE

      || _la == MySqlParser::ONLINE)) {
        antlrcpp::downCast<CreateIndexContext *>(_localctx)->intimeAction = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(938);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::FULLTEXT || _la == MySqlParser::SPATIAL

    || _la == MySqlParser::UNIQUE) {
      setState(937);
      antlrcpp::downCast<CreateIndexContext *>(_localctx)->indexCategory = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::FULLTEXT || _la == MySqlParser::SPATIAL

      || _la == MySqlParser::UNIQUE)) {
        antlrcpp::downCast<CreateIndexContext *>(_localctx)->indexCategory = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(940);
    match(MySqlParser::INDEX);
    setState(941);
    uid();
    setState(943);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::USING) {
      setState(942);
      indexType();
    }
    setState(945);
    match(MySqlParser::ON);
    setState(946);
    tableName();
    setState(947);
    indexColumnNames();
    setState(951);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(948);
        indexOption(); 
      }
      setState(953);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
    }
    setState(966);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(964);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::ALGORITHM: {
            setState(954);
            match(MySqlParser::ALGORITHM);
            setState(956);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySqlParser::EQUAL_SYMBOL) {
              setState(955);
              match(MySqlParser::EQUAL_SYMBOL);
            }
            setState(958);
            antlrcpp::downCast<CreateIndexContext *>(_localctx)->algType = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::COPY || _la == MySqlParser::INPLACE)) {
              antlrcpp::downCast<CreateIndexContext *>(_localctx)->algType = _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
            break;
          }

          case MySqlParser::LOCK: {
            setState(959);
            match(MySqlParser::LOCK);
            setState(961);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySqlParser::EQUAL_SYMBOL) {
              setState(960);
              match(MySqlParser::EQUAL_SYMBOL);
            }
            setState(963);
            antlrcpp::downCast<CreateIndexContext *>(_localctx)->lockType = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::EXCLUSIVE || _la == MySqlParser::NONE || _la == MySqlParser::SHARED)) {
              antlrcpp::downCast<CreateIndexContext *>(_localctx)->lockType = _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(968);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateLogfileGroupContext ------------------------------------------------------------------

MySqlParser::CreateLogfileGroupContext::CreateLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::LOGFILE() {
  return getToken(MySqlParser::LOGFILE, 0);
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::GROUP() {
  return getToken(MySqlParser::GROUP, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::CreateLogfileGroupContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::CreateLogfileGroupContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::UNDOFILE() {
  return getToken(MySqlParser::UNDOFILE, 0);
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::ENGINE() {
  return getToken(MySqlParser::ENGINE, 0);
}

MySqlParser::EngineNameContext* MySqlParser::CreateLogfileGroupContext::engineName() {
  return getRuleContext<MySqlParser::EngineNameContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateLogfileGroupContext::STRING_LITERAL() {
  return getTokens(MySqlParser::STRING_LITERAL);
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::STRING_LITERAL(size_t i) {
  return getToken(MySqlParser::STRING_LITERAL, i);
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::INITIAL_SIZE() {
  return getToken(MySqlParser::INITIAL_SIZE, 0);
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::UNDO_BUFFER_SIZE() {
  return getToken(MySqlParser::UNDO_BUFFER_SIZE, 0);
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::REDO_BUFFER_SIZE() {
  return getToken(MySqlParser::REDO_BUFFER_SIZE, 0);
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::NODEGROUP() {
  return getToken(MySqlParser::NODEGROUP, 0);
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::WAIT() {
  return getToken(MySqlParser::WAIT, 0);
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::COMMENT() {
  return getToken(MySqlParser::COMMENT, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateLogfileGroupContext::EQUAL_SYMBOL() {
  return getTokens(MySqlParser::EQUAL_SYMBOL);
}

tree::TerminalNode* MySqlParser::CreateLogfileGroupContext::EQUAL_SYMBOL(size_t i) {
  return getToken(MySqlParser::EQUAL_SYMBOL, i);
}

std::vector<MySqlParser::FileSizeLiteralContext *> MySqlParser::CreateLogfileGroupContext::fileSizeLiteral() {
  return getRuleContexts<MySqlParser::FileSizeLiteralContext>();
}

MySqlParser::FileSizeLiteralContext* MySqlParser::CreateLogfileGroupContext::fileSizeLiteral(size_t i) {
  return getRuleContext<MySqlParser::FileSizeLiteralContext>(i);
}


size_t MySqlParser::CreateLogfileGroupContext::getRuleIndex() const {
  return MySqlParser::RuleCreateLogfileGroup;
}

void MySqlParser::CreateLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateLogfileGroup(this);
}

void MySqlParser::CreateLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateLogfileGroup(this);
}


std::any MySqlParser::CreateLogfileGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateLogfileGroup(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateLogfileGroupContext* MySqlParser::createLogfileGroup() {
  CreateLogfileGroupContext *_localctx = _tracker.createInstance<CreateLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 30, MySqlParser::RuleCreateLogfileGroup);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(969);
    match(MySqlParser::CREATE);
    setState(970);
    match(MySqlParser::LOGFILE);
    setState(971);
    match(MySqlParser::GROUP);
    setState(972);
    uid();
    setState(973);
    match(MySqlParser::ADD);
    setState(974);
    match(MySqlParser::UNDOFILE);
    setState(975);
    antlrcpp::downCast<CreateLogfileGroupContext *>(_localctx)->undoFile = match(MySqlParser::STRING_LITERAL);
    setState(981);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::INITIAL_SIZE) {
      setState(976);
      match(MySqlParser::INITIAL_SIZE);
      setState(978);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(977);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(980);
      antlrcpp::downCast<CreateLogfileGroupContext *>(_localctx)->initSize = fileSizeLiteral();
    }
    setState(988);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::UNDO_BUFFER_SIZE) {
      setState(983);
      match(MySqlParser::UNDO_BUFFER_SIZE);
      setState(985);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(984);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(987);
      antlrcpp::downCast<CreateLogfileGroupContext *>(_localctx)->undoSize = fileSizeLiteral();
    }
    setState(995);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::REDO_BUFFER_SIZE) {
      setState(990);
      match(MySqlParser::REDO_BUFFER_SIZE);
      setState(992);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(991);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(994);
      antlrcpp::downCast<CreateLogfileGroupContext *>(_localctx)->redoSize = fileSizeLiteral();
    }
    setState(1002);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::NODEGROUP) {
      setState(997);
      match(MySqlParser::NODEGROUP);
      setState(999);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(998);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1001);
      uid();
    }
    setState(1005);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WAIT) {
      setState(1004);
      match(MySqlParser::WAIT);
    }
    setState(1012);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::COMMENT) {
      setState(1007);
      match(MySqlParser::COMMENT);
      setState(1009);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1008);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1011);
      antlrcpp::downCast<CreateLogfileGroupContext *>(_localctx)->comment = match(MySqlParser::STRING_LITERAL);
    }
    setState(1014);
    match(MySqlParser::ENGINE);
    setState(1016);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::EQUAL_SYMBOL) {
      setState(1015);
      match(MySqlParser::EQUAL_SYMBOL);
    }
    setState(1018);
    engineName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateProcedureContext ------------------------------------------------------------------

MySqlParser::CreateProcedureContext::CreateProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateProcedureContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateProcedureContext::PROCEDURE() {
  return getToken(MySqlParser::PROCEDURE, 0);
}

MySqlParser::FullIdContext* MySqlParser::CreateProcedureContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

tree::TerminalNode* MySqlParser::CreateProcedureContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::CreateProcedureContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::RoutineBodyContext* MySqlParser::CreateProcedureContext::routineBody() {
  return getRuleContext<MySqlParser::RoutineBodyContext>(0);
}

MySqlParser::OwnerStatementContext* MySqlParser::CreateProcedureContext::ownerStatement() {
  return getRuleContext<MySqlParser::OwnerStatementContext>(0);
}

std::vector<MySqlParser::ProcedureParameterContext *> MySqlParser::CreateProcedureContext::procedureParameter() {
  return getRuleContexts<MySqlParser::ProcedureParameterContext>();
}

MySqlParser::ProcedureParameterContext* MySqlParser::CreateProcedureContext::procedureParameter(size_t i) {
  return getRuleContext<MySqlParser::ProcedureParameterContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateProcedureContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::CreateProcedureContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

std::vector<MySqlParser::RoutineOptionContext *> MySqlParser::CreateProcedureContext::routineOption() {
  return getRuleContexts<MySqlParser::RoutineOptionContext>();
}

MySqlParser::RoutineOptionContext* MySqlParser::CreateProcedureContext::routineOption(size_t i) {
  return getRuleContext<MySqlParser::RoutineOptionContext>(i);
}


size_t MySqlParser::CreateProcedureContext::getRuleIndex() const {
  return MySqlParser::RuleCreateProcedure;
}

void MySqlParser::CreateProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateProcedure(this);
}

void MySqlParser::CreateProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateProcedure(this);
}


std::any MySqlParser::CreateProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateProcedure(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateProcedureContext* MySqlParser::createProcedure() {
  CreateProcedureContext *_localctx = _tracker.createInstance<CreateProcedureContext>(_ctx, getState());
  enterRule(_localctx, 32, MySqlParser::RuleCreateProcedure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1020);
    match(MySqlParser::CREATE);
    setState(1022);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::DEFINER) {
      setState(1021);
      ownerStatement();
    }
    setState(1024);
    match(MySqlParser::PROCEDURE);
    setState(1025);
    fullId();
    setState(1026);
    match(MySqlParser::LR_BRACKET);
    setState(1028);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 151169654698547409) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
      setState(1027);
      procedureParameter();
    }
    setState(1034);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(1030);
      match(MySqlParser::COMMA);
      setState(1031);
      procedureParameter();
      setState(1036);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1037);
    match(MySqlParser::RR_BRACKET);
    setState(1041);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1038);
        routineOption(); 
      }
      setState(1043);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx);
    }
    setState(1044);
    routineBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateFunctionContext ------------------------------------------------------------------

MySqlParser::CreateFunctionContext::CreateFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateFunctionContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateFunctionContext::FUNCTION() {
  return getToken(MySqlParser::FUNCTION, 0);
}

MySqlParser::FullIdContext* MySqlParser::CreateFunctionContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

tree::TerminalNode* MySqlParser::CreateFunctionContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::CreateFunctionContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::CreateFunctionContext::RETURNS() {
  return getToken(MySqlParser::RETURNS, 0);
}

MySqlParser::DataTypeContext* MySqlParser::CreateFunctionContext::dataType() {
  return getRuleContext<MySqlParser::DataTypeContext>(0);
}

MySqlParser::RoutineBodyContext* MySqlParser::CreateFunctionContext::routineBody() {
  return getRuleContext<MySqlParser::RoutineBodyContext>(0);
}

MySqlParser::ReturnStatementContext* MySqlParser::CreateFunctionContext::returnStatement() {
  return getRuleContext<MySqlParser::ReturnStatementContext>(0);
}

MySqlParser::OwnerStatementContext* MySqlParser::CreateFunctionContext::ownerStatement() {
  return getRuleContext<MySqlParser::OwnerStatementContext>(0);
}

tree::TerminalNode* MySqlParser::CreateFunctionContext::AGGREGATE() {
  return getToken(MySqlParser::AGGREGATE, 0);
}

MySqlParser::IfNotExistsContext* MySqlParser::CreateFunctionContext::ifNotExists() {
  return getRuleContext<MySqlParser::IfNotExistsContext>(0);
}

std::vector<MySqlParser::FunctionParameterContext *> MySqlParser::CreateFunctionContext::functionParameter() {
  return getRuleContexts<MySqlParser::FunctionParameterContext>();
}

MySqlParser::FunctionParameterContext* MySqlParser::CreateFunctionContext::functionParameter(size_t i) {
  return getRuleContext<MySqlParser::FunctionParameterContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateFunctionContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::CreateFunctionContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

std::vector<MySqlParser::RoutineOptionContext *> MySqlParser::CreateFunctionContext::routineOption() {
  return getRuleContexts<MySqlParser::RoutineOptionContext>();
}

MySqlParser::RoutineOptionContext* MySqlParser::CreateFunctionContext::routineOption(size_t i) {
  return getRuleContext<MySqlParser::RoutineOptionContext>(i);
}


size_t MySqlParser::CreateFunctionContext::getRuleIndex() const {
  return MySqlParser::RuleCreateFunction;
}

void MySqlParser::CreateFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateFunction(this);
}

void MySqlParser::CreateFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateFunction(this);
}


std::any MySqlParser::CreateFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateFunction(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateFunctionContext* MySqlParser::createFunction() {
  CreateFunctionContext *_localctx = _tracker.createInstance<CreateFunctionContext>(_ctx, getState());
  enterRule(_localctx, 34, MySqlParser::RuleCreateFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1046);
    match(MySqlParser::CREATE);
    setState(1048);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::DEFINER) {
      setState(1047);
      ownerStatement();
    }
    setState(1051);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::AGGREGATE) {
      setState(1050);
      match(MySqlParser::AGGREGATE);
    }
    setState(1053);
    match(MySqlParser::FUNCTION);
    setState(1055);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      setState(1054);
      ifNotExists();
      break;
    }

    default:
      break;
    }
    setState(1057);
    fullId();
    setState(1058);
    match(MySqlParser::LR_BRACKET);
    setState(1060);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
      setState(1059);
      functionParameter();
    }
    setState(1066);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(1062);
      match(MySqlParser::COMMA);
      setState(1063);
      functionParameter();
      setState(1068);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1069);
    match(MySqlParser::RR_BRACKET);
    setState(1070);
    match(MySqlParser::RETURNS);
    setState(1071);
    dataType();
    setState(1075);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1072);
        routineOption(); 
      }
      setState(1077);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx);
    }
    setState(1080);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::ALTER:
      case MySqlParser::ANALYZE:
      case MySqlParser::ATTRIBUTE:
      case MySqlParser::BUCKETS:
      case MySqlParser::CALL:
      case MySqlParser::CHANGE:
      case MySqlParser::CHECK:
      case MySqlParser::CONDITION:
      case MySqlParser::CREATE:
      case MySqlParser::CURRENT:
      case MySqlParser::CURRENT_USER:
      case MySqlParser::DATABASE:
      case MySqlParser::DEFAULT:
      case MySqlParser::DELETE:
      case MySqlParser::DESC:
      case MySqlParser::DESCRIBE:
      case MySqlParser::DIAGNOSTICS:
      case MySqlParser::DROP:
      case MySqlParser::EMPTY:
      case MySqlParser::ENFORCED:
      case MySqlParser::EXCEPT:
      case MySqlParser::EXPLAIN:
      case MySqlParser::GET:
      case MySqlParser::GRANT:
      case MySqlParser::GROUP:
      case MySqlParser::IF:
      case MySqlParser::IGNORED:
      case MySqlParser::INSERT:
      case MySqlParser::KILL:
      case MySqlParser::LATERAL:
      case MySqlParser::LEFT:
      case MySqlParser::LOAD:
      case MySqlParser::LOCK:
      case MySqlParser::NUMBER:
      case MySqlParser::OPTIMIZE:
      case MySqlParser::OPTIONAL:
      case MySqlParser::ORDER:
      case MySqlParser::PRIMARY:
      case MySqlParser::PURGE:
      case MySqlParser::RELEASE:
      case MySqlParser::RENAME:
      case MySqlParser::REPLACE:
      case MySqlParser::RESIGNAL:
      case MySqlParser::REVOKE:
      case MySqlParser::RIGHT:
      case MySqlParser::SCHEMA:
      case MySqlParser::SELECT:
      case MySqlParser::SET:
      case MySqlParser::SHOW:
      case MySqlParser::SIGNAL:
      case MySqlParser::SKIP_QUERY_REWRITE:
      case MySqlParser::STACKED:
      case MySqlParser::TABLE:
      case MySqlParser::UNLOCK:
      case MySqlParser::UPDATE:
      case MySqlParser::USE:
      case MySqlParser::VALUES:
      case MySqlParser::WITH:
      case MySqlParser::DATE:
      case MySqlParser::TIME:
      case MySqlParser::TIMESTAMP:
      case MySqlParser::DATETIME:
      case MySqlParser::YEAR:
      case MySqlParser::BINARY:
      case MySqlParser::TEXT:
      case MySqlParser::ENUM:
      case MySqlParser::SERIAL:
      case MySqlParser::JSON_ARRAY:
      case MySqlParser::JSON_ARRAYAGG:
      case MySqlParser::JSON_ARRAY_APPEND:
      case MySqlParser::JSON_ARRAY_INSERT:
      case MySqlParser::JSON_CONTAINS:
      case MySqlParser::JSON_CONTAINS_PATH:
      case MySqlParser::JSON_DEPTH:
      case MySqlParser::JSON_EXTRACT:
      case MySqlParser::JSON_INSERT:
      case MySqlParser::JSON_KEYS:
      case MySqlParser::JSON_LENGTH:
      case MySqlParser::JSON_MERGE:
      case MySqlParser::JSON_MERGE_PATCH:
      case MySqlParser::JSON_MERGE_PRESERVE:
      case MySqlParser::JSON_OBJECT:
      case MySqlParser::JSON_OBJECTAGG:
      case MySqlParser::JSON_OVERLAPS:
      case MySqlParser::JSON_PRETTY:
      case MySqlParser::JSON_QUOTE:
      case MySqlParser::JSON_REMOVE:
      case MySqlParser::JSON_REPLACE:
      case MySqlParser::JSON_SCHEMA_VALID:
      case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
      case MySqlParser::JSON_SEARCH:
      case MySqlParser::JSON_SET:
      case MySqlParser::JSON_STORAGE_FREE:
      case MySqlParser::JSON_STORAGE_SIZE:
      case MySqlParser::JSON_TABLE:
      case MySqlParser::JSON_TYPE:
      case MySqlParser::JSON_UNQUOTE:
      case MySqlParser::JSON_VALID:
      case MySqlParser::JSON_VALUE:
      case MySqlParser::NESTED:
      case MySqlParser::ORDINALITY:
      case MySqlParser::PATH:
      case MySqlParser::AVG:
      case MySqlParser::BIT_AND:
      case MySqlParser::BIT_OR:
      case MySqlParser::BIT_XOR:
      case MySqlParser::COUNT:
      case MySqlParser::CUME_DIST:
      case MySqlParser::DENSE_RANK:
      case MySqlParser::FIRST_VALUE:
      case MySqlParser::GROUP_CONCAT:
      case MySqlParser::LAG:
      case MySqlParser::LAST_VALUE:
      case MySqlParser::LEAD:
      case MySqlParser::MAX:
      case MySqlParser::MIN:
      case MySqlParser::NTILE:
      case MySqlParser::NTH_VALUE:
      case MySqlParser::PERCENT_RANK:
      case MySqlParser::RANK:
      case MySqlParser::ROW_NUMBER:
      case MySqlParser::STD:
      case MySqlParser::STDDEV:
      case MySqlParser::STDDEV_POP:
      case MySqlParser::STDDEV_SAMP:
      case MySqlParser::SUM:
      case MySqlParser::VAR_POP:
      case MySqlParser::VAR_SAMP:
      case MySqlParser::VARIANCE:
      case MySqlParser::CURRENT_DATE:
      case MySqlParser::CURRENT_TIME:
      case MySqlParser::CURRENT_TIMESTAMP:
      case MySqlParser::LOCALTIME:
      case MySqlParser::CURDATE:
      case MySqlParser::CURTIME:
      case MySqlParser::DATE_ADD:
      case MySqlParser::DATE_SUB:
      case MySqlParser::LOCALTIMESTAMP:
      case MySqlParser::NOW:
      case MySqlParser::POSITION:
      case MySqlParser::SUBSTR:
      case MySqlParser::SUBSTRING:
      case MySqlParser::SYSDATE:
      case MySqlParser::TRIM:
      case MySqlParser::UTC_DATE:
      case MySqlParser::UTC_TIME:
      case MySqlParser::UTC_TIMESTAMP:
      case MySqlParser::ACCOUNT:
      case MySqlParser::ACTION:
      case MySqlParser::AFTER:
      case MySqlParser::AGGREGATE:
      case MySqlParser::ALGORITHM:
      case MySqlParser::ANY:
      case MySqlParser::AT:
      case MySqlParser::AUTHORS:
      case MySqlParser::AUTOCOMMIT:
      case MySqlParser::AUTOEXTEND_SIZE:
      case MySqlParser::AUTO_INCREMENT:
      case MySqlParser::AVG_ROW_LENGTH:
      case MySqlParser::BEGIN:
      case MySqlParser::BINLOG:
      case MySqlParser::BIT:
      case MySqlParser::BLOCK:
      case MySqlParser::BOOL:
      case MySqlParser::BOOLEAN:
      case MySqlParser::BTREE:
      case MySqlParser::CACHE:
      case MySqlParser::CASCADED:
      case MySqlParser::CHAIN:
      case MySqlParser::CHANGED:
      case MySqlParser::CHANNEL:
      case MySqlParser::CHECKSUM:
      case MySqlParser::PAGE_CHECKSUM:
      case MySqlParser::CIPHER:
      case MySqlParser::CLASS_ORIGIN:
      case MySqlParser::CLIENT:
      case MySqlParser::CLOSE:
      case MySqlParser::CLUSTERING:
      case MySqlParser::COALESCE:
      case MySqlParser::CODE:
      case MySqlParser::COLUMNS:
      case MySqlParser::COLUMN_FORMAT:
      case MySqlParser::COLUMN_NAME:
      case MySqlParser::COMMENT:
      case MySqlParser::COMMIT:
      case MySqlParser::COMPACT:
      case MySqlParser::COMPLETION:
      case MySqlParser::COMPRESSED:
      case MySqlParser::COMPRESSION:
      case MySqlParser::CONCURRENT:
      case MySqlParser::CONNECT:
      case MySqlParser::CONNECTION:
      case MySqlParser::CONSISTENT:
      case MySqlParser::CONSTRAINT_CATALOG:
      case MySqlParser::CONSTRAINT_SCHEMA:
      case MySqlParser::CONSTRAINT_NAME:
      case MySqlParser::CONTAINS:
      case MySqlParser::CONTEXT:
      case MySqlParser::CONTRIBUTORS:
      case MySqlParser::COPY:
      case MySqlParser::CPU:
      case MySqlParser::CURSOR_NAME:
      case MySqlParser::DATA:
      case MySqlParser::DATAFILE:
      case MySqlParser::DEALLOCATE:
      case MySqlParser::DEFAULT_AUTH:
      case MySqlParser::DEFINER:
      case MySqlParser::DELAY_KEY_WRITE:
      case MySqlParser::DES_KEY_FILE:
      case MySqlParser::DIRECTORY:
      case MySqlParser::DISABLE:
      case MySqlParser::DISCARD:
      case MySqlParser::DISK:
      case MySqlParser::DO:
      case MySqlParser::DUMPFILE:
      case MySqlParser::DUPLICATE:
      case MySqlParser::DYNAMIC:
      case MySqlParser::ENABLE:
      case MySqlParser::ENCRYPTION:
      case MySqlParser::END:
      case MySqlParser::ENDS:
      case MySqlParser::ENGINE:
      case MySqlParser::ENGINES:
      case MySqlParser::ERROR:
      case MySqlParser::ERRORS:
      case MySqlParser::ESCAPE:
      case MySqlParser::EVEN:
      case MySqlParser::EVENT:
      case MySqlParser::EVENTS:
      case MySqlParser::EVERY:
      case MySqlParser::EXCHANGE:
      case MySqlParser::EXCLUSIVE:
      case MySqlParser::EXPIRE:
      case MySqlParser::EXPORT:
      case MySqlParser::EXTENDED:
      case MySqlParser::EXTENT_SIZE:
      case MySqlParser::FAILED_LOGIN_ATTEMPTS:
      case MySqlParser::FAST:
      case MySqlParser::FAULTS:
      case MySqlParser::FIELDS:
      case MySqlParser::FILE_BLOCK_SIZE:
      case MySqlParser::FILTER:
      case MySqlParser::FIRST:
      case MySqlParser::FIXED:
      case MySqlParser::FLUSH:
      case MySqlParser::FOLLOWS:
      case MySqlParser::FOUND:
      case MySqlParser::FULL:
      case MySqlParser::FUNCTION:
      case MySqlParser::GENERAL:
      case MySqlParser::GLOBAL:
      case MySqlParser::GRANTS:
      case MySqlParser::GROUP_REPLICATION:
      case MySqlParser::HANDLER:
      case MySqlParser::HASH:
      case MySqlParser::HELP:
      case MySqlParser::HISTORY:
      case MySqlParser::HOST:
      case MySqlParser::HOSTS:
      case MySqlParser::IDENTIFIED:
      case MySqlParser::IGNORE_SERVER_IDS:
      case MySqlParser::IMPORT:
      case MySqlParser::INDEXES:
      case MySqlParser::INITIAL_SIZE:
      case MySqlParser::INPLACE:
      case MySqlParser::INSERT_METHOD:
      case MySqlParser::INSTALL:
      case MySqlParser::INSTANCE:
      case MySqlParser::INSTANT:
      case MySqlParser::INVISIBLE:
      case MySqlParser::INVOKER:
      case MySqlParser::IO:
      case MySqlParser::IO_THREAD:
      case MySqlParser::IPC:
      case MySqlParser::ISOLATION:
      case MySqlParser::ISSUER:
      case MySqlParser::JSON:
      case MySqlParser::KEY_BLOCK_SIZE:
      case MySqlParser::LANGUAGE:
      case MySqlParser::LAST:
      case MySqlParser::LEAVES:
      case MySqlParser::LESS:
      case MySqlParser::LEVEL:
      case MySqlParser::LIST:
      case MySqlParser::LOCAL:
      case MySqlParser::LOGFILE:
      case MySqlParser::LOGS:
      case MySqlParser::MASTER:
      case MySqlParser::MASTER_AUTO_POSITION:
      case MySqlParser::MASTER_CONNECT_RETRY:
      case MySqlParser::MASTER_DELAY:
      case MySqlParser::MASTER_HEARTBEAT_PERIOD:
      case MySqlParser::MASTER_HOST:
      case MySqlParser::MASTER_LOG_FILE:
      case MySqlParser::MASTER_LOG_POS:
      case MySqlParser::MASTER_PASSWORD:
      case MySqlParser::MASTER_PORT:
      case MySqlParser::MASTER_RETRY_COUNT:
      case MySqlParser::MASTER_SSL:
      case MySqlParser::MASTER_SSL_CA:
      case MySqlParser::MASTER_SSL_CAPATH:
      case MySqlParser::MASTER_SSL_CERT:
      case MySqlParser::MASTER_SSL_CIPHER:
      case MySqlParser::MASTER_SSL_CRL:
      case MySqlParser::MASTER_SSL_CRLPATH:
      case MySqlParser::MASTER_SSL_KEY:
      case MySqlParser::MASTER_TLS_VERSION:
      case MySqlParser::MASTER_USER:
      case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
      case MySqlParser::MAX_QUERIES_PER_HOUR:
      case MySqlParser::MAX_ROWS:
      case MySqlParser::MAX_SIZE:
      case MySqlParser::MAX_UPDATES_PER_HOUR:
      case MySqlParser::MAX_USER_CONNECTIONS:
      case MySqlParser::MEDIUM:
      case MySqlParser::MEMBER:
      case MySqlParser::MERGE:
      case MySqlParser::MESSAGE_TEXT:
      case MySqlParser::MID:
      case MySqlParser::MIGRATE:
      case MySqlParser::MIN_ROWS:
      case MySqlParser::MODE:
      case MySqlParser::MODIFY:
      case MySqlParser::MUTEX:
      case MySqlParser::MYSQL:
      case MySqlParser::MYSQL_ERRNO:
      case MySqlParser::NAME:
      case MySqlParser::NAMES:
      case MySqlParser::NCHAR:
      case MySqlParser::NEVER:
      case MySqlParser::NEXT:
      case MySqlParser::NO:
      case MySqlParser::NOCOPY:
      case MySqlParser::NOWAIT:
      case MySqlParser::NODEGROUP:
      case MySqlParser::NONE:
      case MySqlParser::ODBC:
      case MySqlParser::OFFLINE:
      case MySqlParser::OFFSET:
      case MySqlParser::OF:
      case MySqlParser::OJ:
      case MySqlParser::OLD_PASSWORD:
      case MySqlParser::ONE:
      case MySqlParser::ONLINE:
      case MySqlParser::ONLY:
      case MySqlParser::OPEN:
      case MySqlParser::OPTIMIZER_COSTS:
      case MySqlParser::OPTIONS:
      case MySqlParser::OWNER:
      case MySqlParser::PACK_KEYS:
      case MySqlParser::PAGE:
      case MySqlParser::PARSER:
      case MySqlParser::PARTIAL:
      case MySqlParser::PARTITIONING:
      case MySqlParser::PARTITIONS:
      case MySqlParser::PASSWORD:
      case MySqlParser::PASSWORD_LOCK_TIME:
      case MySqlParser::PHASE:
      case MySqlParser::PLUGIN:
      case MySqlParser::PLUGIN_DIR:
      case MySqlParser::PLUGINS:
      case MySqlParser::PORT:
      case MySqlParser::PRECEDES:
      case MySqlParser::PREPARE:
      case MySqlParser::PRESERVE:
      case MySqlParser::PREV:
      case MySqlParser::PROCESSLIST:
      case MySqlParser::PROFILE:
      case MySqlParser::PROFILES:
      case MySqlParser::PROXY:
      case MySqlParser::QUERY:
      case MySqlParser::QUICK:
      case MySqlParser::REBUILD:
      case MySqlParser::RECOVER:
      case MySqlParser::RECURSIVE:
      case MySqlParser::REDO_BUFFER_SIZE:
      case MySqlParser::REDUNDANT:
      case MySqlParser::RELAY:
      case MySqlParser::RELAY_LOG_FILE:
      case MySqlParser::RELAY_LOG_POS:
      case MySqlParser::RELAYLOG:
      case MySqlParser::REMOVE:
      case MySqlParser::REORGANIZE:
      case MySqlParser::REPAIR:
      case MySqlParser::REPLICATE_DO_DB:
      case MySqlParser::REPLICATE_DO_TABLE:
      case MySqlParser::REPLICATE_IGNORE_DB:
      case MySqlParser::REPLICATE_IGNORE_TABLE:
      case MySqlParser::REPLICATE_REWRITE_DB:
      case MySqlParser::REPLICATE_WILD_DO_TABLE:
      case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySqlParser::REPLICATION:
      case MySqlParser::RESET:
      case MySqlParser::RESUME:
      case MySqlParser::RETURNED_SQLSTATE:
      case MySqlParser::RETURNS:
      case MySqlParser::REUSE:
      case MySqlParser::ROLE:
      case MySqlParser::ROLLBACK:
      case MySqlParser::ROLLUP:
      case MySqlParser::ROTATE:
      case MySqlParser::ROW:
      case MySqlParser::ROWS:
      case MySqlParser::ROW_FORMAT:
      case MySqlParser::RTREE:
      case MySqlParser::SAVEPOINT:
      case MySqlParser::SCHEDULE:
      case MySqlParser::SECURITY:
      case MySqlParser::SERVER:
      case MySqlParser::SESSION:
      case MySqlParser::SHARE:
      case MySqlParser::SHARED:
      case MySqlParser::SIGNED:
      case MySqlParser::SIMPLE:
      case MySqlParser::SLAVE:
      case MySqlParser::SLOW:
      case MySqlParser::SNAPSHOT:
      case MySqlParser::SOCKET:
      case MySqlParser::SOME:
      case MySqlParser::SONAME:
      case MySqlParser::SOUNDS:
      case MySqlParser::SOURCE:
      case MySqlParser::SQL_AFTER_GTIDS:
      case MySqlParser::SQL_AFTER_MTS_GAPS:
      case MySqlParser::SQL_BEFORE_GTIDS:
      case MySqlParser::SQL_BUFFER_RESULT:
      case MySqlParser::SQL_CACHE:
      case MySqlParser::SQL_NO_CACHE:
      case MySqlParser::SQL_THREAD:
      case MySqlParser::START:
      case MySqlParser::STARTS:
      case MySqlParser::STATS_AUTO_RECALC:
      case MySqlParser::STATS_PERSISTENT:
      case MySqlParser::STATS_SAMPLE_PAGES:
      case MySqlParser::STATUS:
      case MySqlParser::STOP:
      case MySqlParser::STORAGE:
      case MySqlParser::STRING:
      case MySqlParser::SUBCLASS_ORIGIN:
      case MySqlParser::SUBJECT:
      case MySqlParser::SUBPARTITION:
      case MySqlParser::SUBPARTITIONS:
      case MySqlParser::SUSPEND:
      case MySqlParser::SWAPS:
      case MySqlParser::SWITCHES:
      case MySqlParser::TABLE_NAME:
      case MySqlParser::TABLESPACE:
      case MySqlParser::TABLE_TYPE:
      case MySqlParser::TEMPORARY:
      case MySqlParser::TEMPTABLE:
      case MySqlParser::THAN:
      case MySqlParser::TRADITIONAL:
      case MySqlParser::TRANSACTION:
      case MySqlParser::TRANSACTIONAL:
      case MySqlParser::TRIGGERS:
      case MySqlParser::TRUNCATE:
      case MySqlParser::UNBOUNDED:
      case MySqlParser::UNDEFINED:
      case MySqlParser::UNDOFILE:
      case MySqlParser::UNDO_BUFFER_SIZE:
      case MySqlParser::UNINSTALL:
      case MySqlParser::UNKNOWN:
      case MySqlParser::UNTIL:
      case MySqlParser::UPGRADE:
      case MySqlParser::USER:
      case MySqlParser::USE_FRM:
      case MySqlParser::USER_RESOURCES:
      case MySqlParser::VALIDATION:
      case MySqlParser::VALUE:
      case MySqlParser::VARIABLES:
      case MySqlParser::VIEW:
      case MySqlParser::VIRTUAL:
      case MySqlParser::VISIBLE:
      case MySqlParser::WAIT:
      case MySqlParser::WARNINGS:
      case MySqlParser::WITHOUT:
      case MySqlParser::WORK:
      case MySqlParser::WRAPPER:
      case MySqlParser::X509:
      case MySqlParser::XA:
      case MySqlParser::XML:
      case MySqlParser::EUR:
      case MySqlParser::USA:
      case MySqlParser::JIS:
      case MySqlParser::ISO:
      case MySqlParser::INTERNAL:
      case MySqlParser::QUARTER:
      case MySqlParser::MONTH:
      case MySqlParser::DAY:
      case MySqlParser::HOUR:
      case MySqlParser::MINUTE:
      case MySqlParser::WEEK:
      case MySqlParser::SECOND:
      case MySqlParser::MICROSECOND:
      case MySqlParser::ADMIN:
      case MySqlParser::AUDIT_ABORT_EXEMPT:
      case MySqlParser::AUDIT_ADMIN:
      case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
      case MySqlParser::BACKUP_ADMIN:
      case MySqlParser::BINLOG_ADMIN:
      case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
      case MySqlParser::CLONE_ADMIN:
      case MySqlParser::CONNECTION_ADMIN:
      case MySqlParser::ENCRYPTION_KEY_ADMIN:
      case MySqlParser::EXECUTE:
      case MySqlParser::FILE:
      case MySqlParser::FIREWALL_ADMIN:
      case MySqlParser::FIREWALL_EXEMPT:
      case MySqlParser::FIREWALL_USER:
      case MySqlParser::GROUP_REPLICATION_ADMIN:
      case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
      case MySqlParser::INVOKE:
      case MySqlParser::LAMBDA:
      case MySqlParser::NDB_STORED_USER:
      case MySqlParser::PASSWORDLESS_USER_ADMIN:
      case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
      case MySqlParser::PRIVILEGES:
      case MySqlParser::PROCESS:
      case MySqlParser::RELOAD:
      case MySqlParser::REPLICATION_APPLIER:
      case MySqlParser::REPLICATION_SLAVE_ADMIN:
      case MySqlParser::RESOURCE_GROUP_ADMIN:
      case MySqlParser::RESOURCE_GROUP_USER:
      case MySqlParser::ROLE_ADMIN:
      case MySqlParser::ROUTINE:
      case MySqlParser::S3:
      case MySqlParser::SESSION_VARIABLES_ADMIN:
      case MySqlParser::SET_USER_ID:
      case MySqlParser::SHOW_ROUTINE:
      case MySqlParser::SHUTDOWN:
      case MySqlParser::SUPER:
      case MySqlParser::SYSTEM_VARIABLES_ADMIN:
      case MySqlParser::TABLES:
      case MySqlParser::TABLE_ENCRYPTION_ADMIN:
      case MySqlParser::VERSION_TOKEN_ADMIN:
      case MySqlParser::XA_RECOVER_ADMIN:
      case MySqlParser::ARMSCII8:
      case MySqlParser::ASCII:
      case MySqlParser::BIG5:
      case MySqlParser::CP1250:
      case MySqlParser::CP1251:
      case MySqlParser::CP1256:
      case MySqlParser::CP1257:
      case MySqlParser::CP850:
      case MySqlParser::CP852:
      case MySqlParser::CP866:
      case MySqlParser::CP932:
      case MySqlParser::DEC8:
      case MySqlParser::EUCJPMS:
      case MySqlParser::EUCKR:
      case MySqlParser::GB18030:
      case MySqlParser::GB2312:
      case MySqlParser::GBK:
      case MySqlParser::GEOSTD8:
      case MySqlParser::GREEK:
      case MySqlParser::HEBREW:
      case MySqlParser::HP8:
      case MySqlParser::KEYBCS2:
      case MySqlParser::KOI8R:
      case MySqlParser::KOI8U:
      case MySqlParser::LATIN1:
      case MySqlParser::LATIN2:
      case MySqlParser::LATIN5:
      case MySqlParser::LATIN7:
      case MySqlParser::MACCE:
      case MySqlParser::MACROMAN:
      case MySqlParser::SJIS:
      case MySqlParser::SWE7:
      case MySqlParser::TIS620:
      case MySqlParser::UCS2:
      case MySqlParser::UJIS:
      case MySqlParser::UTF16:
      case MySqlParser::UTF16LE:
      case MySqlParser::UTF32:
      case MySqlParser::UTF8:
      case MySqlParser::UTF8MB3:
      case MySqlParser::UTF8MB4:
      case MySqlParser::ARCHIVE:
      case MySqlParser::BLACKHOLE:
      case MySqlParser::CSV:
      case MySqlParser::FEDERATED:
      case MySqlParser::INNODB:
      case MySqlParser::MEMORY:
      case MySqlParser::MRG_MYISAM:
      case MySqlParser::MYISAM:
      case MySqlParser::NDB:
      case MySqlParser::NDBCLUSTER:
      case MySqlParser::PERFORMANCE_SCHEMA:
      case MySqlParser::TOKUDB:
      case MySqlParser::REPEATABLE:
      case MySqlParser::COMMITTED:
      case MySqlParser::UNCOMMITTED:
      case MySqlParser::SERIALIZABLE:
      case MySqlParser::GEOMETRYCOLLECTION:
      case MySqlParser::LINESTRING:
      case MySqlParser::MULTILINESTRING:
      case MySqlParser::MULTIPOINT:
      case MySqlParser::MULTIPOLYGON:
      case MySqlParser::POINT:
      case MySqlParser::POLYGON:
      case MySqlParser::ABS:
      case MySqlParser::ACOS:
      case MySqlParser::ADDDATE:
      case MySqlParser::ADDTIME:
      case MySqlParser::AES_DECRYPT:
      case MySqlParser::AES_ENCRYPT:
      case MySqlParser::AREA:
      case MySqlParser::ASBINARY:
      case MySqlParser::ASIN:
      case MySqlParser::ASTEXT:
      case MySqlParser::ASWKB:
      case MySqlParser::ASWKT:
      case MySqlParser::ASYMMETRIC_DECRYPT:
      case MySqlParser::ASYMMETRIC_DERIVE:
      case MySqlParser::ASYMMETRIC_ENCRYPT:
      case MySqlParser::ASYMMETRIC_SIGN:
      case MySqlParser::ASYMMETRIC_VERIFY:
      case MySqlParser::ATAN:
      case MySqlParser::ATAN2:
      case MySqlParser::BENCHMARK:
      case MySqlParser::BIN:
      case MySqlParser::BIT_COUNT:
      case MySqlParser::BIT_LENGTH:
      case MySqlParser::BUFFER:
      case MySqlParser::CATALOG_NAME:
      case MySqlParser::CEIL:
      case MySqlParser::CEILING:
      case MySqlParser::CENTROID:
      case MySqlParser::CHARACTER_LENGTH:
      case MySqlParser::CHARSET:
      case MySqlParser::CHAR_LENGTH:
      case MySqlParser::COERCIBILITY:
      case MySqlParser::COLLATION:
      case MySqlParser::COMPRESS:
      case MySqlParser::CONCAT:
      case MySqlParser::CONCAT_WS:
      case MySqlParser::CONNECTION_ID:
      case MySqlParser::CONV:
      case MySqlParser::CONVERT_TZ:
      case MySqlParser::COS:
      case MySqlParser::COT:
      case MySqlParser::CRC32:
      case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
      case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
      case MySqlParser::CREATE_DH_PARAMETERS:
      case MySqlParser::CREATE_DIGEST:
      case MySqlParser::CROSSES:
      case MySqlParser::DATEDIFF:
      case MySqlParser::DATE_FORMAT:
      case MySqlParser::DAYNAME:
      case MySqlParser::DAYOFMONTH:
      case MySqlParser::DAYOFWEEK:
      case MySqlParser::DAYOFYEAR:
      case MySqlParser::DECODE:
      case MySqlParser::DEGREES:
      case MySqlParser::DES_DECRYPT:
      case MySqlParser::DES_ENCRYPT:
      case MySqlParser::DIMENSION:
      case MySqlParser::DISJOINT:
      case MySqlParser::ELT:
      case MySqlParser::ENCODE:
      case MySqlParser::ENCRYPT:
      case MySqlParser::ENDPOINT:
      case MySqlParser::ENGINE_ATTRIBUTE:
      case MySqlParser::ENVELOPE:
      case MySqlParser::EQUALS:
      case MySqlParser::EXP:
      case MySqlParser::EXPORT_SET:
      case MySqlParser::EXTERIORRING:
      case MySqlParser::EXTRACTVALUE:
      case MySqlParser::FIELD:
      case MySqlParser::FIND_IN_SET:
      case MySqlParser::FLOOR:
      case MySqlParser::FORMAT:
      case MySqlParser::FOUND_ROWS:
      case MySqlParser::FROM_BASE64:
      case MySqlParser::FROM_DAYS:
      case MySqlParser::FROM_UNIXTIME:
      case MySqlParser::GEOMCOLLFROMTEXT:
      case MySqlParser::GEOMCOLLFROMWKB:
      case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::GEOMETRYFROMTEXT:
      case MySqlParser::GEOMETRYFROMWKB:
      case MySqlParser::GEOMETRYN:
      case MySqlParser::GEOMETRYTYPE:
      case MySqlParser::GEOMFROMTEXT:
      case MySqlParser::GEOMFROMWKB:
      case MySqlParser::GET_FORMAT:
      case MySqlParser::GET_LOCK:
      case MySqlParser::GLENGTH:
      case MySqlParser::GREATEST:
      case MySqlParser::GTID_SUBSET:
      case MySqlParser::GTID_SUBTRACT:
      case MySqlParser::HEX:
      case MySqlParser::IFNULL:
      case MySqlParser::INET6_ATON:
      case MySqlParser::INET6_NTOA:
      case MySqlParser::INET_ATON:
      case MySqlParser::INET_NTOA:
      case MySqlParser::INSTR:
      case MySqlParser::INTERIORRINGN:
      case MySqlParser::INTERSECTS:
      case MySqlParser::ISCLOSED:
      case MySqlParser::ISEMPTY:
      case MySqlParser::ISNULL:
      case MySqlParser::ISSIMPLE:
      case MySqlParser::IS_FREE_LOCK:
      case MySqlParser::IS_IPV4:
      case MySqlParser::IS_IPV4_COMPAT:
      case MySqlParser::IS_IPV4_MAPPED:
      case MySqlParser::IS_IPV6:
      case MySqlParser::IS_USED_LOCK:
      case MySqlParser::LAST_INSERT_ID:
      case MySqlParser::LCASE:
      case MySqlParser::LEAST:
      case MySqlParser::LENGTH:
      case MySqlParser::LINEFROMTEXT:
      case MySqlParser::LINEFROMWKB:
      case MySqlParser::LINESTRINGFROMTEXT:
      case MySqlParser::LINESTRINGFROMWKB:
      case MySqlParser::LN:
      case MySqlParser::LOAD_FILE:
      case MySqlParser::LOCATE:
      case MySqlParser::LOG:
      case MySqlParser::LOG10:
      case MySqlParser::LOG2:
      case MySqlParser::LOWER:
      case MySqlParser::LPAD:
      case MySqlParser::LTRIM:
      case MySqlParser::MAKEDATE:
      case MySqlParser::MAKETIME:
      case MySqlParser::MAKE_SET:
      case MySqlParser::MASTER_POS_WAIT:
      case MySqlParser::MBRCONTAINS:
      case MySqlParser::MBRDISJOINT:
      case MySqlParser::MBREQUAL:
      case MySqlParser::MBRINTERSECTS:
      case MySqlParser::MBROVERLAPS:
      case MySqlParser::MBRTOUCHES:
      case MySqlParser::MBRWITHIN:
      case MySqlParser::MD5:
      case MySqlParser::MLINEFROMTEXT:
      case MySqlParser::MLINEFROMWKB:
      case MySqlParser::MONTHNAME:
      case MySqlParser::MPOINTFROMTEXT:
      case MySqlParser::MPOINTFROMWKB:
      case MySqlParser::MPOLYFROMTEXT:
      case MySqlParser::MPOLYFROMWKB:
      case MySqlParser::MULTILINESTRINGFROMTEXT:
      case MySqlParser::MULTILINESTRINGFROMWKB:
      case MySqlParser::MULTIPOINTFROMTEXT:
      case MySqlParser::MULTIPOINTFROMWKB:
      case MySqlParser::MULTIPOLYGONFROMTEXT:
      case MySqlParser::MULTIPOLYGONFROMWKB:
      case MySqlParser::NAME_CONST:
      case MySqlParser::NULLIF:
      case MySqlParser::NUMGEOMETRIES:
      case MySqlParser::NUMINTERIORRINGS:
      case MySqlParser::NUMPOINTS:
      case MySqlParser::OCT:
      case MySqlParser::OCTET_LENGTH:
      case MySqlParser::ORD:
      case MySqlParser::OVERLAPS:
      case MySqlParser::PERIOD_ADD:
      case MySqlParser::PERIOD_DIFF:
      case MySqlParser::PI:
      case MySqlParser::POINTFROMTEXT:
      case MySqlParser::POINTFROMWKB:
      case MySqlParser::POINTN:
      case MySqlParser::POLYFROMTEXT:
      case MySqlParser::POLYFROMWKB:
      case MySqlParser::POLYGONFROMTEXT:
      case MySqlParser::POLYGONFROMWKB:
      case MySqlParser::POW:
      case MySqlParser::POWER:
      case MySqlParser::QUOTE:
      case MySqlParser::RADIANS:
      case MySqlParser::RAND:
      case MySqlParser::RANDOM_BYTES:
      case MySqlParser::RELEASE_LOCK:
      case MySqlParser::REVERSE:
      case MySqlParser::ROUND:
      case MySqlParser::ROW_COUNT:
      case MySqlParser::RPAD:
      case MySqlParser::RTRIM:
      case MySqlParser::SEC_TO_TIME:
      case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySqlParser::SESSION_USER:
      case MySqlParser::SHA:
      case MySqlParser::SHA1:
      case MySqlParser::SHA2:
      case MySqlParser::SCHEMA_NAME:
      case MySqlParser::SIGN:
      case MySqlParser::SIN:
      case MySqlParser::SLEEP:
      case MySqlParser::SOUNDEX:
      case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
      case MySqlParser::SQRT:
      case MySqlParser::SRID:
      case MySqlParser::STARTPOINT:
      case MySqlParser::STRCMP:
      case MySqlParser::STR_TO_DATE:
      case MySqlParser::ST_AREA:
      case MySqlParser::ST_ASBINARY:
      case MySqlParser::ST_ASTEXT:
      case MySqlParser::ST_ASWKB:
      case MySqlParser::ST_ASWKT:
      case MySqlParser::ST_BUFFER:
      case MySqlParser::ST_CENTROID:
      case MySqlParser::ST_CONTAINS:
      case MySqlParser::ST_CROSSES:
      case MySqlParser::ST_DIFFERENCE:
      case MySqlParser::ST_DIMENSION:
      case MySqlParser::ST_DISJOINT:
      case MySqlParser::ST_DISTANCE:
      case MySqlParser::ST_ENDPOINT:
      case MySqlParser::ST_ENVELOPE:
      case MySqlParser::ST_EQUALS:
      case MySqlParser::ST_EXTERIORRING:
      case MySqlParser::ST_GEOMCOLLFROMTEXT:
      case MySqlParser::ST_GEOMCOLLFROMTXT:
      case MySqlParser::ST_GEOMCOLLFROMWKB:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::ST_GEOMETRYFROMTEXT:
      case MySqlParser::ST_GEOMETRYFROMWKB:
      case MySqlParser::ST_GEOMETRYN:
      case MySqlParser::ST_GEOMETRYTYPE:
      case MySqlParser::ST_GEOMFROMTEXT:
      case MySqlParser::ST_GEOMFROMWKB:
      case MySqlParser::ST_INTERIORRINGN:
      case MySqlParser::ST_INTERSECTION:
      case MySqlParser::ST_INTERSECTS:
      case MySqlParser::ST_ISCLOSED:
      case MySqlParser::ST_ISEMPTY:
      case MySqlParser::ST_ISSIMPLE:
      case MySqlParser::ST_LINEFROMTEXT:
      case MySqlParser::ST_LINEFROMWKB:
      case MySqlParser::ST_LINESTRINGFROMTEXT:
      case MySqlParser::ST_LINESTRINGFROMWKB:
      case MySqlParser::ST_NUMGEOMETRIES:
      case MySqlParser::ST_NUMINTERIORRING:
      case MySqlParser::ST_NUMINTERIORRINGS:
      case MySqlParser::ST_NUMPOINTS:
      case MySqlParser::ST_OVERLAPS:
      case MySqlParser::ST_POINTFROMTEXT:
      case MySqlParser::ST_POINTFROMWKB:
      case MySqlParser::ST_POINTN:
      case MySqlParser::ST_POLYFROMTEXT:
      case MySqlParser::ST_POLYFROMWKB:
      case MySqlParser::ST_POLYGONFROMTEXT:
      case MySqlParser::ST_POLYGONFROMWKB:
      case MySqlParser::ST_SRID:
      case MySqlParser::ST_STARTPOINT:
      case MySqlParser::ST_SYMDIFFERENCE:
      case MySqlParser::ST_TOUCHES:
      case MySqlParser::ST_UNION:
      case MySqlParser::ST_WITHIN:
      case MySqlParser::ST_X:
      case MySqlParser::ST_Y:
      case MySqlParser::SUBDATE:
      case MySqlParser::SUBSTRING_INDEX:
      case MySqlParser::SUBTIME:
      case MySqlParser::SYSTEM_USER:
      case MySqlParser::TAN:
      case MySqlParser::TIMEDIFF:
      case MySqlParser::TIMESTAMPADD:
      case MySqlParser::TIMESTAMPDIFF:
      case MySqlParser::TIME_FORMAT:
      case MySqlParser::TIME_TO_SEC:
      case MySqlParser::TOUCHES:
      case MySqlParser::TO_BASE64:
      case MySqlParser::TO_DAYS:
      case MySqlParser::TO_SECONDS:
      case MySqlParser::TP_CONNECTION_ADMIN:
      case MySqlParser::UCASE:
      case MySqlParser::UNCOMPRESS:
      case MySqlParser::UNCOMPRESSED_LENGTH:
      case MySqlParser::UNHEX:
      case MySqlParser::UNIX_TIMESTAMP:
      case MySqlParser::UPDATEXML:
      case MySqlParser::UPPER:
      case MySqlParser::UUID:
      case MySqlParser::UUID_SHORT:
      case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
      case MySqlParser::VERSION:
      case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
      case MySqlParser::WEEKDAY:
      case MySqlParser::WEEKOFYEAR:
      case MySqlParser::WEIGHT_STRING:
      case MySqlParser::WITHIN:
      case MySqlParser::YEARWEEK:
      case MySqlParser::Y_FUNCTION:
      case MySqlParser::X_FUNCTION:
      case MySqlParser::MOD:
      case MySqlParser::LR_BRACKET:
      case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
      case MySqlParser::STRING_LITERAL:
      case MySqlParser::ID: {
        setState(1078);
        routineBody();
        break;
      }

      case MySqlParser::RETURN: {
        setState(1079);
        returnStatement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateRoleContext ------------------------------------------------------------------

MySqlParser::CreateRoleContext::CreateRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateRoleContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateRoleContext::ROLE() {
  return getToken(MySqlParser::ROLE, 0);
}

std::vector<MySqlParser::RoleNameContext *> MySqlParser::CreateRoleContext::roleName() {
  return getRuleContexts<MySqlParser::RoleNameContext>();
}

MySqlParser::RoleNameContext* MySqlParser::CreateRoleContext::roleName(size_t i) {
  return getRuleContext<MySqlParser::RoleNameContext>(i);
}

MySqlParser::IfNotExistsContext* MySqlParser::CreateRoleContext::ifNotExists() {
  return getRuleContext<MySqlParser::IfNotExistsContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateRoleContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::CreateRoleContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::CreateRoleContext::getRuleIndex() const {
  return MySqlParser::RuleCreateRole;
}

void MySqlParser::CreateRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateRole(this);
}

void MySqlParser::CreateRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateRole(this);
}


std::any MySqlParser::CreateRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateRole(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateRoleContext* MySqlParser::createRole() {
  CreateRoleContext *_localctx = _tracker.createInstance<CreateRoleContext>(_ctx, getState());
  enterRule(_localctx, 36, MySqlParser::RuleCreateRole);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1082);
    match(MySqlParser::CREATE);
    setState(1083);
    match(MySqlParser::ROLE);
    setState(1085);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      setState(1084);
      ifNotExists();
      break;
    }

    default:
      break;
    }
    setState(1087);
    roleName();
    setState(1092);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(1088);
      match(MySqlParser::COMMA);
      setState(1089);
      roleName();
      setState(1094);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateServerContext ------------------------------------------------------------------

MySqlParser::CreateServerContext::CreateServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateServerContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateServerContext::SERVER() {
  return getToken(MySqlParser::SERVER, 0);
}

MySqlParser::UidContext* MySqlParser::CreateServerContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::CreateServerContext::FOREIGN() {
  return getToken(MySqlParser::FOREIGN, 0);
}

tree::TerminalNode* MySqlParser::CreateServerContext::DATA() {
  return getToken(MySqlParser::DATA, 0);
}

tree::TerminalNode* MySqlParser::CreateServerContext::WRAPPER() {
  return getToken(MySqlParser::WRAPPER, 0);
}

tree::TerminalNode* MySqlParser::CreateServerContext::OPTIONS() {
  return getToken(MySqlParser::OPTIONS, 0);
}

tree::TerminalNode* MySqlParser::CreateServerContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::ServerOptionContext *> MySqlParser::CreateServerContext::serverOption() {
  return getRuleContexts<MySqlParser::ServerOptionContext>();
}

MySqlParser::ServerOptionContext* MySqlParser::CreateServerContext::serverOption(size_t i) {
  return getRuleContext<MySqlParser::ServerOptionContext>(i);
}

tree::TerminalNode* MySqlParser::CreateServerContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::CreateServerContext::MYSQL() {
  return getToken(MySqlParser::MYSQL, 0);
}

tree::TerminalNode* MySqlParser::CreateServerContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateServerContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::CreateServerContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::CreateServerContext::getRuleIndex() const {
  return MySqlParser::RuleCreateServer;
}

void MySqlParser::CreateServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateServer(this);
}

void MySqlParser::CreateServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateServer(this);
}


std::any MySqlParser::CreateServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateServer(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateServerContext* MySqlParser::createServer() {
  CreateServerContext *_localctx = _tracker.createInstance<CreateServerContext>(_ctx, getState());
  enterRule(_localctx, 38, MySqlParser::RuleCreateServer);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1095);
    match(MySqlParser::CREATE);
    setState(1096);
    match(MySqlParser::SERVER);
    setState(1097);
    uid();
    setState(1098);
    match(MySqlParser::FOREIGN);
    setState(1099);
    match(MySqlParser::DATA);
    setState(1100);
    match(MySqlParser::WRAPPER);
    setState(1101);
    antlrcpp::downCast<CreateServerContext *>(_localctx)->wrapperName = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::MYSQL || _la == MySqlParser::STRING_LITERAL)) {
      antlrcpp::downCast<CreateServerContext *>(_localctx)->wrapperName = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1102);
    match(MySqlParser::OPTIONS);
    setState(1103);
    match(MySqlParser::LR_BRACKET);
    setState(1104);
    serverOption();
    setState(1109);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(1105);
      match(MySqlParser::COMMA);
      setState(1106);
      serverOption();
      setState(1111);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1112);
    match(MySqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableContext ------------------------------------------------------------------

MySqlParser::CreateTableContext::CreateTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::CreateTableContext::getRuleIndex() const {
  return MySqlParser::RuleCreateTable;
}

void MySqlParser::CreateTableContext::copyFrom(CreateTableContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- CopyCreateTableContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::CopyCreateTableContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CopyCreateTableContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

std::vector<MySqlParser::TableNameContext *> MySqlParser::CopyCreateTableContext::tableName() {
  return getRuleContexts<MySqlParser::TableNameContext>();
}

MySqlParser::TableNameContext* MySqlParser::CopyCreateTableContext::tableName(size_t i) {
  return getRuleContext<MySqlParser::TableNameContext>(i);
}

tree::TerminalNode* MySqlParser::CopyCreateTableContext::LIKE() {
  return getToken(MySqlParser::LIKE, 0);
}

tree::TerminalNode* MySqlParser::CopyCreateTableContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::CopyCreateTableContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::CopyCreateTableContext::TEMPORARY() {
  return getToken(MySqlParser::TEMPORARY, 0);
}

MySqlParser::IfNotExistsContext* MySqlParser::CopyCreateTableContext::ifNotExists() {
  return getRuleContext<MySqlParser::IfNotExistsContext>(0);
}

MySqlParser::CopyCreateTableContext::CopyCreateTableContext(CreateTableContext *ctx) { copyFrom(ctx); }

void MySqlParser::CopyCreateTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCopyCreateTable(this);
}
void MySqlParser::CopyCreateTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCopyCreateTable(this);
}

std::any MySqlParser::CopyCreateTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCopyCreateTable(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ColumnCreateTableContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ColumnCreateTableContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::ColumnCreateTableContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

MySqlParser::TableNameContext* MySqlParser::ColumnCreateTableContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

MySqlParser::CreateDefinitionsContext* MySqlParser::ColumnCreateTableContext::createDefinitions() {
  return getRuleContext<MySqlParser::CreateDefinitionsContext>(0);
}

tree::TerminalNode* MySqlParser::ColumnCreateTableContext::TEMPORARY() {
  return getToken(MySqlParser::TEMPORARY, 0);
}

MySqlParser::IfNotExistsContext* MySqlParser::ColumnCreateTableContext::ifNotExists() {
  return getRuleContext<MySqlParser::IfNotExistsContext>(0);
}

std::vector<MySqlParser::TableOptionContext *> MySqlParser::ColumnCreateTableContext::tableOption() {
  return getRuleContexts<MySqlParser::TableOptionContext>();
}

MySqlParser::TableOptionContext* MySqlParser::ColumnCreateTableContext::tableOption(size_t i) {
  return getRuleContext<MySqlParser::TableOptionContext>(i);
}

MySqlParser::PartitionDefinitionsContext* MySqlParser::ColumnCreateTableContext::partitionDefinitions() {
  return getRuleContext<MySqlParser::PartitionDefinitionsContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::ColumnCreateTableContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::ColumnCreateTableContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::ColumnCreateTableContext::ColumnCreateTableContext(CreateTableContext *ctx) { copyFrom(ctx); }

void MySqlParser::ColumnCreateTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnCreateTable(this);
}
void MySqlParser::ColumnCreateTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnCreateTable(this);
}

std::any MySqlParser::ColumnCreateTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitColumnCreateTable(this);
  else
    return visitor->visitChildren(this);
}
//----------------- QueryCreateTableContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::QueryCreateTableContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::QueryCreateTableContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

MySqlParser::TableNameContext* MySqlParser::QueryCreateTableContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

MySqlParser::SelectStatementContext* MySqlParser::QueryCreateTableContext::selectStatement() {
  return getRuleContext<MySqlParser::SelectStatementContext>(0);
}

tree::TerminalNode* MySqlParser::QueryCreateTableContext::TEMPORARY() {
  return getToken(MySqlParser::TEMPORARY, 0);
}

MySqlParser::IfNotExistsContext* MySqlParser::QueryCreateTableContext::ifNotExists() {
  return getRuleContext<MySqlParser::IfNotExistsContext>(0);
}

MySqlParser::CreateDefinitionsContext* MySqlParser::QueryCreateTableContext::createDefinitions() {
  return getRuleContext<MySqlParser::CreateDefinitionsContext>(0);
}

std::vector<MySqlParser::TableOptionContext *> MySqlParser::QueryCreateTableContext::tableOption() {
  return getRuleContexts<MySqlParser::TableOptionContext>();
}

MySqlParser::TableOptionContext* MySqlParser::QueryCreateTableContext::tableOption(size_t i) {
  return getRuleContext<MySqlParser::TableOptionContext>(i);
}

MySqlParser::PartitionDefinitionsContext* MySqlParser::QueryCreateTableContext::partitionDefinitions() {
  return getRuleContext<MySqlParser::PartitionDefinitionsContext>(0);
}

tree::TerminalNode* MySqlParser::QueryCreateTableContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

tree::TerminalNode* MySqlParser::QueryCreateTableContext::IGNORE() {
  return getToken(MySqlParser::IGNORE, 0);
}

tree::TerminalNode* MySqlParser::QueryCreateTableContext::REPLACE() {
  return getToken(MySqlParser::REPLACE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::QueryCreateTableContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::QueryCreateTableContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::QueryCreateTableContext::QueryCreateTableContext(CreateTableContext *ctx) { copyFrom(ctx); }

void MySqlParser::QueryCreateTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryCreateTable(this);
}
void MySqlParser::QueryCreateTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryCreateTable(this);
}

std::any MySqlParser::QueryCreateTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitQueryCreateTable(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::CreateTableContext* MySqlParser::createTable() {
  CreateTableContext *_localctx = _tracker.createInstance<CreateTableContext>(_ctx, getState());
  enterRule(_localctx, 40, MySqlParser::RuleCreateTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1192);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::CopyCreateTableContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1114);
      match(MySqlParser::CREATE);
      setState(1116);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::TEMPORARY) {
        setState(1115);
        match(MySqlParser::TEMPORARY);
      }
      setState(1118);
      match(MySqlParser::TABLE);
      setState(1120);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
      case 1: {
        setState(1119);
        ifNotExists();
        break;
      }

      default:
        break;
      }
      setState(1122);
      tableName();
      setState(1130);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::LIKE: {
          setState(1123);
          match(MySqlParser::LIKE);
          setState(1124);
          tableName();
          break;
        }

        case MySqlParser::LR_BRACKET: {
          setState(1125);
          match(MySqlParser::LR_BRACKET);
          setState(1126);
          match(MySqlParser::LIKE);
          setState(1127);
          antlrcpp::downCast<CopyCreateTableContext *>(_localctx)->parenthesisTable = tableName();
          setState(1128);
          match(MySqlParser::RR_BRACKET);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::QueryCreateTableContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1132);
      match(MySqlParser::CREATE);
      setState(1134);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::TEMPORARY) {
        setState(1133);
        match(MySqlParser::TEMPORARY);
      }
      setState(1136);
      match(MySqlParser::TABLE);
      setState(1138);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
      case 1: {
        setState(1137);
        ifNotExists();
        break;
      }

      default:
        break;
      }
      setState(1140);
      tableName();
      setState(1142);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
      case 1: {
        setState(1141);
        createDefinitions();
        break;
      }

      default:
        break;
      }
      setState(1154);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 25) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 25)) & 72057594038059013) != 0) || _la == MySqlParser::UNION

      || _la == MySqlParser::CHAR || ((((_la - 341) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 341)) & 4644375904747527) != 0) || ((((_la - 405) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 405)) & 4612811918334230547) != 0) || ((((_la - 500) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 500)) & 2366149022974977) != 0) || ((((_la - 602) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 602)) & 4609173815820289) != 0) || _la == MySqlParser::CHARSET

      || _la == MySqlParser::ENGINE_ATTRIBUTE || _la == MySqlParser::SECONDARY_ENGINE_ATTRIBUTE || _la == MySqlParser::STRING_LITERAL) {
        setState(1144);
        tableOption();
        setState(1151);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 25) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 25)) & 72057594038059013) != 0) || _la == MySqlParser::UNION

        || _la == MySqlParser::CHAR || ((((_la - 341) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 341)) & 4644375904747527) != 0) || ((((_la - 405) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 405)) & 4612811918334230547) != 0) || ((((_la - 500) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 500)) & 2366149022974977) != 0) || ((((_la - 602) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 602)) & 4609173815820289) != 0) || _la == MySqlParser::CHARSET

        || _la == MySqlParser::ENGINE_ATTRIBUTE || _la == MySqlParser::SECONDARY_ENGINE_ATTRIBUTE || _la == MySqlParser::COMMA

        || _la == MySqlParser::STRING_LITERAL) {
          setState(1146);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::COMMA) {
            setState(1145);
            match(MySqlParser::COMMA);
          }
          setState(1148);
          tableOption();
          setState(1153);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(1157);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::PARTITION) {
        setState(1156);
        partitionDefinitions();
      }
      setState(1160);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::IGNORE

      || _la == MySqlParser::REPLACE) {
        setState(1159);
        antlrcpp::downCast<QueryCreateTableContext *>(_localctx)->keyViolate = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::IGNORE

        || _la == MySqlParser::REPLACE)) {
          antlrcpp::downCast<QueryCreateTableContext *>(_localctx)->keyViolate = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1163);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::AS) {
        setState(1162);
        match(MySqlParser::AS);
      }
      setState(1165);
      selectStatement();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::ColumnCreateTableContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1167);
      match(MySqlParser::CREATE);
      setState(1169);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::TEMPORARY) {
        setState(1168);
        match(MySqlParser::TEMPORARY);
      }
      setState(1171);
      match(MySqlParser::TABLE);
      setState(1173);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
      case 1: {
        setState(1172);
        ifNotExists();
        break;
      }

      default:
        break;
      }
      setState(1175);
      tableName();
      setState(1176);
      createDefinitions();
      setState(1187);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
      case 1: {
        setState(1177);
        tableOption();
        setState(1184);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1179);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySqlParser::COMMA) {
              setState(1178);
              match(MySqlParser::COMMA);
            }
            setState(1181);
            tableOption(); 
          }
          setState(1186);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
        }
        break;
      }

      default:
        break;
      }
      setState(1190);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::PARTITION) {
        setState(1189);
        partitionDefinitions();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTablespaceInnodbContext ------------------------------------------------------------------

MySqlParser::CreateTablespaceInnodbContext::CreateTablespaceInnodbContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateTablespaceInnodbContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceInnodbContext::TABLESPACE() {
  return getToken(MySqlParser::TABLESPACE, 0);
}

MySqlParser::UidContext* MySqlParser::CreateTablespaceInnodbContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceInnodbContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceInnodbContext::DATAFILE() {
  return getToken(MySqlParser::DATAFILE, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceInnodbContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceInnodbContext::FILE_BLOCK_SIZE() {
  return getToken(MySqlParser::FILE_BLOCK_SIZE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateTablespaceInnodbContext::EQUAL_SYMBOL() {
  return getTokens(MySqlParser::EQUAL_SYMBOL);
}

tree::TerminalNode* MySqlParser::CreateTablespaceInnodbContext::EQUAL_SYMBOL(size_t i) {
  return getToken(MySqlParser::EQUAL_SYMBOL, i);
}

tree::TerminalNode* MySqlParser::CreateTablespaceInnodbContext::ENGINE() {
  return getToken(MySqlParser::ENGINE, 0);
}

MySqlParser::EngineNameContext* MySqlParser::CreateTablespaceInnodbContext::engineName() {
  return getRuleContext<MySqlParser::EngineNameContext>(0);
}

MySqlParser::FileSizeLiteralContext* MySqlParser::CreateTablespaceInnodbContext::fileSizeLiteral() {
  return getRuleContext<MySqlParser::FileSizeLiteralContext>(0);
}


size_t MySqlParser::CreateTablespaceInnodbContext::getRuleIndex() const {
  return MySqlParser::RuleCreateTablespaceInnodb;
}

void MySqlParser::CreateTablespaceInnodbContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTablespaceInnodb(this);
}

void MySqlParser::CreateTablespaceInnodbContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTablespaceInnodb(this);
}


std::any MySqlParser::CreateTablespaceInnodbContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateTablespaceInnodb(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateTablespaceInnodbContext* MySqlParser::createTablespaceInnodb() {
  CreateTablespaceInnodbContext *_localctx = _tracker.createInstance<CreateTablespaceInnodbContext>(_ctx, getState());
  enterRule(_localctx, 42, MySqlParser::RuleCreateTablespaceInnodb);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1194);
    match(MySqlParser::CREATE);
    setState(1195);
    match(MySqlParser::TABLESPACE);
    setState(1196);
    uid();
    setState(1197);
    match(MySqlParser::ADD);
    setState(1198);
    match(MySqlParser::DATAFILE);
    setState(1199);
    antlrcpp::downCast<CreateTablespaceInnodbContext *>(_localctx)->datafile = match(MySqlParser::STRING_LITERAL);
    setState(1203);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::FILE_BLOCK_SIZE) {
      setState(1200);
      match(MySqlParser::FILE_BLOCK_SIZE);
      setState(1201);
      match(MySqlParser::EQUAL_SYMBOL);
      setState(1202);
      antlrcpp::downCast<CreateTablespaceInnodbContext *>(_localctx)->fileBlockSize = fileSizeLiteral();
    }
    setState(1210);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ENGINE) {
      setState(1205);
      match(MySqlParser::ENGINE);
      setState(1207);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1206);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1209);
      engineName();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTablespaceNdbContext ------------------------------------------------------------------

MySqlParser::CreateTablespaceNdbContext::CreateTablespaceNdbContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::TABLESPACE() {
  return getToken(MySqlParser::TABLESPACE, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::CreateTablespaceNdbContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::CreateTablespaceNdbContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::DATAFILE() {
  return getToken(MySqlParser::DATAFILE, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::USE() {
  return getToken(MySqlParser::USE, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::LOGFILE() {
  return getToken(MySqlParser::LOGFILE, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::GROUP() {
  return getToken(MySqlParser::GROUP, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::ENGINE() {
  return getToken(MySqlParser::ENGINE, 0);
}

MySqlParser::EngineNameContext* MySqlParser::CreateTablespaceNdbContext::engineName() {
  return getRuleContext<MySqlParser::EngineNameContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateTablespaceNdbContext::STRING_LITERAL() {
  return getTokens(MySqlParser::STRING_LITERAL);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::STRING_LITERAL(size_t i) {
  return getToken(MySqlParser::STRING_LITERAL, i);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::EXTENT_SIZE() {
  return getToken(MySqlParser::EXTENT_SIZE, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::INITIAL_SIZE() {
  return getToken(MySqlParser::INITIAL_SIZE, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::AUTOEXTEND_SIZE() {
  return getToken(MySqlParser::AUTOEXTEND_SIZE, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::MAX_SIZE() {
  return getToken(MySqlParser::MAX_SIZE, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::NODEGROUP() {
  return getToken(MySqlParser::NODEGROUP, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::WAIT() {
  return getToken(MySqlParser::WAIT, 0);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::COMMENT() {
  return getToken(MySqlParser::COMMENT, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateTablespaceNdbContext::EQUAL_SYMBOL() {
  return getTokens(MySqlParser::EQUAL_SYMBOL);
}

tree::TerminalNode* MySqlParser::CreateTablespaceNdbContext::EQUAL_SYMBOL(size_t i) {
  return getToken(MySqlParser::EQUAL_SYMBOL, i);
}

std::vector<MySqlParser::FileSizeLiteralContext *> MySqlParser::CreateTablespaceNdbContext::fileSizeLiteral() {
  return getRuleContexts<MySqlParser::FileSizeLiteralContext>();
}

MySqlParser::FileSizeLiteralContext* MySqlParser::CreateTablespaceNdbContext::fileSizeLiteral(size_t i) {
  return getRuleContext<MySqlParser::FileSizeLiteralContext>(i);
}


size_t MySqlParser::CreateTablespaceNdbContext::getRuleIndex() const {
  return MySqlParser::RuleCreateTablespaceNdb;
}

void MySqlParser::CreateTablespaceNdbContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTablespaceNdb(this);
}

void MySqlParser::CreateTablespaceNdbContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTablespaceNdb(this);
}


std::any MySqlParser::CreateTablespaceNdbContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateTablespaceNdb(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateTablespaceNdbContext* MySqlParser::createTablespaceNdb() {
  CreateTablespaceNdbContext *_localctx = _tracker.createInstance<CreateTablespaceNdbContext>(_ctx, getState());
  enterRule(_localctx, 44, MySqlParser::RuleCreateTablespaceNdb);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1212);
    match(MySqlParser::CREATE);
    setState(1213);
    match(MySqlParser::TABLESPACE);
    setState(1214);
    uid();
    setState(1215);
    match(MySqlParser::ADD);
    setState(1216);
    match(MySqlParser::DATAFILE);
    setState(1217);
    antlrcpp::downCast<CreateTablespaceNdbContext *>(_localctx)->datafile = match(MySqlParser::STRING_LITERAL);
    setState(1218);
    match(MySqlParser::USE);
    setState(1219);
    match(MySqlParser::LOGFILE);
    setState(1220);
    match(MySqlParser::GROUP);
    setState(1221);
    uid();
    setState(1227);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::EXTENT_SIZE) {
      setState(1222);
      match(MySqlParser::EXTENT_SIZE);
      setState(1224);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1223);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1226);
      antlrcpp::downCast<CreateTablespaceNdbContext *>(_localctx)->extentSize = fileSizeLiteral();
    }
    setState(1234);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::INITIAL_SIZE) {
      setState(1229);
      match(MySqlParser::INITIAL_SIZE);
      setState(1231);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1230);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1233);
      antlrcpp::downCast<CreateTablespaceNdbContext *>(_localctx)->initialSize = fileSizeLiteral();
    }
    setState(1241);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::AUTOEXTEND_SIZE) {
      setState(1236);
      match(MySqlParser::AUTOEXTEND_SIZE);
      setState(1238);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1237);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1240);
      antlrcpp::downCast<CreateTablespaceNdbContext *>(_localctx)->autoextendSize = fileSizeLiteral();
    }
    setState(1248);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::MAX_SIZE) {
      setState(1243);
      match(MySqlParser::MAX_SIZE);
      setState(1245);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1244);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1247);
      antlrcpp::downCast<CreateTablespaceNdbContext *>(_localctx)->maxSize = fileSizeLiteral();
    }
    setState(1255);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::NODEGROUP) {
      setState(1250);
      match(MySqlParser::NODEGROUP);
      setState(1252);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1251);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1254);
      uid();
    }
    setState(1258);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WAIT) {
      setState(1257);
      match(MySqlParser::WAIT);
    }
    setState(1265);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::COMMENT) {
      setState(1260);
      match(MySqlParser::COMMENT);
      setState(1262);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1261);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1264);
      antlrcpp::downCast<CreateTablespaceNdbContext *>(_localctx)->comment = match(MySqlParser::STRING_LITERAL);
    }
    setState(1267);
    match(MySqlParser::ENGINE);
    setState(1269);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::EQUAL_SYMBOL) {
      setState(1268);
      match(MySqlParser::EQUAL_SYMBOL);
    }
    setState(1271);
    engineName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTriggerContext ------------------------------------------------------------------

MySqlParser::CreateTriggerContext::CreateTriggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateTriggerContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateTriggerContext::TRIGGER() {
  return getToken(MySqlParser::TRIGGER, 0);
}

tree::TerminalNode* MySqlParser::CreateTriggerContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

MySqlParser::TableNameContext* MySqlParser::CreateTriggerContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::CreateTriggerContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

tree::TerminalNode* MySqlParser::CreateTriggerContext::EACH() {
  return getToken(MySqlParser::EACH, 0);
}

tree::TerminalNode* MySqlParser::CreateTriggerContext::ROW() {
  return getToken(MySqlParser::ROW, 0);
}

MySqlParser::RoutineBodyContext* MySqlParser::CreateTriggerContext::routineBody() {
  return getRuleContext<MySqlParser::RoutineBodyContext>(0);
}

std::vector<MySqlParser::FullIdContext *> MySqlParser::CreateTriggerContext::fullId() {
  return getRuleContexts<MySqlParser::FullIdContext>();
}

MySqlParser::FullIdContext* MySqlParser::CreateTriggerContext::fullId(size_t i) {
  return getRuleContext<MySqlParser::FullIdContext>(i);
}

tree::TerminalNode* MySqlParser::CreateTriggerContext::BEFORE() {
  return getToken(MySqlParser::BEFORE, 0);
}

tree::TerminalNode* MySqlParser::CreateTriggerContext::AFTER() {
  return getToken(MySqlParser::AFTER, 0);
}

tree::TerminalNode* MySqlParser::CreateTriggerContext::INSERT() {
  return getToken(MySqlParser::INSERT, 0);
}

tree::TerminalNode* MySqlParser::CreateTriggerContext::UPDATE() {
  return getToken(MySqlParser::UPDATE, 0);
}

tree::TerminalNode* MySqlParser::CreateTriggerContext::DELETE() {
  return getToken(MySqlParser::DELETE, 0);
}

MySqlParser::OwnerStatementContext* MySqlParser::CreateTriggerContext::ownerStatement() {
  return getRuleContext<MySqlParser::OwnerStatementContext>(0);
}

tree::TerminalNode* MySqlParser::CreateTriggerContext::FOLLOWS() {
  return getToken(MySqlParser::FOLLOWS, 0);
}

tree::TerminalNode* MySqlParser::CreateTriggerContext::PRECEDES() {
  return getToken(MySqlParser::PRECEDES, 0);
}


size_t MySqlParser::CreateTriggerContext::getRuleIndex() const {
  return MySqlParser::RuleCreateTrigger;
}

void MySqlParser::CreateTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTrigger(this);
}

void MySqlParser::CreateTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTrigger(this);
}


std::any MySqlParser::CreateTriggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateTrigger(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateTriggerContext* MySqlParser::createTrigger() {
  CreateTriggerContext *_localctx = _tracker.createInstance<CreateTriggerContext>(_ctx, getState());
  enterRule(_localctx, 46, MySqlParser::RuleCreateTrigger);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1273);
    match(MySqlParser::CREATE);
    setState(1275);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::DEFINER) {
      setState(1274);
      ownerStatement();
    }
    setState(1277);
    match(MySqlParser::TRIGGER);
    setState(1278);
    antlrcpp::downCast<CreateTriggerContext *>(_localctx)->thisTrigger = fullId();
    setState(1279);
    antlrcpp::downCast<CreateTriggerContext *>(_localctx)->triggerTime = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::BEFORE || _la == MySqlParser::AFTER)) {
      antlrcpp::downCast<CreateTriggerContext *>(_localctx)->triggerTime = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1280);
    antlrcpp::downCast<CreateTriggerContext *>(_localctx)->triggerEvent = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::DELETE

    || _la == MySqlParser::INSERT || _la == MySqlParser::UPDATE)) {
      antlrcpp::downCast<CreateTriggerContext *>(_localctx)->triggerEvent = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1281);
    match(MySqlParser::ON);
    setState(1282);
    tableName();
    setState(1283);
    match(MySqlParser::FOR);
    setState(1284);
    match(MySqlParser::EACH);
    setState(1285);
    match(MySqlParser::ROW);
    setState(1288);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx)) {
    case 1: {
      setState(1286);
      antlrcpp::downCast<CreateTriggerContext *>(_localctx)->triggerPlace = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::FOLLOWS || _la == MySqlParser::PRECEDES)) {
        antlrcpp::downCast<CreateTriggerContext *>(_localctx)->triggerPlace = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1287);
      antlrcpp::downCast<CreateTriggerContext *>(_localctx)->otherTrigger = fullId();
      break;
    }

    default:
      break;
    }
    setState(1290);
    routineBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithClauseContext ------------------------------------------------------------------

MySqlParser::WithClauseContext::WithClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::WithClauseContext::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

MySqlParser::CommonTableExpressionsContext* MySqlParser::WithClauseContext::commonTableExpressions() {
  return getRuleContext<MySqlParser::CommonTableExpressionsContext>(0);
}

tree::TerminalNode* MySqlParser::WithClauseContext::RECURSIVE() {
  return getToken(MySqlParser::RECURSIVE, 0);
}


size_t MySqlParser::WithClauseContext::getRuleIndex() const {
  return MySqlParser::RuleWithClause;
}

void MySqlParser::WithClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithClause(this);
}

void MySqlParser::WithClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithClause(this);
}


std::any MySqlParser::WithClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitWithClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::WithClauseContext* MySqlParser::withClause() {
  WithClauseContext *_localctx = _tracker.createInstance<WithClauseContext>(_ctx, getState());
  enterRule(_localctx, 48, MySqlParser::RuleWithClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1292);
    match(MySqlParser::WITH);
    setState(1294);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
    case 1: {
      setState(1293);
      match(MySqlParser::RECURSIVE);
      break;
    }

    default:
      break;
    }
    setState(1296);
    commonTableExpressions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommonTableExpressionsContext ------------------------------------------------------------------

MySqlParser::CommonTableExpressionsContext::CommonTableExpressionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::CteNameContext* MySqlParser::CommonTableExpressionsContext::cteName() {
  return getRuleContext<MySqlParser::CteNameContext>(0);
}

tree::TerminalNode* MySqlParser::CommonTableExpressionsContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::CommonTableExpressionsContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::CommonTableExpressionsContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

MySqlParser::DmlStatementContext* MySqlParser::CommonTableExpressionsContext::dmlStatement() {
  return getRuleContext<MySqlParser::DmlStatementContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::CommonTableExpressionsContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::CommonTableExpressionsContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

std::vector<MySqlParser::CteColumnNameContext *> MySqlParser::CommonTableExpressionsContext::cteColumnName() {
  return getRuleContexts<MySqlParser::CteColumnNameContext>();
}

MySqlParser::CteColumnNameContext* MySqlParser::CommonTableExpressionsContext::cteColumnName(size_t i) {
  return getRuleContext<MySqlParser::CteColumnNameContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::CommonTableExpressionsContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::CommonTableExpressionsContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::CommonTableExpressionsContext* MySqlParser::CommonTableExpressionsContext::commonTableExpressions() {
  return getRuleContext<MySqlParser::CommonTableExpressionsContext>(0);
}


size_t MySqlParser::CommonTableExpressionsContext::getRuleIndex() const {
  return MySqlParser::RuleCommonTableExpressions;
}

void MySqlParser::CommonTableExpressionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommonTableExpressions(this);
}

void MySqlParser::CommonTableExpressionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommonTableExpressions(this);
}


std::any MySqlParser::CommonTableExpressionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCommonTableExpressions(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CommonTableExpressionsContext* MySqlParser::commonTableExpressions() {
  CommonTableExpressionsContext *_localctx = _tracker.createInstance<CommonTableExpressionsContext>(_ctx, getState());
  enterRule(_localctx, 50, MySqlParser::RuleCommonTableExpressions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1298);
    cteName();
    setState(1310);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LR_BRACKET) {
      setState(1299);
      match(MySqlParser::LR_BRACKET);
      setState(1300);
      cteColumnName();
      setState(1305);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(1301);
        match(MySqlParser::COMMA);
        setState(1302);
        cteColumnName();
        setState(1307);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1308);
      match(MySqlParser::RR_BRACKET);
    }
    setState(1312);
    match(MySqlParser::AS);
    setState(1313);
    match(MySqlParser::LR_BRACKET);
    setState(1314);
    dmlStatement();
    setState(1315);
    match(MySqlParser::RR_BRACKET);
    setState(1318);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      setState(1316);
      match(MySqlParser::COMMA);
      setState(1317);
      commonTableExpressions();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CteNameContext ------------------------------------------------------------------

MySqlParser::CteNameContext::CteNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::UidContext* MySqlParser::CteNameContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}


size_t MySqlParser::CteNameContext::getRuleIndex() const {
  return MySqlParser::RuleCteName;
}

void MySqlParser::CteNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCteName(this);
}

void MySqlParser::CteNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCteName(this);
}


std::any MySqlParser::CteNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCteName(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CteNameContext* MySqlParser::cteName() {
  CteNameContext *_localctx = _tracker.createInstance<CteNameContext>(_ctx, getState());
  enterRule(_localctx, 52, MySqlParser::RuleCteName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1320);
    uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CteColumnNameContext ------------------------------------------------------------------

MySqlParser::CteColumnNameContext::CteColumnNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::UidContext* MySqlParser::CteColumnNameContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}


size_t MySqlParser::CteColumnNameContext::getRuleIndex() const {
  return MySqlParser::RuleCteColumnName;
}

void MySqlParser::CteColumnNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCteColumnName(this);
}

void MySqlParser::CteColumnNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCteColumnName(this);
}


std::any MySqlParser::CteColumnNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCteColumnName(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CteColumnNameContext* MySqlParser::cteColumnName() {
  CteColumnNameContext *_localctx = _tracker.createInstance<CteColumnNameContext>(_ctx, getState());
  enterRule(_localctx, 54, MySqlParser::RuleCteColumnName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1322);
    uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateViewContext ------------------------------------------------------------------

MySqlParser::CreateViewContext::CreateViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateViewContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::VIEW() {
  return getToken(MySqlParser::VIEW, 0);
}

MySqlParser::FullIdContext* MySqlParser::CreateViewContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateViewContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::CreateViewContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

MySqlParser::SelectStatementContext* MySqlParser::CreateViewContext::selectStatement() {
  return getRuleContext<MySqlParser::SelectStatementContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateViewContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::CreateViewContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

MySqlParser::OrReplaceContext* MySqlParser::CreateViewContext::orReplace() {
  return getRuleContext<MySqlParser::OrReplaceContext>(0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::ALGORITHM() {
  return getToken(MySqlParser::ALGORITHM, 0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::OwnerStatementContext* MySqlParser::CreateViewContext::ownerStatement() {
  return getRuleContext<MySqlParser::OwnerStatementContext>(0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::SQL() {
  return getToken(MySqlParser::SQL, 0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::SECURITY() {
  return getToken(MySqlParser::SECURITY, 0);
}

MySqlParser::UidListContext* MySqlParser::CreateViewContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::UNDEFINED() {
  return getToken(MySqlParser::UNDEFINED, 0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::MERGE() {
  return getToken(MySqlParser::MERGE, 0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::TEMPTABLE() {
  return getToken(MySqlParser::TEMPTABLE, 0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::DEFINER() {
  return getToken(MySqlParser::DEFINER, 0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::INVOKER() {
  return getToken(MySqlParser::INVOKER, 0);
}

MySqlParser::WithClauseContext* MySqlParser::CreateViewContext::withClause() {
  return getRuleContext<MySqlParser::WithClauseContext>(0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::CHECK() {
  return getToken(MySqlParser::CHECK, 0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::OPTION() {
  return getToken(MySqlParser::OPTION, 0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::CASCADED() {
  return getToken(MySqlParser::CASCADED, 0);
}

tree::TerminalNode* MySqlParser::CreateViewContext::LOCAL() {
  return getToken(MySqlParser::LOCAL, 0);
}


size_t MySqlParser::CreateViewContext::getRuleIndex() const {
  return MySqlParser::RuleCreateView;
}

void MySqlParser::CreateViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateView(this);
}

void MySqlParser::CreateViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateView(this);
}


std::any MySqlParser::CreateViewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateView(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateViewContext* MySqlParser::createView() {
  CreateViewContext *_localctx = _tracker.createInstance<CreateViewContext>(_ctx, getState());
  enterRule(_localctx, 56, MySqlParser::RuleCreateView);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1324);
    match(MySqlParser::CREATE);
    setState(1326);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::OR) {
      setState(1325);
      orReplace();
    }
    setState(1331);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ALGORITHM) {
      setState(1328);
      match(MySqlParser::ALGORITHM);
      setState(1329);
      match(MySqlParser::EQUAL_SYMBOL);
      setState(1330);
      antlrcpp::downCast<CreateViewContext *>(_localctx)->algType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::MERGE || _la == MySqlParser::TEMPTABLE

      || _la == MySqlParser::UNDEFINED)) {
        antlrcpp::downCast<CreateViewContext *>(_localctx)->algType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1334);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::DEFINER) {
      setState(1333);
      ownerStatement();
    }
    setState(1339);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::SQL) {
      setState(1336);
      match(MySqlParser::SQL);
      setState(1337);
      match(MySqlParser::SECURITY);
      setState(1338);
      antlrcpp::downCast<CreateViewContext *>(_localctx)->secContext = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DEFINER || _la == MySqlParser::INVOKER)) {
        antlrcpp::downCast<CreateViewContext *>(_localctx)->secContext = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1341);
    match(MySqlParser::VIEW);
    setState(1342);
    fullId();
    setState(1347);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LR_BRACKET) {
      setState(1343);
      match(MySqlParser::LR_BRACKET);
      setState(1344);
      uidList();
      setState(1345);
      match(MySqlParser::RR_BRACKET);
    }
    setState(1349);
    match(MySqlParser::AS);
    setState(1369);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
    case 1: {
      setState(1350);
      match(MySqlParser::LR_BRACKET);
      setState(1352);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::WITH) {
        setState(1351);
        withClause();
      }
      setState(1354);
      selectStatement();
      setState(1355);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      setState(1358);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::WITH) {
        setState(1357);
        withClause();
      }
      setState(1360);
      selectStatement();
      setState(1367);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx)) {
      case 1: {
        setState(1361);
        match(MySqlParser::WITH);
        setState(1363);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::CASCADED || _la == MySqlParser::LOCAL) {
          setState(1362);
          antlrcpp::downCast<CreateViewContext *>(_localctx)->checkOption = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::CASCADED || _la == MySqlParser::LOCAL)) {
            antlrcpp::downCast<CreateViewContext *>(_localctx)->checkOption = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(1365);
        match(MySqlParser::CHECK);
        setState(1366);
        match(MySqlParser::OPTION);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateDatabaseOptionContext ------------------------------------------------------------------

MySqlParser::CreateDatabaseOptionContext::CreateDatabaseOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::CharSetContext* MySqlParser::CreateDatabaseOptionContext::charSet() {
  return getRuleContext<MySqlParser::CharSetContext>(0);
}

MySqlParser::CharsetNameContext* MySqlParser::CreateDatabaseOptionContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateDatabaseOptionContext::DEFAULT() {
  return getTokens(MySqlParser::DEFAULT);
}

tree::TerminalNode* MySqlParser::CreateDatabaseOptionContext::DEFAULT(size_t i) {
  return getToken(MySqlParser::DEFAULT, i);
}

tree::TerminalNode* MySqlParser::CreateDatabaseOptionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::CreateDatabaseOptionContext::COLLATE() {
  return getToken(MySqlParser::COLLATE, 0);
}

MySqlParser::CollationNameContext* MySqlParser::CreateDatabaseOptionContext::collationName() {
  return getRuleContext<MySqlParser::CollationNameContext>(0);
}

tree::TerminalNode* MySqlParser::CreateDatabaseOptionContext::ENCRYPTION() {
  return getToken(MySqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* MySqlParser::CreateDatabaseOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::CreateDatabaseOptionContext::READ() {
  return getToken(MySqlParser::READ, 0);
}

tree::TerminalNode* MySqlParser::CreateDatabaseOptionContext::ONLY() {
  return getToken(MySqlParser::ONLY, 0);
}

tree::TerminalNode* MySqlParser::CreateDatabaseOptionContext::ZERO_DECIMAL() {
  return getToken(MySqlParser::ZERO_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::CreateDatabaseOptionContext::ONE_DECIMAL() {
  return getToken(MySqlParser::ONE_DECIMAL, 0);
}


size_t MySqlParser::CreateDatabaseOptionContext::getRuleIndex() const {
  return MySqlParser::RuleCreateDatabaseOption;
}

void MySqlParser::CreateDatabaseOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateDatabaseOption(this);
}

void MySqlParser::CreateDatabaseOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateDatabaseOption(this);
}


std::any MySqlParser::CreateDatabaseOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateDatabaseOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateDatabaseOptionContext* MySqlParser::createDatabaseOption() {
  CreateDatabaseOptionContext *_localctx = _tracker.createInstance<CreateDatabaseOptionContext>(_ctx, getState());
  enterRule(_localctx, 58, MySqlParser::RuleCreateDatabaseOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1404);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1372);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::DEFAULT) {
        setState(1371);
        match(MySqlParser::DEFAULT);
      }
      setState(1374);
      charSet();
      setState(1376);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1375);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1380);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::BINARY:
        case MySqlParser::ARMSCII8:
        case MySqlParser::ASCII:
        case MySqlParser::BIG5:
        case MySqlParser::CP1250:
        case MySqlParser::CP1251:
        case MySqlParser::CP1256:
        case MySqlParser::CP1257:
        case MySqlParser::CP850:
        case MySqlParser::CP852:
        case MySqlParser::CP866:
        case MySqlParser::CP932:
        case MySqlParser::DEC8:
        case MySqlParser::EUCJPMS:
        case MySqlParser::EUCKR:
        case MySqlParser::GB18030:
        case MySqlParser::GB2312:
        case MySqlParser::GBK:
        case MySqlParser::GEOSTD8:
        case MySqlParser::GREEK:
        case MySqlParser::HEBREW:
        case MySqlParser::HP8:
        case MySqlParser::KEYBCS2:
        case MySqlParser::KOI8R:
        case MySqlParser::KOI8U:
        case MySqlParser::LATIN1:
        case MySqlParser::LATIN2:
        case MySqlParser::LATIN5:
        case MySqlParser::LATIN7:
        case MySqlParser::MACCE:
        case MySqlParser::MACROMAN:
        case MySqlParser::SJIS:
        case MySqlParser::SWE7:
        case MySqlParser::TIS620:
        case MySqlParser::UCS2:
        case MySqlParser::UJIS:
        case MySqlParser::UTF16:
        case MySqlParser::UTF16LE:
        case MySqlParser::UTF32:
        case MySqlParser::UTF8:
        case MySqlParser::UTF8MB3:
        case MySqlParser::UTF8MB4:
        case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
        case MySqlParser::STRING_LITERAL: {
          setState(1378);
          charsetName();
          break;
        }

        case MySqlParser::DEFAULT: {
          setState(1379);
          match(MySqlParser::DEFAULT);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1383);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::DEFAULT) {
        setState(1382);
        match(MySqlParser::DEFAULT);
      }
      setState(1385);
      match(MySqlParser::COLLATE);
      setState(1387);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1386);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1389);
      collationName();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1391);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::DEFAULT) {
        setState(1390);
        match(MySqlParser::DEFAULT);
      }
      setState(1393);
      match(MySqlParser::ENCRYPTION);
      setState(1395);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1394);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1397);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1398);
      match(MySqlParser::READ);
      setState(1399);
      match(MySqlParser::ONLY);
      setState(1401);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1400);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1403);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::ZERO_DECIMAL

      || _la == MySqlParser::ONE_DECIMAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharSetContext ------------------------------------------------------------------

MySqlParser::CharSetContext::CharSetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CharSetContext::CHARACTER() {
  return getToken(MySqlParser::CHARACTER, 0);
}

tree::TerminalNode* MySqlParser::CharSetContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::CharSetContext::CHARSET() {
  return getToken(MySqlParser::CHARSET, 0);
}

tree::TerminalNode* MySqlParser::CharSetContext::CHAR() {
  return getToken(MySqlParser::CHAR, 0);
}


size_t MySqlParser::CharSetContext::getRuleIndex() const {
  return MySqlParser::RuleCharSet;
}

void MySqlParser::CharSetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharSet(this);
}

void MySqlParser::CharSetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharSet(this);
}


std::any MySqlParser::CharSetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCharSet(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CharSetContext* MySqlParser::charSet() {
  CharSetContext *_localctx = _tracker.createInstance<CharSetContext>(_ctx, getState());
  enterRule(_localctx, 60, MySqlParser::RuleCharSet);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1411);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::CHARACTER: {
        enterOuterAlt(_localctx, 1);
        setState(1406);
        match(MySqlParser::CHARACTER);
        setState(1407);
        match(MySqlParser::SET);
        break;
      }

      case MySqlParser::CHARSET: {
        enterOuterAlt(_localctx, 2);
        setState(1408);
        match(MySqlParser::CHARSET);
        break;
      }

      case MySqlParser::CHAR: {
        enterOuterAlt(_localctx, 3);
        setState(1409);
        match(MySqlParser::CHAR);
        setState(1410);
        match(MySqlParser::SET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OwnerStatementContext ------------------------------------------------------------------

MySqlParser::OwnerStatementContext::OwnerStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::OwnerStatementContext::DEFINER() {
  return getToken(MySqlParser::DEFINER, 0);
}

tree::TerminalNode* MySqlParser::OwnerStatementContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::UserNameContext* MySqlParser::OwnerStatementContext::userName() {
  return getRuleContext<MySqlParser::UserNameContext>(0);
}

tree::TerminalNode* MySqlParser::OwnerStatementContext::CURRENT_USER() {
  return getToken(MySqlParser::CURRENT_USER, 0);
}

tree::TerminalNode* MySqlParser::OwnerStatementContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::OwnerStatementContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}


size_t MySqlParser::OwnerStatementContext::getRuleIndex() const {
  return MySqlParser::RuleOwnerStatement;
}

void MySqlParser::OwnerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOwnerStatement(this);
}

void MySqlParser::OwnerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOwnerStatement(this);
}


std::any MySqlParser::OwnerStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitOwnerStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::OwnerStatementContext* MySqlParser::ownerStatement() {
  OwnerStatementContext *_localctx = _tracker.createInstance<OwnerStatementContext>(_ctx, getState());
  enterRule(_localctx, 62, MySqlParser::RuleOwnerStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1413);
    match(MySqlParser::DEFINER);
    setState(1414);
    match(MySqlParser::EQUAL_SYMBOL);
    setState(1421);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
    case 1: {
      setState(1415);
      userName();
      break;
    }

    case 2: {
      setState(1416);
      match(MySqlParser::CURRENT_USER);
      setState(1419);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LR_BRACKET) {
        setState(1417);
        match(MySqlParser::LR_BRACKET);
        setState(1418);
        match(MySqlParser::RR_BRACKET);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScheduleExpressionContext ------------------------------------------------------------------

MySqlParser::ScheduleExpressionContext::ScheduleExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::ScheduleExpressionContext::getRuleIndex() const {
  return MySqlParser::RuleScheduleExpression;
}

void MySqlParser::ScheduleExpressionContext::copyFrom(ScheduleExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PreciseScheduleContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PreciseScheduleContext::AT() {
  return getToken(MySqlParser::AT, 0);
}

MySqlParser::TimestampValueContext* MySqlParser::PreciseScheduleContext::timestampValue() {
  return getRuleContext<MySqlParser::TimestampValueContext>(0);
}

std::vector<MySqlParser::IntervalExprContext *> MySqlParser::PreciseScheduleContext::intervalExpr() {
  return getRuleContexts<MySqlParser::IntervalExprContext>();
}

MySqlParser::IntervalExprContext* MySqlParser::PreciseScheduleContext::intervalExpr(size_t i) {
  return getRuleContext<MySqlParser::IntervalExprContext>(i);
}

MySqlParser::PreciseScheduleContext::PreciseScheduleContext(ScheduleExpressionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PreciseScheduleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreciseSchedule(this);
}
void MySqlParser::PreciseScheduleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreciseSchedule(this);
}

std::any MySqlParser::PreciseScheduleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPreciseSchedule(this);
  else
    return visitor->visitChildren(this);
}
//----------------- IntervalScheduleContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::IntervalScheduleContext::EVERY() {
  return getToken(MySqlParser::EVERY, 0);
}

MySqlParser::IntervalTypeContext* MySqlParser::IntervalScheduleContext::intervalType() {
  return getRuleContext<MySqlParser::IntervalTypeContext>(0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::IntervalScheduleContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

MySqlParser::ExpressionContext* MySqlParser::IntervalScheduleContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::IntervalScheduleContext::STARTS() {
  return getToken(MySqlParser::STARTS, 0);
}

tree::TerminalNode* MySqlParser::IntervalScheduleContext::ENDS() {
  return getToken(MySqlParser::ENDS, 0);
}

std::vector<MySqlParser::TimestampValueContext *> MySqlParser::IntervalScheduleContext::timestampValue() {
  return getRuleContexts<MySqlParser::TimestampValueContext>();
}

MySqlParser::TimestampValueContext* MySqlParser::IntervalScheduleContext::timestampValue(size_t i) {
  return getRuleContext<MySqlParser::TimestampValueContext>(i);
}

std::vector<MySqlParser::IntervalExprContext *> MySqlParser::IntervalScheduleContext::intervalExpr() {
  return getRuleContexts<MySqlParser::IntervalExprContext>();
}

MySqlParser::IntervalExprContext* MySqlParser::IntervalScheduleContext::intervalExpr(size_t i) {
  return getRuleContext<MySqlParser::IntervalExprContext>(i);
}

MySqlParser::IntervalScheduleContext::IntervalScheduleContext(ScheduleExpressionContext *ctx) { copyFrom(ctx); }

void MySqlParser::IntervalScheduleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalSchedule(this);
}
void MySqlParser::IntervalScheduleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalSchedule(this);
}

std::any MySqlParser::IntervalScheduleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIntervalSchedule(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::ScheduleExpressionContext* MySqlParser::scheduleExpression() {
  ScheduleExpressionContext *_localctx = _tracker.createInstance<ScheduleExpressionContext>(_ctx, getState());
  enterRule(_localctx, 64, MySqlParser::RuleScheduleExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1457);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::AT: {
        _localctx = _tracker.createInstance<MySqlParser::PreciseScheduleContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1423);
        match(MySqlParser::AT);
        setState(1424);
        timestampValue();
        setState(1428);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::PLUS) {
          setState(1425);
          intervalExpr();
          setState(1430);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySqlParser::EVERY: {
        _localctx = _tracker.createInstance<MySqlParser::IntervalScheduleContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1431);
        match(MySqlParser::EVERY);
        setState(1434);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx)) {
        case 1: {
          setState(1432);
          decimalLiteral();
          break;
        }

        case 2: {
          setState(1433);
          expression(0);
          break;
        }

        default:
          break;
        }
        setState(1436);
        intervalType();
        setState(1445);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::STARTS) {
          setState(1437);
          match(MySqlParser::STARTS);
          setState(1438);
          antlrcpp::downCast<IntervalScheduleContext *>(_localctx)->startTimestamp = timestampValue();
          setState(1442);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == MySqlParser::PLUS) {
            setState(1439);
            antlrcpp::downCast<IntervalScheduleContext *>(_localctx)->intervalExprContext = intervalExpr();
            antlrcpp::downCast<IntervalScheduleContext *>(_localctx)->startIntervals.push_back(antlrcpp::downCast<IntervalScheduleContext *>(_localctx)->intervalExprContext);
            setState(1444);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        setState(1455);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::ENDS) {
          setState(1447);
          match(MySqlParser::ENDS);
          setState(1448);
          antlrcpp::downCast<IntervalScheduleContext *>(_localctx)->endTimestamp = timestampValue();
          setState(1452);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == MySqlParser::PLUS) {
            setState(1449);
            antlrcpp::downCast<IntervalScheduleContext *>(_localctx)->intervalExprContext = intervalExpr();
            antlrcpp::downCast<IntervalScheduleContext *>(_localctx)->endIntervals.push_back(antlrcpp::downCast<IntervalScheduleContext *>(_localctx)->intervalExprContext);
            setState(1454);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimestampValueContext ------------------------------------------------------------------

MySqlParser::TimestampValueContext::TimestampValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::TimestampValueContext::CURRENT_TIMESTAMP() {
  return getToken(MySqlParser::CURRENT_TIMESTAMP, 0);
}

MySqlParser::StringLiteralContext* MySqlParser::TimestampValueContext::stringLiteral() {
  return getRuleContext<MySqlParser::StringLiteralContext>(0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::TimestampValueContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

MySqlParser::ExpressionContext* MySqlParser::TimestampValueContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}


size_t MySqlParser::TimestampValueContext::getRuleIndex() const {
  return MySqlParser::RuleTimestampValue;
}

void MySqlParser::TimestampValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimestampValue(this);
}

void MySqlParser::TimestampValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimestampValue(this);
}


std::any MySqlParser::TimestampValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTimestampValue(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TimestampValueContext* MySqlParser::timestampValue() {
  TimestampValueContext *_localctx = _tracker.createInstance<TimestampValueContext>(_ctx, getState());
  enterRule(_localctx, 66, MySqlParser::RuleTimestampValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1463);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1459);
      match(MySqlParser::CURRENT_TIMESTAMP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1460);
      stringLiteral();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1461);
      decimalLiteral();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1462);
      expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalExprContext ------------------------------------------------------------------

MySqlParser::IntervalExprContext::IntervalExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::IntervalExprContext::PLUS() {
  return getToken(MySqlParser::PLUS, 0);
}

tree::TerminalNode* MySqlParser::IntervalExprContext::INTERVAL() {
  return getToken(MySqlParser::INTERVAL, 0);
}

MySqlParser::IntervalTypeContext* MySqlParser::IntervalExprContext::intervalType() {
  return getRuleContext<MySqlParser::IntervalTypeContext>(0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::IntervalExprContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

MySqlParser::ExpressionContext* MySqlParser::IntervalExprContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}


size_t MySqlParser::IntervalExprContext::getRuleIndex() const {
  return MySqlParser::RuleIntervalExpr;
}

void MySqlParser::IntervalExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalExpr(this);
}

void MySqlParser::IntervalExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalExpr(this);
}


std::any MySqlParser::IntervalExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIntervalExpr(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::IntervalExprContext* MySqlParser::intervalExpr() {
  IntervalExprContext *_localctx = _tracker.createInstance<IntervalExprContext>(_ctx, getState());
  enterRule(_localctx, 68, MySqlParser::RuleIntervalExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1465);
    match(MySqlParser::PLUS);
    setState(1466);
    match(MySqlParser::INTERVAL);
    setState(1469);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx)) {
    case 1: {
      setState(1467);
      decimalLiteral();
      break;
    }

    case 2: {
      setState(1468);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(1471);
    intervalType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalTypeContext ------------------------------------------------------------------

MySqlParser::IntervalTypeContext::IntervalTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::IntervalTypeBaseContext* MySqlParser::IntervalTypeContext::intervalTypeBase() {
  return getRuleContext<MySqlParser::IntervalTypeBaseContext>(0);
}

tree::TerminalNode* MySqlParser::IntervalTypeContext::YEAR() {
  return getToken(MySqlParser::YEAR, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeContext::YEAR_MONTH() {
  return getToken(MySqlParser::YEAR_MONTH, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeContext::DAY_HOUR() {
  return getToken(MySqlParser::DAY_HOUR, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeContext::DAY_MINUTE() {
  return getToken(MySqlParser::DAY_MINUTE, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeContext::DAY_SECOND() {
  return getToken(MySqlParser::DAY_SECOND, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeContext::HOUR_MINUTE() {
  return getToken(MySqlParser::HOUR_MINUTE, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeContext::HOUR_SECOND() {
  return getToken(MySqlParser::HOUR_SECOND, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeContext::MINUTE_SECOND() {
  return getToken(MySqlParser::MINUTE_SECOND, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeContext::SECOND_MICROSECOND() {
  return getToken(MySqlParser::SECOND_MICROSECOND, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeContext::MINUTE_MICROSECOND() {
  return getToken(MySqlParser::MINUTE_MICROSECOND, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeContext::HOUR_MICROSECOND() {
  return getToken(MySqlParser::HOUR_MICROSECOND, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeContext::DAY_MICROSECOND() {
  return getToken(MySqlParser::DAY_MICROSECOND, 0);
}


size_t MySqlParser::IntervalTypeContext::getRuleIndex() const {
  return MySqlParser::RuleIntervalType;
}

void MySqlParser::IntervalTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalType(this);
}

void MySqlParser::IntervalTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalType(this);
}


std::any MySqlParser::IntervalTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIntervalType(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::IntervalTypeContext* MySqlParser::intervalType() {
  IntervalTypeContext *_localctx = _tracker.createInstance<IntervalTypeContext>(_ctx, getState());
  enterRule(_localctx, 70, MySqlParser::RuleIntervalType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1486);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::QUARTER:
      case MySqlParser::MONTH:
      case MySqlParser::DAY:
      case MySqlParser::HOUR:
      case MySqlParser::MINUTE:
      case MySqlParser::WEEK:
      case MySqlParser::SECOND:
      case MySqlParser::MICROSECOND: {
        enterOuterAlt(_localctx, 1);
        setState(1473);
        intervalTypeBase();
        break;
      }

      case MySqlParser::YEAR: {
        enterOuterAlt(_localctx, 2);
        setState(1474);
        match(MySqlParser::YEAR);
        break;
      }

      case MySqlParser::YEAR_MONTH: {
        enterOuterAlt(_localctx, 3);
        setState(1475);
        match(MySqlParser::YEAR_MONTH);
        break;
      }

      case MySqlParser::DAY_HOUR: {
        enterOuterAlt(_localctx, 4);
        setState(1476);
        match(MySqlParser::DAY_HOUR);
        break;
      }

      case MySqlParser::DAY_MINUTE: {
        enterOuterAlt(_localctx, 5);
        setState(1477);
        match(MySqlParser::DAY_MINUTE);
        break;
      }

      case MySqlParser::DAY_SECOND: {
        enterOuterAlt(_localctx, 6);
        setState(1478);
        match(MySqlParser::DAY_SECOND);
        break;
      }

      case MySqlParser::HOUR_MINUTE: {
        enterOuterAlt(_localctx, 7);
        setState(1479);
        match(MySqlParser::HOUR_MINUTE);
        break;
      }

      case MySqlParser::HOUR_SECOND: {
        enterOuterAlt(_localctx, 8);
        setState(1480);
        match(MySqlParser::HOUR_SECOND);
        break;
      }

      case MySqlParser::MINUTE_SECOND: {
        enterOuterAlt(_localctx, 9);
        setState(1481);
        match(MySqlParser::MINUTE_SECOND);
        break;
      }

      case MySqlParser::SECOND_MICROSECOND: {
        enterOuterAlt(_localctx, 10);
        setState(1482);
        match(MySqlParser::SECOND_MICROSECOND);
        break;
      }

      case MySqlParser::MINUTE_MICROSECOND: {
        enterOuterAlt(_localctx, 11);
        setState(1483);
        match(MySqlParser::MINUTE_MICROSECOND);
        break;
      }

      case MySqlParser::HOUR_MICROSECOND: {
        enterOuterAlt(_localctx, 12);
        setState(1484);
        match(MySqlParser::HOUR_MICROSECOND);
        break;
      }

      case MySqlParser::DAY_MICROSECOND: {
        enterOuterAlt(_localctx, 13);
        setState(1485);
        match(MySqlParser::DAY_MICROSECOND);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnableTypeContext ------------------------------------------------------------------

MySqlParser::EnableTypeContext::EnableTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::EnableTypeContext::ENABLE() {
  return getToken(MySqlParser::ENABLE, 0);
}

tree::TerminalNode* MySqlParser::EnableTypeContext::DISABLE() {
  return getToken(MySqlParser::DISABLE, 0);
}

tree::TerminalNode* MySqlParser::EnableTypeContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

tree::TerminalNode* MySqlParser::EnableTypeContext::SLAVE() {
  return getToken(MySqlParser::SLAVE, 0);
}


size_t MySqlParser::EnableTypeContext::getRuleIndex() const {
  return MySqlParser::RuleEnableType;
}

void MySqlParser::EnableTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnableType(this);
}

void MySqlParser::EnableTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnableType(this);
}


std::any MySqlParser::EnableTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitEnableType(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::EnableTypeContext* MySqlParser::enableType() {
  EnableTypeContext *_localctx = _tracker.createInstance<EnableTypeContext>(_ctx, getState());
  enterRule(_localctx, 72, MySqlParser::RuleEnableType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1493);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1488);
      match(MySqlParser::ENABLE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1489);
      match(MySqlParser::DISABLE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1490);
      match(MySqlParser::DISABLE);
      setState(1491);
      match(MySqlParser::ON);
      setState(1492);
      match(MySqlParser::SLAVE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexTypeContext ------------------------------------------------------------------

MySqlParser::IndexTypeContext::IndexTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::IndexTypeContext::USING() {
  return getToken(MySqlParser::USING, 0);
}

tree::TerminalNode* MySqlParser::IndexTypeContext::BTREE() {
  return getToken(MySqlParser::BTREE, 0);
}

tree::TerminalNode* MySqlParser::IndexTypeContext::HASH() {
  return getToken(MySqlParser::HASH, 0);
}


size_t MySqlParser::IndexTypeContext::getRuleIndex() const {
  return MySqlParser::RuleIndexType;
}

void MySqlParser::IndexTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexType(this);
}

void MySqlParser::IndexTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexType(this);
}


std::any MySqlParser::IndexTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIndexType(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::IndexTypeContext* MySqlParser::indexType() {
  IndexTypeContext *_localctx = _tracker.createInstance<IndexTypeContext>(_ctx, getState());
  enterRule(_localctx, 74, MySqlParser::RuleIndexType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1495);
    match(MySqlParser::USING);
    setState(1496);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::BTREE || _la == MySqlParser::HASH)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexOptionContext ------------------------------------------------------------------

MySqlParser::IndexOptionContext::IndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::IndexOptionContext::KEY_BLOCK_SIZE() {
  return getToken(MySqlParser::KEY_BLOCK_SIZE, 0);
}

MySqlParser::FileSizeLiteralContext* MySqlParser::IndexOptionContext::fileSizeLiteral() {
  return getRuleContext<MySqlParser::FileSizeLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::IndexOptionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::IndexTypeContext* MySqlParser::IndexOptionContext::indexType() {
  return getRuleContext<MySqlParser::IndexTypeContext>(0);
}

tree::TerminalNode* MySqlParser::IndexOptionContext::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

tree::TerminalNode* MySqlParser::IndexOptionContext::PARSER() {
  return getToken(MySqlParser::PARSER, 0);
}

MySqlParser::UidContext* MySqlParser::IndexOptionContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::IndexOptionContext::COMMENT() {
  return getToken(MySqlParser::COMMENT, 0);
}

tree::TerminalNode* MySqlParser::IndexOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::IndexOptionContext::VISIBLE() {
  return getToken(MySqlParser::VISIBLE, 0);
}

tree::TerminalNode* MySqlParser::IndexOptionContext::INVISIBLE() {
  return getToken(MySqlParser::INVISIBLE, 0);
}

tree::TerminalNode* MySqlParser::IndexOptionContext::ENGINE_ATTRIBUTE() {
  return getToken(MySqlParser::ENGINE_ATTRIBUTE, 0);
}

tree::TerminalNode* MySqlParser::IndexOptionContext::SECONDARY_ENGINE_ATTRIBUTE() {
  return getToken(MySqlParser::SECONDARY_ENGINE_ATTRIBUTE, 0);
}


size_t MySqlParser::IndexOptionContext::getRuleIndex() const {
  return MySqlParser::RuleIndexOption;
}

void MySqlParser::IndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexOption(this);
}

void MySqlParser::IndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexOption(this);
}


std::any MySqlParser::IndexOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIndexOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::IndexOptionContext* MySqlParser::indexOption() {
  IndexOptionContext *_localctx = _tracker.createInstance<IndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 76, MySqlParser::RuleIndexOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1520);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::KEY_BLOCK_SIZE: {
        enterOuterAlt(_localctx, 1);
        setState(1498);
        match(MySqlParser::KEY_BLOCK_SIZE);
        setState(1500);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::EQUAL_SYMBOL) {
          setState(1499);
          match(MySqlParser::EQUAL_SYMBOL);
        }
        setState(1502);
        fileSizeLiteral();
        break;
      }

      case MySqlParser::USING: {
        enterOuterAlt(_localctx, 2);
        setState(1503);
        indexType();
        break;
      }

      case MySqlParser::WITH: {
        enterOuterAlt(_localctx, 3);
        setState(1504);
        match(MySqlParser::WITH);
        setState(1505);
        match(MySqlParser::PARSER);
        setState(1506);
        uid();
        break;
      }

      case MySqlParser::COMMENT: {
        enterOuterAlt(_localctx, 4);
        setState(1507);
        match(MySqlParser::COMMENT);
        setState(1508);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::INVISIBLE:
      case MySqlParser::VISIBLE: {
        enterOuterAlt(_localctx, 5);
        setState(1509);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::INVISIBLE || _la == MySqlParser::VISIBLE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySqlParser::ENGINE_ATTRIBUTE: {
        enterOuterAlt(_localctx, 6);
        setState(1510);
        match(MySqlParser::ENGINE_ATTRIBUTE);
        setState(1512);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::EQUAL_SYMBOL) {
          setState(1511);
          match(MySqlParser::EQUAL_SYMBOL);
        }
        setState(1514);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE: {
        enterOuterAlt(_localctx, 7);
        setState(1515);
        match(MySqlParser::SECONDARY_ENGINE_ATTRIBUTE);
        setState(1517);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::EQUAL_SYMBOL) {
          setState(1516);
          match(MySqlParser::EQUAL_SYMBOL);
        }
        setState(1519);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureParameterContext ------------------------------------------------------------------

MySqlParser::ProcedureParameterContext::ProcedureParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::UidContext* MySqlParser::ProcedureParameterContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::DataTypeContext* MySqlParser::ProcedureParameterContext::dataType() {
  return getRuleContext<MySqlParser::DataTypeContext>(0);
}

tree::TerminalNode* MySqlParser::ProcedureParameterContext::IN() {
  return getToken(MySqlParser::IN, 0);
}

tree::TerminalNode* MySqlParser::ProcedureParameterContext::OUT() {
  return getToken(MySqlParser::OUT, 0);
}

tree::TerminalNode* MySqlParser::ProcedureParameterContext::INOUT() {
  return getToken(MySqlParser::INOUT, 0);
}


size_t MySqlParser::ProcedureParameterContext::getRuleIndex() const {
  return MySqlParser::RuleProcedureParameter;
}

void MySqlParser::ProcedureParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureParameter(this);
}

void MySqlParser::ProcedureParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureParameter(this);
}


std::any MySqlParser::ProcedureParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitProcedureParameter(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ProcedureParameterContext* MySqlParser::procedureParameter() {
  ProcedureParameterContext *_localctx = _tracker.createInstance<ProcedureParameterContext>(_ctx, getState());
  enterRule(_localctx, 78, MySqlParser::RuleProcedureParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1523);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 80) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 80)) & 35184372088849) != 0)) {
      setState(1522);
      antlrcpp::downCast<ProcedureParameterContext *>(_localctx)->direction = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 80) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 80)) & 35184372088849) != 0))) {
        antlrcpp::downCast<ProcedureParameterContext *>(_localctx)->direction = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1525);
    uid();
    setState(1526);
    dataType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionParameterContext ------------------------------------------------------------------

MySqlParser::FunctionParameterContext::FunctionParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::UidContext* MySqlParser::FunctionParameterContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::DataTypeContext* MySqlParser::FunctionParameterContext::dataType() {
  return getRuleContext<MySqlParser::DataTypeContext>(0);
}


size_t MySqlParser::FunctionParameterContext::getRuleIndex() const {
  return MySqlParser::RuleFunctionParameter;
}

void MySqlParser::FunctionParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionParameter(this);
}

void MySqlParser::FunctionParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionParameter(this);
}


std::any MySqlParser::FunctionParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFunctionParameter(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FunctionParameterContext* MySqlParser::functionParameter() {
  FunctionParameterContext *_localctx = _tracker.createInstance<FunctionParameterContext>(_ctx, getState());
  enterRule(_localctx, 80, MySqlParser::RuleFunctionParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1528);
    uid();
    setState(1529);
    dataType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineOptionContext ------------------------------------------------------------------

MySqlParser::RoutineOptionContext::RoutineOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::RoutineOptionContext::getRuleIndex() const {
  return MySqlParser::RuleRoutineOption;
}

void MySqlParser::RoutineOptionContext::copyFrom(RoutineOptionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- RoutineBehaviorContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::RoutineBehaviorContext::DETERMINISTIC() {
  return getToken(MySqlParser::DETERMINISTIC, 0);
}

tree::TerminalNode* MySqlParser::RoutineBehaviorContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}

MySqlParser::RoutineBehaviorContext::RoutineBehaviorContext(RoutineOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::RoutineBehaviorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineBehavior(this);
}
void MySqlParser::RoutineBehaviorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineBehavior(this);
}

std::any MySqlParser::RoutineBehaviorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRoutineBehavior(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RoutineLanguageContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::RoutineLanguageContext::LANGUAGE() {
  return getToken(MySqlParser::LANGUAGE, 0);
}

tree::TerminalNode* MySqlParser::RoutineLanguageContext::SQL() {
  return getToken(MySqlParser::SQL, 0);
}

MySqlParser::RoutineLanguageContext::RoutineLanguageContext(RoutineOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::RoutineLanguageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineLanguage(this);
}
void MySqlParser::RoutineLanguageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineLanguage(this);
}

std::any MySqlParser::RoutineLanguageContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRoutineLanguage(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RoutineCommentContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::RoutineCommentContext::COMMENT() {
  return getToken(MySqlParser::COMMENT, 0);
}

tree::TerminalNode* MySqlParser::RoutineCommentContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

MySqlParser::RoutineCommentContext::RoutineCommentContext(RoutineOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::RoutineCommentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineComment(this);
}
void MySqlParser::RoutineCommentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineComment(this);
}

std::any MySqlParser::RoutineCommentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRoutineComment(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RoutineSecurityContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::RoutineSecurityContext::SQL() {
  return getToken(MySqlParser::SQL, 0);
}

tree::TerminalNode* MySqlParser::RoutineSecurityContext::SECURITY() {
  return getToken(MySqlParser::SECURITY, 0);
}

tree::TerminalNode* MySqlParser::RoutineSecurityContext::DEFINER() {
  return getToken(MySqlParser::DEFINER, 0);
}

tree::TerminalNode* MySqlParser::RoutineSecurityContext::INVOKER() {
  return getToken(MySqlParser::INVOKER, 0);
}

MySqlParser::RoutineSecurityContext::RoutineSecurityContext(RoutineOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::RoutineSecurityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineSecurity(this);
}
void MySqlParser::RoutineSecurityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineSecurity(this);
}

std::any MySqlParser::RoutineSecurityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRoutineSecurity(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RoutineDataContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::RoutineDataContext::CONTAINS() {
  return getToken(MySqlParser::CONTAINS, 0);
}

tree::TerminalNode* MySqlParser::RoutineDataContext::SQL() {
  return getToken(MySqlParser::SQL, 0);
}

tree::TerminalNode* MySqlParser::RoutineDataContext::NO() {
  return getToken(MySqlParser::NO, 0);
}

tree::TerminalNode* MySqlParser::RoutineDataContext::READS() {
  return getToken(MySqlParser::READS, 0);
}

tree::TerminalNode* MySqlParser::RoutineDataContext::DATA() {
  return getToken(MySqlParser::DATA, 0);
}

tree::TerminalNode* MySqlParser::RoutineDataContext::MODIFIES() {
  return getToken(MySqlParser::MODIFIES, 0);
}

MySqlParser::RoutineDataContext::RoutineDataContext(RoutineOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::RoutineDataContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineData(this);
}
void MySqlParser::RoutineDataContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineData(this);
}

std::any MySqlParser::RoutineDataContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRoutineData(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::RoutineOptionContext* MySqlParser::routineOption() {
  RoutineOptionContext *_localctx = _tracker.createInstance<RoutineOptionContext>(_ctx, getState());
  enterRule(_localctx, 82, MySqlParser::RuleRoutineOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1554);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::COMMENT: {
        _localctx = _tracker.createInstance<MySqlParser::RoutineCommentContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1531);
        match(MySqlParser::COMMENT);
        setState(1532);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::LANGUAGE: {
        _localctx = _tracker.createInstance<MySqlParser::RoutineLanguageContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1533);
        match(MySqlParser::LANGUAGE);
        setState(1534);
        match(MySqlParser::SQL);
        break;
      }

      case MySqlParser::DETERMINISTIC:
      case MySqlParser::NOT: {
        _localctx = _tracker.createInstance<MySqlParser::RoutineBehaviorContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(1536);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::NOT) {
          setState(1535);
          match(MySqlParser::NOT);
        }
        setState(1538);
        match(MySqlParser::DETERMINISTIC);
        break;
      }

      case MySqlParser::MODIFIES:
      case MySqlParser::READS:
      case MySqlParser::CONTAINS:
      case MySqlParser::NO: {
        _localctx = _tracker.createInstance<MySqlParser::RoutineDataContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(1549);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::CONTAINS: {
            setState(1539);
            match(MySqlParser::CONTAINS);
            setState(1540);
            match(MySqlParser::SQL);
            break;
          }

          case MySqlParser::NO: {
            setState(1541);
            match(MySqlParser::NO);
            setState(1542);
            match(MySqlParser::SQL);
            break;
          }

          case MySqlParser::READS: {
            setState(1543);
            match(MySqlParser::READS);
            setState(1544);
            match(MySqlParser::SQL);
            setState(1545);
            match(MySqlParser::DATA);
            break;
          }

          case MySqlParser::MODIFIES: {
            setState(1546);
            match(MySqlParser::MODIFIES);
            setState(1547);
            match(MySqlParser::SQL);
            setState(1548);
            match(MySqlParser::DATA);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySqlParser::SQL: {
        _localctx = _tracker.createInstance<MySqlParser::RoutineSecurityContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(1551);
        match(MySqlParser::SQL);
        setState(1552);
        match(MySqlParser::SECURITY);
        setState(1553);
        antlrcpp::downCast<RoutineSecurityContext *>(_localctx)->context = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::DEFINER || _la == MySqlParser::INVOKER)) {
          antlrcpp::downCast<RoutineSecurityContext *>(_localctx)->context = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerOptionContext ------------------------------------------------------------------

MySqlParser::ServerOptionContext::ServerOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ServerOptionContext::HOST() {
  return getToken(MySqlParser::HOST, 0);
}

tree::TerminalNode* MySqlParser::ServerOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::ServerOptionContext::DATABASE() {
  return getToken(MySqlParser::DATABASE, 0);
}

tree::TerminalNode* MySqlParser::ServerOptionContext::USER() {
  return getToken(MySqlParser::USER, 0);
}

tree::TerminalNode* MySqlParser::ServerOptionContext::PASSWORD() {
  return getToken(MySqlParser::PASSWORD, 0);
}

tree::TerminalNode* MySqlParser::ServerOptionContext::SOCKET() {
  return getToken(MySqlParser::SOCKET, 0);
}

tree::TerminalNode* MySqlParser::ServerOptionContext::OWNER() {
  return getToken(MySqlParser::OWNER, 0);
}

tree::TerminalNode* MySqlParser::ServerOptionContext::PORT() {
  return getToken(MySqlParser::PORT, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::ServerOptionContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}


size_t MySqlParser::ServerOptionContext::getRuleIndex() const {
  return MySqlParser::RuleServerOption;
}

void MySqlParser::ServerOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerOption(this);
}

void MySqlParser::ServerOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerOption(this);
}


std::any MySqlParser::ServerOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitServerOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ServerOptionContext* MySqlParser::serverOption() {
  ServerOptionContext *_localctx = _tracker.createInstance<ServerOptionContext>(_ctx, getState());
  enterRule(_localctx, 84, MySqlParser::RuleServerOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1570);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::HOST: {
        enterOuterAlt(_localctx, 1);
        setState(1556);
        match(MySqlParser::HOST);
        setState(1557);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::DATABASE: {
        enterOuterAlt(_localctx, 2);
        setState(1558);
        match(MySqlParser::DATABASE);
        setState(1559);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::USER: {
        enterOuterAlt(_localctx, 3);
        setState(1560);
        match(MySqlParser::USER);
        setState(1561);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::PASSWORD: {
        enterOuterAlt(_localctx, 4);
        setState(1562);
        match(MySqlParser::PASSWORD);
        setState(1563);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::SOCKET: {
        enterOuterAlt(_localctx, 5);
        setState(1564);
        match(MySqlParser::SOCKET);
        setState(1565);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::OWNER: {
        enterOuterAlt(_localctx, 6);
        setState(1566);
        match(MySqlParser::OWNER);
        setState(1567);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::PORT: {
        enterOuterAlt(_localctx, 7);
        setState(1568);
        match(MySqlParser::PORT);
        setState(1569);
        decimalLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateDefinitionsContext ------------------------------------------------------------------

MySqlParser::CreateDefinitionsContext::CreateDefinitionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateDefinitionsContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::CreateDefinitionContext *> MySqlParser::CreateDefinitionsContext::createDefinition() {
  return getRuleContexts<MySqlParser::CreateDefinitionContext>();
}

MySqlParser::CreateDefinitionContext* MySqlParser::CreateDefinitionsContext::createDefinition(size_t i) {
  return getRuleContext<MySqlParser::CreateDefinitionContext>(i);
}

tree::TerminalNode* MySqlParser::CreateDefinitionsContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateDefinitionsContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::CreateDefinitionsContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::CreateDefinitionsContext::getRuleIndex() const {
  return MySqlParser::RuleCreateDefinitions;
}

void MySqlParser::CreateDefinitionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateDefinitions(this);
}

void MySqlParser::CreateDefinitionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateDefinitions(this);
}


std::any MySqlParser::CreateDefinitionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateDefinitions(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateDefinitionsContext* MySqlParser::createDefinitions() {
  CreateDefinitionsContext *_localctx = _tracker.createInstance<CreateDefinitionsContext>(_ctx, getState());
  enterRule(_localctx, 86, MySqlParser::RuleCreateDefinitions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1572);
    match(MySqlParser::LR_BRACKET);
    setState(1573);
    createDefinition();
    setState(1578);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(1574);
      match(MySqlParser::COMMA);
      setState(1575);
      createDefinition();
      setState(1580);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1581);
    match(MySqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateDefinitionContext ------------------------------------------------------------------

MySqlParser::CreateDefinitionContext::CreateDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::CreateDefinitionContext::getRuleIndex() const {
  return MySqlParser::RuleCreateDefinition;
}

void MySqlParser::CreateDefinitionContext::copyFrom(CreateDefinitionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ColumnDeclarationContext ------------------------------------------------------------------

MySqlParser::FullColumnNameContext* MySqlParser::ColumnDeclarationContext::fullColumnName() {
  return getRuleContext<MySqlParser::FullColumnNameContext>(0);
}

MySqlParser::ColumnDefinitionContext* MySqlParser::ColumnDeclarationContext::columnDefinition() {
  return getRuleContext<MySqlParser::ColumnDefinitionContext>(0);
}

MySqlParser::ColumnDeclarationContext::ColumnDeclarationContext(CreateDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::ColumnDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnDeclaration(this);
}
void MySqlParser::ColumnDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnDeclaration(this);
}

std::any MySqlParser::ColumnDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitColumnDeclaration(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ConstraintDeclarationContext ------------------------------------------------------------------

MySqlParser::TableConstraintContext* MySqlParser::ConstraintDeclarationContext::tableConstraint() {
  return getRuleContext<MySqlParser::TableConstraintContext>(0);
}

tree::TerminalNode* MySqlParser::ConstraintDeclarationContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}

tree::TerminalNode* MySqlParser::ConstraintDeclarationContext::ENFORCED() {
  return getToken(MySqlParser::ENFORCED, 0);
}

MySqlParser::ConstraintDeclarationContext::ConstraintDeclarationContext(CreateDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::ConstraintDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintDeclaration(this);
}
void MySqlParser::ConstraintDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintDeclaration(this);
}

std::any MySqlParser::ConstraintDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitConstraintDeclaration(this);
  else
    return visitor->visitChildren(this);
}
//----------------- IndexDeclarationContext ------------------------------------------------------------------

MySqlParser::IndexColumnDefinitionContext* MySqlParser::IndexDeclarationContext::indexColumnDefinition() {
  return getRuleContext<MySqlParser::IndexColumnDefinitionContext>(0);
}

MySqlParser::IndexDeclarationContext::IndexDeclarationContext(CreateDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::IndexDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexDeclaration(this);
}
void MySqlParser::IndexDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexDeclaration(this);
}

std::any MySqlParser::IndexDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIndexDeclaration(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::CreateDefinitionContext* MySqlParser::createDefinition() {
  CreateDefinitionContext *_localctx = _tracker.createInstance<CreateDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 88, MySqlParser::RuleCreateDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1594);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 147, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::ColumnDeclarationContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1583);
      fullColumnName();
      setState(1584);
      columnDefinition();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::ConstraintDeclarationContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1586);
      tableConstraint();
      setState(1588);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::NOT) {
        setState(1587);
        match(MySqlParser::NOT);
      }
      setState(1591);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::ENFORCED) {
        setState(1590);
        match(MySqlParser::ENFORCED);
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::IndexDeclarationContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1593);
      indexColumnDefinition();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnDefinitionContext ------------------------------------------------------------------

MySqlParser::ColumnDefinitionContext::ColumnDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::DataTypeContext* MySqlParser::ColumnDefinitionContext::dataType() {
  return getRuleContext<MySqlParser::DataTypeContext>(0);
}

std::vector<MySqlParser::ColumnConstraintContext *> MySqlParser::ColumnDefinitionContext::columnConstraint() {
  return getRuleContexts<MySqlParser::ColumnConstraintContext>();
}

MySqlParser::ColumnConstraintContext* MySqlParser::ColumnDefinitionContext::columnConstraint(size_t i) {
  return getRuleContext<MySqlParser::ColumnConstraintContext>(i);
}

tree::TerminalNode* MySqlParser::ColumnDefinitionContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}

tree::TerminalNode* MySqlParser::ColumnDefinitionContext::ENFORCED() {
  return getToken(MySqlParser::ENFORCED, 0);
}


size_t MySqlParser::ColumnDefinitionContext::getRuleIndex() const {
  return MySqlParser::RuleColumnDefinition;
}

void MySqlParser::ColumnDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnDefinition(this);
}

void MySqlParser::ColumnDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnDefinition(this);
}


std::any MySqlParser::ColumnDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitColumnDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ColumnDefinitionContext* MySqlParser::columnDefinition() {
  ColumnDefinitionContext *_localctx = _tracker.createInstance<ColumnDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 90, MySqlParser::RuleColumnDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1596);
    dataType();
    setState(1600);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1597);
        columnConstraint(); 
      }
      setState(1602);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx);
    }
    setState(1604);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::NOT) {
      setState(1603);
      match(MySqlParser::NOT);
    }
    setState(1607);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ENFORCED) {
      setState(1606);
      match(MySqlParser::ENFORCED);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnConstraintContext ------------------------------------------------------------------

MySqlParser::ColumnConstraintContext::ColumnConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::ColumnConstraintContext::getRuleIndex() const {
  return MySqlParser::RuleColumnConstraint;
}

void MySqlParser::ColumnConstraintContext::copyFrom(ColumnConstraintContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- StorageColumnConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::StorageColumnConstraintContext::STORAGE() {
  return getToken(MySqlParser::STORAGE, 0);
}

tree::TerminalNode* MySqlParser::StorageColumnConstraintContext::DISK() {
  return getToken(MySqlParser::DISK, 0);
}

tree::TerminalNode* MySqlParser::StorageColumnConstraintContext::MEMORY() {
  return getToken(MySqlParser::MEMORY, 0);
}

tree::TerminalNode* MySqlParser::StorageColumnConstraintContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

MySqlParser::StorageColumnConstraintContext::StorageColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::StorageColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStorageColumnConstraint(this);
}
void MySqlParser::StorageColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStorageColumnConstraint(this);
}

std::any MySqlParser::StorageColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitStorageColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- VisibilityColumnConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::VisibilityColumnConstraintContext::VISIBLE() {
  return getToken(MySqlParser::VISIBLE, 0);
}

MySqlParser::VisibilityColumnConstraintContext::VisibilityColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::VisibilityColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVisibilityColumnConstraint(this);
}
void MySqlParser::VisibilityColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVisibilityColumnConstraint(this);
}

std::any MySqlParser::VisibilityColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitVisibilityColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AutoIncrementColumnConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AutoIncrementColumnConstraintContext::AUTO_INCREMENT() {
  return getToken(MySqlParser::AUTO_INCREMENT, 0);
}

tree::TerminalNode* MySqlParser::AutoIncrementColumnConstraintContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

tree::TerminalNode* MySqlParser::AutoIncrementColumnConstraintContext::UPDATE() {
  return getToken(MySqlParser::UPDATE, 0);
}

MySqlParser::CurrentTimestampContext* MySqlParser::AutoIncrementColumnConstraintContext::currentTimestamp() {
  return getRuleContext<MySqlParser::CurrentTimestampContext>(0);
}

MySqlParser::AutoIncrementColumnConstraintContext::AutoIncrementColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::AutoIncrementColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAutoIncrementColumnConstraint(this);
}
void MySqlParser::AutoIncrementColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAutoIncrementColumnConstraint(this);
}

std::any MySqlParser::AutoIncrementColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAutoIncrementColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CommentColumnConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::CommentColumnConstraintContext::COMMENT() {
  return getToken(MySqlParser::COMMENT, 0);
}

tree::TerminalNode* MySqlParser::CommentColumnConstraintContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

MySqlParser::CommentColumnConstraintContext::CommentColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::CommentColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommentColumnConstraint(this);
}
void MySqlParser::CommentColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommentColumnConstraint(this);
}

std::any MySqlParser::CommentColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCommentColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- UniqueKeyColumnConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::UniqueKeyColumnConstraintContext::UNIQUE() {
  return getToken(MySqlParser::UNIQUE, 0);
}

tree::TerminalNode* MySqlParser::UniqueKeyColumnConstraintContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::UniqueKeyColumnConstraintContext::UniqueKeyColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::UniqueKeyColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUniqueKeyColumnConstraint(this);
}
void MySqlParser::UniqueKeyColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUniqueKeyColumnConstraint(this);
}

std::any MySqlParser::UniqueKeyColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUniqueKeyColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SerialDefaultColumnConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SerialDefaultColumnConstraintContext::SERIAL() {
  return getToken(MySqlParser::SERIAL, 0);
}

tree::TerminalNode* MySqlParser::SerialDefaultColumnConstraintContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::SerialDefaultColumnConstraintContext::VALUE() {
  return getToken(MySqlParser::VALUE, 0);
}

MySqlParser::SerialDefaultColumnConstraintContext::SerialDefaultColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::SerialDefaultColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSerialDefaultColumnConstraint(this);
}
void MySqlParser::SerialDefaultColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSerialDefaultColumnConstraint(this);
}

std::any MySqlParser::SerialDefaultColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSerialDefaultColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- GeneratedColumnConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::GeneratedColumnConstraintContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

tree::TerminalNode* MySqlParser::GeneratedColumnConstraintContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ExpressionContext* MySqlParser::GeneratedColumnConstraintContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::GeneratedColumnConstraintContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::GeneratedColumnConstraintContext::GENERATED() {
  return getToken(MySqlParser::GENERATED, 0);
}

tree::TerminalNode* MySqlParser::GeneratedColumnConstraintContext::ALWAYS() {
  return getToken(MySqlParser::ALWAYS, 0);
}

tree::TerminalNode* MySqlParser::GeneratedColumnConstraintContext::VIRTUAL() {
  return getToken(MySqlParser::VIRTUAL, 0);
}

tree::TerminalNode* MySqlParser::GeneratedColumnConstraintContext::STORED() {
  return getToken(MySqlParser::STORED, 0);
}

MySqlParser::GeneratedColumnConstraintContext::GeneratedColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::GeneratedColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeneratedColumnConstraint(this);
}
void MySqlParser::GeneratedColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeneratedColumnConstraint(this);
}

std::any MySqlParser::GeneratedColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitGeneratedColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- FormatColumnConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::FormatColumnConstraintContext::COLUMN_FORMAT() {
  return getToken(MySqlParser::COLUMN_FORMAT, 0);
}

tree::TerminalNode* MySqlParser::FormatColumnConstraintContext::FIXED() {
  return getToken(MySqlParser::FIXED, 0);
}

tree::TerminalNode* MySqlParser::FormatColumnConstraintContext::DYNAMIC() {
  return getToken(MySqlParser::DYNAMIC, 0);
}

tree::TerminalNode* MySqlParser::FormatColumnConstraintContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

MySqlParser::FormatColumnConstraintContext::FormatColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::FormatColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFormatColumnConstraint(this);
}
void MySqlParser::FormatColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFormatColumnConstraint(this);
}

std::any MySqlParser::FormatColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFormatColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CollateColumnConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::CollateColumnConstraintContext::COLLATE() {
  return getToken(MySqlParser::COLLATE, 0);
}

MySqlParser::CollationNameContext* MySqlParser::CollateColumnConstraintContext::collationName() {
  return getRuleContext<MySqlParser::CollationNameContext>(0);
}

MySqlParser::CollateColumnConstraintContext::CollateColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::CollateColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollateColumnConstraint(this);
}
void MySqlParser::CollateColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollateColumnConstraint(this);
}

std::any MySqlParser::CollateColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCollateColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PrimaryKeyColumnConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PrimaryKeyColumnConstraintContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

tree::TerminalNode* MySqlParser::PrimaryKeyColumnConstraintContext::PRIMARY() {
  return getToken(MySqlParser::PRIMARY, 0);
}

MySqlParser::PrimaryKeyColumnConstraintContext::PrimaryKeyColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::PrimaryKeyColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryKeyColumnConstraint(this);
}
void MySqlParser::PrimaryKeyColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryKeyColumnConstraint(this);
}

std::any MySqlParser::PrimaryKeyColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPrimaryKeyColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CheckColumnConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::CheckColumnConstraintContext::CHECK() {
  return getToken(MySqlParser::CHECK, 0);
}

tree::TerminalNode* MySqlParser::CheckColumnConstraintContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ExpressionContext* MySqlParser::CheckColumnConstraintContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::CheckColumnConstraintContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::CheckColumnConstraintContext::CONSTRAINT() {
  return getToken(MySqlParser::CONSTRAINT, 0);
}

MySqlParser::UidContext* MySqlParser::CheckColumnConstraintContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::CheckColumnConstraintContext::CheckColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::CheckColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckColumnConstraint(this);
}
void MySqlParser::CheckColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckColumnConstraint(this);
}

std::any MySqlParser::CheckColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCheckColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NullColumnConstraintContext ------------------------------------------------------------------

MySqlParser::NullNotnullContext* MySqlParser::NullColumnConstraintContext::nullNotnull() {
  return getRuleContext<MySqlParser::NullNotnullContext>(0);
}

MySqlParser::NullColumnConstraintContext::NullColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::NullColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullColumnConstraint(this);
}
void MySqlParser::NullColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullColumnConstraint(this);
}

std::any MySqlParser::NullColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitNullColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DefaultColumnConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::DefaultColumnConstraintContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

MySqlParser::DefaultValueContext* MySqlParser::DefaultColumnConstraintContext::defaultValue() {
  return getRuleContext<MySqlParser::DefaultValueContext>(0);
}

MySqlParser::DefaultColumnConstraintContext::DefaultColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::DefaultColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultColumnConstraint(this);
}
void MySqlParser::DefaultColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultColumnConstraint(this);
}

std::any MySqlParser::DefaultColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDefaultColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ReferenceColumnConstraintContext ------------------------------------------------------------------

MySqlParser::ReferenceDefinitionContext* MySqlParser::ReferenceColumnConstraintContext::referenceDefinition() {
  return getRuleContext<MySqlParser::ReferenceDefinitionContext>(0);
}

MySqlParser::ReferenceColumnConstraintContext::ReferenceColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::ReferenceColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReferenceColumnConstraint(this);
}
void MySqlParser::ReferenceColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReferenceColumnConstraint(this);
}

std::any MySqlParser::ReferenceColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitReferenceColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- InvisibilityColumnConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::InvisibilityColumnConstraintContext::INVISIBLE() {
  return getToken(MySqlParser::INVISIBLE, 0);
}

MySqlParser::InvisibilityColumnConstraintContext::InvisibilityColumnConstraintContext(ColumnConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::InvisibilityColumnConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInvisibilityColumnConstraint(this);
}
void MySqlParser::InvisibilityColumnConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInvisibilityColumnConstraint(this);
}

std::any MySqlParser::InvisibilityColumnConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitInvisibilityColumnConstraint(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::ColumnConstraintContext* MySqlParser::columnConstraint() {
  ColumnConstraintContext *_localctx = _tracker.createInstance<ColumnConstraintContext>(_ctx, getState());
  enterRule(_localctx, 92, MySqlParser::RuleColumnConstraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1662);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::NOT:
      case MySqlParser::NULL_LITERAL:
      case MySqlParser::NULL_SPEC_LITERAL: {
        _localctx = _tracker.createInstance<MySqlParser::NullColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1609);
        nullNotnull();
        break;
      }

      case MySqlParser::DEFAULT: {
        _localctx = _tracker.createInstance<MySqlParser::DefaultColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1610);
        match(MySqlParser::DEFAULT);
        setState(1611);
        defaultValue();
        break;
      }

      case MySqlParser::VISIBLE: {
        _localctx = _tracker.createInstance<MySqlParser::VisibilityColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(1612);
        match(MySqlParser::VISIBLE);
        break;
      }

      case MySqlParser::INVISIBLE: {
        _localctx = _tracker.createInstance<MySqlParser::InvisibilityColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(1613);
        match(MySqlParser::INVISIBLE);
        break;
      }

      case MySqlParser::ON:
      case MySqlParser::AUTO_INCREMENT: {
        _localctx = _tracker.createInstance<MySqlParser::AutoIncrementColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(1618);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::AUTO_INCREMENT: {
            setState(1614);
            match(MySqlParser::AUTO_INCREMENT);
            break;
          }

          case MySqlParser::ON: {
            setState(1615);
            match(MySqlParser::ON);
            setState(1616);
            match(MySqlParser::UPDATE);
            setState(1617);
            currentTimestamp();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySqlParser::KEY:
      case MySqlParser::PRIMARY: {
        _localctx = _tracker.createInstance<MySqlParser::PrimaryKeyColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(1621);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::PRIMARY) {
          setState(1620);
          match(MySqlParser::PRIMARY);
        }
        setState(1623);
        match(MySqlParser::KEY);
        break;
      }

      case MySqlParser::UNIQUE: {
        _localctx = _tracker.createInstance<MySqlParser::UniqueKeyColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(1624);
        match(MySqlParser::UNIQUE);
        setState(1626);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx)) {
        case 1: {
          setState(1625);
          match(MySqlParser::KEY);
          break;
        }

        default:
          break;
        }
        break;
      }

      case MySqlParser::COMMENT: {
        _localctx = _tracker.createInstance<MySqlParser::CommentColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 8);
        setState(1628);
        match(MySqlParser::COMMENT);
        setState(1629);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::COLUMN_FORMAT: {
        _localctx = _tracker.createInstance<MySqlParser::FormatColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 9);
        setState(1630);
        match(MySqlParser::COLUMN_FORMAT);
        setState(1631);
        antlrcpp::downCast<FormatColumnConstraintContext *>(_localctx)->colformat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::DYNAMIC

        || _la == MySqlParser::FIXED)) {
          antlrcpp::downCast<FormatColumnConstraintContext *>(_localctx)->colformat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySqlParser::STORAGE: {
        _localctx = _tracker.createInstance<MySqlParser::StorageColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 10);
        setState(1632);
        match(MySqlParser::STORAGE);
        setState(1633);
        antlrcpp::downCast<StorageColumnConstraintContext *>(_localctx)->storageval = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::DISK || _la == MySqlParser::MEMORY)) {
          antlrcpp::downCast<StorageColumnConstraintContext *>(_localctx)->storageval = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySqlParser::REFERENCES: {
        _localctx = _tracker.createInstance<MySqlParser::ReferenceColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 11);
        setState(1634);
        referenceDefinition();
        break;
      }

      case MySqlParser::COLLATE: {
        _localctx = _tracker.createInstance<MySqlParser::CollateColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 12);
        setState(1635);
        match(MySqlParser::COLLATE);
        setState(1636);
        collationName();
        break;
      }

      case MySqlParser::AS:
      case MySqlParser::GENERATED: {
        _localctx = _tracker.createInstance<MySqlParser::GeneratedColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 13);
        setState(1639);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::GENERATED) {
          setState(1637);
          match(MySqlParser::GENERATED);
          setState(1638);
          match(MySqlParser::ALWAYS);
        }
        setState(1641);
        match(MySqlParser::AS);
        setState(1642);
        match(MySqlParser::LR_BRACKET);
        setState(1643);
        expression(0);
        setState(1644);
        match(MySqlParser::RR_BRACKET);
        setState(1646);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::STORED

        || _la == MySqlParser::VIRTUAL) {
          setState(1645);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::STORED

          || _la == MySqlParser::VIRTUAL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        break;
      }

      case MySqlParser::SERIAL: {
        _localctx = _tracker.createInstance<MySqlParser::SerialDefaultColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 14);
        setState(1648);
        match(MySqlParser::SERIAL);
        setState(1649);
        match(MySqlParser::DEFAULT);
        setState(1650);
        match(MySqlParser::VALUE);
        break;
      }

      case MySqlParser::CHECK:
      case MySqlParser::CONSTRAINT: {
        _localctx = _tracker.createInstance<MySqlParser::CheckColumnConstraintContext>(_localctx);
        enterOuterAlt(_localctx, 15);
        setState(1655);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::CONSTRAINT) {
          setState(1651);
          match(MySqlParser::CONSTRAINT);
          setState(1653);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
            setState(1652);
            antlrcpp::downCast<CheckColumnConstraintContext *>(_localctx)->name = uid();
          }
        }
        setState(1657);
        match(MySqlParser::CHECK);
        setState(1658);
        match(MySqlParser::LR_BRACKET);
        setState(1659);
        expression(0);
        setState(1660);
        match(MySqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableConstraintContext ------------------------------------------------------------------

MySqlParser::TableConstraintContext::TableConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::TableConstraintContext::getRuleIndex() const {
  return MySqlParser::RuleTableConstraint;
}

void MySqlParser::TableConstraintContext::copyFrom(TableConstraintContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- UniqueKeyTableConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::UniqueKeyTableConstraintContext::UNIQUE() {
  return getToken(MySqlParser::UNIQUE, 0);
}

MySqlParser::IndexColumnNamesContext* MySqlParser::UniqueKeyTableConstraintContext::indexColumnNames() {
  return getRuleContext<MySqlParser::IndexColumnNamesContext>(0);
}

tree::TerminalNode* MySqlParser::UniqueKeyTableConstraintContext::CONSTRAINT() {
  return getToken(MySqlParser::CONSTRAINT, 0);
}

MySqlParser::IndexTypeContext* MySqlParser::UniqueKeyTableConstraintContext::indexType() {
  return getRuleContext<MySqlParser::IndexTypeContext>(0);
}

std::vector<MySqlParser::IndexOptionContext *> MySqlParser::UniqueKeyTableConstraintContext::indexOption() {
  return getRuleContexts<MySqlParser::IndexOptionContext>();
}

MySqlParser::IndexOptionContext* MySqlParser::UniqueKeyTableConstraintContext::indexOption(size_t i) {
  return getRuleContext<MySqlParser::IndexOptionContext>(i);
}

std::vector<MySqlParser::UidContext *> MySqlParser::UniqueKeyTableConstraintContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::UniqueKeyTableConstraintContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

tree::TerminalNode* MySqlParser::UniqueKeyTableConstraintContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::UniqueKeyTableConstraintContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::UniqueKeyTableConstraintContext::UniqueKeyTableConstraintContext(TableConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::UniqueKeyTableConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUniqueKeyTableConstraint(this);
}
void MySqlParser::UniqueKeyTableConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUniqueKeyTableConstraint(this);
}

std::any MySqlParser::UniqueKeyTableConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUniqueKeyTableConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CheckTableConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::CheckTableConstraintContext::CHECK() {
  return getToken(MySqlParser::CHECK, 0);
}

tree::TerminalNode* MySqlParser::CheckTableConstraintContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ExpressionContext* MySqlParser::CheckTableConstraintContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::CheckTableConstraintContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::CheckTableConstraintContext::CONSTRAINT() {
  return getToken(MySqlParser::CONSTRAINT, 0);
}

MySqlParser::UidContext* MySqlParser::CheckTableConstraintContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::CheckTableConstraintContext::CheckTableConstraintContext(TableConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::CheckTableConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckTableConstraint(this);
}
void MySqlParser::CheckTableConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckTableConstraint(this);
}

std::any MySqlParser::CheckTableConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCheckTableConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PrimaryKeyTableConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PrimaryKeyTableConstraintContext::PRIMARY() {
  return getToken(MySqlParser::PRIMARY, 0);
}

tree::TerminalNode* MySqlParser::PrimaryKeyTableConstraintContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::IndexColumnNamesContext* MySqlParser::PrimaryKeyTableConstraintContext::indexColumnNames() {
  return getRuleContext<MySqlParser::IndexColumnNamesContext>(0);
}

tree::TerminalNode* MySqlParser::PrimaryKeyTableConstraintContext::CONSTRAINT() {
  return getToken(MySqlParser::CONSTRAINT, 0);
}

MySqlParser::IndexTypeContext* MySqlParser::PrimaryKeyTableConstraintContext::indexType() {
  return getRuleContext<MySqlParser::IndexTypeContext>(0);
}

std::vector<MySqlParser::IndexOptionContext *> MySqlParser::PrimaryKeyTableConstraintContext::indexOption() {
  return getRuleContexts<MySqlParser::IndexOptionContext>();
}

MySqlParser::IndexOptionContext* MySqlParser::PrimaryKeyTableConstraintContext::indexOption(size_t i) {
  return getRuleContext<MySqlParser::IndexOptionContext>(i);
}

std::vector<MySqlParser::UidContext *> MySqlParser::PrimaryKeyTableConstraintContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::PrimaryKeyTableConstraintContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

MySqlParser::PrimaryKeyTableConstraintContext::PrimaryKeyTableConstraintContext(TableConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::PrimaryKeyTableConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryKeyTableConstraint(this);
}
void MySqlParser::PrimaryKeyTableConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryKeyTableConstraint(this);
}

std::any MySqlParser::PrimaryKeyTableConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPrimaryKeyTableConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ForeignKeyTableConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ForeignKeyTableConstraintContext::FOREIGN() {
  return getToken(MySqlParser::FOREIGN, 0);
}

tree::TerminalNode* MySqlParser::ForeignKeyTableConstraintContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::IndexColumnNamesContext* MySqlParser::ForeignKeyTableConstraintContext::indexColumnNames() {
  return getRuleContext<MySqlParser::IndexColumnNamesContext>(0);
}

MySqlParser::ReferenceDefinitionContext* MySqlParser::ForeignKeyTableConstraintContext::referenceDefinition() {
  return getRuleContext<MySqlParser::ReferenceDefinitionContext>(0);
}

tree::TerminalNode* MySqlParser::ForeignKeyTableConstraintContext::CONSTRAINT() {
  return getToken(MySqlParser::CONSTRAINT, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::ForeignKeyTableConstraintContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::ForeignKeyTableConstraintContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

MySqlParser::ForeignKeyTableConstraintContext::ForeignKeyTableConstraintContext(TableConstraintContext *ctx) { copyFrom(ctx); }

void MySqlParser::ForeignKeyTableConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForeignKeyTableConstraint(this);
}
void MySqlParser::ForeignKeyTableConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForeignKeyTableConstraint(this);
}

std::any MySqlParser::ForeignKeyTableConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitForeignKeyTableConstraint(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::TableConstraintContext* MySqlParser::tableConstraint() {
  TableConstraintContext *_localctx = _tracker.createInstance<TableConstraintContext>(_ctx, getState());
  enterRule(_localctx, 94, MySqlParser::RuleTableConstraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1733);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::PrimaryKeyTableConstraintContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1668);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::CONSTRAINT) {
        setState(1664);
        match(MySqlParser::CONSTRAINT);
        setState(1666);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx)) {
        case 1: {
          setState(1665);
          antlrcpp::downCast<PrimaryKeyTableConstraintContext *>(_localctx)->name = uid();
          break;
        }

        default:
          break;
        }
      }
      setState(1670);
      match(MySqlParser::PRIMARY);
      setState(1671);
      match(MySqlParser::KEY);
      setState(1673);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
        setState(1672);
        antlrcpp::downCast<PrimaryKeyTableConstraintContext *>(_localctx)->index = uid();
      }
      setState(1676);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::USING) {
        setState(1675);
        indexType();
      }
      setState(1678);
      indexColumnNames();
      setState(1682);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::USING

      || _la == MySqlParser::WITH || _la == MySqlParser::COMMENT || _la == MySqlParser::INVISIBLE

      || _la == MySqlParser::KEY_BLOCK_SIZE || _la == MySqlParser::VISIBLE || _la == MySqlParser::ENGINE_ATTRIBUTE || _la == MySqlParser::SECONDARY_ENGINE_ATTRIBUTE) {
        setState(1679);
        indexOption();
        setState(1684);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::UniqueKeyTableConstraintContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1689);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::CONSTRAINT) {
        setState(1685);
        match(MySqlParser::CONSTRAINT);
        setState(1687);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
          setState(1686);
          antlrcpp::downCast<UniqueKeyTableConstraintContext *>(_localctx)->name = uid();
        }
      }
      setState(1691);
      match(MySqlParser::UNIQUE);
      setState(1693);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::INDEX

      || _la == MySqlParser::KEY) {
        setState(1692);
        antlrcpp::downCast<UniqueKeyTableConstraintContext *>(_localctx)->indexFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::INDEX

        || _la == MySqlParser::KEY)) {
          antlrcpp::downCast<UniqueKeyTableConstraintContext *>(_localctx)->indexFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1696);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
        setState(1695);
        antlrcpp::downCast<UniqueKeyTableConstraintContext *>(_localctx)->index = uid();
      }
      setState(1699);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::USING) {
        setState(1698);
        indexType();
      }
      setState(1701);
      indexColumnNames();
      setState(1705);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::USING

      || _la == MySqlParser::WITH || _la == MySqlParser::COMMENT || _la == MySqlParser::INVISIBLE

      || _la == MySqlParser::KEY_BLOCK_SIZE || _la == MySqlParser::VISIBLE || _la == MySqlParser::ENGINE_ATTRIBUTE || _la == MySqlParser::SECONDARY_ENGINE_ATTRIBUTE) {
        setState(1702);
        indexOption();
        setState(1707);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::ForeignKeyTableConstraintContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1712);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::CONSTRAINT) {
        setState(1708);
        match(MySqlParser::CONSTRAINT);
        setState(1710);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
          setState(1709);
          antlrcpp::downCast<ForeignKeyTableConstraintContext *>(_localctx)->name = uid();
        }
      }
      setState(1714);
      match(MySqlParser::FOREIGN);
      setState(1715);
      match(MySqlParser::KEY);
      setState(1717);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
        setState(1716);
        antlrcpp::downCast<ForeignKeyTableConstraintContext *>(_localctx)->index = uid();
      }
      setState(1719);
      indexColumnNames();
      setState(1720);
      referenceDefinition();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::CheckTableConstraintContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(1726);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::CONSTRAINT) {
        setState(1722);
        match(MySqlParser::CONSTRAINT);
        setState(1724);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
          setState(1723);
          antlrcpp::downCast<CheckTableConstraintContext *>(_localctx)->name = uid();
        }
      }
      setState(1728);
      match(MySqlParser::CHECK);
      setState(1729);
      match(MySqlParser::LR_BRACKET);
      setState(1730);
      expression(0);
      setState(1731);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReferenceDefinitionContext ------------------------------------------------------------------

MySqlParser::ReferenceDefinitionContext::ReferenceDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ReferenceDefinitionContext::REFERENCES() {
  return getToken(MySqlParser::REFERENCES, 0);
}

MySqlParser::TableNameContext* MySqlParser::ReferenceDefinitionContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

MySqlParser::IndexColumnNamesContext* MySqlParser::ReferenceDefinitionContext::indexColumnNames() {
  return getRuleContext<MySqlParser::IndexColumnNamesContext>(0);
}

tree::TerminalNode* MySqlParser::ReferenceDefinitionContext::MATCH() {
  return getToken(MySqlParser::MATCH, 0);
}

MySqlParser::ReferenceActionContext* MySqlParser::ReferenceDefinitionContext::referenceAction() {
  return getRuleContext<MySqlParser::ReferenceActionContext>(0);
}

tree::TerminalNode* MySqlParser::ReferenceDefinitionContext::FULL() {
  return getToken(MySqlParser::FULL, 0);
}

tree::TerminalNode* MySqlParser::ReferenceDefinitionContext::PARTIAL() {
  return getToken(MySqlParser::PARTIAL, 0);
}

tree::TerminalNode* MySqlParser::ReferenceDefinitionContext::SIMPLE() {
  return getToken(MySqlParser::SIMPLE, 0);
}


size_t MySqlParser::ReferenceDefinitionContext::getRuleIndex() const {
  return MySqlParser::RuleReferenceDefinition;
}

void MySqlParser::ReferenceDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReferenceDefinition(this);
}

void MySqlParser::ReferenceDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReferenceDefinition(this);
}


std::any MySqlParser::ReferenceDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitReferenceDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ReferenceDefinitionContext* MySqlParser::referenceDefinition() {
  ReferenceDefinitionContext *_localctx = _tracker.createInstance<ReferenceDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 96, MySqlParser::RuleReferenceDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1735);
    match(MySqlParser::REFERENCES);
    setState(1736);
    tableName();
    setState(1738);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 176, _ctx)) {
    case 1: {
      setState(1737);
      indexColumnNames();
      break;
    }

    default:
      break;
    }
    setState(1742);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::MATCH) {
      setState(1740);
      match(MySqlParser::MATCH);
      setState(1741);
      antlrcpp::downCast<ReferenceDefinitionContext *>(_localctx)->matchType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::FULL || _la == MySqlParser::PARTIAL || _la == MySqlParser::SIMPLE)) {
        antlrcpp::downCast<ReferenceDefinitionContext *>(_localctx)->matchType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1745);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {
    case 1: {
      setState(1744);
      referenceAction();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReferenceActionContext ------------------------------------------------------------------

MySqlParser::ReferenceActionContext::ReferenceActionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySqlParser::ReferenceActionContext::ON() {
  return getTokens(MySqlParser::ON);
}

tree::TerminalNode* MySqlParser::ReferenceActionContext::ON(size_t i) {
  return getToken(MySqlParser::ON, i);
}

tree::TerminalNode* MySqlParser::ReferenceActionContext::DELETE() {
  return getToken(MySqlParser::DELETE, 0);
}

std::vector<MySqlParser::ReferenceControlTypeContext *> MySqlParser::ReferenceActionContext::referenceControlType() {
  return getRuleContexts<MySqlParser::ReferenceControlTypeContext>();
}

MySqlParser::ReferenceControlTypeContext* MySqlParser::ReferenceActionContext::referenceControlType(size_t i) {
  return getRuleContext<MySqlParser::ReferenceControlTypeContext>(i);
}

tree::TerminalNode* MySqlParser::ReferenceActionContext::UPDATE() {
  return getToken(MySqlParser::UPDATE, 0);
}


size_t MySqlParser::ReferenceActionContext::getRuleIndex() const {
  return MySqlParser::RuleReferenceAction;
}

void MySqlParser::ReferenceActionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReferenceAction(this);
}

void MySqlParser::ReferenceActionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReferenceAction(this);
}


std::any MySqlParser::ReferenceActionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitReferenceAction(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ReferenceActionContext* MySqlParser::referenceAction() {
  ReferenceActionContext *_localctx = _tracker.createInstance<ReferenceActionContext>(_ctx, getState());
  enterRule(_localctx, 98, MySqlParser::RuleReferenceAction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1763);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1747);
      match(MySqlParser::ON);
      setState(1748);
      match(MySqlParser::DELETE);
      setState(1749);
      antlrcpp::downCast<ReferenceActionContext *>(_localctx)->onDelete = referenceControlType();
      setState(1753);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx)) {
      case 1: {
        setState(1750);
        match(MySqlParser::ON);
        setState(1751);
        match(MySqlParser::UPDATE);
        setState(1752);
        antlrcpp::downCast<ReferenceActionContext *>(_localctx)->onUpdate = referenceControlType();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1755);
      match(MySqlParser::ON);
      setState(1756);
      match(MySqlParser::UPDATE);
      setState(1757);
      antlrcpp::downCast<ReferenceActionContext *>(_localctx)->onUpdate = referenceControlType();
      setState(1761);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx)) {
      case 1: {
        setState(1758);
        match(MySqlParser::ON);
        setState(1759);
        match(MySqlParser::DELETE);
        setState(1760);
        antlrcpp::downCast<ReferenceActionContext *>(_localctx)->onDelete = referenceControlType();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReferenceControlTypeContext ------------------------------------------------------------------

MySqlParser::ReferenceControlTypeContext::ReferenceControlTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ReferenceControlTypeContext::RESTRICT() {
  return getToken(MySqlParser::RESTRICT, 0);
}

tree::TerminalNode* MySqlParser::ReferenceControlTypeContext::CASCADE() {
  return getToken(MySqlParser::CASCADE, 0);
}

tree::TerminalNode* MySqlParser::ReferenceControlTypeContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::ReferenceControlTypeContext::NULL_LITERAL() {
  return getToken(MySqlParser::NULL_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::ReferenceControlTypeContext::NO() {
  return getToken(MySqlParser::NO, 0);
}

tree::TerminalNode* MySqlParser::ReferenceControlTypeContext::ACTION() {
  return getToken(MySqlParser::ACTION, 0);
}

tree::TerminalNode* MySqlParser::ReferenceControlTypeContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}


size_t MySqlParser::ReferenceControlTypeContext::getRuleIndex() const {
  return MySqlParser::RuleReferenceControlType;
}

void MySqlParser::ReferenceControlTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReferenceControlType(this);
}

void MySqlParser::ReferenceControlTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReferenceControlType(this);
}


std::any MySqlParser::ReferenceControlTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitReferenceControlType(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ReferenceControlTypeContext* MySqlParser::referenceControlType() {
  ReferenceControlTypeContext *_localctx = _tracker.createInstance<ReferenceControlTypeContext>(_ctx, getState());
  enterRule(_localctx, 100, MySqlParser::RuleReferenceControlType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1773);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1765);
      match(MySqlParser::RESTRICT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1766);
      match(MySqlParser::CASCADE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1767);
      match(MySqlParser::SET);
      setState(1768);
      match(MySqlParser::NULL_LITERAL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1769);
      match(MySqlParser::NO);
      setState(1770);
      match(MySqlParser::ACTION);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1771);
      match(MySqlParser::SET);
      setState(1772);
      match(MySqlParser::DEFAULT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexColumnDefinitionContext ------------------------------------------------------------------

MySqlParser::IndexColumnDefinitionContext::IndexColumnDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::IndexColumnDefinitionContext::getRuleIndex() const {
  return MySqlParser::RuleIndexColumnDefinition;
}

void MySqlParser::IndexColumnDefinitionContext::copyFrom(IndexColumnDefinitionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SpecialIndexDeclarationContext ------------------------------------------------------------------

MySqlParser::IndexColumnNamesContext* MySqlParser::SpecialIndexDeclarationContext::indexColumnNames() {
  return getRuleContext<MySqlParser::IndexColumnNamesContext>(0);
}

tree::TerminalNode* MySqlParser::SpecialIndexDeclarationContext::FULLTEXT() {
  return getToken(MySqlParser::FULLTEXT, 0);
}

tree::TerminalNode* MySqlParser::SpecialIndexDeclarationContext::SPATIAL() {
  return getToken(MySqlParser::SPATIAL, 0);
}

MySqlParser::UidContext* MySqlParser::SpecialIndexDeclarationContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

std::vector<MySqlParser::IndexOptionContext *> MySqlParser::SpecialIndexDeclarationContext::indexOption() {
  return getRuleContexts<MySqlParser::IndexOptionContext>();
}

MySqlParser::IndexOptionContext* MySqlParser::SpecialIndexDeclarationContext::indexOption(size_t i) {
  return getRuleContext<MySqlParser::IndexOptionContext>(i);
}

tree::TerminalNode* MySqlParser::SpecialIndexDeclarationContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::SpecialIndexDeclarationContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::SpecialIndexDeclarationContext::SpecialIndexDeclarationContext(IndexColumnDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::SpecialIndexDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecialIndexDeclaration(this);
}
void MySqlParser::SpecialIndexDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecialIndexDeclaration(this);
}

std::any MySqlParser::SpecialIndexDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSpecialIndexDeclaration(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleIndexDeclarationContext ------------------------------------------------------------------

MySqlParser::IndexColumnNamesContext* MySqlParser::SimpleIndexDeclarationContext::indexColumnNames() {
  return getRuleContext<MySqlParser::IndexColumnNamesContext>(0);
}

tree::TerminalNode* MySqlParser::SimpleIndexDeclarationContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::SimpleIndexDeclarationContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::UidContext* MySqlParser::SimpleIndexDeclarationContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::IndexTypeContext* MySqlParser::SimpleIndexDeclarationContext::indexType() {
  return getRuleContext<MySqlParser::IndexTypeContext>(0);
}

std::vector<MySqlParser::IndexOptionContext *> MySqlParser::SimpleIndexDeclarationContext::indexOption() {
  return getRuleContexts<MySqlParser::IndexOptionContext>();
}

MySqlParser::IndexOptionContext* MySqlParser::SimpleIndexDeclarationContext::indexOption(size_t i) {
  return getRuleContext<MySqlParser::IndexOptionContext>(i);
}

MySqlParser::SimpleIndexDeclarationContext::SimpleIndexDeclarationContext(IndexColumnDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::SimpleIndexDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleIndexDeclaration(this);
}
void MySqlParser::SimpleIndexDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleIndexDeclaration(this);
}

std::any MySqlParser::SimpleIndexDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSimpleIndexDeclaration(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::IndexColumnDefinitionContext* MySqlParser::indexColumnDefinition() {
  IndexColumnDefinitionContext *_localctx = _tracker.createInstance<IndexColumnDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 102, MySqlParser::RuleIndexColumnDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1803);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::INDEX:
      case MySqlParser::KEY: {
        _localctx = _tracker.createInstance<MySqlParser::SimpleIndexDeclarationContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1775);
        antlrcpp::downCast<SimpleIndexDeclarationContext *>(_localctx)->indexFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::INDEX

        || _la == MySqlParser::KEY)) {
          antlrcpp::downCast<SimpleIndexDeclarationContext *>(_localctx)->indexFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1777);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
          setState(1776);
          uid();
        }
        setState(1780);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::USING) {
          setState(1779);
          indexType();
        }
        setState(1782);
        indexColumnNames();
        setState(1786);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::USING

        || _la == MySqlParser::WITH || _la == MySqlParser::COMMENT || _la == MySqlParser::INVISIBLE

        || _la == MySqlParser::KEY_BLOCK_SIZE || _la == MySqlParser::VISIBLE || _la == MySqlParser::ENGINE_ATTRIBUTE || _la == MySqlParser::SECONDARY_ENGINE_ATTRIBUTE) {
          setState(1783);
          indexOption();
          setState(1788);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySqlParser::FULLTEXT:
      case MySqlParser::SPATIAL: {
        _localctx = _tracker.createInstance<MySqlParser::SpecialIndexDeclarationContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1789);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::FULLTEXT || _la == MySqlParser::SPATIAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1791);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::INDEX

        || _la == MySqlParser::KEY) {
          setState(1790);
          antlrcpp::downCast<SpecialIndexDeclarationContext *>(_localctx)->indexFormat = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::INDEX

          || _la == MySqlParser::KEY)) {
            antlrcpp::downCast<SpecialIndexDeclarationContext *>(_localctx)->indexFormat = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(1794);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
          setState(1793);
          uid();
        }
        setState(1796);
        indexColumnNames();
        setState(1800);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::USING

        || _la == MySqlParser::WITH || _la == MySqlParser::COMMENT || _la == MySqlParser::INVISIBLE

        || _la == MySqlParser::KEY_BLOCK_SIZE || _la == MySqlParser::VISIBLE || _la == MySqlParser::ENGINE_ATTRIBUTE || _la == MySqlParser::SECONDARY_ENGINE_ATTRIBUTE) {
          setState(1797);
          indexOption();
          setState(1802);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableOptionContext ------------------------------------------------------------------

MySqlParser::TableOptionContext::TableOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::TableOptionContext::getRuleIndex() const {
  return MySqlParser::RuleTableOption;
}

void MySqlParser::TableOptionContext::copyFrom(TableOptionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TableOptionEngineContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionEngineContext::ENGINE() {
  return getToken(MySqlParser::ENGINE, 0);
}

tree::TerminalNode* MySqlParser::TableOptionEngineContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::EngineNameContext* MySqlParser::TableOptionEngineContext::engineName() {
  return getRuleContext<MySqlParser::EngineNameContext>(0);
}

MySqlParser::TableOptionEngineContext::TableOptionEngineContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionEngineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionEngine(this);
}
void MySqlParser::TableOptionEngineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionEngine(this);
}

std::any MySqlParser::TableOptionEngineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionEngine(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionMaxRowsContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionMaxRowsContext::MAX_ROWS() {
  return getToken(MySqlParser::MAX_ROWS, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::TableOptionMaxRowsContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::TableOptionMaxRowsContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionMaxRowsContext::TableOptionMaxRowsContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionMaxRowsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionMaxRows(this);
}
void MySqlParser::TableOptionMaxRowsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionMaxRows(this);
}

std::any MySqlParser::TableOptionMaxRowsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionMaxRows(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionCollateContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionCollateContext::COLLATE() {
  return getToken(MySqlParser::COLLATE, 0);
}

MySqlParser::CollationNameContext* MySqlParser::TableOptionCollateContext::collationName() {
  return getRuleContext<MySqlParser::CollationNameContext>(0);
}

tree::TerminalNode* MySqlParser::TableOptionCollateContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::TableOptionCollateContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionCollateContext::TableOptionCollateContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionCollateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionCollate(this);
}
void MySqlParser::TableOptionCollateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionCollate(this);
}

std::any MySqlParser::TableOptionCollateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionCollate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionPersistentContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionPersistentContext::STATS_PERSISTENT() {
  return getToken(MySqlParser::STATS_PERSISTENT, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPersistentContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPersistentContext::ZERO_DECIMAL() {
  return getToken(MySqlParser::ZERO_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPersistentContext::ONE_DECIMAL() {
  return getToken(MySqlParser::ONE_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPersistentContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionPersistentContext::TableOptionPersistentContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionPersistentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionPersistent(this);
}
void MySqlParser::TableOptionPersistentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionPersistent(this);
}

std::any MySqlParser::TableOptionPersistentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionPersistent(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionTablespaceContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionTablespaceContext::TABLESPACE() {
  return getToken(MySqlParser::TABLESPACE, 0);
}

MySqlParser::UidContext* MySqlParser::TableOptionTablespaceContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::TablespaceStorageContext* MySqlParser::TableOptionTablespaceContext::tablespaceStorage() {
  return getRuleContext<MySqlParser::TablespaceStorageContext>(0);
}

MySqlParser::TableOptionTablespaceContext::TableOptionTablespaceContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionTablespace(this);
}
void MySqlParser::TableOptionTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionTablespace(this);
}

std::any MySqlParser::TableOptionTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionTablespace(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionAutoextendSizeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionAutoextendSizeContext::AUTOEXTEND_SIZE() {
  return getToken(MySqlParser::AUTOEXTEND_SIZE, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::TableOptionAutoextendSizeContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::TableOptionAutoextendSizeContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionAutoextendSizeContext::TableOptionAutoextendSizeContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionAutoextendSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionAutoextendSize(this);
}
void MySqlParser::TableOptionAutoextendSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionAutoextendSize(this);
}

std::any MySqlParser::TableOptionAutoextendSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionAutoextendSize(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionPageCompressedContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionPageCompressedContext::PAGE_COMPRESSED() {
  return getToken(MySqlParser::PAGE_COMPRESSED, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPageCompressedContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPageCompressedContext::ZERO_DECIMAL() {
  return getToken(MySqlParser::ZERO_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPageCompressedContext::ONE_DECIMAL() {
  return getToken(MySqlParser::ONE_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPageCompressedContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionPageCompressedContext::TableOptionPageCompressedContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionPageCompressedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionPageCompressed(this);
}
void MySqlParser::TableOptionPageCompressedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionPageCompressed(this);
}

std::any MySqlParser::TableOptionPageCompressedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionPageCompressed(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionStartTransactionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionStartTransactionContext::START() {
  return getToken(MySqlParser::START, 0);
}

tree::TerminalNode* MySqlParser::TableOptionStartTransactionContext::TRANSACTION() {
  return getToken(MySqlParser::TRANSACTION, 0);
}

MySqlParser::TableOptionStartTransactionContext::TableOptionStartTransactionContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionStartTransactionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionStartTransaction(this);
}
void MySqlParser::TableOptionStartTransactionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionStartTransaction(this);
}

std::any MySqlParser::TableOptionStartTransactionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionStartTransaction(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionPackKeysContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionPackKeysContext::PACK_KEYS() {
  return getToken(MySqlParser::PACK_KEYS, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPackKeysContext::ZERO_DECIMAL() {
  return getToken(MySqlParser::ZERO_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPackKeysContext::ONE_DECIMAL() {
  return getToken(MySqlParser::ONE_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPackKeysContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPackKeysContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionPackKeysContext::TableOptionPackKeysContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionPackKeysContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionPackKeys(this);
}
void MySqlParser::TableOptionPackKeysContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionPackKeys(this);
}

std::any MySqlParser::TableOptionPackKeysContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionPackKeys(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionPasswordContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionPasswordContext::PASSWORD() {
  return getToken(MySqlParser::PASSWORD, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPasswordContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPasswordContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionPasswordContext::TableOptionPasswordContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionPassword(this);
}
void MySqlParser::TableOptionPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionPassword(this);
}

std::any MySqlParser::TableOptionPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionPassword(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionUnionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionUnionContext::UNION() {
  return getToken(MySqlParser::UNION, 0);
}

tree::TerminalNode* MySqlParser::TableOptionUnionContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::TablesContext* MySqlParser::TableOptionUnionContext::tables() {
  return getRuleContext<MySqlParser::TablesContext>(0);
}

tree::TerminalNode* MySqlParser::TableOptionUnionContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::TableOptionUnionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionUnionContext::TableOptionUnionContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionUnionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionUnion(this);
}
void MySqlParser::TableOptionUnionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionUnion(this);
}

std::any MySqlParser::TableOptionUnionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionUnion(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionSamplePageContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionSamplePageContext::STATS_SAMPLE_PAGES() {
  return getToken(MySqlParser::STATS_SAMPLE_PAGES, 0);
}

tree::TerminalNode* MySqlParser::TableOptionSamplePageContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::TableOptionSamplePageContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::TableOptionSamplePageContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionSamplePageContext::TableOptionSamplePageContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionSamplePageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionSamplePage(this);
}
void MySqlParser::TableOptionSamplePageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionSamplePage(this);
}

std::any MySqlParser::TableOptionSamplePageContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionSamplePage(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionCharsetContext ------------------------------------------------------------------

MySqlParser::CharSetContext* MySqlParser::TableOptionCharsetContext::charSet() {
  return getRuleContext<MySqlParser::CharSetContext>(0);
}

MySqlParser::CharsetNameContext* MySqlParser::TableOptionCharsetContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::TableOptionCharsetContext::DEFAULT() {
  return getTokens(MySqlParser::DEFAULT);
}

tree::TerminalNode* MySqlParser::TableOptionCharsetContext::DEFAULT(size_t i) {
  return getToken(MySqlParser::DEFAULT, i);
}

tree::TerminalNode* MySqlParser::TableOptionCharsetContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionCharsetContext::TableOptionCharsetContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionCharsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionCharset(this);
}
void MySqlParser::TableOptionCharsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionCharset(this);
}

std::any MySqlParser::TableOptionCharsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionCharset(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionIndexDirectoryContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionIndexDirectoryContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::TableOptionIndexDirectoryContext::DIRECTORY() {
  return getToken(MySqlParser::DIRECTORY, 0);
}

tree::TerminalNode* MySqlParser::TableOptionIndexDirectoryContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionIndexDirectoryContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionIndexDirectoryContext::TableOptionIndexDirectoryContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionIndexDirectoryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionIndexDirectory(this);
}
void MySqlParser::TableOptionIndexDirectoryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionIndexDirectory(this);
}

std::any MySqlParser::TableOptionIndexDirectoryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionIndexDirectory(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionTableTypeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionTableTypeContext::TABLE_TYPE() {
  return getToken(MySqlParser::TABLE_TYPE, 0);
}

tree::TerminalNode* MySqlParser::TableOptionTableTypeContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableTypeContext* MySqlParser::TableOptionTableTypeContext::tableType() {
  return getRuleContext<MySqlParser::TableTypeContext>(0);
}

MySqlParser::TableOptionTableTypeContext::TableOptionTableTypeContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionTableTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionTableType(this);
}
void MySqlParser::TableOptionTableTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionTableType(this);
}

std::any MySqlParser::TableOptionTableTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionTableType(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionKeyBlockSizeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionKeyBlockSizeContext::KEY_BLOCK_SIZE() {
  return getToken(MySqlParser::KEY_BLOCK_SIZE, 0);
}

MySqlParser::FileSizeLiteralContext* MySqlParser::TableOptionKeyBlockSizeContext::fileSizeLiteral() {
  return getRuleContext<MySqlParser::FileSizeLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::TableOptionKeyBlockSizeContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionKeyBlockSizeContext::TableOptionKeyBlockSizeContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionKeyBlockSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionKeyBlockSize(this);
}
void MySqlParser::TableOptionKeyBlockSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionKeyBlockSize(this);
}

std::any MySqlParser::TableOptionKeyBlockSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionKeyBlockSize(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionEncryptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionEncryptionContext::ENCRYPTION() {
  return getToken(MySqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* MySqlParser::TableOptionEncryptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionEncryptionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionEncryptionContext::TableOptionEncryptionContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionEncryptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionEncryption(this);
}
void MySqlParser::TableOptionEncryptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionEncryption(this);
}

std::any MySqlParser::TableOptionEncryptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionEncryption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionDataDirectoryContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionDataDirectoryContext::DIRECTORY() {
  return getToken(MySqlParser::DIRECTORY, 0);
}

tree::TerminalNode* MySqlParser::TableOptionDataDirectoryContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionDataDirectoryContext::DATA() {
  return getToken(MySqlParser::DATA, 0);
}

tree::TerminalNode* MySqlParser::TableOptionDataDirectoryContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::TableOptionDataDirectoryContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionDataDirectoryContext::TableOptionDataDirectoryContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionDataDirectoryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionDataDirectory(this);
}
void MySqlParser::TableOptionDataDirectoryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionDataDirectory(this);
}

std::any MySqlParser::TableOptionDataDirectoryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionDataDirectory(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionRecalculationContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionRecalculationContext::STATS_AUTO_RECALC() {
  return getToken(MySqlParser::STATS_AUTO_RECALC, 0);
}

tree::TerminalNode* MySqlParser::TableOptionRecalculationContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::TableOptionRecalculationContext::ZERO_DECIMAL() {
  return getToken(MySqlParser::ZERO_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionRecalculationContext::ONE_DECIMAL() {
  return getToken(MySqlParser::ONE_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionRecalculationContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionRecalculationContext::TableOptionRecalculationContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionRecalculationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionRecalculation(this);
}
void MySqlParser::TableOptionRecalculationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionRecalculation(this);
}

std::any MySqlParser::TableOptionRecalculationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionRecalculation(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionAutoIncrementContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionAutoIncrementContext::AUTO_INCREMENT() {
  return getToken(MySqlParser::AUTO_INCREMENT, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::TableOptionAutoIncrementContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::TableOptionAutoIncrementContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionAutoIncrementContext::TableOptionAutoIncrementContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionAutoIncrementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionAutoIncrement(this);
}
void MySqlParser::TableOptionAutoIncrementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionAutoIncrement(this);
}

std::any MySqlParser::TableOptionAutoIncrementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionAutoIncrement(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionEncryptionKeyIdContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionEncryptionKeyIdContext::ENCRYPTION_KEY_ID() {
  return getToken(MySqlParser::ENCRYPTION_KEY_ID, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::TableOptionEncryptionKeyIdContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::TableOptionEncryptionKeyIdContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionEncryptionKeyIdContext::TableOptionEncryptionKeyIdContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionEncryptionKeyIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionEncryptionKeyId(this);
}
void MySqlParser::TableOptionEncryptionKeyIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionEncryptionKeyId(this);
}

std::any MySqlParser::TableOptionEncryptionKeyIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionEncryptionKeyId(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionChecksumContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionChecksumContext::CHECKSUM() {
  return getToken(MySqlParser::CHECKSUM, 0);
}

tree::TerminalNode* MySqlParser::TableOptionChecksumContext::PAGE_CHECKSUM() {
  return getToken(MySqlParser::PAGE_CHECKSUM, 0);
}

tree::TerminalNode* MySqlParser::TableOptionChecksumContext::ZERO_DECIMAL() {
  return getToken(MySqlParser::ZERO_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionChecksumContext::ONE_DECIMAL() {
  return getToken(MySqlParser::ONE_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionChecksumContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionChecksumContext::TableOptionChecksumContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionChecksumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionChecksum(this);
}
void MySqlParser::TableOptionChecksumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionChecksum(this);
}

std::any MySqlParser::TableOptionChecksumContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionChecksum(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionDelayContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionDelayContext::DELAY_KEY_WRITE() {
  return getToken(MySqlParser::DELAY_KEY_WRITE, 0);
}

tree::TerminalNode* MySqlParser::TableOptionDelayContext::ZERO_DECIMAL() {
  return getToken(MySqlParser::ZERO_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionDelayContext::ONE_DECIMAL() {
  return getToken(MySqlParser::ONE_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionDelayContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionDelayContext::TableOptionDelayContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionDelayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionDelay(this);
}
void MySqlParser::TableOptionDelayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionDelay(this);
}

std::any MySqlParser::TableOptionDelayContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionDelay(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionConnectionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionConnectionContext::CONNECTION() {
  return getToken(MySqlParser::CONNECTION, 0);
}

tree::TerminalNode* MySqlParser::TableOptionConnectionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionConnectionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionConnectionContext::TableOptionConnectionContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionConnectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionConnection(this);
}
void MySqlParser::TableOptionConnectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionConnection(this);
}

std::any MySqlParser::TableOptionConnectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionConnection(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionTransactionalContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionTransactionalContext::TRANSACTIONAL() {
  return getToken(MySqlParser::TRANSACTIONAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionTransactionalContext::ZERO_DECIMAL() {
  return getToken(MySqlParser::ZERO_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionTransactionalContext::ONE_DECIMAL() {
  return getToken(MySqlParser::ONE_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionTransactionalContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionTransactionalContext::TableOptionTransactionalContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionTransactionalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionTransactional(this);
}
void MySqlParser::TableOptionTransactionalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionTransactional(this);
}

std::any MySqlParser::TableOptionTransactionalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionTransactional(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionPageCompressionLevelContext ------------------------------------------------------------------

MySqlParser::DecimalLiteralContext* MySqlParser::TableOptionPageCompressionLevelContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::TableOptionPageCompressionLevelContext::PAGE_COMPRESSION_LEVEL() {
  return getToken(MySqlParser::PAGE_COMPRESSION_LEVEL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPageCompressionLevelContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionPageCompressionLevelContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionPageCompressionLevelContext::TableOptionPageCompressionLevelContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionPageCompressionLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionPageCompressionLevel(this);
}
void MySqlParser::TableOptionPageCompressionLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionPageCompressionLevel(this);
}

std::any MySqlParser::TableOptionPageCompressionLevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionPageCompressionLevel(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionSecondaryEngineAttributeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionSecondaryEngineAttributeContext::SECONDARY_ENGINE_ATTRIBUTE() {
  return getToken(MySqlParser::SECONDARY_ENGINE_ATTRIBUTE, 0);
}

tree::TerminalNode* MySqlParser::TableOptionSecondaryEngineAttributeContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionSecondaryEngineAttributeContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionSecondaryEngineAttributeContext::TableOptionSecondaryEngineAttributeContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionSecondaryEngineAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionSecondaryEngineAttribute(this);
}
void MySqlParser::TableOptionSecondaryEngineAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionSecondaryEngineAttribute(this);
}

std::any MySqlParser::TableOptionSecondaryEngineAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionSecondaryEngineAttribute(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionCommentContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionCommentContext::COMMENT() {
  return getToken(MySqlParser::COMMENT, 0);
}

tree::TerminalNode* MySqlParser::TableOptionCommentContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionCommentContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionCommentContext::TableOptionCommentContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionCommentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionComment(this);
}
void MySqlParser::TableOptionCommentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionComment(this);
}

std::any MySqlParser::TableOptionCommentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionComment(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionAverageContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionAverageContext::AVG_ROW_LENGTH() {
  return getToken(MySqlParser::AVG_ROW_LENGTH, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::TableOptionAverageContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::TableOptionAverageContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionAverageContext::TableOptionAverageContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionAverageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionAverage(this);
}
void MySqlParser::TableOptionAverageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionAverage(this);
}

std::any MySqlParser::TableOptionAverageContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionAverage(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionRowFormatContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionRowFormatContext::ROW_FORMAT() {
  return getToken(MySqlParser::ROW_FORMAT, 0);
}

tree::TerminalNode* MySqlParser::TableOptionRowFormatContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::TableOptionRowFormatContext::DYNAMIC() {
  return getToken(MySqlParser::DYNAMIC, 0);
}

tree::TerminalNode* MySqlParser::TableOptionRowFormatContext::FIXED() {
  return getToken(MySqlParser::FIXED, 0);
}

tree::TerminalNode* MySqlParser::TableOptionRowFormatContext::COMPRESSED() {
  return getToken(MySqlParser::COMPRESSED, 0);
}

tree::TerminalNode* MySqlParser::TableOptionRowFormatContext::REDUNDANT() {
  return getToken(MySqlParser::REDUNDANT, 0);
}

tree::TerminalNode* MySqlParser::TableOptionRowFormatContext::COMPACT() {
  return getToken(MySqlParser::COMPACT, 0);
}

tree::TerminalNode* MySqlParser::TableOptionRowFormatContext::ID() {
  return getToken(MySqlParser::ID, 0);
}

tree::TerminalNode* MySqlParser::TableOptionRowFormatContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionRowFormatContext::TableOptionRowFormatContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionRowFormatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionRowFormat(this);
}
void MySqlParser::TableOptionRowFormatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionRowFormat(this);
}

std::any MySqlParser::TableOptionRowFormatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionRowFormat(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionCompressionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionCompressionContext::COMPRESSION() {
  return getToken(MySqlParser::COMPRESSION, 0);
}

tree::TerminalNode* MySqlParser::TableOptionCompressionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionCompressionContext::ID() {
  return getToken(MySqlParser::ID, 0);
}

tree::TerminalNode* MySqlParser::TableOptionCompressionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionCompressionContext::TableOptionCompressionContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionCompressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionCompression(this);
}
void MySqlParser::TableOptionCompressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionCompression(this);
}

std::any MySqlParser::TableOptionCompressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionCompression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionInsertMethodContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionInsertMethodContext::INSERT_METHOD() {
  return getToken(MySqlParser::INSERT_METHOD, 0);
}

tree::TerminalNode* MySqlParser::TableOptionInsertMethodContext::NO() {
  return getToken(MySqlParser::NO, 0);
}

tree::TerminalNode* MySqlParser::TableOptionInsertMethodContext::FIRST() {
  return getToken(MySqlParser::FIRST, 0);
}

tree::TerminalNode* MySqlParser::TableOptionInsertMethodContext::LAST() {
  return getToken(MySqlParser::LAST, 0);
}

tree::TerminalNode* MySqlParser::TableOptionInsertMethodContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionInsertMethodContext::TableOptionInsertMethodContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionInsertMethodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionInsertMethod(this);
}
void MySqlParser::TableOptionInsertMethodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionInsertMethod(this);
}

std::any MySqlParser::TableOptionInsertMethodContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionInsertMethod(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionEngineAttributeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionEngineAttributeContext::ENGINE_ATTRIBUTE() {
  return getToken(MySqlParser::ENGINE_ATTRIBUTE, 0);
}

tree::TerminalNode* MySqlParser::TableOptionEngineAttributeContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::TableOptionEngineAttributeContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionEngineAttributeContext::TableOptionEngineAttributeContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionEngineAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionEngineAttribute(this);
}
void MySqlParser::TableOptionEngineAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionEngineAttribute(this);
}

std::any MySqlParser::TableOptionEngineAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionEngineAttribute(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOptionMinRowsContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableOptionMinRowsContext::MIN_ROWS() {
  return getToken(MySqlParser::MIN_ROWS, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::TableOptionMinRowsContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::TableOptionMinRowsContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::TableOptionMinRowsContext::TableOptionMinRowsContext(TableOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableOptionMinRowsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOptionMinRows(this);
}
void MySqlParser::TableOptionMinRowsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOptionMinRows(this);
}

std::any MySqlParser::TableOptionMinRowsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableOptionMinRows(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::TableOptionContext* MySqlParser::tableOption() {
  TableOptionContext *_localctx = _tracker.createInstance<TableOptionContext>(_ctx, getState());
  enterRule(_localctx, 104, MySqlParser::RuleTableOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1990);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionEngineContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1805);
      match(MySqlParser::ENGINE);
      setState(1807);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1806);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1810);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx)) {
      case 1: {
        setState(1809);
        engineName();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionEngineAttributeContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1812);
      match(MySqlParser::ENGINE_ATTRIBUTE);
      setState(1814);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1813);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1816);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionAutoextendSizeContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1817);
      match(MySqlParser::AUTOEXTEND_SIZE);
      setState(1819);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1818);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1821);
      decimalLiteral();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionAutoIncrementContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(1822);
      match(MySqlParser::AUTO_INCREMENT);
      setState(1824);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1823);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1826);
      decimalLiteral();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionAverageContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(1827);
      match(MySqlParser::AVG_ROW_LENGTH);
      setState(1829);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1828);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1831);
      decimalLiteral();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionCharsetContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(1833);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::DEFAULT) {
        setState(1832);
        match(MySqlParser::DEFAULT);
      }
      setState(1835);
      charSet();
      setState(1837);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1836);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1841);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::BINARY:
        case MySqlParser::ARMSCII8:
        case MySqlParser::ASCII:
        case MySqlParser::BIG5:
        case MySqlParser::CP1250:
        case MySqlParser::CP1251:
        case MySqlParser::CP1256:
        case MySqlParser::CP1257:
        case MySqlParser::CP850:
        case MySqlParser::CP852:
        case MySqlParser::CP866:
        case MySqlParser::CP932:
        case MySqlParser::DEC8:
        case MySqlParser::EUCJPMS:
        case MySqlParser::EUCKR:
        case MySqlParser::GB18030:
        case MySqlParser::GB2312:
        case MySqlParser::GBK:
        case MySqlParser::GEOSTD8:
        case MySqlParser::GREEK:
        case MySqlParser::HEBREW:
        case MySqlParser::HP8:
        case MySqlParser::KEYBCS2:
        case MySqlParser::KOI8R:
        case MySqlParser::KOI8U:
        case MySqlParser::LATIN1:
        case MySqlParser::LATIN2:
        case MySqlParser::LATIN5:
        case MySqlParser::LATIN7:
        case MySqlParser::MACCE:
        case MySqlParser::MACROMAN:
        case MySqlParser::SJIS:
        case MySqlParser::SWE7:
        case MySqlParser::TIS620:
        case MySqlParser::UCS2:
        case MySqlParser::UJIS:
        case MySqlParser::UTF16:
        case MySqlParser::UTF16LE:
        case MySqlParser::UTF32:
        case MySqlParser::UTF8:
        case MySqlParser::UTF8MB3:
        case MySqlParser::UTF8MB4:
        case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
        case MySqlParser::STRING_LITERAL: {
          setState(1839);
          charsetName();
          break;
        }

        case MySqlParser::DEFAULT: {
          setState(1840);
          match(MySqlParser::DEFAULT);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionChecksumContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(1843);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::CHECKSUM

      || _la == MySqlParser::PAGE_CHECKSUM)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1845);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1844);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1847);
      antlrcpp::downCast<TableOptionChecksumContext *>(_localctx)->boolValue = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::ZERO_DECIMAL

      || _la == MySqlParser::ONE_DECIMAL)) {
        antlrcpp::downCast<TableOptionChecksumContext *>(_localctx)->boolValue = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionCollateContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(1849);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::DEFAULT) {
        setState(1848);
        match(MySqlParser::DEFAULT);
      }
      setState(1851);
      match(MySqlParser::COLLATE);
      setState(1853);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1852);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1855);
      collationName();
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionCommentContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(1856);
      match(MySqlParser::COMMENT);
      setState(1858);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1857);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1860);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionCompressionContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(1861);
      match(MySqlParser::COMPRESSION);
      setState(1863);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1862);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1865);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::STRING_LITERAL

      || _la == MySqlParser::ID)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionConnectionContext>(_localctx);
      enterOuterAlt(_localctx, 11);
      setState(1866);
      match(MySqlParser::CONNECTION);
      setState(1868);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1867);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1870);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionDataDirectoryContext>(_localctx);
      enterOuterAlt(_localctx, 12);
      setState(1871);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::INDEX || _la == MySqlParser::DATA)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1872);
      match(MySqlParser::DIRECTORY);
      setState(1874);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1873);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1876);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionDelayContext>(_localctx);
      enterOuterAlt(_localctx, 13);
      setState(1877);
      match(MySqlParser::DELAY_KEY_WRITE);
      setState(1879);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1878);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1881);
      antlrcpp::downCast<TableOptionDelayContext *>(_localctx)->boolValue = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::ZERO_DECIMAL

      || _la == MySqlParser::ONE_DECIMAL)) {
        antlrcpp::downCast<TableOptionDelayContext *>(_localctx)->boolValue = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionEncryptionContext>(_localctx);
      enterOuterAlt(_localctx, 14);
      setState(1882);
      match(MySqlParser::ENCRYPTION);
      setState(1884);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1883);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1886);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    case 15: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionPageCompressedContext>(_localctx);
      enterOuterAlt(_localctx, 15);
      setState(1887);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::PAGE_COMPRESSED || _la == MySqlParser::STRING_LITERAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1889);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1888);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1891);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::ZERO_DECIMAL

      || _la == MySqlParser::ONE_DECIMAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 16: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionPageCompressionLevelContext>(_localctx);
      enterOuterAlt(_localctx, 16);
      setState(1892);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::PAGE_COMPRESSION_LEVEL || _la == MySqlParser::STRING_LITERAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1894);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1893);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1896);
      decimalLiteral();
      break;
    }

    case 17: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionEncryptionKeyIdContext>(_localctx);
      enterOuterAlt(_localctx, 17);
      setState(1897);
      match(MySqlParser::ENCRYPTION_KEY_ID);
      setState(1899);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1898);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1901);
      decimalLiteral();
      break;
    }

    case 18: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionIndexDirectoryContext>(_localctx);
      enterOuterAlt(_localctx, 18);
      setState(1902);
      match(MySqlParser::INDEX);
      setState(1903);
      match(MySqlParser::DIRECTORY);
      setState(1905);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1904);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1907);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    case 19: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionInsertMethodContext>(_localctx);
      enterOuterAlt(_localctx, 19);
      setState(1908);
      match(MySqlParser::INSERT_METHOD);
      setState(1910);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1909);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1912);
      antlrcpp::downCast<TableOptionInsertMethodContext *>(_localctx)->insertMethod = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::FIRST

      || _la == MySqlParser::LAST || _la == MySqlParser::NO)) {
        antlrcpp::downCast<TableOptionInsertMethodContext *>(_localctx)->insertMethod = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 20: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionKeyBlockSizeContext>(_localctx);
      enterOuterAlt(_localctx, 20);
      setState(1913);
      match(MySqlParser::KEY_BLOCK_SIZE);
      setState(1915);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1914);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1917);
      fileSizeLiteral();
      break;
    }

    case 21: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionMaxRowsContext>(_localctx);
      enterOuterAlt(_localctx, 21);
      setState(1918);
      match(MySqlParser::MAX_ROWS);
      setState(1920);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1919);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1922);
      decimalLiteral();
      break;
    }

    case 22: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionMinRowsContext>(_localctx);
      enterOuterAlt(_localctx, 22);
      setState(1923);
      match(MySqlParser::MIN_ROWS);
      setState(1925);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1924);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1927);
      decimalLiteral();
      break;
    }

    case 23: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionPackKeysContext>(_localctx);
      enterOuterAlt(_localctx, 23);
      setState(1928);
      match(MySqlParser::PACK_KEYS);
      setState(1930);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1929);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1932);
      antlrcpp::downCast<TableOptionPackKeysContext *>(_localctx)->extBoolValue = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::ZERO_DECIMAL

      || _la == MySqlParser::ONE_DECIMAL)) {
        antlrcpp::downCast<TableOptionPackKeysContext *>(_localctx)->extBoolValue = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 24: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionPasswordContext>(_localctx);
      enterOuterAlt(_localctx, 24);
      setState(1933);
      match(MySqlParser::PASSWORD);
      setState(1935);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1934);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1937);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    case 25: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionRowFormatContext>(_localctx);
      enterOuterAlt(_localctx, 25);
      setState(1938);
      match(MySqlParser::ROW_FORMAT);
      setState(1940);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1939);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1942);
      antlrcpp::downCast<TableOptionRowFormatContext *>(_localctx)->rowFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DEFAULT || ((((_la - 370) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 370)) & 2305843013508661253) != 0) || _la == MySqlParser::REDUNDANT || _la == MySqlParser::ID)) {
        antlrcpp::downCast<TableOptionRowFormatContext *>(_localctx)->rowFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 26: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionStartTransactionContext>(_localctx);
      enterOuterAlt(_localctx, 26);
      setState(1943);
      match(MySqlParser::START);
      setState(1944);
      match(MySqlParser::TRANSACTION);
      break;
    }

    case 27: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionSecondaryEngineAttributeContext>(_localctx);
      enterOuterAlt(_localctx, 27);
      setState(1945);
      match(MySqlParser::SECONDARY_ENGINE_ATTRIBUTE);
      setState(1947);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1946);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1949);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    case 28: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionRecalculationContext>(_localctx);
      enterOuterAlt(_localctx, 28);
      setState(1950);
      match(MySqlParser::STATS_AUTO_RECALC);
      setState(1952);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1951);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1954);
      antlrcpp::downCast<TableOptionRecalculationContext *>(_localctx)->extBoolValue = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::ZERO_DECIMAL

      || _la == MySqlParser::ONE_DECIMAL)) {
        antlrcpp::downCast<TableOptionRecalculationContext *>(_localctx)->extBoolValue = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 29: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionPersistentContext>(_localctx);
      enterOuterAlt(_localctx, 29);
      setState(1955);
      match(MySqlParser::STATS_PERSISTENT);
      setState(1957);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1956);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1959);
      antlrcpp::downCast<TableOptionPersistentContext *>(_localctx)->extBoolValue = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::ZERO_DECIMAL

      || _la == MySqlParser::ONE_DECIMAL)) {
        antlrcpp::downCast<TableOptionPersistentContext *>(_localctx)->extBoolValue = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 30: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionSamplePageContext>(_localctx);
      enterOuterAlt(_localctx, 30);
      setState(1960);
      match(MySqlParser::STATS_SAMPLE_PAGES);
      setState(1962);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1961);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1966);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::DEFAULT: {
          setState(1964);
          match(MySqlParser::DEFAULT);
          break;
        }

        case MySqlParser::ZERO_DECIMAL:
        case MySqlParser::ONE_DECIMAL:
        case MySqlParser::TWO_DECIMAL:
        case MySqlParser::DECIMAL_LITERAL:
        case MySqlParser::REAL_LITERAL: {
          setState(1965);
          decimalLiteral();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 31: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionTablespaceContext>(_localctx);
      enterOuterAlt(_localctx, 31);
      setState(1968);
      match(MySqlParser::TABLESPACE);
      setState(1969);
      uid();
      setState(1971);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, _ctx)) {
      case 1: {
        setState(1970);
        tablespaceStorage();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 32: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionTableTypeContext>(_localctx);
      enterOuterAlt(_localctx, 32);
      setState(1973);
      match(MySqlParser::TABLE_TYPE);
      setState(1974);
      match(MySqlParser::EQUAL_SYMBOL);
      setState(1975);
      tableType();
      break;
    }

    case 33: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionTablespaceContext>(_localctx);
      enterOuterAlt(_localctx, 33);
      setState(1976);
      tablespaceStorage();
      break;
    }

    case 34: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionTransactionalContext>(_localctx);
      enterOuterAlt(_localctx, 34);
      setState(1977);
      match(MySqlParser::TRANSACTIONAL);
      setState(1979);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1978);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1981);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::ZERO_DECIMAL

      || _la == MySqlParser::ONE_DECIMAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 35: {
      _localctx = _tracker.createInstance<MySqlParser::TableOptionUnionContext>(_localctx);
      enterOuterAlt(_localctx, 35);
      setState(1982);
      match(MySqlParser::UNION);
      setState(1984);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(1983);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(1986);
      match(MySqlParser::LR_BRACKET);
      setState(1987);
      tables();
      setState(1988);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableTypeContext ------------------------------------------------------------------

MySqlParser::TableTypeContext::TableTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::TableTypeContext::MYSQL() {
  return getToken(MySqlParser::MYSQL, 0);
}

tree::TerminalNode* MySqlParser::TableTypeContext::ODBC() {
  return getToken(MySqlParser::ODBC, 0);
}


size_t MySqlParser::TableTypeContext::getRuleIndex() const {
  return MySqlParser::RuleTableType;
}

void MySqlParser::TableTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableType(this);
}

void MySqlParser::TableTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableType(this);
}


std::any MySqlParser::TableTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableType(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TableTypeContext* MySqlParser::tableType() {
  TableTypeContext *_localctx = _tracker.createInstance<TableTypeContext>(_ctx, getState());
  enterRule(_localctx, 106, MySqlParser::RuleTableType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1992);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::MYSQL

    || _la == MySqlParser::ODBC)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablespaceStorageContext ------------------------------------------------------------------

MySqlParser::TablespaceStorageContext::TablespaceStorageContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::TablespaceStorageContext::STORAGE() {
  return getToken(MySqlParser::STORAGE, 0);
}

tree::TerminalNode* MySqlParser::TablespaceStorageContext::DISK() {
  return getToken(MySqlParser::DISK, 0);
}

tree::TerminalNode* MySqlParser::TablespaceStorageContext::MEMORY() {
  return getToken(MySqlParser::MEMORY, 0);
}

tree::TerminalNode* MySqlParser::TablespaceStorageContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}


size_t MySqlParser::TablespaceStorageContext::getRuleIndex() const {
  return MySqlParser::RuleTablespaceStorage;
}

void MySqlParser::TablespaceStorageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablespaceStorage(this);
}

void MySqlParser::TablespaceStorageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablespaceStorage(this);
}


std::any MySqlParser::TablespaceStorageContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTablespaceStorage(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TablespaceStorageContext* MySqlParser::tablespaceStorage() {
  TablespaceStorageContext *_localctx = _tracker.createInstance<TablespaceStorageContext>(_ctx, getState());
  enterRule(_localctx, 108, MySqlParser::RuleTablespaceStorage);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1994);
    match(MySqlParser::STORAGE);
    setState(1995);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::DISK || _la == MySqlParser::MEMORY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDefinitionsContext ------------------------------------------------------------------

MySqlParser::PartitionDefinitionsContext::PartitionDefinitionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::PartitionDefinitionsContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionDefinitionsContext::BY() {
  return getTokens(MySqlParser::BY);
}

tree::TerminalNode* MySqlParser::PartitionDefinitionsContext::BY(size_t i) {
  return getToken(MySqlParser::BY, i);
}

MySqlParser::PartitionFunctionDefinitionContext* MySqlParser::PartitionDefinitionsContext::partitionFunctionDefinition() {
  return getRuleContext<MySqlParser::PartitionFunctionDefinitionContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionDefinitionsContext::PARTITIONS() {
  return getToken(MySqlParser::PARTITIONS, 0);
}

tree::TerminalNode* MySqlParser::PartitionDefinitionsContext::SUBPARTITION() {
  return getToken(MySqlParser::SUBPARTITION, 0);
}

MySqlParser::SubpartitionFunctionDefinitionContext* MySqlParser::PartitionDefinitionsContext::subpartitionFunctionDefinition() {
  return getRuleContext<MySqlParser::SubpartitionFunctionDefinitionContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionDefinitionsContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::PartitionDefinitionContext *> MySqlParser::PartitionDefinitionsContext::partitionDefinition() {
  return getRuleContexts<MySqlParser::PartitionDefinitionContext>();
}

MySqlParser::PartitionDefinitionContext* MySqlParser::PartitionDefinitionsContext::partitionDefinition(size_t i) {
  return getRuleContext<MySqlParser::PartitionDefinitionContext>(i);
}

tree::TerminalNode* MySqlParser::PartitionDefinitionsContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<MySqlParser::DecimalLiteralContext *> MySqlParser::PartitionDefinitionsContext::decimalLiteral() {
  return getRuleContexts<MySqlParser::DecimalLiteralContext>();
}

MySqlParser::DecimalLiteralContext* MySqlParser::PartitionDefinitionsContext::decimalLiteral(size_t i) {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(i);
}

tree::TerminalNode* MySqlParser::PartitionDefinitionsContext::SUBPARTITIONS() {
  return getToken(MySqlParser::SUBPARTITIONS, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionDefinitionsContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::PartitionDefinitionsContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::PartitionDefinitionsContext::getRuleIndex() const {
  return MySqlParser::RulePartitionDefinitions;
}

void MySqlParser::PartitionDefinitionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefinitions(this);
}

void MySqlParser::PartitionDefinitionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefinitions(this);
}


std::any MySqlParser::PartitionDefinitionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionDefinitions(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::PartitionDefinitionsContext* MySqlParser::partitionDefinitions() {
  PartitionDefinitionsContext *_localctx = _tracker.createInstance<PartitionDefinitionsContext>(_ctx, getState());
  enterRule(_localctx, 110, MySqlParser::RulePartitionDefinitions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1997);
    match(MySqlParser::PARTITION);
    setState(1998);
    match(MySqlParser::BY);
    setState(1999);
    partitionFunctionDefinition();
    setState(2002);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::PARTITIONS) {
      setState(2000);
      match(MySqlParser::PARTITIONS);
      setState(2001);
      antlrcpp::downCast<PartitionDefinitionsContext *>(_localctx)->count = decimalLiteral();
    }
    setState(2011);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::SUBPARTITION) {
      setState(2004);
      match(MySqlParser::SUBPARTITION);
      setState(2005);
      match(MySqlParser::BY);
      setState(2006);
      subpartitionFunctionDefinition();
      setState(2009);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::SUBPARTITIONS) {
        setState(2007);
        match(MySqlParser::SUBPARTITIONS);
        setState(2008);
        antlrcpp::downCast<PartitionDefinitionsContext *>(_localctx)->subCount = decimalLiteral();
      }
    }
    setState(2024);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
    case 1: {
      setState(2013);
      match(MySqlParser::LR_BRACKET);
      setState(2014);
      partitionDefinition();
      setState(2019);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(2015);
        match(MySqlParser::COMMA);
        setState(2016);
        partitionDefinition();
        setState(2021);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2022);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionFunctionDefinitionContext ------------------------------------------------------------------

MySqlParser::PartitionFunctionDefinitionContext::PartitionFunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::PartitionFunctionDefinitionContext::getRuleIndex() const {
  return MySqlParser::RulePartitionFunctionDefinition;
}

void MySqlParser::PartitionFunctionDefinitionContext::copyFrom(PartitionFunctionDefinitionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PartitionFunctionKeyContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionFunctionKeyContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionKeyContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionKeyContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionKeyContext::LINEAR() {
  return getToken(MySqlParser::LINEAR, 0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionKeyContext::ALGORITHM() {
  return getToken(MySqlParser::ALGORITHM, 0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionKeyContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::UidListContext* MySqlParser::PartitionFunctionKeyContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionKeyContext::ONE_DECIMAL() {
  return getToken(MySqlParser::ONE_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionKeyContext::TWO_DECIMAL() {
  return getToken(MySqlParser::TWO_DECIMAL, 0);
}

MySqlParser::PartitionFunctionKeyContext::PartitionFunctionKeyContext(PartitionFunctionDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionFunctionKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionFunctionKey(this);
}
void MySqlParser::PartitionFunctionKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionFunctionKey(this);
}

std::any MySqlParser::PartitionFunctionKeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionFunctionKey(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionFunctionHashContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionFunctionHashContext::HASH() {
  return getToken(MySqlParser::HASH, 0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionHashContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ExpressionContext* MySqlParser::PartitionFunctionHashContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionHashContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionHashContext::LINEAR() {
  return getToken(MySqlParser::LINEAR, 0);
}

MySqlParser::PartitionFunctionHashContext::PartitionFunctionHashContext(PartitionFunctionDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionFunctionHashContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionFunctionHash(this);
}
void MySqlParser::PartitionFunctionHashContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionFunctionHash(this);
}

std::any MySqlParser::PartitionFunctionHashContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionFunctionHash(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionFunctionListContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionFunctionListContext::LIST() {
  return getToken(MySqlParser::LIST, 0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionListContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ExpressionContext* MySqlParser::PartitionFunctionListContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionListContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionListContext::COLUMNS() {
  return getToken(MySqlParser::COLUMNS, 0);
}

MySqlParser::UidListContext* MySqlParser::PartitionFunctionListContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

MySqlParser::PartitionFunctionListContext::PartitionFunctionListContext(PartitionFunctionDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionFunctionListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionFunctionList(this);
}
void MySqlParser::PartitionFunctionListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionFunctionList(this);
}

std::any MySqlParser::PartitionFunctionListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionFunctionList(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionFunctionRangeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionFunctionRangeContext::RANGE() {
  return getToken(MySqlParser::RANGE, 0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionRangeContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ExpressionContext* MySqlParser::PartitionFunctionRangeContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionRangeContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::PartitionFunctionRangeContext::COLUMNS() {
  return getToken(MySqlParser::COLUMNS, 0);
}

MySqlParser::UidListContext* MySqlParser::PartitionFunctionRangeContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

MySqlParser::PartitionFunctionRangeContext::PartitionFunctionRangeContext(PartitionFunctionDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionFunctionRangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionFunctionRange(this);
}
void MySqlParser::PartitionFunctionRangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionFunctionRange(this);
}

std::any MySqlParser::PartitionFunctionRangeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionFunctionRange(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::PartitionFunctionDefinitionContext* MySqlParser::partitionFunctionDefinition() {
  PartitionFunctionDefinitionContext *_localctx = _tracker.createInstance<PartitionFunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 112, MySqlParser::RulePartitionFunctionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2072);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::PartitionFunctionHashContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(2027);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LINEAR) {
        setState(2026);
        match(MySqlParser::LINEAR);
      }
      setState(2029);
      match(MySqlParser::HASH);
      setState(2030);
      match(MySqlParser::LR_BRACKET);
      setState(2031);
      expression(0);
      setState(2032);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::PartitionFunctionKeyContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(2035);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LINEAR) {
        setState(2034);
        match(MySqlParser::LINEAR);
      }
      setState(2037);
      match(MySqlParser::KEY);
      setState(2041);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::ALGORITHM) {
        setState(2038);
        match(MySqlParser::ALGORITHM);
        setState(2039);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(2040);
        antlrcpp::downCast<PartitionFunctionKeyContext *>(_localctx)->algType = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::ONE_DECIMAL

        || _la == MySqlParser::TWO_DECIMAL)) {
          antlrcpp::downCast<PartitionFunctionKeyContext *>(_localctx)->algType = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(2043);
      match(MySqlParser::LR_BRACKET);
      setState(2045);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
        setState(2044);
        uidList();
      }
      setState(2047);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::PartitionFunctionRangeContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(2048);
      match(MySqlParser::RANGE);
      setState(2058);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::LR_BRACKET: {
          setState(2049);
          match(MySqlParser::LR_BRACKET);
          setState(2050);
          expression(0);
          setState(2051);
          match(MySqlParser::RR_BRACKET);
          break;
        }

        case MySqlParser::COLUMNS: {
          setState(2053);
          match(MySqlParser::COLUMNS);
          setState(2054);
          match(MySqlParser::LR_BRACKET);
          setState(2055);
          uidList();
          setState(2056);
          match(MySqlParser::RR_BRACKET);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::PartitionFunctionListContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(2060);
      match(MySqlParser::LIST);
      setState(2070);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::LR_BRACKET: {
          setState(2061);
          match(MySqlParser::LR_BRACKET);
          setState(2062);
          expression(0);
          setState(2063);
          match(MySqlParser::RR_BRACKET);
          break;
        }

        case MySqlParser::COLUMNS: {
          setState(2065);
          match(MySqlParser::COLUMNS);
          setState(2066);
          match(MySqlParser::LR_BRACKET);
          setState(2067);
          uidList();
          setState(2068);
          match(MySqlParser::RR_BRACKET);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubpartitionFunctionDefinitionContext ------------------------------------------------------------------

MySqlParser::SubpartitionFunctionDefinitionContext::SubpartitionFunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::SubpartitionFunctionDefinitionContext::getRuleIndex() const {
  return MySqlParser::RuleSubpartitionFunctionDefinition;
}

void MySqlParser::SubpartitionFunctionDefinitionContext::copyFrom(SubpartitionFunctionDefinitionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SubPartitionFunctionHashContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SubPartitionFunctionHashContext::HASH() {
  return getToken(MySqlParser::HASH, 0);
}

tree::TerminalNode* MySqlParser::SubPartitionFunctionHashContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ExpressionContext* MySqlParser::SubPartitionFunctionHashContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::SubPartitionFunctionHashContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::SubPartitionFunctionHashContext::LINEAR() {
  return getToken(MySqlParser::LINEAR, 0);
}

MySqlParser::SubPartitionFunctionHashContext::SubPartitionFunctionHashContext(SubpartitionFunctionDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::SubPartitionFunctionHashContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubPartitionFunctionHash(this);
}
void MySqlParser::SubPartitionFunctionHashContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubPartitionFunctionHash(this);
}

std::any MySqlParser::SubPartitionFunctionHashContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSubPartitionFunctionHash(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SubPartitionFunctionKeyContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SubPartitionFunctionKeyContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

tree::TerminalNode* MySqlParser::SubPartitionFunctionKeyContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::UidListContext* MySqlParser::SubPartitionFunctionKeyContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::SubPartitionFunctionKeyContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::SubPartitionFunctionKeyContext::LINEAR() {
  return getToken(MySqlParser::LINEAR, 0);
}

tree::TerminalNode* MySqlParser::SubPartitionFunctionKeyContext::ALGORITHM() {
  return getToken(MySqlParser::ALGORITHM, 0);
}

tree::TerminalNode* MySqlParser::SubPartitionFunctionKeyContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::SubPartitionFunctionKeyContext::ONE_DECIMAL() {
  return getToken(MySqlParser::ONE_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::SubPartitionFunctionKeyContext::TWO_DECIMAL() {
  return getToken(MySqlParser::TWO_DECIMAL, 0);
}

MySqlParser::SubPartitionFunctionKeyContext::SubPartitionFunctionKeyContext(SubpartitionFunctionDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::SubPartitionFunctionKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubPartitionFunctionKey(this);
}
void MySqlParser::SubPartitionFunctionKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubPartitionFunctionKey(this);
}

std::any MySqlParser::SubPartitionFunctionKeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSubPartitionFunctionKey(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::SubpartitionFunctionDefinitionContext* MySqlParser::subpartitionFunctionDefinition() {
  SubpartitionFunctionDefinitionContext *_localctx = _tracker.createInstance<SubpartitionFunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 114, MySqlParser::RuleSubpartitionFunctionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2095);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::SubPartitionFunctionHashContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(2075);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LINEAR) {
        setState(2074);
        match(MySqlParser::LINEAR);
      }
      setState(2077);
      match(MySqlParser::HASH);
      setState(2078);
      match(MySqlParser::LR_BRACKET);
      setState(2079);
      expression(0);
      setState(2080);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::SubPartitionFunctionKeyContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(2083);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LINEAR) {
        setState(2082);
        match(MySqlParser::LINEAR);
      }
      setState(2085);
      match(MySqlParser::KEY);
      setState(2089);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::ALGORITHM) {
        setState(2086);
        match(MySqlParser::ALGORITHM);
        setState(2087);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(2088);
        antlrcpp::downCast<SubPartitionFunctionKeyContext *>(_localctx)->algType = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::ONE_DECIMAL

        || _la == MySqlParser::TWO_DECIMAL)) {
          antlrcpp::downCast<SubPartitionFunctionKeyContext *>(_localctx)->algType = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(2091);
      match(MySqlParser::LR_BRACKET);
      setState(2092);
      uidList();
      setState(2093);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDefinitionContext ------------------------------------------------------------------

MySqlParser::PartitionDefinitionContext::PartitionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::PartitionDefinitionContext::getRuleIndex() const {
  return MySqlParser::RulePartitionDefinition;
}

void MySqlParser::PartitionDefinitionContext::copyFrom(PartitionDefinitionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PartitionComparisonContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionComparisonContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::UidContext* MySqlParser::PartitionComparisonContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionComparisonContext::VALUES() {
  return getToken(MySqlParser::VALUES, 0);
}

tree::TerminalNode* MySqlParser::PartitionComparisonContext::LESS() {
  return getToken(MySqlParser::LESS, 0);
}

tree::TerminalNode* MySqlParser::PartitionComparisonContext::THAN() {
  return getToken(MySqlParser::THAN, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionComparisonContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::PartitionComparisonContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

std::vector<MySqlParser::PartitionDefinerAtomContext *> MySqlParser::PartitionComparisonContext::partitionDefinerAtom() {
  return getRuleContexts<MySqlParser::PartitionDefinerAtomContext>();
}

MySqlParser::PartitionDefinerAtomContext* MySqlParser::PartitionComparisonContext::partitionDefinerAtom(size_t i) {
  return getRuleContext<MySqlParser::PartitionDefinerAtomContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionComparisonContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::PartitionComparisonContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionComparisonContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::PartitionComparisonContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

std::vector<MySqlParser::PartitionOptionContext *> MySqlParser::PartitionComparisonContext::partitionOption() {
  return getRuleContexts<MySqlParser::PartitionOptionContext>();
}

MySqlParser::PartitionOptionContext* MySqlParser::PartitionComparisonContext::partitionOption(size_t i) {
  return getRuleContext<MySqlParser::PartitionOptionContext>(i);
}

std::vector<MySqlParser::SubpartitionDefinitionContext *> MySqlParser::PartitionComparisonContext::subpartitionDefinition() {
  return getRuleContexts<MySqlParser::SubpartitionDefinitionContext>();
}

MySqlParser::SubpartitionDefinitionContext* MySqlParser::PartitionComparisonContext::subpartitionDefinition(size_t i) {
  return getRuleContext<MySqlParser::SubpartitionDefinitionContext>(i);
}

MySqlParser::PartitionComparisonContext::PartitionComparisonContext(PartitionDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionComparisonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionComparison(this);
}
void MySqlParser::PartitionComparisonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionComparison(this);
}

std::any MySqlParser::PartitionComparisonContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionComparison(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionListAtomContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionListAtomContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::UidContext* MySqlParser::PartitionListAtomContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionListAtomContext::VALUES() {
  return getToken(MySqlParser::VALUES, 0);
}

tree::TerminalNode* MySqlParser::PartitionListAtomContext::IN() {
  return getToken(MySqlParser::IN, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionListAtomContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::PartitionListAtomContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

std::vector<MySqlParser::PartitionDefinerAtomContext *> MySqlParser::PartitionListAtomContext::partitionDefinerAtom() {
  return getRuleContexts<MySqlParser::PartitionDefinerAtomContext>();
}

MySqlParser::PartitionDefinerAtomContext* MySqlParser::PartitionListAtomContext::partitionDefinerAtom(size_t i) {
  return getRuleContext<MySqlParser::PartitionDefinerAtomContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionListAtomContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::PartitionListAtomContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionListAtomContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::PartitionListAtomContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

std::vector<MySqlParser::PartitionOptionContext *> MySqlParser::PartitionListAtomContext::partitionOption() {
  return getRuleContexts<MySqlParser::PartitionOptionContext>();
}

MySqlParser::PartitionOptionContext* MySqlParser::PartitionListAtomContext::partitionOption(size_t i) {
  return getRuleContext<MySqlParser::PartitionOptionContext>(i);
}

std::vector<MySqlParser::SubpartitionDefinitionContext *> MySqlParser::PartitionListAtomContext::subpartitionDefinition() {
  return getRuleContexts<MySqlParser::SubpartitionDefinitionContext>();
}

MySqlParser::SubpartitionDefinitionContext* MySqlParser::PartitionListAtomContext::subpartitionDefinition(size_t i) {
  return getRuleContext<MySqlParser::SubpartitionDefinitionContext>(i);
}

MySqlParser::PartitionListAtomContext::PartitionListAtomContext(PartitionDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionListAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionListAtom(this);
}
void MySqlParser::PartitionListAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionListAtom(this);
}

std::any MySqlParser::PartitionListAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionListAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionListVectorContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionListVectorContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::UidContext* MySqlParser::PartitionListVectorContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionListVectorContext::VALUES() {
  return getToken(MySqlParser::VALUES, 0);
}

tree::TerminalNode* MySqlParser::PartitionListVectorContext::IN() {
  return getToken(MySqlParser::IN, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionListVectorContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::PartitionListVectorContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

std::vector<MySqlParser::PartitionDefinerVectorContext *> MySqlParser::PartitionListVectorContext::partitionDefinerVector() {
  return getRuleContexts<MySqlParser::PartitionDefinerVectorContext>();
}

MySqlParser::PartitionDefinerVectorContext* MySqlParser::PartitionListVectorContext::partitionDefinerVector(size_t i) {
  return getRuleContext<MySqlParser::PartitionDefinerVectorContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionListVectorContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::PartitionListVectorContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionListVectorContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::PartitionListVectorContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

std::vector<MySqlParser::PartitionOptionContext *> MySqlParser::PartitionListVectorContext::partitionOption() {
  return getRuleContexts<MySqlParser::PartitionOptionContext>();
}

MySqlParser::PartitionOptionContext* MySqlParser::PartitionListVectorContext::partitionOption(size_t i) {
  return getRuleContext<MySqlParser::PartitionOptionContext>(i);
}

std::vector<MySqlParser::SubpartitionDefinitionContext *> MySqlParser::PartitionListVectorContext::subpartitionDefinition() {
  return getRuleContexts<MySqlParser::SubpartitionDefinitionContext>();
}

MySqlParser::SubpartitionDefinitionContext* MySqlParser::PartitionListVectorContext::subpartitionDefinition(size_t i) {
  return getRuleContext<MySqlParser::SubpartitionDefinitionContext>(i);
}

MySqlParser::PartitionListVectorContext::PartitionListVectorContext(PartitionDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionListVectorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionListVector(this);
}
void MySqlParser::PartitionListVectorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionListVector(this);
}

std::any MySqlParser::PartitionListVectorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionListVector(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionSimpleContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionSimpleContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::UidContext* MySqlParser::PartitionSimpleContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

std::vector<MySqlParser::PartitionOptionContext *> MySqlParser::PartitionSimpleContext::partitionOption() {
  return getRuleContexts<MySqlParser::PartitionOptionContext>();
}

MySqlParser::PartitionOptionContext* MySqlParser::PartitionSimpleContext::partitionOption(size_t i) {
  return getRuleContext<MySqlParser::PartitionOptionContext>(i);
}

tree::TerminalNode* MySqlParser::PartitionSimpleContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::SubpartitionDefinitionContext *> MySqlParser::PartitionSimpleContext::subpartitionDefinition() {
  return getRuleContexts<MySqlParser::SubpartitionDefinitionContext>();
}

MySqlParser::SubpartitionDefinitionContext* MySqlParser::PartitionSimpleContext::subpartitionDefinition(size_t i) {
  return getRuleContext<MySqlParser::SubpartitionDefinitionContext>(i);
}

tree::TerminalNode* MySqlParser::PartitionSimpleContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionSimpleContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::PartitionSimpleContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::PartitionSimpleContext::PartitionSimpleContext(PartitionDefinitionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionSimpleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionSimple(this);
}
void MySqlParser::PartitionSimpleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionSimple(this);
}

std::any MySqlParser::PartitionSimpleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionSimple(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::PartitionDefinitionContext* MySqlParser::partitionDefinition() {
  PartitionDefinitionContext *_localctx = _tracker.createInstance<PartitionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 116, MySqlParser::RulePartitionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2243);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::PartitionComparisonContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(2097);
      match(MySqlParser::PARTITION);
      setState(2098);
      uid();
      setState(2099);
      match(MySqlParser::VALUES);
      setState(2100);
      match(MySqlParser::LESS);
      setState(2101);
      match(MySqlParser::THAN);
      setState(2102);
      match(MySqlParser::LR_BRACKET);
      setState(2103);
      partitionDefinerAtom();
      setState(2108);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(2104);
        match(MySqlParser::COMMA);
        setState(2105);
        partitionDefinerAtom();
        setState(2110);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2111);
      match(MySqlParser::RR_BRACKET);
      setState(2115);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::DEFAULT

      || _la == MySqlParser::INDEX || ((((_la - 368) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 368)) & 2199024304129) != 0) || ((((_la - 500) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 500)) & 268436481) != 0) || _la == MySqlParser::STORAGE

      || _la == MySqlParser::TABLESPACE) {
        setState(2112);
        partitionOption();
        setState(2117);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2129);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LR_BRACKET) {
        setState(2118);
        match(MySqlParser::LR_BRACKET);
        setState(2119);
        subpartitionDefinition();
        setState(2124);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(2120);
          match(MySqlParser::COMMA);
          setState(2121);
          subpartitionDefinition();
          setState(2126);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2127);
        match(MySqlParser::RR_BRACKET);
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::PartitionComparisonContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(2131);
      match(MySqlParser::PARTITION);
      setState(2132);
      uid();
      setState(2133);
      match(MySqlParser::VALUES);
      setState(2134);
      match(MySqlParser::LESS);
      setState(2135);
      match(MySqlParser::THAN);
      setState(2136);
      partitionDefinerAtom();
      setState(2140);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::DEFAULT

      || _la == MySqlParser::INDEX || ((((_la - 368) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 368)) & 2199024304129) != 0) || ((((_la - 500) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 500)) & 268436481) != 0) || _la == MySqlParser::STORAGE

      || _la == MySqlParser::TABLESPACE) {
        setState(2137);
        partitionOption();
        setState(2142);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2154);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LR_BRACKET) {
        setState(2143);
        match(MySqlParser::LR_BRACKET);
        setState(2144);
        subpartitionDefinition();
        setState(2149);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(2145);
          match(MySqlParser::COMMA);
          setState(2146);
          subpartitionDefinition();
          setState(2151);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2152);
        match(MySqlParser::RR_BRACKET);
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::PartitionListAtomContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(2156);
      match(MySqlParser::PARTITION);
      setState(2157);
      uid();
      setState(2158);
      match(MySqlParser::VALUES);
      setState(2159);
      match(MySqlParser::IN);
      setState(2160);
      match(MySqlParser::LR_BRACKET);
      setState(2161);
      partitionDefinerAtom();
      setState(2166);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(2162);
        match(MySqlParser::COMMA);
        setState(2163);
        partitionDefinerAtom();
        setState(2168);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2169);
      match(MySqlParser::RR_BRACKET);
      setState(2173);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::DEFAULT

      || _la == MySqlParser::INDEX || ((((_la - 368) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 368)) & 2199024304129) != 0) || ((((_la - 500) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 500)) & 268436481) != 0) || _la == MySqlParser::STORAGE

      || _la == MySqlParser::TABLESPACE) {
        setState(2170);
        partitionOption();
        setState(2175);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2187);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LR_BRACKET) {
        setState(2176);
        match(MySqlParser::LR_BRACKET);
        setState(2177);
        subpartitionDefinition();
        setState(2182);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(2178);
          match(MySqlParser::COMMA);
          setState(2179);
          subpartitionDefinition();
          setState(2184);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2185);
        match(MySqlParser::RR_BRACKET);
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::PartitionListVectorContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(2189);
      match(MySqlParser::PARTITION);
      setState(2190);
      uid();
      setState(2191);
      match(MySqlParser::VALUES);
      setState(2192);
      match(MySqlParser::IN);
      setState(2193);
      match(MySqlParser::LR_BRACKET);
      setState(2194);
      partitionDefinerVector();
      setState(2199);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(2195);
        match(MySqlParser::COMMA);
        setState(2196);
        partitionDefinerVector();
        setState(2201);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2202);
      match(MySqlParser::RR_BRACKET);
      setState(2206);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::DEFAULT

      || _la == MySqlParser::INDEX || ((((_la - 368) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 368)) & 2199024304129) != 0) || ((((_la - 500) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 500)) & 268436481) != 0) || _la == MySqlParser::STORAGE

      || _la == MySqlParser::TABLESPACE) {
        setState(2203);
        partitionOption();
        setState(2208);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2220);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LR_BRACKET) {
        setState(2209);
        match(MySqlParser::LR_BRACKET);
        setState(2210);
        subpartitionDefinition();
        setState(2215);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(2211);
          match(MySqlParser::COMMA);
          setState(2212);
          subpartitionDefinition();
          setState(2217);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2218);
        match(MySqlParser::RR_BRACKET);
      }
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<MySqlParser::PartitionSimpleContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(2222);
      match(MySqlParser::PARTITION);
      setState(2223);
      uid();
      setState(2227);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::DEFAULT

      || _la == MySqlParser::INDEX || ((((_la - 368) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 368)) & 2199024304129) != 0) || ((((_la - 500) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 500)) & 268436481) != 0) || _la == MySqlParser::STORAGE

      || _la == MySqlParser::TABLESPACE) {
        setState(2224);
        partitionOption();
        setState(2229);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2241);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LR_BRACKET) {
        setState(2230);
        match(MySqlParser::LR_BRACKET);
        setState(2231);
        subpartitionDefinition();
        setState(2236);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(2232);
          match(MySqlParser::COMMA);
          setState(2233);
          subpartitionDefinition();
          setState(2238);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2239);
        match(MySqlParser::RR_BRACKET);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDefinerAtomContext ------------------------------------------------------------------

MySqlParser::PartitionDefinerAtomContext::PartitionDefinerAtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::ConstantContext* MySqlParser::PartitionDefinerAtomContext::constant() {
  return getRuleContext<MySqlParser::ConstantContext>(0);
}

MySqlParser::ExpressionContext* MySqlParser::PartitionDefinerAtomContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionDefinerAtomContext::MAXVALUE() {
  return getToken(MySqlParser::MAXVALUE, 0);
}


size_t MySqlParser::PartitionDefinerAtomContext::getRuleIndex() const {
  return MySqlParser::RulePartitionDefinerAtom;
}

void MySqlParser::PartitionDefinerAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefinerAtom(this);
}

void MySqlParser::PartitionDefinerAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefinerAtom(this);
}


std::any MySqlParser::PartitionDefinerAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionDefinerAtom(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::PartitionDefinerAtomContext* MySqlParser::partitionDefinerAtom() {
  PartitionDefinerAtomContext *_localctx = _tracker.createInstance<PartitionDefinerAtomContext>(_ctx, getState());
  enterRule(_localctx, 118, MySqlParser::RulePartitionDefinerAtom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2248);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 263, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2245);
      constant();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2246);
      expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2247);
      match(MySqlParser::MAXVALUE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDefinerVectorContext ------------------------------------------------------------------

MySqlParser::PartitionDefinerVectorContext::PartitionDefinerVectorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::PartitionDefinerVectorContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::PartitionDefinerAtomContext *> MySqlParser::PartitionDefinerVectorContext::partitionDefinerAtom() {
  return getRuleContexts<MySqlParser::PartitionDefinerAtomContext>();
}

MySqlParser::PartitionDefinerAtomContext* MySqlParser::PartitionDefinerVectorContext::partitionDefinerAtom(size_t i) {
  return getRuleContext<MySqlParser::PartitionDefinerAtomContext>(i);
}

tree::TerminalNode* MySqlParser::PartitionDefinerVectorContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionDefinerVectorContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::PartitionDefinerVectorContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::PartitionDefinerVectorContext::getRuleIndex() const {
  return MySqlParser::RulePartitionDefinerVector;
}

void MySqlParser::PartitionDefinerVectorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefinerVector(this);
}

void MySqlParser::PartitionDefinerVectorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefinerVector(this);
}


std::any MySqlParser::PartitionDefinerVectorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionDefinerVector(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::PartitionDefinerVectorContext* MySqlParser::partitionDefinerVector() {
  PartitionDefinerVectorContext *_localctx = _tracker.createInstance<PartitionDefinerVectorContext>(_ctx, getState());
  enterRule(_localctx, 120, MySqlParser::RulePartitionDefinerVector);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2250);
    match(MySqlParser::LR_BRACKET);
    setState(2251);
    partitionDefinerAtom();
    setState(2254); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2252);
      match(MySqlParser::COMMA);
      setState(2253);
      partitionDefinerAtom();
      setState(2256); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MySqlParser::COMMA);
    setState(2258);
    match(MySqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubpartitionDefinitionContext ------------------------------------------------------------------

MySqlParser::SubpartitionDefinitionContext::SubpartitionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SubpartitionDefinitionContext::SUBPARTITION() {
  return getToken(MySqlParser::SUBPARTITION, 0);
}

MySqlParser::UidContext* MySqlParser::SubpartitionDefinitionContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

std::vector<MySqlParser::PartitionOptionContext *> MySqlParser::SubpartitionDefinitionContext::partitionOption() {
  return getRuleContexts<MySqlParser::PartitionOptionContext>();
}

MySqlParser::PartitionOptionContext* MySqlParser::SubpartitionDefinitionContext::partitionOption(size_t i) {
  return getRuleContext<MySqlParser::PartitionOptionContext>(i);
}


size_t MySqlParser::SubpartitionDefinitionContext::getRuleIndex() const {
  return MySqlParser::RuleSubpartitionDefinition;
}

void MySqlParser::SubpartitionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubpartitionDefinition(this);
}

void MySqlParser::SubpartitionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubpartitionDefinition(this);
}


std::any MySqlParser::SubpartitionDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSubpartitionDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SubpartitionDefinitionContext* MySqlParser::subpartitionDefinition() {
  SubpartitionDefinitionContext *_localctx = _tracker.createInstance<SubpartitionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 122, MySqlParser::RuleSubpartitionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2260);
    match(MySqlParser::SUBPARTITION);
    setState(2261);
    uid();
    setState(2265);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::DEFAULT

    || _la == MySqlParser::INDEX || ((((_la - 368) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 368)) & 2199024304129) != 0) || ((((_la - 500) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 500)) & 268436481) != 0) || _la == MySqlParser::STORAGE

    || _la == MySqlParser::TABLESPACE) {
      setState(2262);
      partitionOption();
      setState(2267);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionOptionContext ------------------------------------------------------------------

MySqlParser::PartitionOptionContext::PartitionOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::PartitionOptionContext::getRuleIndex() const {
  return MySqlParser::RulePartitionOption;
}

void MySqlParser::PartitionOptionContext::copyFrom(PartitionOptionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PartitionOptionCommentContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionOptionCommentContext::COMMENT() {
  return getToken(MySqlParser::COMMENT, 0);
}

tree::TerminalNode* MySqlParser::PartitionOptionCommentContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::PartitionOptionCommentContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::PartitionOptionCommentContext::PartitionOptionCommentContext(PartitionOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionOptionCommentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionOptionComment(this);
}
void MySqlParser::PartitionOptionCommentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionOptionComment(this);
}

std::any MySqlParser::PartitionOptionCommentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionOptionComment(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionOptionNodeGroupContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionOptionNodeGroupContext::NODEGROUP() {
  return getToken(MySqlParser::NODEGROUP, 0);
}

MySqlParser::UidContext* MySqlParser::PartitionOptionNodeGroupContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionOptionNodeGroupContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::PartitionOptionNodeGroupContext::PartitionOptionNodeGroupContext(PartitionOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionOptionNodeGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionOptionNodeGroup(this);
}
void MySqlParser::PartitionOptionNodeGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionOptionNodeGroup(this);
}

std::any MySqlParser::PartitionOptionNodeGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionOptionNodeGroup(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionOptionIndexDirectoryContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionOptionIndexDirectoryContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::PartitionOptionIndexDirectoryContext::DIRECTORY() {
  return getToken(MySqlParser::DIRECTORY, 0);
}

tree::TerminalNode* MySqlParser::PartitionOptionIndexDirectoryContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::PartitionOptionIndexDirectoryContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::PartitionOptionIndexDirectoryContext::PartitionOptionIndexDirectoryContext(PartitionOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionOptionIndexDirectoryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionOptionIndexDirectory(this);
}
void MySqlParser::PartitionOptionIndexDirectoryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionOptionIndexDirectory(this);
}

std::any MySqlParser::PartitionOptionIndexDirectoryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionOptionIndexDirectory(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionOptionMaxRowsContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionOptionMaxRowsContext::MAX_ROWS() {
  return getToken(MySqlParser::MAX_ROWS, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::PartitionOptionMaxRowsContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionOptionMaxRowsContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::PartitionOptionMaxRowsContext::PartitionOptionMaxRowsContext(PartitionOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionOptionMaxRowsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionOptionMaxRows(this);
}
void MySqlParser::PartitionOptionMaxRowsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionOptionMaxRows(this);
}

std::any MySqlParser::PartitionOptionMaxRowsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionOptionMaxRows(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionOptionTablespaceContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionOptionTablespaceContext::TABLESPACE() {
  return getToken(MySqlParser::TABLESPACE, 0);
}

MySqlParser::UidContext* MySqlParser::PartitionOptionTablespaceContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionOptionTablespaceContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::PartitionOptionTablespaceContext::PartitionOptionTablespaceContext(PartitionOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionOptionTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionOptionTablespace(this);
}
void MySqlParser::PartitionOptionTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionOptionTablespace(this);
}

std::any MySqlParser::PartitionOptionTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionOptionTablespace(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionOptionEngineContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionOptionEngineContext::ENGINE() {
  return getToken(MySqlParser::ENGINE, 0);
}

MySqlParser::EngineNameContext* MySqlParser::PartitionOptionEngineContext::engineName() {
  return getRuleContext<MySqlParser::EngineNameContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionOptionEngineContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::PartitionOptionEngineContext::STORAGE() {
  return getToken(MySqlParser::STORAGE, 0);
}

tree::TerminalNode* MySqlParser::PartitionOptionEngineContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::PartitionOptionEngineContext::PartitionOptionEngineContext(PartitionOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionOptionEngineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionOptionEngine(this);
}
void MySqlParser::PartitionOptionEngineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionOptionEngine(this);
}

std::any MySqlParser::PartitionOptionEngineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionOptionEngine(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionOptionMinRowsContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionOptionMinRowsContext::MIN_ROWS() {
  return getToken(MySqlParser::MIN_ROWS, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::PartitionOptionMinRowsContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::PartitionOptionMinRowsContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::PartitionOptionMinRowsContext::PartitionOptionMinRowsContext(PartitionOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionOptionMinRowsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionOptionMinRows(this);
}
void MySqlParser::PartitionOptionMinRowsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionOptionMinRows(this);
}

std::any MySqlParser::PartitionOptionMinRowsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionOptionMinRows(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionOptionDataDirectoryContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PartitionOptionDataDirectoryContext::DATA() {
  return getToken(MySqlParser::DATA, 0);
}

tree::TerminalNode* MySqlParser::PartitionOptionDataDirectoryContext::DIRECTORY() {
  return getToken(MySqlParser::DIRECTORY, 0);
}

tree::TerminalNode* MySqlParser::PartitionOptionDataDirectoryContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::PartitionOptionDataDirectoryContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::PartitionOptionDataDirectoryContext::PartitionOptionDataDirectoryContext(PartitionOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PartitionOptionDataDirectoryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionOptionDataDirectory(this);
}
void MySqlParser::PartitionOptionDataDirectoryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionOptionDataDirectory(this);
}

std::any MySqlParser::PartitionOptionDataDirectoryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionOptionDataDirectory(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::PartitionOptionContext* MySqlParser::partitionOption() {
  PartitionOptionContext *_localctx = _tracker.createInstance<PartitionOptionContext>(_ctx, getState());
  enterRule(_localctx, 124, MySqlParser::RulePartitionOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2316);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::DEFAULT:
      case MySqlParser::ENGINE:
      case MySqlParser::STORAGE: {
        _localctx = _tracker.createInstance<MySqlParser::PartitionOptionEngineContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(2269);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::DEFAULT) {
          setState(2268);
          match(MySqlParser::DEFAULT);
        }
        setState(2272);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::STORAGE) {
          setState(2271);
          match(MySqlParser::STORAGE);
        }
        setState(2274);
        match(MySqlParser::ENGINE);
        setState(2276);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::EQUAL_SYMBOL) {
          setState(2275);
          match(MySqlParser::EQUAL_SYMBOL);
        }
        setState(2278);
        engineName();
        break;
      }

      case MySqlParser::COMMENT: {
        _localctx = _tracker.createInstance<MySqlParser::PartitionOptionCommentContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(2279);
        match(MySqlParser::COMMENT);
        setState(2281);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::EQUAL_SYMBOL) {
          setState(2280);
          match(MySqlParser::EQUAL_SYMBOL);
        }
        setState(2283);
        antlrcpp::downCast<PartitionOptionCommentContext *>(_localctx)->comment = match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::DATA: {
        _localctx = _tracker.createInstance<MySqlParser::PartitionOptionDataDirectoryContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(2284);
        match(MySqlParser::DATA);
        setState(2285);
        match(MySqlParser::DIRECTORY);
        setState(2287);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::EQUAL_SYMBOL) {
          setState(2286);
          match(MySqlParser::EQUAL_SYMBOL);
        }
        setState(2289);
        antlrcpp::downCast<PartitionOptionDataDirectoryContext *>(_localctx)->dataDirectory = match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::INDEX: {
        _localctx = _tracker.createInstance<MySqlParser::PartitionOptionIndexDirectoryContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(2290);
        match(MySqlParser::INDEX);
        setState(2291);
        match(MySqlParser::DIRECTORY);
        setState(2293);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::EQUAL_SYMBOL) {
          setState(2292);
          match(MySqlParser::EQUAL_SYMBOL);
        }
        setState(2295);
        antlrcpp::downCast<PartitionOptionIndexDirectoryContext *>(_localctx)->indexDirectory = match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::MAX_ROWS: {
        _localctx = _tracker.createInstance<MySqlParser::PartitionOptionMaxRowsContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(2296);
        match(MySqlParser::MAX_ROWS);
        setState(2298);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::EQUAL_SYMBOL) {
          setState(2297);
          match(MySqlParser::EQUAL_SYMBOL);
        }
        setState(2300);
        antlrcpp::downCast<PartitionOptionMaxRowsContext *>(_localctx)->maxRows = decimalLiteral();
        break;
      }

      case MySqlParser::MIN_ROWS: {
        _localctx = _tracker.createInstance<MySqlParser::PartitionOptionMinRowsContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(2301);
        match(MySqlParser::MIN_ROWS);
        setState(2303);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::EQUAL_SYMBOL) {
          setState(2302);
          match(MySqlParser::EQUAL_SYMBOL);
        }
        setState(2305);
        antlrcpp::downCast<PartitionOptionMinRowsContext *>(_localctx)->minRows = decimalLiteral();
        break;
      }

      case MySqlParser::TABLESPACE: {
        _localctx = _tracker.createInstance<MySqlParser::PartitionOptionTablespaceContext>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(2306);
        match(MySqlParser::TABLESPACE);
        setState(2308);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::EQUAL_SYMBOL) {
          setState(2307);
          match(MySqlParser::EQUAL_SYMBOL);
        }
        setState(2310);
        antlrcpp::downCast<PartitionOptionTablespaceContext *>(_localctx)->tablespace = uid();
        break;
      }

      case MySqlParser::NODEGROUP: {
        _localctx = _tracker.createInstance<MySqlParser::PartitionOptionNodeGroupContext>(_localctx);
        enterOuterAlt(_localctx, 8);
        setState(2311);
        match(MySqlParser::NODEGROUP);
        setState(2313);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::EQUAL_SYMBOL) {
          setState(2312);
          match(MySqlParser::EQUAL_SYMBOL);
        }
        setState(2315);
        antlrcpp::downCast<PartitionOptionNodeGroupContext *>(_localctx)->nodegroup = uid();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterDatabaseContext ------------------------------------------------------------------

MySqlParser::AlterDatabaseContext::AlterDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::AlterDatabaseContext::getRuleIndex() const {
  return MySqlParser::RuleAlterDatabase;
}

void MySqlParser::AlterDatabaseContext::copyFrom(AlterDatabaseContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- AlterUpgradeNameContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterUpgradeNameContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

MySqlParser::UidContext* MySqlParser::AlterUpgradeNameContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::AlterUpgradeNameContext::UPGRADE() {
  return getToken(MySqlParser::UPGRADE, 0);
}

tree::TerminalNode* MySqlParser::AlterUpgradeNameContext::DATA() {
  return getToken(MySqlParser::DATA, 0);
}

tree::TerminalNode* MySqlParser::AlterUpgradeNameContext::DIRECTORY() {
  return getToken(MySqlParser::DIRECTORY, 0);
}

tree::TerminalNode* MySqlParser::AlterUpgradeNameContext::NAME() {
  return getToken(MySqlParser::NAME, 0);
}

tree::TerminalNode* MySqlParser::AlterUpgradeNameContext::DATABASE() {
  return getToken(MySqlParser::DATABASE, 0);
}

tree::TerminalNode* MySqlParser::AlterUpgradeNameContext::SCHEMA() {
  return getToken(MySqlParser::SCHEMA, 0);
}

MySqlParser::AlterUpgradeNameContext::AlterUpgradeNameContext(AlterDatabaseContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterUpgradeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUpgradeName(this);
}
void MySqlParser::AlterUpgradeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUpgradeName(this);
}

std::any MySqlParser::AlterUpgradeNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterUpgradeName(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterSimpleDatabaseContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterSimpleDatabaseContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterSimpleDatabaseContext::DATABASE() {
  return getToken(MySqlParser::DATABASE, 0);
}

tree::TerminalNode* MySqlParser::AlterSimpleDatabaseContext::SCHEMA() {
  return getToken(MySqlParser::SCHEMA, 0);
}

MySqlParser::UidContext* MySqlParser::AlterSimpleDatabaseContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

std::vector<MySqlParser::CreateDatabaseOptionContext *> MySqlParser::AlterSimpleDatabaseContext::createDatabaseOption() {
  return getRuleContexts<MySqlParser::CreateDatabaseOptionContext>();
}

MySqlParser::CreateDatabaseOptionContext* MySqlParser::AlterSimpleDatabaseContext::createDatabaseOption(size_t i) {
  return getRuleContext<MySqlParser::CreateDatabaseOptionContext>(i);
}

MySqlParser::AlterSimpleDatabaseContext::AlterSimpleDatabaseContext(AlterDatabaseContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterSimpleDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterSimpleDatabase(this);
}
void MySqlParser::AlterSimpleDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterSimpleDatabase(this);
}

std::any MySqlParser::AlterSimpleDatabaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterSimpleDatabase(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::AlterDatabaseContext* MySqlParser::alterDatabase() {
  AlterDatabaseContext *_localctx = _tracker.createInstance<AlterDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 126, MySqlParser::RuleAlterDatabase);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2336);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 279, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::AlterSimpleDatabaseContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(2318);
      match(MySqlParser::ALTER);
      setState(2319);
      antlrcpp::downCast<AlterSimpleDatabaseContext *>(_localctx)->dbFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DATABASE || _la == MySqlParser::SCHEMA)) {
        antlrcpp::downCast<AlterSimpleDatabaseContext *>(_localctx)->dbFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2321);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 277, _ctx)) {
      case 1: {
        setState(2320);
        uid();
        break;
      }

      default:
        break;
      }
      setState(2324); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2323);
        createDatabaseOption();
        setState(2326); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 4398214283264) != 0) || _la == MySqlParser::READ || _la == MySqlParser::CHAR || _la == MySqlParser::ENCRYPTION || _la == MySqlParser::CHARSET);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::AlterUpgradeNameContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(2328);
      match(MySqlParser::ALTER);
      setState(2329);
      antlrcpp::downCast<AlterUpgradeNameContext *>(_localctx)->dbFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DATABASE || _la == MySqlParser::SCHEMA)) {
        antlrcpp::downCast<AlterUpgradeNameContext *>(_localctx)->dbFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2330);
      uid();
      setState(2331);
      match(MySqlParser::UPGRADE);
      setState(2332);
      match(MySqlParser::DATA);
      setState(2333);
      match(MySqlParser::DIRECTORY);
      setState(2334);
      match(MySqlParser::NAME);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterEventContext ------------------------------------------------------------------

MySqlParser::AlterEventContext::AlterEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::AlterEventContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterEventContext::EVENT() {
  return getToken(MySqlParser::EVENT, 0);
}

std::vector<MySqlParser::FullIdContext *> MySqlParser::AlterEventContext::fullId() {
  return getRuleContexts<MySqlParser::FullIdContext>();
}

MySqlParser::FullIdContext* MySqlParser::AlterEventContext::fullId(size_t i) {
  return getRuleContext<MySqlParser::FullIdContext>(i);
}

MySqlParser::OwnerStatementContext* MySqlParser::AlterEventContext::ownerStatement() {
  return getRuleContext<MySqlParser::OwnerStatementContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterEventContext::ON() {
  return getTokens(MySqlParser::ON);
}

tree::TerminalNode* MySqlParser::AlterEventContext::ON(size_t i) {
  return getToken(MySqlParser::ON, i);
}

tree::TerminalNode* MySqlParser::AlterEventContext::SCHEDULE() {
  return getToken(MySqlParser::SCHEDULE, 0);
}

MySqlParser::ScheduleExpressionContext* MySqlParser::AlterEventContext::scheduleExpression() {
  return getRuleContext<MySqlParser::ScheduleExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::AlterEventContext::COMPLETION() {
  return getToken(MySqlParser::COMPLETION, 0);
}

tree::TerminalNode* MySqlParser::AlterEventContext::PRESERVE() {
  return getToken(MySqlParser::PRESERVE, 0);
}

tree::TerminalNode* MySqlParser::AlterEventContext::RENAME() {
  return getToken(MySqlParser::RENAME, 0);
}

tree::TerminalNode* MySqlParser::AlterEventContext::TO() {
  return getToken(MySqlParser::TO, 0);
}

MySqlParser::EnableTypeContext* MySqlParser::AlterEventContext::enableType() {
  return getRuleContext<MySqlParser::EnableTypeContext>(0);
}

tree::TerminalNode* MySqlParser::AlterEventContext::COMMENT() {
  return getToken(MySqlParser::COMMENT, 0);
}

tree::TerminalNode* MySqlParser::AlterEventContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::AlterEventContext::DO() {
  return getToken(MySqlParser::DO, 0);
}

MySqlParser::RoutineBodyContext* MySqlParser::AlterEventContext::routineBody() {
  return getRuleContext<MySqlParser::RoutineBodyContext>(0);
}

tree::TerminalNode* MySqlParser::AlterEventContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}


size_t MySqlParser::AlterEventContext::getRuleIndex() const {
  return MySqlParser::RuleAlterEvent;
}

void MySqlParser::AlterEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterEvent(this);
}

void MySqlParser::AlterEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterEvent(this);
}


std::any MySqlParser::AlterEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterEvent(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AlterEventContext* MySqlParser::alterEvent() {
  AlterEventContext *_localctx = _tracker.createInstance<AlterEventContext>(_ctx, getState());
  enterRule(_localctx, 128, MySqlParser::RuleAlterEvent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2338);
    match(MySqlParser::ALTER);
    setState(2340);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::DEFINER) {
      setState(2339);
      ownerStatement();
    }
    setState(2342);
    match(MySqlParser::EVENT);
    setState(2343);
    fullId();
    setState(2347);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx)) {
    case 1: {
      setState(2344);
      match(MySqlParser::ON);
      setState(2345);
      match(MySqlParser::SCHEDULE);
      setState(2346);
      scheduleExpression();
      break;
    }

    default:
      break;
    }
    setState(2355);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ON) {
      setState(2349);
      match(MySqlParser::ON);
      setState(2350);
      match(MySqlParser::COMPLETION);
      setState(2352);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::NOT) {
        setState(2351);
        match(MySqlParser::NOT);
      }
      setState(2354);
      match(MySqlParser::PRESERVE);
    }
    setState(2360);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx)) {
    case 1: {
      setState(2357);
      match(MySqlParser::RENAME);
      setState(2358);
      match(MySqlParser::TO);
      setState(2359);
      fullId();
      break;
    }

    default:
      break;
    }
    setState(2363);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::DISABLE

    || _la == MySqlParser::ENABLE) {
      setState(2362);
      enableType();
    }
    setState(2367);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::COMMENT) {
      setState(2365);
      match(MySqlParser::COMMENT);
      setState(2366);
      match(MySqlParser::STRING_LITERAL);
    }
    setState(2371);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 287, _ctx)) {
    case 1: {
      setState(2369);
      match(MySqlParser::DO);
      setState(2370);
      routineBody();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterFunctionContext ------------------------------------------------------------------

MySqlParser::AlterFunctionContext::AlterFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::AlterFunctionContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterFunctionContext::FUNCTION() {
  return getToken(MySqlParser::FUNCTION, 0);
}

MySqlParser::FullIdContext* MySqlParser::AlterFunctionContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

std::vector<MySqlParser::RoutineOptionContext *> MySqlParser::AlterFunctionContext::routineOption() {
  return getRuleContexts<MySqlParser::RoutineOptionContext>();
}

MySqlParser::RoutineOptionContext* MySqlParser::AlterFunctionContext::routineOption(size_t i) {
  return getRuleContext<MySqlParser::RoutineOptionContext>(i);
}


size_t MySqlParser::AlterFunctionContext::getRuleIndex() const {
  return MySqlParser::RuleAlterFunction;
}

void MySqlParser::AlterFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterFunction(this);
}

void MySqlParser::AlterFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterFunction(this);
}


std::any MySqlParser::AlterFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterFunction(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AlterFunctionContext* MySqlParser::alterFunction() {
  AlterFunctionContext *_localctx = _tracker.createInstance<AlterFunctionContext>(_ctx, getState());
  enterRule(_localctx, 130, MySqlParser::RuleAlterFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2373);
    match(MySqlParser::ALTER);
    setState(2374);
    match(MySqlParser::FUNCTION);
    setState(2375);
    fullId();
    setState(2379);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::DETERMINISTIC || ((((_la - 112) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 112)) & 281474985099269) != 0) || _la == MySqlParser::COMMENT

    || _la == MySqlParser::CONTAINS || _la == MySqlParser::LANGUAGE

    || _la == MySqlParser::NO) {
      setState(2376);
      routineOption();
      setState(2381);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterInstanceContext ------------------------------------------------------------------

MySqlParser::AlterInstanceContext::AlterInstanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::AlterInstanceContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterInstanceContext::INSTANCE() {
  return getToken(MySqlParser::INSTANCE, 0);
}

tree::TerminalNode* MySqlParser::AlterInstanceContext::ROTATE() {
  return getToken(MySqlParser::ROTATE, 0);
}

tree::TerminalNode* MySqlParser::AlterInstanceContext::INNODB() {
  return getToken(MySqlParser::INNODB, 0);
}

tree::TerminalNode* MySqlParser::AlterInstanceContext::MASTER() {
  return getToken(MySqlParser::MASTER, 0);
}

tree::TerminalNode* MySqlParser::AlterInstanceContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}


size_t MySqlParser::AlterInstanceContext::getRuleIndex() const {
  return MySqlParser::RuleAlterInstance;
}

void MySqlParser::AlterInstanceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterInstance(this);
}

void MySqlParser::AlterInstanceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterInstance(this);
}


std::any MySqlParser::AlterInstanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterInstance(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AlterInstanceContext* MySqlParser::alterInstance() {
  AlterInstanceContext *_localctx = _tracker.createInstance<AlterInstanceContext>(_ctx, getState());
  enterRule(_localctx, 132, MySqlParser::RuleAlterInstance);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2382);
    match(MySqlParser::ALTER);
    setState(2383);
    match(MySqlParser::INSTANCE);
    setState(2384);
    match(MySqlParser::ROTATE);
    setState(2385);
    match(MySqlParser::INNODB);
    setState(2386);
    match(MySqlParser::MASTER);
    setState(2387);
    match(MySqlParser::KEY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLogfileGroupContext ------------------------------------------------------------------

MySqlParser::AlterLogfileGroupContext::AlterLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::AlterLogfileGroupContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterLogfileGroupContext::LOGFILE() {
  return getToken(MySqlParser::LOGFILE, 0);
}

tree::TerminalNode* MySqlParser::AlterLogfileGroupContext::GROUP() {
  return getToken(MySqlParser::GROUP, 0);
}

MySqlParser::UidContext* MySqlParser::AlterLogfileGroupContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::AlterLogfileGroupContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

tree::TerminalNode* MySqlParser::AlterLogfileGroupContext::UNDOFILE() {
  return getToken(MySqlParser::UNDOFILE, 0);
}

tree::TerminalNode* MySqlParser::AlterLogfileGroupContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::AlterLogfileGroupContext::ENGINE() {
  return getToken(MySqlParser::ENGINE, 0);
}

MySqlParser::EngineNameContext* MySqlParser::AlterLogfileGroupContext::engineName() {
  return getRuleContext<MySqlParser::EngineNameContext>(0);
}

tree::TerminalNode* MySqlParser::AlterLogfileGroupContext::INITIAL_SIZE() {
  return getToken(MySqlParser::INITIAL_SIZE, 0);
}

MySqlParser::FileSizeLiteralContext* MySqlParser::AlterLogfileGroupContext::fileSizeLiteral() {
  return getRuleContext<MySqlParser::FileSizeLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::AlterLogfileGroupContext::WAIT() {
  return getToken(MySqlParser::WAIT, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterLogfileGroupContext::EQUAL_SYMBOL() {
  return getTokens(MySqlParser::EQUAL_SYMBOL);
}

tree::TerminalNode* MySqlParser::AlterLogfileGroupContext::EQUAL_SYMBOL(size_t i) {
  return getToken(MySqlParser::EQUAL_SYMBOL, i);
}


size_t MySqlParser::AlterLogfileGroupContext::getRuleIndex() const {
  return MySqlParser::RuleAlterLogfileGroup;
}

void MySqlParser::AlterLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLogfileGroup(this);
}

void MySqlParser::AlterLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLogfileGroup(this);
}


std::any MySqlParser::AlterLogfileGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterLogfileGroup(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AlterLogfileGroupContext* MySqlParser::alterLogfileGroup() {
  AlterLogfileGroupContext *_localctx = _tracker.createInstance<AlterLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 134, MySqlParser::RuleAlterLogfileGroup);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2389);
    match(MySqlParser::ALTER);
    setState(2390);
    match(MySqlParser::LOGFILE);
    setState(2391);
    match(MySqlParser::GROUP);
    setState(2392);
    uid();
    setState(2393);
    match(MySqlParser::ADD);
    setState(2394);
    match(MySqlParser::UNDOFILE);
    setState(2395);
    match(MySqlParser::STRING_LITERAL);
    setState(2401);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::INITIAL_SIZE) {
      setState(2396);
      match(MySqlParser::INITIAL_SIZE);
      setState(2398);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(2397);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(2400);
      fileSizeLiteral();
    }
    setState(2404);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WAIT) {
      setState(2403);
      match(MySqlParser::WAIT);
    }
    setState(2406);
    match(MySqlParser::ENGINE);
    setState(2408);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::EQUAL_SYMBOL) {
      setState(2407);
      match(MySqlParser::EQUAL_SYMBOL);
    }
    setState(2410);
    engineName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterProcedureContext ------------------------------------------------------------------

MySqlParser::AlterProcedureContext::AlterProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::AlterProcedureContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterProcedureContext::PROCEDURE() {
  return getToken(MySqlParser::PROCEDURE, 0);
}

MySqlParser::FullIdContext* MySqlParser::AlterProcedureContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

std::vector<MySqlParser::RoutineOptionContext *> MySqlParser::AlterProcedureContext::routineOption() {
  return getRuleContexts<MySqlParser::RoutineOptionContext>();
}

MySqlParser::RoutineOptionContext* MySqlParser::AlterProcedureContext::routineOption(size_t i) {
  return getRuleContext<MySqlParser::RoutineOptionContext>(i);
}


size_t MySqlParser::AlterProcedureContext::getRuleIndex() const {
  return MySqlParser::RuleAlterProcedure;
}

void MySqlParser::AlterProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterProcedure(this);
}

void MySqlParser::AlterProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterProcedure(this);
}


std::any MySqlParser::AlterProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterProcedure(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AlterProcedureContext* MySqlParser::alterProcedure() {
  AlterProcedureContext *_localctx = _tracker.createInstance<AlterProcedureContext>(_ctx, getState());
  enterRule(_localctx, 136, MySqlParser::RuleAlterProcedure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2412);
    match(MySqlParser::ALTER);
    setState(2413);
    match(MySqlParser::PROCEDURE);
    setState(2414);
    fullId();
    setState(2418);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::DETERMINISTIC || ((((_la - 112) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 112)) & 281474985099269) != 0) || _la == MySqlParser::COMMENT

    || _la == MySqlParser::CONTAINS || _la == MySqlParser::LANGUAGE

    || _la == MySqlParser::NO) {
      setState(2415);
      routineOption();
      setState(2420);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterServerContext ------------------------------------------------------------------

MySqlParser::AlterServerContext::AlterServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::AlterServerContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterServerContext::SERVER() {
  return getToken(MySqlParser::SERVER, 0);
}

MySqlParser::UidContext* MySqlParser::AlterServerContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::AlterServerContext::OPTIONS() {
  return getToken(MySqlParser::OPTIONS, 0);
}

tree::TerminalNode* MySqlParser::AlterServerContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::ServerOptionContext *> MySqlParser::AlterServerContext::serverOption() {
  return getRuleContexts<MySqlParser::ServerOptionContext>();
}

MySqlParser::ServerOptionContext* MySqlParser::AlterServerContext::serverOption(size_t i) {
  return getRuleContext<MySqlParser::ServerOptionContext>(i);
}

tree::TerminalNode* MySqlParser::AlterServerContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterServerContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::AlterServerContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::AlterServerContext::getRuleIndex() const {
  return MySqlParser::RuleAlterServer;
}

void MySqlParser::AlterServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterServer(this);
}

void MySqlParser::AlterServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterServer(this);
}


std::any MySqlParser::AlterServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterServer(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AlterServerContext* MySqlParser::alterServer() {
  AlterServerContext *_localctx = _tracker.createInstance<AlterServerContext>(_ctx, getState());
  enterRule(_localctx, 138, MySqlParser::RuleAlterServer);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2421);
    match(MySqlParser::ALTER);
    setState(2422);
    match(MySqlParser::SERVER);
    setState(2423);
    uid();
    setState(2424);
    match(MySqlParser::OPTIONS);
    setState(2425);
    match(MySqlParser::LR_BRACKET);
    setState(2426);
    serverOption();
    setState(2431);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(2427);
      match(MySqlParser::COMMA);
      setState(2428);
      serverOption();
      setState(2433);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2434);
    match(MySqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTableContext ------------------------------------------------------------------

MySqlParser::AlterTableContext::AlterTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::AlterTableContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterTableContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

MySqlParser::TableNameContext* MySqlParser::AlterTableContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::AlterTableContext::IGNORE() {
  return getToken(MySqlParser::IGNORE, 0);
}

MySqlParser::WaitNowaitClauseContext* MySqlParser::AlterTableContext::waitNowaitClause() {
  return getRuleContext<MySqlParser::WaitNowaitClauseContext>(0);
}

std::vector<MySqlParser::AlterSpecificationContext *> MySqlParser::AlterTableContext::alterSpecification() {
  return getRuleContexts<MySqlParser::AlterSpecificationContext>();
}

MySqlParser::AlterSpecificationContext* MySqlParser::AlterTableContext::alterSpecification(size_t i) {
  return getRuleContext<MySqlParser::AlterSpecificationContext>(i);
}

MySqlParser::PartitionDefinitionsContext* MySqlParser::AlterTableContext::partitionDefinitions() {
  return getRuleContext<MySqlParser::PartitionDefinitionsContext>(0);
}

tree::TerminalNode* MySqlParser::AlterTableContext::ONLINE() {
  return getToken(MySqlParser::ONLINE, 0);
}

tree::TerminalNode* MySqlParser::AlterTableContext::OFFLINE() {
  return getToken(MySqlParser::OFFLINE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterTableContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::AlterTableContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::AlterTableContext::getRuleIndex() const {
  return MySqlParser::RuleAlterTable;
}

void MySqlParser::AlterTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTable(this);
}

void MySqlParser::AlterTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTable(this);
}


std::any MySqlParser::AlterTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterTable(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AlterTableContext* MySqlParser::alterTable() {
  AlterTableContext *_localctx = _tracker.createInstance<AlterTableContext>(_ctx, getState());
  enterRule(_localctx, 140, MySqlParser::RuleAlterTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2436);
    match(MySqlParser::ALTER);
    setState(2438);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::OFFLINE

    || _la == MySqlParser::ONLINE) {
      setState(2437);
      antlrcpp::downCast<AlterTableContext *>(_localctx)->intimeAction = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::OFFLINE

      || _la == MySqlParser::ONLINE)) {
        antlrcpp::downCast<AlterTableContext *>(_localctx)->intimeAction = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2441);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IGNORE) {
      setState(2440);
      match(MySqlParser::IGNORE);
    }
    setState(2443);
    match(MySqlParser::TABLE);
    setState(2444);
    tableName();
    setState(2446);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::NOWAIT || _la == MySqlParser::WAIT) {
      setState(2445);
      waitNowaitClause();
    }
    setState(2456);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, _ctx)) {
    case 1: {
      setState(2448);
      alterSpecification();
      setState(2453);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(2449);
        match(MySqlParser::COMMA);
        setState(2450);
        alterSpecification();
        setState(2455);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
    setState(2459);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::PARTITION) {
      setState(2458);
      partitionDefinitions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTablespaceContext ------------------------------------------------------------------

MySqlParser::AlterTablespaceContext::AlterTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::AlterTablespaceContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterTablespaceContext::TABLESPACE() {
  return getToken(MySqlParser::TABLESPACE, 0);
}

MySqlParser::UidContext* MySqlParser::AlterTablespaceContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::AlterTablespaceContext::DATAFILE() {
  return getToken(MySqlParser::DATAFILE, 0);
}

tree::TerminalNode* MySqlParser::AlterTablespaceContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::AlterTablespaceContext::ENGINE() {
  return getToken(MySqlParser::ENGINE, 0);
}

MySqlParser::EngineNameContext* MySqlParser::AlterTablespaceContext::engineName() {
  return getRuleContext<MySqlParser::EngineNameContext>(0);
}

tree::TerminalNode* MySqlParser::AlterTablespaceContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

tree::TerminalNode* MySqlParser::AlterTablespaceContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::AlterTablespaceContext::INITIAL_SIZE() {
  return getToken(MySqlParser::INITIAL_SIZE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterTablespaceContext::EQUAL_SYMBOL() {
  return getTokens(MySqlParser::EQUAL_SYMBOL);
}

tree::TerminalNode* MySqlParser::AlterTablespaceContext::EQUAL_SYMBOL(size_t i) {
  return getToken(MySqlParser::EQUAL_SYMBOL, i);
}

MySqlParser::FileSizeLiteralContext* MySqlParser::AlterTablespaceContext::fileSizeLiteral() {
  return getRuleContext<MySqlParser::FileSizeLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::AlterTablespaceContext::WAIT() {
  return getToken(MySqlParser::WAIT, 0);
}


size_t MySqlParser::AlterTablespaceContext::getRuleIndex() const {
  return MySqlParser::RuleAlterTablespace;
}

void MySqlParser::AlterTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTablespace(this);
}

void MySqlParser::AlterTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTablespace(this);
}


std::any MySqlParser::AlterTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterTablespace(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AlterTablespaceContext* MySqlParser::alterTablespace() {
  AlterTablespaceContext *_localctx = _tracker.createInstance<AlterTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 142, MySqlParser::RuleAlterTablespace);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2461);
    match(MySqlParser::ALTER);
    setState(2462);
    match(MySqlParser::TABLESPACE);
    setState(2463);
    uid();
    setState(2464);
    antlrcpp::downCast<AlterTablespaceContext *>(_localctx)->objectAction = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::ADD

    || _la == MySqlParser::DROP)) {
      antlrcpp::downCast<AlterTablespaceContext *>(_localctx)->objectAction = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2465);
    match(MySqlParser::DATAFILE);
    setState(2466);
    match(MySqlParser::STRING_LITERAL);
    setState(2470);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::INITIAL_SIZE) {
      setState(2467);
      match(MySqlParser::INITIAL_SIZE);
      setState(2468);
      match(MySqlParser::EQUAL_SYMBOL);
      setState(2469);
      fileSizeLiteral();
    }
    setState(2473);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WAIT) {
      setState(2472);
      match(MySqlParser::WAIT);
    }
    setState(2475);
    match(MySqlParser::ENGINE);
    setState(2477);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::EQUAL_SYMBOL) {
      setState(2476);
      match(MySqlParser::EQUAL_SYMBOL);
    }
    setState(2479);
    engineName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterViewContext ------------------------------------------------------------------

MySqlParser::AlterViewContext::AlterViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::AlterViewContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::VIEW() {
  return getToken(MySqlParser::VIEW, 0);
}

MySqlParser::FullIdContext* MySqlParser::AlterViewContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

MySqlParser::SelectStatementContext* MySqlParser::AlterViewContext::selectStatement() {
  return getRuleContext<MySqlParser::SelectStatementContext>(0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::ALGORITHM() {
  return getToken(MySqlParser::ALGORITHM, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::OwnerStatementContext* MySqlParser::AlterViewContext::ownerStatement() {
  return getRuleContext<MySqlParser::OwnerStatementContext>(0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::SQL() {
  return getToken(MySqlParser::SQL, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::SECURITY() {
  return getToken(MySqlParser::SECURITY, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::UidListContext* MySqlParser::AlterViewContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::CHECK() {
  return getToken(MySqlParser::CHECK, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::OPTION() {
  return getToken(MySqlParser::OPTION, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::UNDEFINED() {
  return getToken(MySqlParser::UNDEFINED, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::MERGE() {
  return getToken(MySqlParser::MERGE, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::TEMPTABLE() {
  return getToken(MySqlParser::TEMPTABLE, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::DEFINER() {
  return getToken(MySqlParser::DEFINER, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::INVOKER() {
  return getToken(MySqlParser::INVOKER, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::CASCADED() {
  return getToken(MySqlParser::CASCADED, 0);
}

tree::TerminalNode* MySqlParser::AlterViewContext::LOCAL() {
  return getToken(MySqlParser::LOCAL, 0);
}


size_t MySqlParser::AlterViewContext::getRuleIndex() const {
  return MySqlParser::RuleAlterView;
}

void MySqlParser::AlterViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterView(this);
}

void MySqlParser::AlterViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterView(this);
}


std::any MySqlParser::AlterViewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterView(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AlterViewContext* MySqlParser::alterView() {
  AlterViewContext *_localctx = _tracker.createInstance<AlterViewContext>(_ctx, getState());
  enterRule(_localctx, 144, MySqlParser::RuleAlterView);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2481);
    match(MySqlParser::ALTER);
    setState(2485);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ALGORITHM) {
      setState(2482);
      match(MySqlParser::ALGORITHM);
      setState(2483);
      match(MySqlParser::EQUAL_SYMBOL);
      setState(2484);
      antlrcpp::downCast<AlterViewContext *>(_localctx)->algType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::MERGE || _la == MySqlParser::TEMPTABLE

      || _la == MySqlParser::UNDEFINED)) {
        antlrcpp::downCast<AlterViewContext *>(_localctx)->algType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2488);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::DEFINER) {
      setState(2487);
      ownerStatement();
    }
    setState(2493);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::SQL) {
      setState(2490);
      match(MySqlParser::SQL);
      setState(2491);
      match(MySqlParser::SECURITY);
      setState(2492);
      antlrcpp::downCast<AlterViewContext *>(_localctx)->secContext = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DEFINER || _la == MySqlParser::INVOKER)) {
        antlrcpp::downCast<AlterViewContext *>(_localctx)->secContext = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2495);
    match(MySqlParser::VIEW);
    setState(2496);
    fullId();
    setState(2501);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LR_BRACKET) {
      setState(2497);
      match(MySqlParser::LR_BRACKET);
      setState(2498);
      uidList();
      setState(2499);
      match(MySqlParser::RR_BRACKET);
    }
    setState(2503);
    match(MySqlParser::AS);
    setState(2504);
    selectStatement();
    setState(2511);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
    case 1: {
      setState(2505);
      match(MySqlParser::WITH);
      setState(2507);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::CASCADED || _la == MySqlParser::LOCAL) {
        setState(2506);
        antlrcpp::downCast<AlterViewContext *>(_localctx)->checkOpt = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::CASCADED || _la == MySqlParser::LOCAL)) {
          antlrcpp::downCast<AlterViewContext *>(_localctx)->checkOpt = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(2509);
      match(MySqlParser::CHECK);
      setState(2510);
      match(MySqlParser::OPTION);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterSpecificationContext ------------------------------------------------------------------

MySqlParser::AlterSpecificationContext::AlterSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::AlterSpecificationContext::getRuleIndex() const {
  return MySqlParser::RuleAlterSpecification;
}

void MySqlParser::AlterSpecificationContext::copyFrom(AlterSpecificationContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- AlterByAlterColumnDefaultContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAlterColumnDefaultContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

MySqlParser::UidContext* MySqlParser::AlterByAlterColumnDefaultContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAlterColumnDefaultContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::AlterByAlterColumnDefaultContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::AlterByAlterColumnDefaultContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::AlterByAlterColumnDefaultContext::COLUMN() {
  return getToken(MySqlParser::COLUMN, 0);
}

tree::TerminalNode* MySqlParser::AlterByAlterColumnDefaultContext::VISIBLE() {
  return getToken(MySqlParser::VISIBLE, 0);
}

tree::TerminalNode* MySqlParser::AlterByAlterColumnDefaultContext::INVISIBLE() {
  return getToken(MySqlParser::INVISIBLE, 0);
}

MySqlParser::StringLiteralContext* MySqlParser::AlterByAlterColumnDefaultContext::stringLiteral() {
  return getRuleContext<MySqlParser::StringLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAlterColumnDefaultContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ExpressionContext* MySqlParser::AlterByAlterColumnDefaultContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAlterColumnDefaultContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::AlterByAlterColumnDefaultContext::AlterByAlterColumnDefaultContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAlterColumnDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAlterColumnDefault(this);
}
void MySqlParser::AlterByAlterColumnDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAlterColumnDefault(this);
}

std::any MySqlParser::AlterByAlterColumnDefaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAlterColumnDefault(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByDisableKeysContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByDisableKeysContext::DISABLE() {
  return getToken(MySqlParser::DISABLE, 0);
}

tree::TerminalNode* MySqlParser::AlterByDisableKeysContext::KEYS() {
  return getToken(MySqlParser::KEYS, 0);
}

MySqlParser::AlterByDisableKeysContext::AlterByDisableKeysContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByDisableKeysContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByDisableKeys(this);
}
void MySqlParser::AlterByDisableKeysContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByDisableKeys(this);
}

std::any MySqlParser::AlterByDisableKeysContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByDisableKeys(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByDefaultCharsetContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByDefaultCharsetContext::CHARACTER() {
  return getToken(MySqlParser::CHARACTER, 0);
}

tree::TerminalNode* MySqlParser::AlterByDefaultCharsetContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterByDefaultCharsetContext::EQUAL_SYMBOL() {
  return getTokens(MySqlParser::EQUAL_SYMBOL);
}

tree::TerminalNode* MySqlParser::AlterByDefaultCharsetContext::EQUAL_SYMBOL(size_t i) {
  return getToken(MySqlParser::EQUAL_SYMBOL, i);
}

MySqlParser::CharsetNameContext* MySqlParser::AlterByDefaultCharsetContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByDefaultCharsetContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::AlterByDefaultCharsetContext::COLLATE() {
  return getToken(MySqlParser::COLLATE, 0);
}

MySqlParser::CollationNameContext* MySqlParser::AlterByDefaultCharsetContext::collationName() {
  return getRuleContext<MySqlParser::CollationNameContext>(0);
}

MySqlParser::AlterByDefaultCharsetContext::AlterByDefaultCharsetContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByDefaultCharsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByDefaultCharset(this);
}
void MySqlParser::AlterByDefaultCharsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByDefaultCharset(this);
}

std::any MySqlParser::AlterByDefaultCharsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByDefaultCharset(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByRenameColumnContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByRenameColumnContext::RENAME() {
  return getToken(MySqlParser::RENAME, 0);
}

tree::TerminalNode* MySqlParser::AlterByRenameColumnContext::COLUMN() {
  return getToken(MySqlParser::COLUMN, 0);
}

tree::TerminalNode* MySqlParser::AlterByRenameColumnContext::TO() {
  return getToken(MySqlParser::TO, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::AlterByRenameColumnContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::AlterByRenameColumnContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

MySqlParser::AlterByRenameColumnContext::AlterByRenameColumnContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByRenameColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByRenameColumn(this);
}
void MySqlParser::AlterByRenameColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByRenameColumn(this);
}

std::any MySqlParser::AlterByRenameColumnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByRenameColumn(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByConvertCharsetContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByConvertCharsetContext::CONVERT() {
  return getToken(MySqlParser::CONVERT, 0);
}

tree::TerminalNode* MySqlParser::AlterByConvertCharsetContext::TO() {
  return getToken(MySqlParser::TO, 0);
}

MySqlParser::CharsetNameContext* MySqlParser::AlterByConvertCharsetContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByConvertCharsetContext::CHARSET() {
  return getToken(MySqlParser::CHARSET, 0);
}

tree::TerminalNode* MySqlParser::AlterByConvertCharsetContext::CHARACTER() {
  return getToken(MySqlParser::CHARACTER, 0);
}

tree::TerminalNode* MySqlParser::AlterByConvertCharsetContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::AlterByConvertCharsetContext::COLLATE() {
  return getToken(MySqlParser::COLLATE, 0);
}

MySqlParser::CollationNameContext* MySqlParser::AlterByConvertCharsetContext::collationName() {
  return getRuleContext<MySqlParser::CollationNameContext>(0);
}

MySqlParser::AlterByConvertCharsetContext::AlterByConvertCharsetContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByConvertCharsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByConvertCharset(this);
}
void MySqlParser::AlterByConvertCharsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByConvertCharset(this);
}

std::any MySqlParser::AlterByConvertCharsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByConvertCharset(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByAddForeignKeyContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAddForeignKeyContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddForeignKeyContext::FOREIGN() {
  return getToken(MySqlParser::FOREIGN, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddForeignKeyContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::IndexColumnNamesContext* MySqlParser::AlterByAddForeignKeyContext::indexColumnNames() {
  return getRuleContext<MySqlParser::IndexColumnNamesContext>(0);
}

MySqlParser::ReferenceDefinitionContext* MySqlParser::AlterByAddForeignKeyContext::referenceDefinition() {
  return getRuleContext<MySqlParser::ReferenceDefinitionContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAddForeignKeyContext::CONSTRAINT() {
  return getToken(MySqlParser::CONSTRAINT, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::AlterByAddForeignKeyContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::AlterByAddForeignKeyContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

MySqlParser::AlterByAddForeignKeyContext::AlterByAddForeignKeyContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAddForeignKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAddForeignKey(this);
}
void MySqlParser::AlterByAddForeignKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAddForeignKey(this);
}

std::any MySqlParser::AlterByAddForeignKeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAddForeignKey(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByRenameIndexContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByRenameIndexContext::RENAME() {
  return getToken(MySqlParser::RENAME, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::AlterByRenameIndexContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::AlterByRenameIndexContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

tree::TerminalNode* MySqlParser::AlterByRenameIndexContext::TO() {
  return getToken(MySqlParser::TO, 0);
}

tree::TerminalNode* MySqlParser::AlterByRenameIndexContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::AlterByRenameIndexContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::AlterByRenameIndexContext::AlterByRenameIndexContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByRenameIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByRenameIndex(this);
}
void MySqlParser::AlterByRenameIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByRenameIndex(this);
}

std::any MySqlParser::AlterByRenameIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByRenameIndex(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByRenameContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByRenameContext::RENAME() {
  return getToken(MySqlParser::RENAME, 0);
}

MySqlParser::UidContext* MySqlParser::AlterByRenameContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::FullIdContext* MySqlParser::AlterByRenameContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByRenameContext::TO() {
  return getToken(MySqlParser::TO, 0);
}

tree::TerminalNode* MySqlParser::AlterByRenameContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

MySqlParser::AlterByRenameContext::AlterByRenameContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByRenameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByRename(this);
}
void MySqlParser::AlterByRenameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByRename(this);
}

std::any MySqlParser::AlterByRenameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByRename(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByImportTablespaceContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByImportTablespaceContext::IMPORT() {
  return getToken(MySqlParser::IMPORT, 0);
}

tree::TerminalNode* MySqlParser::AlterByImportTablespaceContext::TABLESPACE() {
  return getToken(MySqlParser::TABLESPACE, 0);
}

MySqlParser::AlterByImportTablespaceContext::AlterByImportTablespaceContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByImportTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByImportTablespace(this);
}
void MySqlParser::AlterByImportTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByImportTablespace(this);
}

std::any MySqlParser::AlterByImportTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByImportTablespace(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByAddDefinitionsContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAddDefinitionsContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddDefinitionsContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::CreateDefinitionContext *> MySqlParser::AlterByAddDefinitionsContext::createDefinition() {
  return getRuleContexts<MySqlParser::CreateDefinitionContext>();
}

MySqlParser::CreateDefinitionContext* MySqlParser::AlterByAddDefinitionsContext::createDefinition(size_t i) {
  return getRuleContext<MySqlParser::CreateDefinitionContext>(i);
}

tree::TerminalNode* MySqlParser::AlterByAddDefinitionsContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddDefinitionsContext::COLUMN() {
  return getToken(MySqlParser::COLUMN, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterByAddDefinitionsContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::AlterByAddDefinitionsContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::AlterByAddDefinitionsContext::AlterByAddDefinitionsContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAddDefinitionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAddDefinitions(this);
}
void MySqlParser::AlterByAddDefinitionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAddDefinitions(this);
}

std::any MySqlParser::AlterByAddDefinitionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAddDefinitions(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByAlterCheckTableConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAlterCheckTableConstraintContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterByAlterCheckTableConstraintContext::CHECK() {
  return getToken(MySqlParser::CHECK, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::AlterByAlterCheckTableConstraintContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::AlterByAlterCheckTableConstraintContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

MySqlParser::StringLiteralContext* MySqlParser::AlterByAlterCheckTableConstraintContext::stringLiteral() {
  return getRuleContext<MySqlParser::StringLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAlterCheckTableConstraintContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ExpressionContext* MySqlParser::AlterByAlterCheckTableConstraintContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAlterCheckTableConstraintContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::AlterByAlterCheckTableConstraintContext::CONSTRAINT() {
  return getToken(MySqlParser::CONSTRAINT, 0);
}

tree::TerminalNode* MySqlParser::AlterByAlterCheckTableConstraintContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}

tree::TerminalNode* MySqlParser::AlterByAlterCheckTableConstraintContext::ENFORCED() {
  return getToken(MySqlParser::ENFORCED, 0);
}

MySqlParser::AlterByAlterCheckTableConstraintContext::AlterByAlterCheckTableConstraintContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAlterCheckTableConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAlterCheckTableConstraint(this);
}
void MySqlParser::AlterByAlterCheckTableConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAlterCheckTableConstraint(this);
}

std::any MySqlParser::AlterByAlterCheckTableConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAlterCheckTableConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByDropConstraintCheckContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByDropConstraintCheckContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

MySqlParser::UidContext* MySqlParser::AlterByDropConstraintCheckContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByDropConstraintCheckContext::CONSTRAINT() {
  return getToken(MySqlParser::CONSTRAINT, 0);
}

tree::TerminalNode* MySqlParser::AlterByDropConstraintCheckContext::CHECK() {
  return getToken(MySqlParser::CHECK, 0);
}

MySqlParser::AlterByDropConstraintCheckContext::AlterByDropConstraintCheckContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByDropConstraintCheckContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByDropConstraintCheck(this);
}
void MySqlParser::AlterByDropConstraintCheckContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByDropConstraintCheck(this);
}

std::any MySqlParser::AlterByDropConstraintCheckContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByDropConstraintCheck(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByAddColumnsContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAddColumnsContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddColumnsContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::AlterByAddColumnsContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::AlterByAddColumnsContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

std::vector<MySqlParser::ColumnDefinitionContext *> MySqlParser::AlterByAddColumnsContext::columnDefinition() {
  return getRuleContexts<MySqlParser::ColumnDefinitionContext>();
}

MySqlParser::ColumnDefinitionContext* MySqlParser::AlterByAddColumnsContext::columnDefinition(size_t i) {
  return getRuleContext<MySqlParser::ColumnDefinitionContext>(i);
}

tree::TerminalNode* MySqlParser::AlterByAddColumnsContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddColumnsContext::COLUMN() {
  return getToken(MySqlParser::COLUMN, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterByAddColumnsContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::AlterByAddColumnsContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::AlterByAddColumnsContext::AlterByAddColumnsContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAddColumnsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAddColumns(this);
}
void MySqlParser::AlterByAddColumnsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAddColumns(this);
}

std::any MySqlParser::AlterByAddColumnsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAddColumns(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByAlterIndexVisibilityContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAlterIndexVisibilityContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterByAlterIndexVisibilityContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

MySqlParser::UidContext* MySqlParser::AlterByAlterIndexVisibilityContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAlterIndexVisibilityContext::VISIBLE() {
  return getToken(MySqlParser::VISIBLE, 0);
}

tree::TerminalNode* MySqlParser::AlterByAlterIndexVisibilityContext::INVISIBLE() {
  return getToken(MySqlParser::INVISIBLE, 0);
}

MySqlParser::AlterByAlterIndexVisibilityContext::AlterByAlterIndexVisibilityContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAlterIndexVisibilityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAlterIndexVisibility(this);
}
void MySqlParser::AlterByAlterIndexVisibilityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAlterIndexVisibility(this);
}

std::any MySqlParser::AlterByAlterIndexVisibilityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAlterIndexVisibility(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByDropForeignKeyContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByDropForeignKeyContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::AlterByDropForeignKeyContext::FOREIGN() {
  return getToken(MySqlParser::FOREIGN, 0);
}

tree::TerminalNode* MySqlParser::AlterByDropForeignKeyContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::UidContext* MySqlParser::AlterByDropForeignKeyContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::AlterByDropForeignKeyContext::AlterByDropForeignKeyContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByDropForeignKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByDropForeignKey(this);
}
void MySqlParser::AlterByDropForeignKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByDropForeignKey(this);
}

std::any MySqlParser::AlterByDropForeignKeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByDropForeignKey(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByAddCheckTableConstraintContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAddCheckTableConstraintContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddCheckTableConstraintContext::CHECK() {
  return getToken(MySqlParser::CHECK, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::AlterByAddCheckTableConstraintContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::AlterByAddCheckTableConstraintContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

MySqlParser::StringLiteralContext* MySqlParser::AlterByAddCheckTableConstraintContext::stringLiteral() {
  return getRuleContext<MySqlParser::StringLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAddCheckTableConstraintContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ExpressionContext* MySqlParser::AlterByAddCheckTableConstraintContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAddCheckTableConstraintContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddCheckTableConstraintContext::CONSTRAINT() {
  return getToken(MySqlParser::CONSTRAINT, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddCheckTableConstraintContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddCheckTableConstraintContext::ENFORCED() {
  return getToken(MySqlParser::ENFORCED, 0);
}

MySqlParser::AlterByAddCheckTableConstraintContext::AlterByAddCheckTableConstraintContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAddCheckTableConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAddCheckTableConstraint(this);
}
void MySqlParser::AlterByAddCheckTableConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAddCheckTableConstraint(this);
}

std::any MySqlParser::AlterByAddCheckTableConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAddCheckTableConstraint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterPartitionContext ------------------------------------------------------------------

MySqlParser::AlterPartitionSpecificationContext* MySqlParser::AlterPartitionContext::alterPartitionSpecification() {
  return getRuleContext<MySqlParser::AlterPartitionSpecificationContext>(0);
}

MySqlParser::AlterPartitionContext::AlterPartitionContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterPartition(this);
}
void MySqlParser::AlterPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterPartition(this);
}

std::any MySqlParser::AlterPartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterPartition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByAddIndexContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAddIndexContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

MySqlParser::IndexColumnNamesContext* MySqlParser::AlterByAddIndexContext::indexColumnNames() {
  return getRuleContext<MySqlParser::IndexColumnNamesContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAddIndexContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddIndexContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::UidContext* MySqlParser::AlterByAddIndexContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::IndexTypeContext* MySqlParser::AlterByAddIndexContext::indexType() {
  return getRuleContext<MySqlParser::IndexTypeContext>(0);
}

std::vector<MySqlParser::IndexOptionContext *> MySqlParser::AlterByAddIndexContext::indexOption() {
  return getRuleContexts<MySqlParser::IndexOptionContext>();
}

MySqlParser::IndexOptionContext* MySqlParser::AlterByAddIndexContext::indexOption(size_t i) {
  return getRuleContext<MySqlParser::IndexOptionContext>(i);
}

MySqlParser::AlterByAddIndexContext::AlterByAddIndexContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAddIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAddIndex(this);
}
void MySqlParser::AlterByAddIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAddIndex(this);
}

std::any MySqlParser::AlterByAddIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAddIndex(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByDropColumnContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByDropColumnContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

MySqlParser::UidContext* MySqlParser::AlterByDropColumnContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByDropColumnContext::COLUMN() {
  return getToken(MySqlParser::COLUMN, 0);
}

tree::TerminalNode* MySqlParser::AlterByDropColumnContext::RESTRICT() {
  return getToken(MySqlParser::RESTRICT, 0);
}

MySqlParser::AlterByDropColumnContext::AlterByDropColumnContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByDropColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByDropColumn(this);
}
void MySqlParser::AlterByDropColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByDropColumn(this);
}

std::any MySqlParser::AlterByDropColumnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByDropColumn(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByChangeDefaultContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByChangeDefaultContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

MySqlParser::UidContext* MySqlParser::AlterByChangeDefaultContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByChangeDefaultContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::AlterByChangeDefaultContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

MySqlParser::DefaultValueContext* MySqlParser::AlterByChangeDefaultContext::defaultValue() {
  return getRuleContext<MySqlParser::DefaultValueContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByChangeDefaultContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::AlterByChangeDefaultContext::COLUMN() {
  return getToken(MySqlParser::COLUMN, 0);
}

MySqlParser::AlterByChangeDefaultContext::AlterByChangeDefaultContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByChangeDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByChangeDefault(this);
}
void MySqlParser::AlterByChangeDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByChangeDefault(this);
}

std::any MySqlParser::AlterByChangeDefaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByChangeDefault(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByForceContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByForceContext::FORCE() {
  return getToken(MySqlParser::FORCE, 0);
}

MySqlParser::AlterByForceContext::AlterByForceContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByForceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByForce(this);
}
void MySqlParser::AlterByForceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByForce(this);
}

std::any MySqlParser::AlterByForceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByForce(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByAddSpecialIndexContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAddSpecialIndexContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

MySqlParser::IndexColumnNamesContext* MySqlParser::AlterByAddSpecialIndexContext::indexColumnNames() {
  return getRuleContext<MySqlParser::IndexColumnNamesContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAddSpecialIndexContext::FULLTEXT() {
  return getToken(MySqlParser::FULLTEXT, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddSpecialIndexContext::SPATIAL() {
  return getToken(MySqlParser::SPATIAL, 0);
}

MySqlParser::UidContext* MySqlParser::AlterByAddSpecialIndexContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

std::vector<MySqlParser::IndexOptionContext *> MySqlParser::AlterByAddSpecialIndexContext::indexOption() {
  return getRuleContexts<MySqlParser::IndexOptionContext>();
}

MySqlParser::IndexOptionContext* MySqlParser::AlterByAddSpecialIndexContext::indexOption(size_t i) {
  return getRuleContext<MySqlParser::IndexOptionContext>(i);
}

tree::TerminalNode* MySqlParser::AlterByAddSpecialIndexContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddSpecialIndexContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::AlterByAddSpecialIndexContext::AlterByAddSpecialIndexContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAddSpecialIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAddSpecialIndex(this);
}
void MySqlParser::AlterByAddSpecialIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAddSpecialIndex(this);
}

std::any MySqlParser::AlterByAddSpecialIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAddSpecialIndex(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByModifyColumnContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByModifyColumnContext::MODIFY() {
  return getToken(MySqlParser::MODIFY, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::AlterByModifyColumnContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::AlterByModifyColumnContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

MySqlParser::ColumnDefinitionContext* MySqlParser::AlterByModifyColumnContext::columnDefinition() {
  return getRuleContext<MySqlParser::ColumnDefinitionContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByModifyColumnContext::COLUMN() {
  return getToken(MySqlParser::COLUMN, 0);
}

tree::TerminalNode* MySqlParser::AlterByModifyColumnContext::FIRST() {
  return getToken(MySqlParser::FIRST, 0);
}

tree::TerminalNode* MySqlParser::AlterByModifyColumnContext::AFTER() {
  return getToken(MySqlParser::AFTER, 0);
}

MySqlParser::AlterByModifyColumnContext::AlterByModifyColumnContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByModifyColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByModifyColumn(this);
}
void MySqlParser::AlterByModifyColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByModifyColumn(this);
}

std::any MySqlParser::AlterByModifyColumnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByModifyColumn(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByTableOptionContext ------------------------------------------------------------------

std::vector<MySqlParser::TableOptionContext *> MySqlParser::AlterByTableOptionContext::tableOption() {
  return getRuleContexts<MySqlParser::TableOptionContext>();
}

MySqlParser::TableOptionContext* MySqlParser::AlterByTableOptionContext::tableOption(size_t i) {
  return getRuleContext<MySqlParser::TableOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterByTableOptionContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::AlterByTableOptionContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::AlterByTableOptionContext::AlterByTableOptionContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByTableOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByTableOption(this);
}
void MySqlParser::AlterByTableOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByTableOption(this);
}

std::any MySqlParser::AlterByTableOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByTableOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByDropPrimaryKeyContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByDropPrimaryKeyContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::AlterByDropPrimaryKeyContext::PRIMARY() {
  return getToken(MySqlParser::PRIMARY, 0);
}

tree::TerminalNode* MySqlParser::AlterByDropPrimaryKeyContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::AlterByDropPrimaryKeyContext::AlterByDropPrimaryKeyContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByDropPrimaryKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByDropPrimaryKey(this);
}
void MySqlParser::AlterByDropPrimaryKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByDropPrimaryKey(this);
}

std::any MySqlParser::AlterByDropPrimaryKeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByDropPrimaryKey(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByLockContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByLockContext::LOCK() {
  return getToken(MySqlParser::LOCK, 0);
}

tree::TerminalNode* MySqlParser::AlterByLockContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::AlterByLockContext::NONE() {
  return getToken(MySqlParser::NONE, 0);
}

tree::TerminalNode* MySqlParser::AlterByLockContext::SHARED() {
  return getToken(MySqlParser::SHARED, 0);
}

tree::TerminalNode* MySqlParser::AlterByLockContext::EXCLUSIVE() {
  return getToken(MySqlParser::EXCLUSIVE, 0);
}

tree::TerminalNode* MySqlParser::AlterByLockContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::AlterByLockContext::AlterByLockContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByLockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByLock(this);
}
void MySqlParser::AlterByLockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByLock(this);
}

std::any MySqlParser::AlterByLockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByLock(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByDiscardTablespaceContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByDiscardTablespaceContext::DISCARD() {
  return getToken(MySqlParser::DISCARD, 0);
}

tree::TerminalNode* MySqlParser::AlterByDiscardTablespaceContext::TABLESPACE() {
  return getToken(MySqlParser::TABLESPACE, 0);
}

MySqlParser::AlterByDiscardTablespaceContext::AlterByDiscardTablespaceContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByDiscardTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByDiscardTablespace(this);
}
void MySqlParser::AlterByDiscardTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByDiscardTablespace(this);
}

std::any MySqlParser::AlterByDiscardTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByDiscardTablespace(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByValidateContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByValidateContext::VALIDATION() {
  return getToken(MySqlParser::VALIDATION, 0);
}

tree::TerminalNode* MySqlParser::AlterByValidateContext::WITHOUT() {
  return getToken(MySqlParser::WITHOUT, 0);
}

tree::TerminalNode* MySqlParser::AlterByValidateContext::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

MySqlParser::AlterByValidateContext::AlterByValidateContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByValidateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByValidate(this);
}
void MySqlParser::AlterByValidateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByValidate(this);
}

std::any MySqlParser::AlterByValidateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByValidate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByAddPrimaryKeyContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAddPrimaryKeyContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddPrimaryKeyContext::PRIMARY() {
  return getToken(MySqlParser::PRIMARY, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddPrimaryKeyContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::IndexColumnNamesContext* MySqlParser::AlterByAddPrimaryKeyContext::indexColumnNames() {
  return getRuleContext<MySqlParser::IndexColumnNamesContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAddPrimaryKeyContext::CONSTRAINT() {
  return getToken(MySqlParser::CONSTRAINT, 0);
}

MySqlParser::IndexTypeContext* MySqlParser::AlterByAddPrimaryKeyContext::indexType() {
  return getRuleContext<MySqlParser::IndexTypeContext>(0);
}

std::vector<MySqlParser::IndexOptionContext *> MySqlParser::AlterByAddPrimaryKeyContext::indexOption() {
  return getRuleContexts<MySqlParser::IndexOptionContext>();
}

MySqlParser::IndexOptionContext* MySqlParser::AlterByAddPrimaryKeyContext::indexOption(size_t i) {
  return getRuleContext<MySqlParser::IndexOptionContext>(i);
}

std::vector<MySqlParser::UidContext *> MySqlParser::AlterByAddPrimaryKeyContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::AlterByAddPrimaryKeyContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

MySqlParser::AlterByAddPrimaryKeyContext::AlterByAddPrimaryKeyContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAddPrimaryKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAddPrimaryKey(this);
}
void MySqlParser::AlterByAddPrimaryKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAddPrimaryKey(this);
}

std::any MySqlParser::AlterByAddPrimaryKeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAddPrimaryKey(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByEnableKeysContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByEnableKeysContext::ENABLE() {
  return getToken(MySqlParser::ENABLE, 0);
}

tree::TerminalNode* MySqlParser::AlterByEnableKeysContext::KEYS() {
  return getToken(MySqlParser::KEYS, 0);
}

MySqlParser::AlterByEnableKeysContext::AlterByEnableKeysContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByEnableKeysContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByEnableKeys(this);
}
void MySqlParser::AlterByEnableKeysContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByEnableKeys(this);
}

std::any MySqlParser::AlterByEnableKeysContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByEnableKeys(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterBySetAlgorithmContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterBySetAlgorithmContext::ALGORITHM() {
  return getToken(MySqlParser::ALGORITHM, 0);
}

tree::TerminalNode* MySqlParser::AlterBySetAlgorithmContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::AlterBySetAlgorithmContext::INSTANT() {
  return getToken(MySqlParser::INSTANT, 0);
}

tree::TerminalNode* MySqlParser::AlterBySetAlgorithmContext::INPLACE() {
  return getToken(MySqlParser::INPLACE, 0);
}

tree::TerminalNode* MySqlParser::AlterBySetAlgorithmContext::COPY() {
  return getToken(MySqlParser::COPY, 0);
}

tree::TerminalNode* MySqlParser::AlterBySetAlgorithmContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::AlterBySetAlgorithmContext::AlterBySetAlgorithmContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterBySetAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterBySetAlgorithm(this);
}
void MySqlParser::AlterBySetAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterBySetAlgorithm(this);
}

std::any MySqlParser::AlterBySetAlgorithmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterBySetAlgorithm(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByChangeColumnContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByChangeColumnContext::CHANGE() {
  return getToken(MySqlParser::CHANGE, 0);
}

MySqlParser::ColumnDefinitionContext* MySqlParser::AlterByChangeColumnContext::columnDefinition() {
  return getRuleContext<MySqlParser::ColumnDefinitionContext>(0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::AlterByChangeColumnContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::AlterByChangeColumnContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

tree::TerminalNode* MySqlParser::AlterByChangeColumnContext::COLUMN() {
  return getToken(MySqlParser::COLUMN, 0);
}

tree::TerminalNode* MySqlParser::AlterByChangeColumnContext::FIRST() {
  return getToken(MySqlParser::FIRST, 0);
}

tree::TerminalNode* MySqlParser::AlterByChangeColumnContext::AFTER() {
  return getToken(MySqlParser::AFTER, 0);
}

MySqlParser::AlterByChangeColumnContext::AlterByChangeColumnContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByChangeColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByChangeColumn(this);
}
void MySqlParser::AlterByChangeColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByChangeColumn(this);
}

std::any MySqlParser::AlterByChangeColumnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByChangeColumn(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByAddUniqueKeyContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAddUniqueKeyContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddUniqueKeyContext::UNIQUE() {
  return getToken(MySqlParser::UNIQUE, 0);
}

MySqlParser::IndexColumnNamesContext* MySqlParser::AlterByAddUniqueKeyContext::indexColumnNames() {
  return getRuleContext<MySqlParser::IndexColumnNamesContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAddUniqueKeyContext::CONSTRAINT() {
  return getToken(MySqlParser::CONSTRAINT, 0);
}

MySqlParser::IndexTypeContext* MySqlParser::AlterByAddUniqueKeyContext::indexType() {
  return getRuleContext<MySqlParser::IndexTypeContext>(0);
}

std::vector<MySqlParser::IndexOptionContext *> MySqlParser::AlterByAddUniqueKeyContext::indexOption() {
  return getRuleContexts<MySqlParser::IndexOptionContext>();
}

MySqlParser::IndexOptionContext* MySqlParser::AlterByAddUniqueKeyContext::indexOption(size_t i) {
  return getRuleContext<MySqlParser::IndexOptionContext>(i);
}

std::vector<MySqlParser::UidContext *> MySqlParser::AlterByAddUniqueKeyContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::AlterByAddUniqueKeyContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

tree::TerminalNode* MySqlParser::AlterByAddUniqueKeyContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddUniqueKeyContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::AlterByAddUniqueKeyContext::AlterByAddUniqueKeyContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAddUniqueKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAddUniqueKey(this);
}
void MySqlParser::AlterByAddUniqueKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAddUniqueKey(this);
}

std::any MySqlParser::AlterByAddUniqueKeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAddUniqueKey(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByDropIndexContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByDropIndexContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

MySqlParser::UidContext* MySqlParser::AlterByDropIndexContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByDropIndexContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::AlterByDropIndexContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

MySqlParser::AlterByDropIndexContext::AlterByDropIndexContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByDropIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByDropIndex(this);
}
void MySqlParser::AlterByDropIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByDropIndex(this);
}

std::any MySqlParser::AlterByDropIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByDropIndex(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByAddColumnContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAddColumnContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::AlterByAddColumnContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::AlterByAddColumnContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

MySqlParser::ColumnDefinitionContext* MySqlParser::AlterByAddColumnContext::columnDefinition() {
  return getRuleContext<MySqlParser::ColumnDefinitionContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAddColumnContext::COLUMN() {
  return getToken(MySqlParser::COLUMN, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddColumnContext::FIRST() {
  return getToken(MySqlParser::FIRST, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddColumnContext::AFTER() {
  return getToken(MySqlParser::AFTER, 0);
}

MySqlParser::AlterByAddColumnContext::AlterByAddColumnContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAddColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAddColumn(this);
}
void MySqlParser::AlterByAddColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAddColumn(this);
}

std::any MySqlParser::AlterByAddColumnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAddColumn(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByOrderContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByOrderContext::ORDER() {
  return getToken(MySqlParser::ORDER, 0);
}

tree::TerminalNode* MySqlParser::AlterByOrderContext::BY() {
  return getToken(MySqlParser::BY, 0);
}

MySqlParser::UidListContext* MySqlParser::AlterByOrderContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

MySqlParser::AlterByOrderContext::AlterByOrderContext(AlterSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByOrderContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByOrder(this);
}
void MySqlParser::AlterByOrderContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByOrder(this);
}

std::any MySqlParser::AlterByOrderContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByOrder(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::AlterSpecificationContext* MySqlParser::alterSpecification() {
  AlterSpecificationContext *_localctx = _tracker.createInstance<AlterSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 146, MySqlParser::RuleAlterSpecification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(2864);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 369, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByTableOptionContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(2513);
      tableOption();
      setState(2520);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 311, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2515);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::COMMA) {
            setState(2514);
            match(MySqlParser::COMMA);
          }
          setState(2517);
          tableOption(); 
        }
        setState(2522);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 311, _ctx);
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByAddColumnContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(2523);
      match(MySqlParser::ADD);
      setState(2525);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::COLUMN) {
        setState(2524);
        match(MySqlParser::COLUMN);
      }
      setState(2527);
      uid();
      setState(2528);
      columnDefinition();
      setState(2532);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::FIRST: {
          setState(2529);
          match(MySqlParser::FIRST);
          break;
        }

        case MySqlParser::AFTER: {
          setState(2530);
          match(MySqlParser::AFTER);
          setState(2531);
          uid();
          break;
        }

        case MySqlParser::EOF:
        case MySqlParser::ALTER:
        case MySqlParser::ANALYZE:
        case MySqlParser::CALL:
        case MySqlParser::CHANGE:
        case MySqlParser::CHECK:
        case MySqlParser::CREATE:
        case MySqlParser::DELETE:
        case MySqlParser::DESC:
        case MySqlParser::DESCRIBE:
        case MySqlParser::DROP:
        case MySqlParser::EXPLAIN:
        case MySqlParser::GET:
        case MySqlParser::GRANT:
        case MySqlParser::INSERT:
        case MySqlParser::KILL:
        case MySqlParser::LOAD:
        case MySqlParser::LOCK:
        case MySqlParser::OPTIMIZE:
        case MySqlParser::PARTITION:
        case MySqlParser::PURGE:
        case MySqlParser::RELEASE:
        case MySqlParser::RENAME:
        case MySqlParser::REPLACE:
        case MySqlParser::RESIGNAL:
        case MySqlParser::REVOKE:
        case MySqlParser::SELECT:
        case MySqlParser::SET:
        case MySqlParser::SHOW:
        case MySqlParser::SIGNAL:
        case MySqlParser::TABLE:
        case MySqlParser::UNLOCK:
        case MySqlParser::UPDATE:
        case MySqlParser::USE:
        case MySqlParser::VALUES:
        case MySqlParser::WITH:
        case MySqlParser::BEGIN:
        case MySqlParser::BINLOG:
        case MySqlParser::CACHE:
        case MySqlParser::CHECKSUM:
        case MySqlParser::COMMIT:
        case MySqlParser::DEALLOCATE:
        case MySqlParser::DO:
        case MySqlParser::FLUSH:
        case MySqlParser::HANDLER:
        case MySqlParser::HELP:
        case MySqlParser::INSTALL:
        case MySqlParser::PREPARE:
        case MySqlParser::REPAIR:
        case MySqlParser::RESET:
        case MySqlParser::ROLLBACK:
        case MySqlParser::SAVEPOINT:
        case MySqlParser::START:
        case MySqlParser::STOP:
        case MySqlParser::TRUNCATE:
        case MySqlParser::UNINSTALL:
        case MySqlParser::XA:
        case MySqlParser::EXECUTE:
        case MySqlParser::SHUTDOWN:
        case MySqlParser::MINUS:
        case MySqlParser::LR_BRACKET:
        case MySqlParser::COMMA:
        case MySqlParser::SEMI: {
          break;
        }

      default:
        break;
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByAddColumnsContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(2534);
      match(MySqlParser::ADD);
      setState(2536);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::COLUMN) {
        setState(2535);
        match(MySqlParser::COLUMN);
      }
      setState(2538);
      match(MySqlParser::LR_BRACKET);
      setState(2539);
      uid();
      setState(2540);
      columnDefinition();
      setState(2547);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(2541);
        match(MySqlParser::COMMA);
        setState(2542);
        uid();
        setState(2543);
        columnDefinition();
        setState(2549);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2550);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByAddIndexContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(2552);
      match(MySqlParser::ADD);
      setState(2553);
      antlrcpp::downCast<AlterByAddIndexContext *>(_localctx)->indexFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::INDEX

      || _la == MySqlParser::KEY)) {
        antlrcpp::downCast<AlterByAddIndexContext *>(_localctx)->indexFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2555);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
        setState(2554);
        uid();
      }
      setState(2558);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::USING) {
        setState(2557);
        indexType();
      }
      setState(2560);
      indexColumnNames();
      setState(2564);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2561);
          indexOption(); 
        }
        setState(2566);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx);
      }
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByAddPrimaryKeyContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(2567);
      match(MySqlParser::ADD);
      setState(2572);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::CONSTRAINT) {
        setState(2568);
        match(MySqlParser::CONSTRAINT);
        setState(2570);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx)) {
        case 1: {
          setState(2569);
          antlrcpp::downCast<AlterByAddPrimaryKeyContext *>(_localctx)->name = uid();
          break;
        }

        default:
          break;
        }
      }
      setState(2574);
      match(MySqlParser::PRIMARY);
      setState(2575);
      match(MySqlParser::KEY);
      setState(2577);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
        setState(2576);
        antlrcpp::downCast<AlterByAddPrimaryKeyContext *>(_localctx)->index = uid();
      }
      setState(2580);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::USING) {
        setState(2579);
        indexType();
      }
      setState(2582);
      indexColumnNames();
      setState(2586);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 323, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2583);
          indexOption(); 
        }
        setState(2588);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 323, _ctx);
      }
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByAddUniqueKeyContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(2589);
      match(MySqlParser::ADD);
      setState(2594);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::CONSTRAINT) {
        setState(2590);
        match(MySqlParser::CONSTRAINT);
        setState(2592);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
          setState(2591);
          antlrcpp::downCast<AlterByAddUniqueKeyContext *>(_localctx)->name = uid();
        }
      }
      setState(2596);
      match(MySqlParser::UNIQUE);
      setState(2598);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::INDEX

      || _la == MySqlParser::KEY) {
        setState(2597);
        antlrcpp::downCast<AlterByAddUniqueKeyContext *>(_localctx)->indexFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::INDEX

        || _la == MySqlParser::KEY)) {
          antlrcpp::downCast<AlterByAddUniqueKeyContext *>(_localctx)->indexFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(2601);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
        setState(2600);
        antlrcpp::downCast<AlterByAddUniqueKeyContext *>(_localctx)->indexName = uid();
      }
      setState(2604);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::USING) {
        setState(2603);
        indexType();
      }
      setState(2606);
      indexColumnNames();
      setState(2610);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 329, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2607);
          indexOption(); 
        }
        setState(2612);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 329, _ctx);
      }
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByAddSpecialIndexContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(2613);
      match(MySqlParser::ADD);
      setState(2614);
      antlrcpp::downCast<AlterByAddSpecialIndexContext *>(_localctx)->keyType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::FULLTEXT || _la == MySqlParser::SPATIAL)) {
        antlrcpp::downCast<AlterByAddSpecialIndexContext *>(_localctx)->keyType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2616);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::INDEX

      || _la == MySqlParser::KEY) {
        setState(2615);
        antlrcpp::downCast<AlterByAddSpecialIndexContext *>(_localctx)->indexFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::INDEX

        || _la == MySqlParser::KEY)) {
          antlrcpp::downCast<AlterByAddSpecialIndexContext *>(_localctx)->indexFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(2619);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
        setState(2618);
        uid();
      }
      setState(2621);
      indexColumnNames();
      setState(2625);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2622);
          indexOption(); 
        }
        setState(2627);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx);
      }
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByAddForeignKeyContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(2628);
      match(MySqlParser::ADD);
      setState(2633);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::CONSTRAINT) {
        setState(2629);
        match(MySqlParser::CONSTRAINT);
        setState(2631);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
          setState(2630);
          antlrcpp::downCast<AlterByAddForeignKeyContext *>(_localctx)->name = uid();
        }
      }
      setState(2635);
      match(MySqlParser::FOREIGN);
      setState(2636);
      match(MySqlParser::KEY);
      setState(2638);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
        setState(2637);
        antlrcpp::downCast<AlterByAddForeignKeyContext *>(_localctx)->indexName = uid();
      }
      setState(2640);
      indexColumnNames();
      setState(2641);
      referenceDefinition();
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByAddCheckTableConstraintContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(2643);
      match(MySqlParser::ADD);
      setState(2648);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::CONSTRAINT) {
        setState(2644);
        match(MySqlParser::CONSTRAINT);
        setState(2646);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
          setState(2645);
          antlrcpp::downCast<AlterByAddCheckTableConstraintContext *>(_localctx)->name = uid();
        }
      }
      setState(2650);
      match(MySqlParser::CHECK);
      setState(2657);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx)) {
      case 1: {
        setState(2651);
        uid();
        break;
      }

      case 2: {
        setState(2652);
        stringLiteral();
        break;
      }

      case 3: {
        setState(2653);
        match(MySqlParser::LR_BRACKET);
        setState(2654);
        expression(0);
        setState(2655);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
      setState(2660);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::NOT) {
        setState(2659);
        match(MySqlParser::NOT);
      }
      setState(2663);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::ENFORCED) {
        setState(2662);
        match(MySqlParser::ENFORCED);
      }
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByAlterCheckTableConstraintContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(2665);
      match(MySqlParser::ALTER);
      setState(2670);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::CONSTRAINT) {
        setState(2666);
        match(MySqlParser::CONSTRAINT);
        setState(2668);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
          setState(2667);
          antlrcpp::downCast<AlterByAlterCheckTableConstraintContext *>(_localctx)->name = uid();
        }
      }
      setState(2672);
      match(MySqlParser::CHECK);
      setState(2679);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
      case 1: {
        setState(2673);
        uid();
        break;
      }

      case 2: {
        setState(2674);
        stringLiteral();
        break;
      }

      case 3: {
        setState(2675);
        match(MySqlParser::LR_BRACKET);
        setState(2676);
        expression(0);
        setState(2677);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
      setState(2682);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::NOT) {
        setState(2681);
        match(MySqlParser::NOT);
      }
      setState(2685);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::ENFORCED) {
        setState(2684);
        match(MySqlParser::ENFORCED);
      }
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByAddCheckTableConstraintContext>(_localctx);
      enterOuterAlt(_localctx, 11);
      setState(2687);
      match(MySqlParser::ADD);
      setState(2692);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::CONSTRAINT) {
        setState(2688);
        match(MySqlParser::CONSTRAINT);
        setState(2690);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
          setState(2689);
          antlrcpp::downCast<AlterByAddCheckTableConstraintContext *>(_localctx)->name = uid();
        }
      }
      setState(2694);
      match(MySqlParser::CHECK);
      setState(2695);
      match(MySqlParser::LR_BRACKET);
      setState(2696);
      expression(0);
      setState(2697);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<MySqlParser::AlterBySetAlgorithmContext>(_localctx);
      enterOuterAlt(_localctx, 12);
      setState(2699);
      match(MySqlParser::ALGORITHM);
      setState(2701);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(2700);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(2703);
      antlrcpp::downCast<AlterBySetAlgorithmContext *>(_localctx)->algType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::COPY || _la == MySqlParser::INPLACE

      || _la == MySqlParser::INSTANT)) {
        antlrcpp::downCast<AlterBySetAlgorithmContext *>(_localctx)->algType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByChangeDefaultContext>(_localctx);
      enterOuterAlt(_localctx, 13);
      setState(2704);
      match(MySqlParser::ALTER);
      setState(2706);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::COLUMN) {
        setState(2705);
        match(MySqlParser::COLUMN);
      }
      setState(2708);
      uid();
      setState(2714);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::SET: {
          setState(2709);
          match(MySqlParser::SET);
          setState(2710);
          match(MySqlParser::DEFAULT);
          setState(2711);
          defaultValue();
          break;
        }

        case MySqlParser::DROP: {
          setState(2712);
          match(MySqlParser::DROP);
          setState(2713);
          match(MySqlParser::DEFAULT);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByChangeColumnContext>(_localctx);
      enterOuterAlt(_localctx, 14);
      setState(2716);
      match(MySqlParser::CHANGE);
      setState(2718);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::COLUMN) {
        setState(2717);
        match(MySqlParser::COLUMN);
      }
      setState(2720);
      antlrcpp::downCast<AlterByChangeColumnContext *>(_localctx)->oldColumn = uid();
      setState(2721);
      antlrcpp::downCast<AlterByChangeColumnContext *>(_localctx)->newColumn = uid();
      setState(2722);
      columnDefinition();
      setState(2726);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::FIRST: {
          setState(2723);
          match(MySqlParser::FIRST);
          break;
        }

        case MySqlParser::AFTER: {
          setState(2724);
          match(MySqlParser::AFTER);
          setState(2725);
          antlrcpp::downCast<AlterByChangeColumnContext *>(_localctx)->afterColumn = uid();
          break;
        }

        case MySqlParser::EOF:
        case MySqlParser::ALTER:
        case MySqlParser::ANALYZE:
        case MySqlParser::CALL:
        case MySqlParser::CHANGE:
        case MySqlParser::CHECK:
        case MySqlParser::CREATE:
        case MySqlParser::DELETE:
        case MySqlParser::DESC:
        case MySqlParser::DESCRIBE:
        case MySqlParser::DROP:
        case MySqlParser::EXPLAIN:
        case MySqlParser::GET:
        case MySqlParser::GRANT:
        case MySqlParser::INSERT:
        case MySqlParser::KILL:
        case MySqlParser::LOAD:
        case MySqlParser::LOCK:
        case MySqlParser::OPTIMIZE:
        case MySqlParser::PARTITION:
        case MySqlParser::PURGE:
        case MySqlParser::RELEASE:
        case MySqlParser::RENAME:
        case MySqlParser::REPLACE:
        case MySqlParser::RESIGNAL:
        case MySqlParser::REVOKE:
        case MySqlParser::SELECT:
        case MySqlParser::SET:
        case MySqlParser::SHOW:
        case MySqlParser::SIGNAL:
        case MySqlParser::TABLE:
        case MySqlParser::UNLOCK:
        case MySqlParser::UPDATE:
        case MySqlParser::USE:
        case MySqlParser::VALUES:
        case MySqlParser::WITH:
        case MySqlParser::BEGIN:
        case MySqlParser::BINLOG:
        case MySqlParser::CACHE:
        case MySqlParser::CHECKSUM:
        case MySqlParser::COMMIT:
        case MySqlParser::DEALLOCATE:
        case MySqlParser::DO:
        case MySqlParser::FLUSH:
        case MySqlParser::HANDLER:
        case MySqlParser::HELP:
        case MySqlParser::INSTALL:
        case MySqlParser::PREPARE:
        case MySqlParser::REPAIR:
        case MySqlParser::RESET:
        case MySqlParser::ROLLBACK:
        case MySqlParser::SAVEPOINT:
        case MySqlParser::START:
        case MySqlParser::STOP:
        case MySqlParser::TRUNCATE:
        case MySqlParser::UNINSTALL:
        case MySqlParser::XA:
        case MySqlParser::EXECUTE:
        case MySqlParser::SHUTDOWN:
        case MySqlParser::MINUS:
        case MySqlParser::LR_BRACKET:
        case MySqlParser::COMMA:
        case MySqlParser::SEMI: {
          break;
        }

      default:
        break;
      }
      break;
    }

    case 15: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByRenameColumnContext>(_localctx);
      enterOuterAlt(_localctx, 15);
      setState(2728);
      match(MySqlParser::RENAME);
      setState(2729);
      match(MySqlParser::COLUMN);
      setState(2730);
      antlrcpp::downCast<AlterByRenameColumnContext *>(_localctx)->oldColumn = uid();
      setState(2731);
      match(MySqlParser::TO);
      setState(2732);
      antlrcpp::downCast<AlterByRenameColumnContext *>(_localctx)->newColumn = uid();
      break;
    }

    case 16: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByLockContext>(_localctx);
      enterOuterAlt(_localctx, 16);
      setState(2734);
      match(MySqlParser::LOCK);
      setState(2736);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(2735);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(2738);
      antlrcpp::downCast<AlterByLockContext *>(_localctx)->lockType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::EXCLUSIVE || _la == MySqlParser::NONE || _la == MySqlParser::SHARED)) {
        antlrcpp::downCast<AlterByLockContext *>(_localctx)->lockType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 17: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByModifyColumnContext>(_localctx);
      enterOuterAlt(_localctx, 17);
      setState(2739);
      match(MySqlParser::MODIFY);
      setState(2741);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::COLUMN) {
        setState(2740);
        match(MySqlParser::COLUMN);
      }
      setState(2743);
      uid();
      setState(2744);
      columnDefinition();
      setState(2748);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::FIRST: {
          setState(2745);
          match(MySqlParser::FIRST);
          break;
        }

        case MySqlParser::AFTER: {
          setState(2746);
          match(MySqlParser::AFTER);
          setState(2747);
          uid();
          break;
        }

        case MySqlParser::EOF:
        case MySqlParser::ALTER:
        case MySqlParser::ANALYZE:
        case MySqlParser::CALL:
        case MySqlParser::CHANGE:
        case MySqlParser::CHECK:
        case MySqlParser::CREATE:
        case MySqlParser::DELETE:
        case MySqlParser::DESC:
        case MySqlParser::DESCRIBE:
        case MySqlParser::DROP:
        case MySqlParser::EXPLAIN:
        case MySqlParser::GET:
        case MySqlParser::GRANT:
        case MySqlParser::INSERT:
        case MySqlParser::KILL:
        case MySqlParser::LOAD:
        case MySqlParser::LOCK:
        case MySqlParser::OPTIMIZE:
        case MySqlParser::PARTITION:
        case MySqlParser::PURGE:
        case MySqlParser::RELEASE:
        case MySqlParser::RENAME:
        case MySqlParser::REPLACE:
        case MySqlParser::RESIGNAL:
        case MySqlParser::REVOKE:
        case MySqlParser::SELECT:
        case MySqlParser::SET:
        case MySqlParser::SHOW:
        case MySqlParser::SIGNAL:
        case MySqlParser::TABLE:
        case MySqlParser::UNLOCK:
        case MySqlParser::UPDATE:
        case MySqlParser::USE:
        case MySqlParser::VALUES:
        case MySqlParser::WITH:
        case MySqlParser::BEGIN:
        case MySqlParser::BINLOG:
        case MySqlParser::CACHE:
        case MySqlParser::CHECKSUM:
        case MySqlParser::COMMIT:
        case MySqlParser::DEALLOCATE:
        case MySqlParser::DO:
        case MySqlParser::FLUSH:
        case MySqlParser::HANDLER:
        case MySqlParser::HELP:
        case MySqlParser::INSTALL:
        case MySqlParser::PREPARE:
        case MySqlParser::REPAIR:
        case MySqlParser::RESET:
        case MySqlParser::ROLLBACK:
        case MySqlParser::SAVEPOINT:
        case MySqlParser::START:
        case MySqlParser::STOP:
        case MySqlParser::TRUNCATE:
        case MySqlParser::UNINSTALL:
        case MySqlParser::XA:
        case MySqlParser::EXECUTE:
        case MySqlParser::SHUTDOWN:
        case MySqlParser::MINUS:
        case MySqlParser::LR_BRACKET:
        case MySqlParser::COMMA:
        case MySqlParser::SEMI: {
          break;
        }

      default:
        break;
      }
      break;
    }

    case 18: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByDropColumnContext>(_localctx);
      enterOuterAlt(_localctx, 18);
      setState(2750);
      match(MySqlParser::DROP);
      setState(2752);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::COLUMN) {
        setState(2751);
        match(MySqlParser::COLUMN);
      }
      setState(2754);
      uid();
      setState(2756);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::RESTRICT) {
        setState(2755);
        match(MySqlParser::RESTRICT);
      }
      break;
    }

    case 19: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByDropConstraintCheckContext>(_localctx);
      enterOuterAlt(_localctx, 19);
      setState(2758);
      match(MySqlParser::DROP);
      setState(2759);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::CHECK

      || _la == MySqlParser::CONSTRAINT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2760);
      uid();
      break;
    }

    case 20: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByDropPrimaryKeyContext>(_localctx);
      enterOuterAlt(_localctx, 20);
      setState(2761);
      match(MySqlParser::DROP);
      setState(2762);
      match(MySqlParser::PRIMARY);
      setState(2763);
      match(MySqlParser::KEY);
      break;
    }

    case 21: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByDropIndexContext>(_localctx);
      enterOuterAlt(_localctx, 21);
      setState(2764);
      match(MySqlParser::DROP);
      setState(2765);
      antlrcpp::downCast<AlterByDropIndexContext *>(_localctx)->indexFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::INDEX

      || _la == MySqlParser::KEY)) {
        antlrcpp::downCast<AlterByDropIndexContext *>(_localctx)->indexFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2766);
      uid();
      break;
    }

    case 22: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByRenameIndexContext>(_localctx);
      enterOuterAlt(_localctx, 22);
      setState(2767);
      match(MySqlParser::RENAME);
      setState(2768);
      antlrcpp::downCast<AlterByRenameIndexContext *>(_localctx)->indexFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::INDEX

      || _la == MySqlParser::KEY)) {
        antlrcpp::downCast<AlterByRenameIndexContext *>(_localctx)->indexFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2769);
      uid();
      setState(2770);
      match(MySqlParser::TO);
      setState(2771);
      uid();
      break;
    }

    case 23: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByAlterColumnDefaultContext>(_localctx);
      enterOuterAlt(_localctx, 23);
      setState(2773);
      match(MySqlParser::ALTER);
      setState(2775);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::COLUMN) {
        setState(2774);
        match(MySqlParser::COLUMN);
      }
      setState(2777);
      uid();
      setState(2791);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 360, _ctx)) {
      case 1: {
        setState(2778);
        match(MySqlParser::SET);
        setState(2779);
        match(MySqlParser::DEFAULT);
        setState(2785);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::START_NATIONAL_STRING_LITERAL:
          case MySqlParser::STRING_LITERAL:
          case MySqlParser::STRING_CHARSET_NAME: {
            setState(2780);
            stringLiteral();
            break;
          }

          case MySqlParser::LR_BRACKET: {
            setState(2781);
            match(MySqlParser::LR_BRACKET);
            setState(2782);
            expression(0);
            setState(2783);
            match(MySqlParser::RR_BRACKET);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case 2: {
        setState(2787);
        match(MySqlParser::SET);
        setState(2788);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::INVISIBLE || _la == MySqlParser::VISIBLE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case 3: {
        setState(2789);
        match(MySqlParser::DROP);
        setState(2790);
        match(MySqlParser::DEFAULT);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 24: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByAlterIndexVisibilityContext>(_localctx);
      enterOuterAlt(_localctx, 24);
      setState(2793);
      match(MySqlParser::ALTER);
      setState(2794);
      match(MySqlParser::INDEX);
      setState(2795);
      uid();
      setState(2796);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::INVISIBLE || _la == MySqlParser::VISIBLE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 25: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByDropForeignKeyContext>(_localctx);
      enterOuterAlt(_localctx, 25);
      setState(2798);
      match(MySqlParser::DROP);
      setState(2799);
      match(MySqlParser::FOREIGN);
      setState(2800);
      match(MySqlParser::KEY);
      setState(2801);
      uid();
      break;
    }

    case 26: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByDisableKeysContext>(_localctx);
      enterOuterAlt(_localctx, 26);
      setState(2802);
      match(MySqlParser::DISABLE);
      setState(2803);
      match(MySqlParser::KEYS);
      break;
    }

    case 27: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByEnableKeysContext>(_localctx);
      enterOuterAlt(_localctx, 27);
      setState(2804);
      match(MySqlParser::ENABLE);
      setState(2805);
      match(MySqlParser::KEYS);
      break;
    }

    case 28: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByRenameContext>(_localctx);
      enterOuterAlt(_localctx, 28);
      setState(2806);
      match(MySqlParser::RENAME);
      setState(2808);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::AS || _la == MySqlParser::TO) {
        setState(2807);
        antlrcpp::downCast<AlterByRenameContext *>(_localctx)->renameFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::AS || _la == MySqlParser::TO)) {
          antlrcpp::downCast<AlterByRenameContext *>(_localctx)->renameFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(2812);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 362, _ctx)) {
      case 1: {
        setState(2810);
        uid();
        break;
      }

      case 2: {
        setState(2811);
        fullId();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 29: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByOrderContext>(_localctx);
      enterOuterAlt(_localctx, 29);
      setState(2814);
      match(MySqlParser::ORDER);
      setState(2815);
      match(MySqlParser::BY);
      setState(2816);
      uidList();
      break;
    }

    case 30: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByConvertCharsetContext>(_localctx);
      enterOuterAlt(_localctx, 30);
      setState(2817);
      match(MySqlParser::CONVERT);
      setState(2818);
      match(MySqlParser::TO);
      setState(2822);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::CHARSET: {
          setState(2819);
          match(MySqlParser::CHARSET);
          break;
        }

        case MySqlParser::CHARACTER: {
          setState(2820);
          match(MySqlParser::CHARACTER);
          setState(2821);
          match(MySqlParser::SET);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(2824);
      charsetName();
      setState(2827);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::COLLATE) {
        setState(2825);
        match(MySqlParser::COLLATE);
        setState(2826);
        collationName();
      }
      break;
    }

    case 31: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByDefaultCharsetContext>(_localctx);
      enterOuterAlt(_localctx, 31);
      setState(2830);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::DEFAULT) {
        setState(2829);
        match(MySqlParser::DEFAULT);
      }
      setState(2832);
      match(MySqlParser::CHARACTER);
      setState(2833);
      match(MySqlParser::SET);
      setState(2834);
      match(MySqlParser::EQUAL_SYMBOL);
      setState(2835);
      charsetName();
      setState(2839);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::COLLATE) {
        setState(2836);
        match(MySqlParser::COLLATE);
        setState(2837);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(2838);
        collationName();
      }
      break;
    }

    case 32: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByDiscardTablespaceContext>(_localctx);
      enterOuterAlt(_localctx, 32);
      setState(2841);
      match(MySqlParser::DISCARD);
      setState(2842);
      match(MySqlParser::TABLESPACE);
      break;
    }

    case 33: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByImportTablespaceContext>(_localctx);
      enterOuterAlt(_localctx, 33);
      setState(2843);
      match(MySqlParser::IMPORT);
      setState(2844);
      match(MySqlParser::TABLESPACE);
      break;
    }

    case 34: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByForceContext>(_localctx);
      enterOuterAlt(_localctx, 34);
      setState(2845);
      match(MySqlParser::FORCE);
      break;
    }

    case 35: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByValidateContext>(_localctx);
      enterOuterAlt(_localctx, 35);
      setState(2846);
      antlrcpp::downCast<AlterByValidateContext *>(_localctx)->validationFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::WITH || _la == MySqlParser::WITHOUT)) {
        antlrcpp::downCast<AlterByValidateContext *>(_localctx)->validationFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(2847);
      match(MySqlParser::VALIDATION);
      break;
    }

    case 36: {
      _localctx = _tracker.createInstance<MySqlParser::AlterByAddDefinitionsContext>(_localctx);
      enterOuterAlt(_localctx, 36);
      setState(2848);
      match(MySqlParser::ADD);
      setState(2850);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::COLUMN) {
        setState(2849);
        match(MySqlParser::COLUMN);
      }
      setState(2852);
      match(MySqlParser::LR_BRACKET);
      setState(2853);
      createDefinition();
      setState(2858);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(2854);
        match(MySqlParser::COMMA);
        setState(2855);
        createDefinition();
        setState(2860);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2861);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 37: {
      _localctx = _tracker.createInstance<MySqlParser::AlterPartitionContext>(_localctx);
      enterOuterAlt(_localctx, 37);
      setState(2863);
      alterPartitionSpecification();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterPartitionSpecificationContext ------------------------------------------------------------------

MySqlParser::AlterPartitionSpecificationContext::AlterPartitionSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::AlterPartitionSpecificationContext::getRuleIndex() const {
  return MySqlParser::RuleAlterPartitionSpecification;
}

void MySqlParser::AlterPartitionSpecificationContext::copyFrom(AlterPartitionSpecificationContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- AlterByImportPartitionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByImportPartitionContext::IMPORT() {
  return getToken(MySqlParser::IMPORT, 0);
}

tree::TerminalNode* MySqlParser::AlterByImportPartitionContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

tree::TerminalNode* MySqlParser::AlterByImportPartitionContext::TABLESPACE() {
  return getToken(MySqlParser::TABLESPACE, 0);
}

MySqlParser::UidListContext* MySqlParser::AlterByImportPartitionContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByImportPartitionContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

MySqlParser::AlterByImportPartitionContext::AlterByImportPartitionContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByImportPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByImportPartition(this);
}
void MySqlParser::AlterByImportPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByImportPartition(this);
}

std::any MySqlParser::AlterByImportPartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByImportPartition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByDropPartitionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByDropPartitionContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::AlterByDropPartitionContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::UidListContext* MySqlParser::AlterByDropPartitionContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

MySqlParser::AlterByDropPartitionContext::AlterByDropPartitionContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByDropPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByDropPartition(this);
}
void MySqlParser::AlterByDropPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByDropPartition(this);
}

std::any MySqlParser::AlterByDropPartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByDropPartition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByDiscardPartitionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByDiscardPartitionContext::DISCARD() {
  return getToken(MySqlParser::DISCARD, 0);
}

tree::TerminalNode* MySqlParser::AlterByDiscardPartitionContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

tree::TerminalNode* MySqlParser::AlterByDiscardPartitionContext::TABLESPACE() {
  return getToken(MySqlParser::TABLESPACE, 0);
}

MySqlParser::UidListContext* MySqlParser::AlterByDiscardPartitionContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByDiscardPartitionContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

MySqlParser::AlterByDiscardPartitionContext::AlterByDiscardPartitionContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByDiscardPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByDiscardPartition(this);
}
void MySqlParser::AlterByDiscardPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByDiscardPartition(this);
}

std::any MySqlParser::AlterByDiscardPartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByDiscardPartition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByAddPartitionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAddPartitionContext::ADD() {
  return getToken(MySqlParser::ADD, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddPartitionContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

tree::TerminalNode* MySqlParser::AlterByAddPartitionContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::PartitionDefinitionContext *> MySqlParser::AlterByAddPartitionContext::partitionDefinition() {
  return getRuleContexts<MySqlParser::PartitionDefinitionContext>();
}

MySqlParser::PartitionDefinitionContext* MySqlParser::AlterByAddPartitionContext::partitionDefinition(size_t i) {
  return getRuleContext<MySqlParser::PartitionDefinitionContext>(i);
}

tree::TerminalNode* MySqlParser::AlterByAddPartitionContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterByAddPartitionContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::AlterByAddPartitionContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::AlterByAddPartitionContext::AlterByAddPartitionContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAddPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAddPartition(this);
}
void MySqlParser::AlterByAddPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAddPartition(this);
}

std::any MySqlParser::AlterByAddPartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAddPartition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByRemovePartitioningContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByRemovePartitioningContext::REMOVE() {
  return getToken(MySqlParser::REMOVE, 0);
}

tree::TerminalNode* MySqlParser::AlterByRemovePartitioningContext::PARTITIONING() {
  return getToken(MySqlParser::PARTITIONING, 0);
}

MySqlParser::AlterByRemovePartitioningContext::AlterByRemovePartitioningContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByRemovePartitioningContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByRemovePartitioning(this);
}
void MySqlParser::AlterByRemovePartitioningContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByRemovePartitioning(this);
}

std::any MySqlParser::AlterByRemovePartitioningContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByRemovePartitioning(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByOptimizePartitionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByOptimizePartitionContext::OPTIMIZE() {
  return getToken(MySqlParser::OPTIMIZE, 0);
}

tree::TerminalNode* MySqlParser::AlterByOptimizePartitionContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::UidListContext* MySqlParser::AlterByOptimizePartitionContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByOptimizePartitionContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

MySqlParser::AlterByOptimizePartitionContext::AlterByOptimizePartitionContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByOptimizePartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByOptimizePartition(this);
}
void MySqlParser::AlterByOptimizePartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByOptimizePartition(this);
}

std::any MySqlParser::AlterByOptimizePartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByOptimizePartition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByCheckPartitionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByCheckPartitionContext::CHECK() {
  return getToken(MySqlParser::CHECK, 0);
}

tree::TerminalNode* MySqlParser::AlterByCheckPartitionContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::UidListContext* MySqlParser::AlterByCheckPartitionContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByCheckPartitionContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

MySqlParser::AlterByCheckPartitionContext::AlterByCheckPartitionContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByCheckPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByCheckPartition(this);
}
void MySqlParser::AlterByCheckPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByCheckPartition(this);
}

std::any MySqlParser::AlterByCheckPartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByCheckPartition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByCoalescePartitionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByCoalescePartitionContext::COALESCE() {
  return getToken(MySqlParser::COALESCE, 0);
}

tree::TerminalNode* MySqlParser::AlterByCoalescePartitionContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::AlterByCoalescePartitionContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

MySqlParser::AlterByCoalescePartitionContext::AlterByCoalescePartitionContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByCoalescePartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByCoalescePartition(this);
}
void MySqlParser::AlterByCoalescePartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByCoalescePartition(this);
}

std::any MySqlParser::AlterByCoalescePartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByCoalescePartition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByReorganizePartitionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByReorganizePartitionContext::REORGANIZE() {
  return getToken(MySqlParser::REORGANIZE, 0);
}

tree::TerminalNode* MySqlParser::AlterByReorganizePartitionContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::UidListContext* MySqlParser::AlterByReorganizePartitionContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByReorganizePartitionContext::INTO() {
  return getToken(MySqlParser::INTO, 0);
}

tree::TerminalNode* MySqlParser::AlterByReorganizePartitionContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::PartitionDefinitionContext *> MySqlParser::AlterByReorganizePartitionContext::partitionDefinition() {
  return getRuleContexts<MySqlParser::PartitionDefinitionContext>();
}

MySqlParser::PartitionDefinitionContext* MySqlParser::AlterByReorganizePartitionContext::partitionDefinition(size_t i) {
  return getRuleContext<MySqlParser::PartitionDefinitionContext>(i);
}

tree::TerminalNode* MySqlParser::AlterByReorganizePartitionContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterByReorganizePartitionContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::AlterByReorganizePartitionContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::AlterByReorganizePartitionContext::AlterByReorganizePartitionContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByReorganizePartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByReorganizePartition(this);
}
void MySqlParser::AlterByReorganizePartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByReorganizePartition(this);
}

std::any MySqlParser::AlterByReorganizePartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByReorganizePartition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByAnalyzePartitionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByAnalyzePartitionContext::ANALYZE() {
  return getToken(MySqlParser::ANALYZE, 0);
}

tree::TerminalNode* MySqlParser::AlterByAnalyzePartitionContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::UidListContext* MySqlParser::AlterByAnalyzePartitionContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByAnalyzePartitionContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

MySqlParser::AlterByAnalyzePartitionContext::AlterByAnalyzePartitionContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByAnalyzePartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByAnalyzePartition(this);
}
void MySqlParser::AlterByAnalyzePartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByAnalyzePartition(this);
}

std::any MySqlParser::AlterByAnalyzePartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByAnalyzePartition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByRebuildPartitionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByRebuildPartitionContext::REBUILD() {
  return getToken(MySqlParser::REBUILD, 0);
}

tree::TerminalNode* MySqlParser::AlterByRebuildPartitionContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::UidListContext* MySqlParser::AlterByRebuildPartitionContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByRebuildPartitionContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

MySqlParser::AlterByRebuildPartitionContext::AlterByRebuildPartitionContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByRebuildPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByRebuildPartition(this);
}
void MySqlParser::AlterByRebuildPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByRebuildPartition(this);
}

std::any MySqlParser::AlterByRebuildPartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByRebuildPartition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByUpgradePartitioningContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByUpgradePartitioningContext::UPGRADE() {
  return getToken(MySqlParser::UPGRADE, 0);
}

tree::TerminalNode* MySqlParser::AlterByUpgradePartitioningContext::PARTITIONING() {
  return getToken(MySqlParser::PARTITIONING, 0);
}

MySqlParser::AlterByUpgradePartitioningContext::AlterByUpgradePartitioningContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByUpgradePartitioningContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByUpgradePartitioning(this);
}
void MySqlParser::AlterByUpgradePartitioningContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByUpgradePartitioning(this);
}

std::any MySqlParser::AlterByUpgradePartitioningContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByUpgradePartitioning(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByTruncatePartitionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByTruncatePartitionContext::TRUNCATE() {
  return getToken(MySqlParser::TRUNCATE, 0);
}

tree::TerminalNode* MySqlParser::AlterByTruncatePartitionContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::UidListContext* MySqlParser::AlterByTruncatePartitionContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByTruncatePartitionContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

MySqlParser::AlterByTruncatePartitionContext::AlterByTruncatePartitionContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByTruncatePartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByTruncatePartition(this);
}
void MySqlParser::AlterByTruncatePartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByTruncatePartition(this);
}

std::any MySqlParser::AlterByTruncatePartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByTruncatePartition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByRepairPartitionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByRepairPartitionContext::REPAIR() {
  return getToken(MySqlParser::REPAIR, 0);
}

tree::TerminalNode* MySqlParser::AlterByRepairPartitionContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::UidListContext* MySqlParser::AlterByRepairPartitionContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByRepairPartitionContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

MySqlParser::AlterByRepairPartitionContext::AlterByRepairPartitionContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByRepairPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByRepairPartition(this);
}
void MySqlParser::AlterByRepairPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByRepairPartition(this);
}

std::any MySqlParser::AlterByRepairPartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByRepairPartition(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterByExchangePartitionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterByExchangePartitionContext::EXCHANGE() {
  return getToken(MySqlParser::EXCHANGE, 0);
}

tree::TerminalNode* MySqlParser::AlterByExchangePartitionContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

MySqlParser::UidContext* MySqlParser::AlterByExchangePartitionContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterByExchangePartitionContext::WITH() {
  return getTokens(MySqlParser::WITH);
}

tree::TerminalNode* MySqlParser::AlterByExchangePartitionContext::WITH(size_t i) {
  return getToken(MySqlParser::WITH, i);
}

tree::TerminalNode* MySqlParser::AlterByExchangePartitionContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

MySqlParser::TableNameContext* MySqlParser::AlterByExchangePartitionContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::AlterByExchangePartitionContext::VALIDATION() {
  return getToken(MySqlParser::VALIDATION, 0);
}

tree::TerminalNode* MySqlParser::AlterByExchangePartitionContext::WITHOUT() {
  return getToken(MySqlParser::WITHOUT, 0);
}

MySqlParser::AlterByExchangePartitionContext::AlterByExchangePartitionContext(AlterPartitionSpecificationContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterByExchangePartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterByExchangePartition(this);
}
void MySqlParser::AlterByExchangePartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterByExchangePartition(this);
}

std::any MySqlParser::AlterByExchangePartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterByExchangePartition(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::AlterPartitionSpecificationContext* MySqlParser::alterPartitionSpecification() {
  AlterPartitionSpecificationContext *_localctx = _tracker.createInstance<AlterPartitionSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 148, MySqlParser::RuleAlterPartitionSpecification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2964);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::ADD: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByAddPartitionContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(2866);
        match(MySqlParser::ADD);
        setState(2867);
        match(MySqlParser::PARTITION);
        setState(2868);
        match(MySqlParser::LR_BRACKET);
        setState(2869);
        partitionDefinition();
        setState(2874);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(2870);
          match(MySqlParser::COMMA);
          setState(2871);
          partitionDefinition();
          setState(2876);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2877);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      case MySqlParser::DROP: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByDropPartitionContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(2879);
        match(MySqlParser::DROP);
        setState(2880);
        match(MySqlParser::PARTITION);
        setState(2881);
        uidList();
        break;
      }

      case MySqlParser::DISCARD: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByDiscardPartitionContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(2882);
        match(MySqlParser::DISCARD);
        setState(2883);
        match(MySqlParser::PARTITION);
        setState(2886);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::ATTRIBUTE:
          case MySqlParser::BUCKETS:
          case MySqlParser::CONDITION:
          case MySqlParser::CURRENT:
          case MySqlParser::CURRENT_USER:
          case MySqlParser::DATABASE:
          case MySqlParser::DEFAULT:
          case MySqlParser::DIAGNOSTICS:
          case MySqlParser::EMPTY:
          case MySqlParser::ENFORCED:
          case MySqlParser::EXCEPT:
          case MySqlParser::GROUP:
          case MySqlParser::IF:
          case MySqlParser::IGNORED:
          case MySqlParser::INSERT:
          case MySqlParser::LATERAL:
          case MySqlParser::LEFT:
          case MySqlParser::NUMBER:
          case MySqlParser::OPTIONAL:
          case MySqlParser::ORDER:
          case MySqlParser::PRIMARY:
          case MySqlParser::REPLACE:
          case MySqlParser::RIGHT:
          case MySqlParser::SCHEMA:
          case MySqlParser::SKIP_QUERY_REWRITE:
          case MySqlParser::STACKED:
          case MySqlParser::DATE:
          case MySqlParser::TIME:
          case MySqlParser::TIMESTAMP:
          case MySqlParser::DATETIME:
          case MySqlParser::YEAR:
          case MySqlParser::BINARY:
          case MySqlParser::TEXT:
          case MySqlParser::ENUM:
          case MySqlParser::SERIAL:
          case MySqlParser::JSON_ARRAY:
          case MySqlParser::JSON_ARRAYAGG:
          case MySqlParser::JSON_ARRAY_APPEND:
          case MySqlParser::JSON_ARRAY_INSERT:
          case MySqlParser::JSON_CONTAINS:
          case MySqlParser::JSON_CONTAINS_PATH:
          case MySqlParser::JSON_DEPTH:
          case MySqlParser::JSON_EXTRACT:
          case MySqlParser::JSON_INSERT:
          case MySqlParser::JSON_KEYS:
          case MySqlParser::JSON_LENGTH:
          case MySqlParser::JSON_MERGE:
          case MySqlParser::JSON_MERGE_PATCH:
          case MySqlParser::JSON_MERGE_PRESERVE:
          case MySqlParser::JSON_OBJECT:
          case MySqlParser::JSON_OBJECTAGG:
          case MySqlParser::JSON_OVERLAPS:
          case MySqlParser::JSON_PRETTY:
          case MySqlParser::JSON_QUOTE:
          case MySqlParser::JSON_REMOVE:
          case MySqlParser::JSON_REPLACE:
          case MySqlParser::JSON_SCHEMA_VALID:
          case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
          case MySqlParser::JSON_SEARCH:
          case MySqlParser::JSON_SET:
          case MySqlParser::JSON_STORAGE_FREE:
          case MySqlParser::JSON_STORAGE_SIZE:
          case MySqlParser::JSON_TABLE:
          case MySqlParser::JSON_TYPE:
          case MySqlParser::JSON_UNQUOTE:
          case MySqlParser::JSON_VALID:
          case MySqlParser::JSON_VALUE:
          case MySqlParser::NESTED:
          case MySqlParser::ORDINALITY:
          case MySqlParser::PATH:
          case MySqlParser::AVG:
          case MySqlParser::BIT_AND:
          case MySqlParser::BIT_OR:
          case MySqlParser::BIT_XOR:
          case MySqlParser::COUNT:
          case MySqlParser::CUME_DIST:
          case MySqlParser::DENSE_RANK:
          case MySqlParser::FIRST_VALUE:
          case MySqlParser::GROUP_CONCAT:
          case MySqlParser::LAG:
          case MySqlParser::LAST_VALUE:
          case MySqlParser::LEAD:
          case MySqlParser::MAX:
          case MySqlParser::MIN:
          case MySqlParser::NTILE:
          case MySqlParser::NTH_VALUE:
          case MySqlParser::PERCENT_RANK:
          case MySqlParser::RANK:
          case MySqlParser::ROW_NUMBER:
          case MySqlParser::STD:
          case MySqlParser::STDDEV:
          case MySqlParser::STDDEV_POP:
          case MySqlParser::STDDEV_SAMP:
          case MySqlParser::SUM:
          case MySqlParser::VAR_POP:
          case MySqlParser::VAR_SAMP:
          case MySqlParser::VARIANCE:
          case MySqlParser::CURRENT_DATE:
          case MySqlParser::CURRENT_TIME:
          case MySqlParser::CURRENT_TIMESTAMP:
          case MySqlParser::LOCALTIME:
          case MySqlParser::CURDATE:
          case MySqlParser::CURTIME:
          case MySqlParser::DATE_ADD:
          case MySqlParser::DATE_SUB:
          case MySqlParser::LOCALTIMESTAMP:
          case MySqlParser::NOW:
          case MySqlParser::POSITION:
          case MySqlParser::SUBSTR:
          case MySqlParser::SUBSTRING:
          case MySqlParser::SYSDATE:
          case MySqlParser::TRIM:
          case MySqlParser::UTC_DATE:
          case MySqlParser::UTC_TIME:
          case MySqlParser::UTC_TIMESTAMP:
          case MySqlParser::ACCOUNT:
          case MySqlParser::ACTION:
          case MySqlParser::AFTER:
          case MySqlParser::AGGREGATE:
          case MySqlParser::ALGORITHM:
          case MySqlParser::ANY:
          case MySqlParser::AT:
          case MySqlParser::AUTHORS:
          case MySqlParser::AUTOCOMMIT:
          case MySqlParser::AUTOEXTEND_SIZE:
          case MySqlParser::AUTO_INCREMENT:
          case MySqlParser::AVG_ROW_LENGTH:
          case MySqlParser::BEGIN:
          case MySqlParser::BINLOG:
          case MySqlParser::BIT:
          case MySqlParser::BLOCK:
          case MySqlParser::BOOL:
          case MySqlParser::BOOLEAN:
          case MySqlParser::BTREE:
          case MySqlParser::CACHE:
          case MySqlParser::CASCADED:
          case MySqlParser::CHAIN:
          case MySqlParser::CHANGED:
          case MySqlParser::CHANNEL:
          case MySqlParser::CHECKSUM:
          case MySqlParser::PAGE_CHECKSUM:
          case MySqlParser::CIPHER:
          case MySqlParser::CLASS_ORIGIN:
          case MySqlParser::CLIENT:
          case MySqlParser::CLOSE:
          case MySqlParser::CLUSTERING:
          case MySqlParser::COALESCE:
          case MySqlParser::CODE:
          case MySqlParser::COLUMNS:
          case MySqlParser::COLUMN_FORMAT:
          case MySqlParser::COLUMN_NAME:
          case MySqlParser::COMMENT:
          case MySqlParser::COMMIT:
          case MySqlParser::COMPACT:
          case MySqlParser::COMPLETION:
          case MySqlParser::COMPRESSED:
          case MySqlParser::COMPRESSION:
          case MySqlParser::CONCURRENT:
          case MySqlParser::CONNECT:
          case MySqlParser::CONNECTION:
          case MySqlParser::CONSISTENT:
          case MySqlParser::CONSTRAINT_CATALOG:
          case MySqlParser::CONSTRAINT_SCHEMA:
          case MySqlParser::CONSTRAINT_NAME:
          case MySqlParser::CONTAINS:
          case MySqlParser::CONTEXT:
          case MySqlParser::CONTRIBUTORS:
          case MySqlParser::COPY:
          case MySqlParser::CPU:
          case MySqlParser::CURSOR_NAME:
          case MySqlParser::DATA:
          case MySqlParser::DATAFILE:
          case MySqlParser::DEALLOCATE:
          case MySqlParser::DEFAULT_AUTH:
          case MySqlParser::DEFINER:
          case MySqlParser::DELAY_KEY_WRITE:
          case MySqlParser::DES_KEY_FILE:
          case MySqlParser::DIRECTORY:
          case MySqlParser::DISABLE:
          case MySqlParser::DISCARD:
          case MySqlParser::DISK:
          case MySqlParser::DO:
          case MySqlParser::DUMPFILE:
          case MySqlParser::DUPLICATE:
          case MySqlParser::DYNAMIC:
          case MySqlParser::ENABLE:
          case MySqlParser::ENCRYPTION:
          case MySqlParser::END:
          case MySqlParser::ENDS:
          case MySqlParser::ENGINE:
          case MySqlParser::ENGINES:
          case MySqlParser::ERROR:
          case MySqlParser::ERRORS:
          case MySqlParser::ESCAPE:
          case MySqlParser::EVEN:
          case MySqlParser::EVENT:
          case MySqlParser::EVENTS:
          case MySqlParser::EVERY:
          case MySqlParser::EXCHANGE:
          case MySqlParser::EXCLUSIVE:
          case MySqlParser::EXPIRE:
          case MySqlParser::EXPORT:
          case MySqlParser::EXTENDED:
          case MySqlParser::EXTENT_SIZE:
          case MySqlParser::FAILED_LOGIN_ATTEMPTS:
          case MySqlParser::FAST:
          case MySqlParser::FAULTS:
          case MySqlParser::FIELDS:
          case MySqlParser::FILE_BLOCK_SIZE:
          case MySqlParser::FILTER:
          case MySqlParser::FIRST:
          case MySqlParser::FIXED:
          case MySqlParser::FLUSH:
          case MySqlParser::FOLLOWS:
          case MySqlParser::FOUND:
          case MySqlParser::FULL:
          case MySqlParser::FUNCTION:
          case MySqlParser::GENERAL:
          case MySqlParser::GLOBAL:
          case MySqlParser::GRANTS:
          case MySqlParser::GROUP_REPLICATION:
          case MySqlParser::HANDLER:
          case MySqlParser::HASH:
          case MySqlParser::HELP:
          case MySqlParser::HISTORY:
          case MySqlParser::HOST:
          case MySqlParser::HOSTS:
          case MySqlParser::IDENTIFIED:
          case MySqlParser::IGNORE_SERVER_IDS:
          case MySqlParser::IMPORT:
          case MySqlParser::INDEXES:
          case MySqlParser::INITIAL_SIZE:
          case MySqlParser::INPLACE:
          case MySqlParser::INSERT_METHOD:
          case MySqlParser::INSTALL:
          case MySqlParser::INSTANCE:
          case MySqlParser::INSTANT:
          case MySqlParser::INVISIBLE:
          case MySqlParser::INVOKER:
          case MySqlParser::IO:
          case MySqlParser::IO_THREAD:
          case MySqlParser::IPC:
          case MySqlParser::ISOLATION:
          case MySqlParser::ISSUER:
          case MySqlParser::JSON:
          case MySqlParser::KEY_BLOCK_SIZE:
          case MySqlParser::LANGUAGE:
          case MySqlParser::LAST:
          case MySqlParser::LEAVES:
          case MySqlParser::LESS:
          case MySqlParser::LEVEL:
          case MySqlParser::LIST:
          case MySqlParser::LOCAL:
          case MySqlParser::LOGFILE:
          case MySqlParser::LOGS:
          case MySqlParser::MASTER:
          case MySqlParser::MASTER_AUTO_POSITION:
          case MySqlParser::MASTER_CONNECT_RETRY:
          case MySqlParser::MASTER_DELAY:
          case MySqlParser::MASTER_HEARTBEAT_PERIOD:
          case MySqlParser::MASTER_HOST:
          case MySqlParser::MASTER_LOG_FILE:
          case MySqlParser::MASTER_LOG_POS:
          case MySqlParser::MASTER_PASSWORD:
          case MySqlParser::MASTER_PORT:
          case MySqlParser::MASTER_RETRY_COUNT:
          case MySqlParser::MASTER_SSL:
          case MySqlParser::MASTER_SSL_CA:
          case MySqlParser::MASTER_SSL_CAPATH:
          case MySqlParser::MASTER_SSL_CERT:
          case MySqlParser::MASTER_SSL_CIPHER:
          case MySqlParser::MASTER_SSL_CRL:
          case MySqlParser::MASTER_SSL_CRLPATH:
          case MySqlParser::MASTER_SSL_KEY:
          case MySqlParser::MASTER_TLS_VERSION:
          case MySqlParser::MASTER_USER:
          case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
          case MySqlParser::MAX_QUERIES_PER_HOUR:
          case MySqlParser::MAX_ROWS:
          case MySqlParser::MAX_SIZE:
          case MySqlParser::MAX_UPDATES_PER_HOUR:
          case MySqlParser::MAX_USER_CONNECTIONS:
          case MySqlParser::MEDIUM:
          case MySqlParser::MEMBER:
          case MySqlParser::MERGE:
          case MySqlParser::MESSAGE_TEXT:
          case MySqlParser::MID:
          case MySqlParser::MIGRATE:
          case MySqlParser::MIN_ROWS:
          case MySqlParser::MODE:
          case MySqlParser::MODIFY:
          case MySqlParser::MUTEX:
          case MySqlParser::MYSQL:
          case MySqlParser::MYSQL_ERRNO:
          case MySqlParser::NAME:
          case MySqlParser::NAMES:
          case MySqlParser::NCHAR:
          case MySqlParser::NEVER:
          case MySqlParser::NEXT:
          case MySqlParser::NO:
          case MySqlParser::NOCOPY:
          case MySqlParser::NOWAIT:
          case MySqlParser::NODEGROUP:
          case MySqlParser::NONE:
          case MySqlParser::ODBC:
          case MySqlParser::OFFLINE:
          case MySqlParser::OFFSET:
          case MySqlParser::OF:
          case MySqlParser::OJ:
          case MySqlParser::OLD_PASSWORD:
          case MySqlParser::ONE:
          case MySqlParser::ONLINE:
          case MySqlParser::ONLY:
          case MySqlParser::OPEN:
          case MySqlParser::OPTIMIZER_COSTS:
          case MySqlParser::OPTIONS:
          case MySqlParser::OWNER:
          case MySqlParser::PACK_KEYS:
          case MySqlParser::PAGE:
          case MySqlParser::PARSER:
          case MySqlParser::PARTIAL:
          case MySqlParser::PARTITIONING:
          case MySqlParser::PARTITIONS:
          case MySqlParser::PASSWORD:
          case MySqlParser::PASSWORD_LOCK_TIME:
          case MySqlParser::PHASE:
          case MySqlParser::PLUGIN:
          case MySqlParser::PLUGIN_DIR:
          case MySqlParser::PLUGINS:
          case MySqlParser::PORT:
          case MySqlParser::PRECEDES:
          case MySqlParser::PREPARE:
          case MySqlParser::PRESERVE:
          case MySqlParser::PREV:
          case MySqlParser::PROCESSLIST:
          case MySqlParser::PROFILE:
          case MySqlParser::PROFILES:
          case MySqlParser::PROXY:
          case MySqlParser::QUERY:
          case MySqlParser::QUICK:
          case MySqlParser::REBUILD:
          case MySqlParser::RECOVER:
          case MySqlParser::RECURSIVE:
          case MySqlParser::REDO_BUFFER_SIZE:
          case MySqlParser::REDUNDANT:
          case MySqlParser::RELAY:
          case MySqlParser::RELAY_LOG_FILE:
          case MySqlParser::RELAY_LOG_POS:
          case MySqlParser::RELAYLOG:
          case MySqlParser::REMOVE:
          case MySqlParser::REORGANIZE:
          case MySqlParser::REPAIR:
          case MySqlParser::REPLICATE_DO_DB:
          case MySqlParser::REPLICATE_DO_TABLE:
          case MySqlParser::REPLICATE_IGNORE_DB:
          case MySqlParser::REPLICATE_IGNORE_TABLE:
          case MySqlParser::REPLICATE_REWRITE_DB:
          case MySqlParser::REPLICATE_WILD_DO_TABLE:
          case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
          case MySqlParser::REPLICATION:
          case MySqlParser::RESET:
          case MySqlParser::RESUME:
          case MySqlParser::RETURNED_SQLSTATE:
          case MySqlParser::RETURNS:
          case MySqlParser::REUSE:
          case MySqlParser::ROLE:
          case MySqlParser::ROLLBACK:
          case MySqlParser::ROLLUP:
          case MySqlParser::ROTATE:
          case MySqlParser::ROW:
          case MySqlParser::ROWS:
          case MySqlParser::ROW_FORMAT:
          case MySqlParser::RTREE:
          case MySqlParser::SAVEPOINT:
          case MySqlParser::SCHEDULE:
          case MySqlParser::SECURITY:
          case MySqlParser::SERVER:
          case MySqlParser::SESSION:
          case MySqlParser::SHARE:
          case MySqlParser::SHARED:
          case MySqlParser::SIGNED:
          case MySqlParser::SIMPLE:
          case MySqlParser::SLAVE:
          case MySqlParser::SLOW:
          case MySqlParser::SNAPSHOT:
          case MySqlParser::SOCKET:
          case MySqlParser::SOME:
          case MySqlParser::SONAME:
          case MySqlParser::SOUNDS:
          case MySqlParser::SOURCE:
          case MySqlParser::SQL_AFTER_GTIDS:
          case MySqlParser::SQL_AFTER_MTS_GAPS:
          case MySqlParser::SQL_BEFORE_GTIDS:
          case MySqlParser::SQL_BUFFER_RESULT:
          case MySqlParser::SQL_CACHE:
          case MySqlParser::SQL_NO_CACHE:
          case MySqlParser::SQL_THREAD:
          case MySqlParser::START:
          case MySqlParser::STARTS:
          case MySqlParser::STATS_AUTO_RECALC:
          case MySqlParser::STATS_PERSISTENT:
          case MySqlParser::STATS_SAMPLE_PAGES:
          case MySqlParser::STATUS:
          case MySqlParser::STOP:
          case MySqlParser::STORAGE:
          case MySqlParser::STRING:
          case MySqlParser::SUBCLASS_ORIGIN:
          case MySqlParser::SUBJECT:
          case MySqlParser::SUBPARTITION:
          case MySqlParser::SUBPARTITIONS:
          case MySqlParser::SUSPEND:
          case MySqlParser::SWAPS:
          case MySqlParser::SWITCHES:
          case MySqlParser::TABLE_NAME:
          case MySqlParser::TABLESPACE:
          case MySqlParser::TABLE_TYPE:
          case MySqlParser::TEMPORARY:
          case MySqlParser::TEMPTABLE:
          case MySqlParser::THAN:
          case MySqlParser::TRADITIONAL:
          case MySqlParser::TRANSACTION:
          case MySqlParser::TRANSACTIONAL:
          case MySqlParser::TRIGGERS:
          case MySqlParser::TRUNCATE:
          case MySqlParser::UNBOUNDED:
          case MySqlParser::UNDEFINED:
          case MySqlParser::UNDOFILE:
          case MySqlParser::UNDO_BUFFER_SIZE:
          case MySqlParser::UNINSTALL:
          case MySqlParser::UNKNOWN:
          case MySqlParser::UNTIL:
          case MySqlParser::UPGRADE:
          case MySqlParser::USER:
          case MySqlParser::USE_FRM:
          case MySqlParser::USER_RESOURCES:
          case MySqlParser::VALIDATION:
          case MySqlParser::VALUE:
          case MySqlParser::VARIABLES:
          case MySqlParser::VIEW:
          case MySqlParser::VIRTUAL:
          case MySqlParser::VISIBLE:
          case MySqlParser::WAIT:
          case MySqlParser::WARNINGS:
          case MySqlParser::WITHOUT:
          case MySqlParser::WORK:
          case MySqlParser::WRAPPER:
          case MySqlParser::X509:
          case MySqlParser::XA:
          case MySqlParser::XML:
          case MySqlParser::EUR:
          case MySqlParser::USA:
          case MySqlParser::JIS:
          case MySqlParser::ISO:
          case MySqlParser::INTERNAL:
          case MySqlParser::QUARTER:
          case MySqlParser::MONTH:
          case MySqlParser::DAY:
          case MySqlParser::HOUR:
          case MySqlParser::MINUTE:
          case MySqlParser::WEEK:
          case MySqlParser::SECOND:
          case MySqlParser::MICROSECOND:
          case MySqlParser::ADMIN:
          case MySqlParser::AUDIT_ABORT_EXEMPT:
          case MySqlParser::AUDIT_ADMIN:
          case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
          case MySqlParser::BACKUP_ADMIN:
          case MySqlParser::BINLOG_ADMIN:
          case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
          case MySqlParser::CLONE_ADMIN:
          case MySqlParser::CONNECTION_ADMIN:
          case MySqlParser::ENCRYPTION_KEY_ADMIN:
          case MySqlParser::EXECUTE:
          case MySqlParser::FILE:
          case MySqlParser::FIREWALL_ADMIN:
          case MySqlParser::FIREWALL_EXEMPT:
          case MySqlParser::FIREWALL_USER:
          case MySqlParser::GROUP_REPLICATION_ADMIN:
          case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
          case MySqlParser::INVOKE:
          case MySqlParser::LAMBDA:
          case MySqlParser::NDB_STORED_USER:
          case MySqlParser::PASSWORDLESS_USER_ADMIN:
          case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
          case MySqlParser::PRIVILEGES:
          case MySqlParser::PROCESS:
          case MySqlParser::RELOAD:
          case MySqlParser::REPLICATION_APPLIER:
          case MySqlParser::REPLICATION_SLAVE_ADMIN:
          case MySqlParser::RESOURCE_GROUP_ADMIN:
          case MySqlParser::RESOURCE_GROUP_USER:
          case MySqlParser::ROLE_ADMIN:
          case MySqlParser::ROUTINE:
          case MySqlParser::S3:
          case MySqlParser::SESSION_VARIABLES_ADMIN:
          case MySqlParser::SET_USER_ID:
          case MySqlParser::SHOW_ROUTINE:
          case MySqlParser::SHUTDOWN:
          case MySqlParser::SUPER:
          case MySqlParser::SYSTEM_VARIABLES_ADMIN:
          case MySqlParser::TABLES:
          case MySqlParser::TABLE_ENCRYPTION_ADMIN:
          case MySqlParser::VERSION_TOKEN_ADMIN:
          case MySqlParser::XA_RECOVER_ADMIN:
          case MySqlParser::ARMSCII8:
          case MySqlParser::ASCII:
          case MySqlParser::BIG5:
          case MySqlParser::CP1250:
          case MySqlParser::CP1251:
          case MySqlParser::CP1256:
          case MySqlParser::CP1257:
          case MySqlParser::CP850:
          case MySqlParser::CP852:
          case MySqlParser::CP866:
          case MySqlParser::CP932:
          case MySqlParser::DEC8:
          case MySqlParser::EUCJPMS:
          case MySqlParser::EUCKR:
          case MySqlParser::GB18030:
          case MySqlParser::GB2312:
          case MySqlParser::GBK:
          case MySqlParser::GEOSTD8:
          case MySqlParser::GREEK:
          case MySqlParser::HEBREW:
          case MySqlParser::HP8:
          case MySqlParser::KEYBCS2:
          case MySqlParser::KOI8R:
          case MySqlParser::KOI8U:
          case MySqlParser::LATIN1:
          case MySqlParser::LATIN2:
          case MySqlParser::LATIN5:
          case MySqlParser::LATIN7:
          case MySqlParser::MACCE:
          case MySqlParser::MACROMAN:
          case MySqlParser::SJIS:
          case MySqlParser::SWE7:
          case MySqlParser::TIS620:
          case MySqlParser::UCS2:
          case MySqlParser::UJIS:
          case MySqlParser::UTF16:
          case MySqlParser::UTF16LE:
          case MySqlParser::UTF32:
          case MySqlParser::UTF8:
          case MySqlParser::UTF8MB3:
          case MySqlParser::UTF8MB4:
          case MySqlParser::ARCHIVE:
          case MySqlParser::BLACKHOLE:
          case MySqlParser::CSV:
          case MySqlParser::FEDERATED:
          case MySqlParser::INNODB:
          case MySqlParser::MEMORY:
          case MySqlParser::MRG_MYISAM:
          case MySqlParser::MYISAM:
          case MySqlParser::NDB:
          case MySqlParser::NDBCLUSTER:
          case MySqlParser::PERFORMANCE_SCHEMA:
          case MySqlParser::TOKUDB:
          case MySqlParser::REPEATABLE:
          case MySqlParser::COMMITTED:
          case MySqlParser::UNCOMMITTED:
          case MySqlParser::SERIALIZABLE:
          case MySqlParser::GEOMETRYCOLLECTION:
          case MySqlParser::LINESTRING:
          case MySqlParser::MULTILINESTRING:
          case MySqlParser::MULTIPOINT:
          case MySqlParser::MULTIPOLYGON:
          case MySqlParser::POINT:
          case MySqlParser::POLYGON:
          case MySqlParser::ABS:
          case MySqlParser::ACOS:
          case MySqlParser::ADDDATE:
          case MySqlParser::ADDTIME:
          case MySqlParser::AES_DECRYPT:
          case MySqlParser::AES_ENCRYPT:
          case MySqlParser::AREA:
          case MySqlParser::ASBINARY:
          case MySqlParser::ASIN:
          case MySqlParser::ASTEXT:
          case MySqlParser::ASWKB:
          case MySqlParser::ASWKT:
          case MySqlParser::ASYMMETRIC_DECRYPT:
          case MySqlParser::ASYMMETRIC_DERIVE:
          case MySqlParser::ASYMMETRIC_ENCRYPT:
          case MySqlParser::ASYMMETRIC_SIGN:
          case MySqlParser::ASYMMETRIC_VERIFY:
          case MySqlParser::ATAN:
          case MySqlParser::ATAN2:
          case MySqlParser::BENCHMARK:
          case MySqlParser::BIN:
          case MySqlParser::BIT_COUNT:
          case MySqlParser::BIT_LENGTH:
          case MySqlParser::BUFFER:
          case MySqlParser::CATALOG_NAME:
          case MySqlParser::CEIL:
          case MySqlParser::CEILING:
          case MySqlParser::CENTROID:
          case MySqlParser::CHARACTER_LENGTH:
          case MySqlParser::CHARSET:
          case MySqlParser::CHAR_LENGTH:
          case MySqlParser::COERCIBILITY:
          case MySqlParser::COLLATION:
          case MySqlParser::COMPRESS:
          case MySqlParser::CONCAT:
          case MySqlParser::CONCAT_WS:
          case MySqlParser::CONNECTION_ID:
          case MySqlParser::CONV:
          case MySqlParser::CONVERT_TZ:
          case MySqlParser::COS:
          case MySqlParser::COT:
          case MySqlParser::CRC32:
          case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
          case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
          case MySqlParser::CREATE_DH_PARAMETERS:
          case MySqlParser::CREATE_DIGEST:
          case MySqlParser::CROSSES:
          case MySqlParser::DATEDIFF:
          case MySqlParser::DATE_FORMAT:
          case MySqlParser::DAYNAME:
          case MySqlParser::DAYOFMONTH:
          case MySqlParser::DAYOFWEEK:
          case MySqlParser::DAYOFYEAR:
          case MySqlParser::DECODE:
          case MySqlParser::DEGREES:
          case MySqlParser::DES_DECRYPT:
          case MySqlParser::DES_ENCRYPT:
          case MySqlParser::DIMENSION:
          case MySqlParser::DISJOINT:
          case MySqlParser::ELT:
          case MySqlParser::ENCODE:
          case MySqlParser::ENCRYPT:
          case MySqlParser::ENDPOINT:
          case MySqlParser::ENGINE_ATTRIBUTE:
          case MySqlParser::ENVELOPE:
          case MySqlParser::EQUALS:
          case MySqlParser::EXP:
          case MySqlParser::EXPORT_SET:
          case MySqlParser::EXTERIORRING:
          case MySqlParser::EXTRACTVALUE:
          case MySqlParser::FIELD:
          case MySqlParser::FIND_IN_SET:
          case MySqlParser::FLOOR:
          case MySqlParser::FORMAT:
          case MySqlParser::FOUND_ROWS:
          case MySqlParser::FROM_BASE64:
          case MySqlParser::FROM_DAYS:
          case MySqlParser::FROM_UNIXTIME:
          case MySqlParser::GEOMCOLLFROMTEXT:
          case MySqlParser::GEOMCOLLFROMWKB:
          case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::GEOMETRYFROMTEXT:
          case MySqlParser::GEOMETRYFROMWKB:
          case MySqlParser::GEOMETRYN:
          case MySqlParser::GEOMETRYTYPE:
          case MySqlParser::GEOMFROMTEXT:
          case MySqlParser::GEOMFROMWKB:
          case MySqlParser::GET_FORMAT:
          case MySqlParser::GET_LOCK:
          case MySqlParser::GLENGTH:
          case MySqlParser::GREATEST:
          case MySqlParser::GTID_SUBSET:
          case MySqlParser::GTID_SUBTRACT:
          case MySqlParser::HEX:
          case MySqlParser::IFNULL:
          case MySqlParser::INET6_ATON:
          case MySqlParser::INET6_NTOA:
          case MySqlParser::INET_ATON:
          case MySqlParser::INET_NTOA:
          case MySqlParser::INSTR:
          case MySqlParser::INTERIORRINGN:
          case MySqlParser::INTERSECTS:
          case MySqlParser::ISCLOSED:
          case MySqlParser::ISEMPTY:
          case MySqlParser::ISNULL:
          case MySqlParser::ISSIMPLE:
          case MySqlParser::IS_FREE_LOCK:
          case MySqlParser::IS_IPV4:
          case MySqlParser::IS_IPV4_COMPAT:
          case MySqlParser::IS_IPV4_MAPPED:
          case MySqlParser::IS_IPV6:
          case MySqlParser::IS_USED_LOCK:
          case MySqlParser::LAST_INSERT_ID:
          case MySqlParser::LCASE:
          case MySqlParser::LEAST:
          case MySqlParser::LENGTH:
          case MySqlParser::LINEFROMTEXT:
          case MySqlParser::LINEFROMWKB:
          case MySqlParser::LINESTRINGFROMTEXT:
          case MySqlParser::LINESTRINGFROMWKB:
          case MySqlParser::LN:
          case MySqlParser::LOAD_FILE:
          case MySqlParser::LOCATE:
          case MySqlParser::LOG:
          case MySqlParser::LOG10:
          case MySqlParser::LOG2:
          case MySqlParser::LOWER:
          case MySqlParser::LPAD:
          case MySqlParser::LTRIM:
          case MySqlParser::MAKEDATE:
          case MySqlParser::MAKETIME:
          case MySqlParser::MAKE_SET:
          case MySqlParser::MASTER_POS_WAIT:
          case MySqlParser::MBRCONTAINS:
          case MySqlParser::MBRDISJOINT:
          case MySqlParser::MBREQUAL:
          case MySqlParser::MBRINTERSECTS:
          case MySqlParser::MBROVERLAPS:
          case MySqlParser::MBRTOUCHES:
          case MySqlParser::MBRWITHIN:
          case MySqlParser::MD5:
          case MySqlParser::MLINEFROMTEXT:
          case MySqlParser::MLINEFROMWKB:
          case MySqlParser::MONTHNAME:
          case MySqlParser::MPOINTFROMTEXT:
          case MySqlParser::MPOINTFROMWKB:
          case MySqlParser::MPOLYFROMTEXT:
          case MySqlParser::MPOLYFROMWKB:
          case MySqlParser::MULTILINESTRINGFROMTEXT:
          case MySqlParser::MULTILINESTRINGFROMWKB:
          case MySqlParser::MULTIPOINTFROMTEXT:
          case MySqlParser::MULTIPOINTFROMWKB:
          case MySqlParser::MULTIPOLYGONFROMTEXT:
          case MySqlParser::MULTIPOLYGONFROMWKB:
          case MySqlParser::NAME_CONST:
          case MySqlParser::NULLIF:
          case MySqlParser::NUMGEOMETRIES:
          case MySqlParser::NUMINTERIORRINGS:
          case MySqlParser::NUMPOINTS:
          case MySqlParser::OCT:
          case MySqlParser::OCTET_LENGTH:
          case MySqlParser::ORD:
          case MySqlParser::OVERLAPS:
          case MySqlParser::PERIOD_ADD:
          case MySqlParser::PERIOD_DIFF:
          case MySqlParser::PI:
          case MySqlParser::POINTFROMTEXT:
          case MySqlParser::POINTFROMWKB:
          case MySqlParser::POINTN:
          case MySqlParser::POLYFROMTEXT:
          case MySqlParser::POLYFROMWKB:
          case MySqlParser::POLYGONFROMTEXT:
          case MySqlParser::POLYGONFROMWKB:
          case MySqlParser::POW:
          case MySqlParser::POWER:
          case MySqlParser::QUOTE:
          case MySqlParser::RADIANS:
          case MySqlParser::RAND:
          case MySqlParser::RANDOM_BYTES:
          case MySqlParser::RELEASE_LOCK:
          case MySqlParser::REVERSE:
          case MySqlParser::ROUND:
          case MySqlParser::ROW_COUNT:
          case MySqlParser::RPAD:
          case MySqlParser::RTRIM:
          case MySqlParser::SEC_TO_TIME:
          case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
          case MySqlParser::SESSION_USER:
          case MySqlParser::SHA:
          case MySqlParser::SHA1:
          case MySqlParser::SHA2:
          case MySqlParser::SCHEMA_NAME:
          case MySqlParser::SIGN:
          case MySqlParser::SIN:
          case MySqlParser::SLEEP:
          case MySqlParser::SOUNDEX:
          case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
          case MySqlParser::SQRT:
          case MySqlParser::SRID:
          case MySqlParser::STARTPOINT:
          case MySqlParser::STRCMP:
          case MySqlParser::STR_TO_DATE:
          case MySqlParser::ST_AREA:
          case MySqlParser::ST_ASBINARY:
          case MySqlParser::ST_ASTEXT:
          case MySqlParser::ST_ASWKB:
          case MySqlParser::ST_ASWKT:
          case MySqlParser::ST_BUFFER:
          case MySqlParser::ST_CENTROID:
          case MySqlParser::ST_CONTAINS:
          case MySqlParser::ST_CROSSES:
          case MySqlParser::ST_DIFFERENCE:
          case MySqlParser::ST_DIMENSION:
          case MySqlParser::ST_DISJOINT:
          case MySqlParser::ST_DISTANCE:
          case MySqlParser::ST_ENDPOINT:
          case MySqlParser::ST_ENVELOPE:
          case MySqlParser::ST_EQUALS:
          case MySqlParser::ST_EXTERIORRING:
          case MySqlParser::ST_GEOMCOLLFROMTEXT:
          case MySqlParser::ST_GEOMCOLLFROMTXT:
          case MySqlParser::ST_GEOMCOLLFROMWKB:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::ST_GEOMETRYFROMTEXT:
          case MySqlParser::ST_GEOMETRYFROMWKB:
          case MySqlParser::ST_GEOMETRYN:
          case MySqlParser::ST_GEOMETRYTYPE:
          case MySqlParser::ST_GEOMFROMTEXT:
          case MySqlParser::ST_GEOMFROMWKB:
          case MySqlParser::ST_INTERIORRINGN:
          case MySqlParser::ST_INTERSECTION:
          case MySqlParser::ST_INTERSECTS:
          case MySqlParser::ST_ISCLOSED:
          case MySqlParser::ST_ISEMPTY:
          case MySqlParser::ST_ISSIMPLE:
          case MySqlParser::ST_LINEFROMTEXT:
          case MySqlParser::ST_LINEFROMWKB:
          case MySqlParser::ST_LINESTRINGFROMTEXT:
          case MySqlParser::ST_LINESTRINGFROMWKB:
          case MySqlParser::ST_NUMGEOMETRIES:
          case MySqlParser::ST_NUMINTERIORRING:
          case MySqlParser::ST_NUMINTERIORRINGS:
          case MySqlParser::ST_NUMPOINTS:
          case MySqlParser::ST_OVERLAPS:
          case MySqlParser::ST_POINTFROMTEXT:
          case MySqlParser::ST_POINTFROMWKB:
          case MySqlParser::ST_POINTN:
          case MySqlParser::ST_POLYFROMTEXT:
          case MySqlParser::ST_POLYFROMWKB:
          case MySqlParser::ST_POLYGONFROMTEXT:
          case MySqlParser::ST_POLYGONFROMWKB:
          case MySqlParser::ST_SRID:
          case MySqlParser::ST_STARTPOINT:
          case MySqlParser::ST_SYMDIFFERENCE:
          case MySqlParser::ST_TOUCHES:
          case MySqlParser::ST_UNION:
          case MySqlParser::ST_WITHIN:
          case MySqlParser::ST_X:
          case MySqlParser::ST_Y:
          case MySqlParser::SUBDATE:
          case MySqlParser::SUBSTRING_INDEX:
          case MySqlParser::SUBTIME:
          case MySqlParser::SYSTEM_USER:
          case MySqlParser::TAN:
          case MySqlParser::TIMEDIFF:
          case MySqlParser::TIMESTAMPADD:
          case MySqlParser::TIMESTAMPDIFF:
          case MySqlParser::TIME_FORMAT:
          case MySqlParser::TIME_TO_SEC:
          case MySqlParser::TOUCHES:
          case MySqlParser::TO_BASE64:
          case MySqlParser::TO_DAYS:
          case MySqlParser::TO_SECONDS:
          case MySqlParser::TP_CONNECTION_ADMIN:
          case MySqlParser::UCASE:
          case MySqlParser::UNCOMPRESS:
          case MySqlParser::UNCOMPRESSED_LENGTH:
          case MySqlParser::UNHEX:
          case MySqlParser::UNIX_TIMESTAMP:
          case MySqlParser::UPDATEXML:
          case MySqlParser::UPPER:
          case MySqlParser::UUID:
          case MySqlParser::UUID_SHORT:
          case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
          case MySqlParser::VERSION:
          case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
          case MySqlParser::WEEKDAY:
          case MySqlParser::WEEKOFYEAR:
          case MySqlParser::WEIGHT_STRING:
          case MySqlParser::WITHIN:
          case MySqlParser::YEARWEEK:
          case MySqlParser::Y_FUNCTION:
          case MySqlParser::X_FUNCTION:
          case MySqlParser::MOD:
          case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
          case MySqlParser::STRING_LITERAL:
          case MySqlParser::ID: {
            setState(2884);
            uidList();
            break;
          }

          case MySqlParser::ALL: {
            setState(2885);
            match(MySqlParser::ALL);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2888);
        match(MySqlParser::TABLESPACE);
        break;
      }

      case MySqlParser::IMPORT: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByImportPartitionContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(2889);
        match(MySqlParser::IMPORT);
        setState(2890);
        match(MySqlParser::PARTITION);
        setState(2893);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::ATTRIBUTE:
          case MySqlParser::BUCKETS:
          case MySqlParser::CONDITION:
          case MySqlParser::CURRENT:
          case MySqlParser::CURRENT_USER:
          case MySqlParser::DATABASE:
          case MySqlParser::DEFAULT:
          case MySqlParser::DIAGNOSTICS:
          case MySqlParser::EMPTY:
          case MySqlParser::ENFORCED:
          case MySqlParser::EXCEPT:
          case MySqlParser::GROUP:
          case MySqlParser::IF:
          case MySqlParser::IGNORED:
          case MySqlParser::INSERT:
          case MySqlParser::LATERAL:
          case MySqlParser::LEFT:
          case MySqlParser::NUMBER:
          case MySqlParser::OPTIONAL:
          case MySqlParser::ORDER:
          case MySqlParser::PRIMARY:
          case MySqlParser::REPLACE:
          case MySqlParser::RIGHT:
          case MySqlParser::SCHEMA:
          case MySqlParser::SKIP_QUERY_REWRITE:
          case MySqlParser::STACKED:
          case MySqlParser::DATE:
          case MySqlParser::TIME:
          case MySqlParser::TIMESTAMP:
          case MySqlParser::DATETIME:
          case MySqlParser::YEAR:
          case MySqlParser::BINARY:
          case MySqlParser::TEXT:
          case MySqlParser::ENUM:
          case MySqlParser::SERIAL:
          case MySqlParser::JSON_ARRAY:
          case MySqlParser::JSON_ARRAYAGG:
          case MySqlParser::JSON_ARRAY_APPEND:
          case MySqlParser::JSON_ARRAY_INSERT:
          case MySqlParser::JSON_CONTAINS:
          case MySqlParser::JSON_CONTAINS_PATH:
          case MySqlParser::JSON_DEPTH:
          case MySqlParser::JSON_EXTRACT:
          case MySqlParser::JSON_INSERT:
          case MySqlParser::JSON_KEYS:
          case MySqlParser::JSON_LENGTH:
          case MySqlParser::JSON_MERGE:
          case MySqlParser::JSON_MERGE_PATCH:
          case MySqlParser::JSON_MERGE_PRESERVE:
          case MySqlParser::JSON_OBJECT:
          case MySqlParser::JSON_OBJECTAGG:
          case MySqlParser::JSON_OVERLAPS:
          case MySqlParser::JSON_PRETTY:
          case MySqlParser::JSON_QUOTE:
          case MySqlParser::JSON_REMOVE:
          case MySqlParser::JSON_REPLACE:
          case MySqlParser::JSON_SCHEMA_VALID:
          case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
          case MySqlParser::JSON_SEARCH:
          case MySqlParser::JSON_SET:
          case MySqlParser::JSON_STORAGE_FREE:
          case MySqlParser::JSON_STORAGE_SIZE:
          case MySqlParser::JSON_TABLE:
          case MySqlParser::JSON_TYPE:
          case MySqlParser::JSON_UNQUOTE:
          case MySqlParser::JSON_VALID:
          case MySqlParser::JSON_VALUE:
          case MySqlParser::NESTED:
          case MySqlParser::ORDINALITY:
          case MySqlParser::PATH:
          case MySqlParser::AVG:
          case MySqlParser::BIT_AND:
          case MySqlParser::BIT_OR:
          case MySqlParser::BIT_XOR:
          case MySqlParser::COUNT:
          case MySqlParser::CUME_DIST:
          case MySqlParser::DENSE_RANK:
          case MySqlParser::FIRST_VALUE:
          case MySqlParser::GROUP_CONCAT:
          case MySqlParser::LAG:
          case MySqlParser::LAST_VALUE:
          case MySqlParser::LEAD:
          case MySqlParser::MAX:
          case MySqlParser::MIN:
          case MySqlParser::NTILE:
          case MySqlParser::NTH_VALUE:
          case MySqlParser::PERCENT_RANK:
          case MySqlParser::RANK:
          case MySqlParser::ROW_NUMBER:
          case MySqlParser::STD:
          case MySqlParser::STDDEV:
          case MySqlParser::STDDEV_POP:
          case MySqlParser::STDDEV_SAMP:
          case MySqlParser::SUM:
          case MySqlParser::VAR_POP:
          case MySqlParser::VAR_SAMP:
          case MySqlParser::VARIANCE:
          case MySqlParser::CURRENT_DATE:
          case MySqlParser::CURRENT_TIME:
          case MySqlParser::CURRENT_TIMESTAMP:
          case MySqlParser::LOCALTIME:
          case MySqlParser::CURDATE:
          case MySqlParser::CURTIME:
          case MySqlParser::DATE_ADD:
          case MySqlParser::DATE_SUB:
          case MySqlParser::LOCALTIMESTAMP:
          case MySqlParser::NOW:
          case MySqlParser::POSITION:
          case MySqlParser::SUBSTR:
          case MySqlParser::SUBSTRING:
          case MySqlParser::SYSDATE:
          case MySqlParser::TRIM:
          case MySqlParser::UTC_DATE:
          case MySqlParser::UTC_TIME:
          case MySqlParser::UTC_TIMESTAMP:
          case MySqlParser::ACCOUNT:
          case MySqlParser::ACTION:
          case MySqlParser::AFTER:
          case MySqlParser::AGGREGATE:
          case MySqlParser::ALGORITHM:
          case MySqlParser::ANY:
          case MySqlParser::AT:
          case MySqlParser::AUTHORS:
          case MySqlParser::AUTOCOMMIT:
          case MySqlParser::AUTOEXTEND_SIZE:
          case MySqlParser::AUTO_INCREMENT:
          case MySqlParser::AVG_ROW_LENGTH:
          case MySqlParser::BEGIN:
          case MySqlParser::BINLOG:
          case MySqlParser::BIT:
          case MySqlParser::BLOCK:
          case MySqlParser::BOOL:
          case MySqlParser::BOOLEAN:
          case MySqlParser::BTREE:
          case MySqlParser::CACHE:
          case MySqlParser::CASCADED:
          case MySqlParser::CHAIN:
          case MySqlParser::CHANGED:
          case MySqlParser::CHANNEL:
          case MySqlParser::CHECKSUM:
          case MySqlParser::PAGE_CHECKSUM:
          case MySqlParser::CIPHER:
          case MySqlParser::CLASS_ORIGIN:
          case MySqlParser::CLIENT:
          case MySqlParser::CLOSE:
          case MySqlParser::CLUSTERING:
          case MySqlParser::COALESCE:
          case MySqlParser::CODE:
          case MySqlParser::COLUMNS:
          case MySqlParser::COLUMN_FORMAT:
          case MySqlParser::COLUMN_NAME:
          case MySqlParser::COMMENT:
          case MySqlParser::COMMIT:
          case MySqlParser::COMPACT:
          case MySqlParser::COMPLETION:
          case MySqlParser::COMPRESSED:
          case MySqlParser::COMPRESSION:
          case MySqlParser::CONCURRENT:
          case MySqlParser::CONNECT:
          case MySqlParser::CONNECTION:
          case MySqlParser::CONSISTENT:
          case MySqlParser::CONSTRAINT_CATALOG:
          case MySqlParser::CONSTRAINT_SCHEMA:
          case MySqlParser::CONSTRAINT_NAME:
          case MySqlParser::CONTAINS:
          case MySqlParser::CONTEXT:
          case MySqlParser::CONTRIBUTORS:
          case MySqlParser::COPY:
          case MySqlParser::CPU:
          case MySqlParser::CURSOR_NAME:
          case MySqlParser::DATA:
          case MySqlParser::DATAFILE:
          case MySqlParser::DEALLOCATE:
          case MySqlParser::DEFAULT_AUTH:
          case MySqlParser::DEFINER:
          case MySqlParser::DELAY_KEY_WRITE:
          case MySqlParser::DES_KEY_FILE:
          case MySqlParser::DIRECTORY:
          case MySqlParser::DISABLE:
          case MySqlParser::DISCARD:
          case MySqlParser::DISK:
          case MySqlParser::DO:
          case MySqlParser::DUMPFILE:
          case MySqlParser::DUPLICATE:
          case MySqlParser::DYNAMIC:
          case MySqlParser::ENABLE:
          case MySqlParser::ENCRYPTION:
          case MySqlParser::END:
          case MySqlParser::ENDS:
          case MySqlParser::ENGINE:
          case MySqlParser::ENGINES:
          case MySqlParser::ERROR:
          case MySqlParser::ERRORS:
          case MySqlParser::ESCAPE:
          case MySqlParser::EVEN:
          case MySqlParser::EVENT:
          case MySqlParser::EVENTS:
          case MySqlParser::EVERY:
          case MySqlParser::EXCHANGE:
          case MySqlParser::EXCLUSIVE:
          case MySqlParser::EXPIRE:
          case MySqlParser::EXPORT:
          case MySqlParser::EXTENDED:
          case MySqlParser::EXTENT_SIZE:
          case MySqlParser::FAILED_LOGIN_ATTEMPTS:
          case MySqlParser::FAST:
          case MySqlParser::FAULTS:
          case MySqlParser::FIELDS:
          case MySqlParser::FILE_BLOCK_SIZE:
          case MySqlParser::FILTER:
          case MySqlParser::FIRST:
          case MySqlParser::FIXED:
          case MySqlParser::FLUSH:
          case MySqlParser::FOLLOWS:
          case MySqlParser::FOUND:
          case MySqlParser::FULL:
          case MySqlParser::FUNCTION:
          case MySqlParser::GENERAL:
          case MySqlParser::GLOBAL:
          case MySqlParser::GRANTS:
          case MySqlParser::GROUP_REPLICATION:
          case MySqlParser::HANDLER:
          case MySqlParser::HASH:
          case MySqlParser::HELP:
          case MySqlParser::HISTORY:
          case MySqlParser::HOST:
          case MySqlParser::HOSTS:
          case MySqlParser::IDENTIFIED:
          case MySqlParser::IGNORE_SERVER_IDS:
          case MySqlParser::IMPORT:
          case MySqlParser::INDEXES:
          case MySqlParser::INITIAL_SIZE:
          case MySqlParser::INPLACE:
          case MySqlParser::INSERT_METHOD:
          case MySqlParser::INSTALL:
          case MySqlParser::INSTANCE:
          case MySqlParser::INSTANT:
          case MySqlParser::INVISIBLE:
          case MySqlParser::INVOKER:
          case MySqlParser::IO:
          case MySqlParser::IO_THREAD:
          case MySqlParser::IPC:
          case MySqlParser::ISOLATION:
          case MySqlParser::ISSUER:
          case MySqlParser::JSON:
          case MySqlParser::KEY_BLOCK_SIZE:
          case MySqlParser::LANGUAGE:
          case MySqlParser::LAST:
          case MySqlParser::LEAVES:
          case MySqlParser::LESS:
          case MySqlParser::LEVEL:
          case MySqlParser::LIST:
          case MySqlParser::LOCAL:
          case MySqlParser::LOGFILE:
          case MySqlParser::LOGS:
          case MySqlParser::MASTER:
          case MySqlParser::MASTER_AUTO_POSITION:
          case MySqlParser::MASTER_CONNECT_RETRY:
          case MySqlParser::MASTER_DELAY:
          case MySqlParser::MASTER_HEARTBEAT_PERIOD:
          case MySqlParser::MASTER_HOST:
          case MySqlParser::MASTER_LOG_FILE:
          case MySqlParser::MASTER_LOG_POS:
          case MySqlParser::MASTER_PASSWORD:
          case MySqlParser::MASTER_PORT:
          case MySqlParser::MASTER_RETRY_COUNT:
          case MySqlParser::MASTER_SSL:
          case MySqlParser::MASTER_SSL_CA:
          case MySqlParser::MASTER_SSL_CAPATH:
          case MySqlParser::MASTER_SSL_CERT:
          case MySqlParser::MASTER_SSL_CIPHER:
          case MySqlParser::MASTER_SSL_CRL:
          case MySqlParser::MASTER_SSL_CRLPATH:
          case MySqlParser::MASTER_SSL_KEY:
          case MySqlParser::MASTER_TLS_VERSION:
          case MySqlParser::MASTER_USER:
          case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
          case MySqlParser::MAX_QUERIES_PER_HOUR:
          case MySqlParser::MAX_ROWS:
          case MySqlParser::MAX_SIZE:
          case MySqlParser::MAX_UPDATES_PER_HOUR:
          case MySqlParser::MAX_USER_CONNECTIONS:
          case MySqlParser::MEDIUM:
          case MySqlParser::MEMBER:
          case MySqlParser::MERGE:
          case MySqlParser::MESSAGE_TEXT:
          case MySqlParser::MID:
          case MySqlParser::MIGRATE:
          case MySqlParser::MIN_ROWS:
          case MySqlParser::MODE:
          case MySqlParser::MODIFY:
          case MySqlParser::MUTEX:
          case MySqlParser::MYSQL:
          case MySqlParser::MYSQL_ERRNO:
          case MySqlParser::NAME:
          case MySqlParser::NAMES:
          case MySqlParser::NCHAR:
          case MySqlParser::NEVER:
          case MySqlParser::NEXT:
          case MySqlParser::NO:
          case MySqlParser::NOCOPY:
          case MySqlParser::NOWAIT:
          case MySqlParser::NODEGROUP:
          case MySqlParser::NONE:
          case MySqlParser::ODBC:
          case MySqlParser::OFFLINE:
          case MySqlParser::OFFSET:
          case MySqlParser::OF:
          case MySqlParser::OJ:
          case MySqlParser::OLD_PASSWORD:
          case MySqlParser::ONE:
          case MySqlParser::ONLINE:
          case MySqlParser::ONLY:
          case MySqlParser::OPEN:
          case MySqlParser::OPTIMIZER_COSTS:
          case MySqlParser::OPTIONS:
          case MySqlParser::OWNER:
          case MySqlParser::PACK_KEYS:
          case MySqlParser::PAGE:
          case MySqlParser::PARSER:
          case MySqlParser::PARTIAL:
          case MySqlParser::PARTITIONING:
          case MySqlParser::PARTITIONS:
          case MySqlParser::PASSWORD:
          case MySqlParser::PASSWORD_LOCK_TIME:
          case MySqlParser::PHASE:
          case MySqlParser::PLUGIN:
          case MySqlParser::PLUGIN_DIR:
          case MySqlParser::PLUGINS:
          case MySqlParser::PORT:
          case MySqlParser::PRECEDES:
          case MySqlParser::PREPARE:
          case MySqlParser::PRESERVE:
          case MySqlParser::PREV:
          case MySqlParser::PROCESSLIST:
          case MySqlParser::PROFILE:
          case MySqlParser::PROFILES:
          case MySqlParser::PROXY:
          case MySqlParser::QUERY:
          case MySqlParser::QUICK:
          case MySqlParser::REBUILD:
          case MySqlParser::RECOVER:
          case MySqlParser::RECURSIVE:
          case MySqlParser::REDO_BUFFER_SIZE:
          case MySqlParser::REDUNDANT:
          case MySqlParser::RELAY:
          case MySqlParser::RELAY_LOG_FILE:
          case MySqlParser::RELAY_LOG_POS:
          case MySqlParser::RELAYLOG:
          case MySqlParser::REMOVE:
          case MySqlParser::REORGANIZE:
          case MySqlParser::REPAIR:
          case MySqlParser::REPLICATE_DO_DB:
          case MySqlParser::REPLICATE_DO_TABLE:
          case MySqlParser::REPLICATE_IGNORE_DB:
          case MySqlParser::REPLICATE_IGNORE_TABLE:
          case MySqlParser::REPLICATE_REWRITE_DB:
          case MySqlParser::REPLICATE_WILD_DO_TABLE:
          case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
          case MySqlParser::REPLICATION:
          case MySqlParser::RESET:
          case MySqlParser::RESUME:
          case MySqlParser::RETURNED_SQLSTATE:
          case MySqlParser::RETURNS:
          case MySqlParser::REUSE:
          case MySqlParser::ROLE:
          case MySqlParser::ROLLBACK:
          case MySqlParser::ROLLUP:
          case MySqlParser::ROTATE:
          case MySqlParser::ROW:
          case MySqlParser::ROWS:
          case MySqlParser::ROW_FORMAT:
          case MySqlParser::RTREE:
          case MySqlParser::SAVEPOINT:
          case MySqlParser::SCHEDULE:
          case MySqlParser::SECURITY:
          case MySqlParser::SERVER:
          case MySqlParser::SESSION:
          case MySqlParser::SHARE:
          case MySqlParser::SHARED:
          case MySqlParser::SIGNED:
          case MySqlParser::SIMPLE:
          case MySqlParser::SLAVE:
          case MySqlParser::SLOW:
          case MySqlParser::SNAPSHOT:
          case MySqlParser::SOCKET:
          case MySqlParser::SOME:
          case MySqlParser::SONAME:
          case MySqlParser::SOUNDS:
          case MySqlParser::SOURCE:
          case MySqlParser::SQL_AFTER_GTIDS:
          case MySqlParser::SQL_AFTER_MTS_GAPS:
          case MySqlParser::SQL_BEFORE_GTIDS:
          case MySqlParser::SQL_BUFFER_RESULT:
          case MySqlParser::SQL_CACHE:
          case MySqlParser::SQL_NO_CACHE:
          case MySqlParser::SQL_THREAD:
          case MySqlParser::START:
          case MySqlParser::STARTS:
          case MySqlParser::STATS_AUTO_RECALC:
          case MySqlParser::STATS_PERSISTENT:
          case MySqlParser::STATS_SAMPLE_PAGES:
          case MySqlParser::STATUS:
          case MySqlParser::STOP:
          case MySqlParser::STORAGE:
          case MySqlParser::STRING:
          case MySqlParser::SUBCLASS_ORIGIN:
          case MySqlParser::SUBJECT:
          case MySqlParser::SUBPARTITION:
          case MySqlParser::SUBPARTITIONS:
          case MySqlParser::SUSPEND:
          case MySqlParser::SWAPS:
          case MySqlParser::SWITCHES:
          case MySqlParser::TABLE_NAME:
          case MySqlParser::TABLESPACE:
          case MySqlParser::TABLE_TYPE:
          case MySqlParser::TEMPORARY:
          case MySqlParser::TEMPTABLE:
          case MySqlParser::THAN:
          case MySqlParser::TRADITIONAL:
          case MySqlParser::TRANSACTION:
          case MySqlParser::TRANSACTIONAL:
          case MySqlParser::TRIGGERS:
          case MySqlParser::TRUNCATE:
          case MySqlParser::UNBOUNDED:
          case MySqlParser::UNDEFINED:
          case MySqlParser::UNDOFILE:
          case MySqlParser::UNDO_BUFFER_SIZE:
          case MySqlParser::UNINSTALL:
          case MySqlParser::UNKNOWN:
          case MySqlParser::UNTIL:
          case MySqlParser::UPGRADE:
          case MySqlParser::USER:
          case MySqlParser::USE_FRM:
          case MySqlParser::USER_RESOURCES:
          case MySqlParser::VALIDATION:
          case MySqlParser::VALUE:
          case MySqlParser::VARIABLES:
          case MySqlParser::VIEW:
          case MySqlParser::VIRTUAL:
          case MySqlParser::VISIBLE:
          case MySqlParser::WAIT:
          case MySqlParser::WARNINGS:
          case MySqlParser::WITHOUT:
          case MySqlParser::WORK:
          case MySqlParser::WRAPPER:
          case MySqlParser::X509:
          case MySqlParser::XA:
          case MySqlParser::XML:
          case MySqlParser::EUR:
          case MySqlParser::USA:
          case MySqlParser::JIS:
          case MySqlParser::ISO:
          case MySqlParser::INTERNAL:
          case MySqlParser::QUARTER:
          case MySqlParser::MONTH:
          case MySqlParser::DAY:
          case MySqlParser::HOUR:
          case MySqlParser::MINUTE:
          case MySqlParser::WEEK:
          case MySqlParser::SECOND:
          case MySqlParser::MICROSECOND:
          case MySqlParser::ADMIN:
          case MySqlParser::AUDIT_ABORT_EXEMPT:
          case MySqlParser::AUDIT_ADMIN:
          case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
          case MySqlParser::BACKUP_ADMIN:
          case MySqlParser::BINLOG_ADMIN:
          case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
          case MySqlParser::CLONE_ADMIN:
          case MySqlParser::CONNECTION_ADMIN:
          case MySqlParser::ENCRYPTION_KEY_ADMIN:
          case MySqlParser::EXECUTE:
          case MySqlParser::FILE:
          case MySqlParser::FIREWALL_ADMIN:
          case MySqlParser::FIREWALL_EXEMPT:
          case MySqlParser::FIREWALL_USER:
          case MySqlParser::GROUP_REPLICATION_ADMIN:
          case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
          case MySqlParser::INVOKE:
          case MySqlParser::LAMBDA:
          case MySqlParser::NDB_STORED_USER:
          case MySqlParser::PASSWORDLESS_USER_ADMIN:
          case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
          case MySqlParser::PRIVILEGES:
          case MySqlParser::PROCESS:
          case MySqlParser::RELOAD:
          case MySqlParser::REPLICATION_APPLIER:
          case MySqlParser::REPLICATION_SLAVE_ADMIN:
          case MySqlParser::RESOURCE_GROUP_ADMIN:
          case MySqlParser::RESOURCE_GROUP_USER:
          case MySqlParser::ROLE_ADMIN:
          case MySqlParser::ROUTINE:
          case MySqlParser::S3:
          case MySqlParser::SESSION_VARIABLES_ADMIN:
          case MySqlParser::SET_USER_ID:
          case MySqlParser::SHOW_ROUTINE:
          case MySqlParser::SHUTDOWN:
          case MySqlParser::SUPER:
          case MySqlParser::SYSTEM_VARIABLES_ADMIN:
          case MySqlParser::TABLES:
          case MySqlParser::TABLE_ENCRYPTION_ADMIN:
          case MySqlParser::VERSION_TOKEN_ADMIN:
          case MySqlParser::XA_RECOVER_ADMIN:
          case MySqlParser::ARMSCII8:
          case MySqlParser::ASCII:
          case MySqlParser::BIG5:
          case MySqlParser::CP1250:
          case MySqlParser::CP1251:
          case MySqlParser::CP1256:
          case MySqlParser::CP1257:
          case MySqlParser::CP850:
          case MySqlParser::CP852:
          case MySqlParser::CP866:
          case MySqlParser::CP932:
          case MySqlParser::DEC8:
          case MySqlParser::EUCJPMS:
          case MySqlParser::EUCKR:
          case MySqlParser::GB18030:
          case MySqlParser::GB2312:
          case MySqlParser::GBK:
          case MySqlParser::GEOSTD8:
          case MySqlParser::GREEK:
          case MySqlParser::HEBREW:
          case MySqlParser::HP8:
          case MySqlParser::KEYBCS2:
          case MySqlParser::KOI8R:
          case MySqlParser::KOI8U:
          case MySqlParser::LATIN1:
          case MySqlParser::LATIN2:
          case MySqlParser::LATIN5:
          case MySqlParser::LATIN7:
          case MySqlParser::MACCE:
          case MySqlParser::MACROMAN:
          case MySqlParser::SJIS:
          case MySqlParser::SWE7:
          case MySqlParser::TIS620:
          case MySqlParser::UCS2:
          case MySqlParser::UJIS:
          case MySqlParser::UTF16:
          case MySqlParser::UTF16LE:
          case MySqlParser::UTF32:
          case MySqlParser::UTF8:
          case MySqlParser::UTF8MB3:
          case MySqlParser::UTF8MB4:
          case MySqlParser::ARCHIVE:
          case MySqlParser::BLACKHOLE:
          case MySqlParser::CSV:
          case MySqlParser::FEDERATED:
          case MySqlParser::INNODB:
          case MySqlParser::MEMORY:
          case MySqlParser::MRG_MYISAM:
          case MySqlParser::MYISAM:
          case MySqlParser::NDB:
          case MySqlParser::NDBCLUSTER:
          case MySqlParser::PERFORMANCE_SCHEMA:
          case MySqlParser::TOKUDB:
          case MySqlParser::REPEATABLE:
          case MySqlParser::COMMITTED:
          case MySqlParser::UNCOMMITTED:
          case MySqlParser::SERIALIZABLE:
          case MySqlParser::GEOMETRYCOLLECTION:
          case MySqlParser::LINESTRING:
          case MySqlParser::MULTILINESTRING:
          case MySqlParser::MULTIPOINT:
          case MySqlParser::MULTIPOLYGON:
          case MySqlParser::POINT:
          case MySqlParser::POLYGON:
          case MySqlParser::ABS:
          case MySqlParser::ACOS:
          case MySqlParser::ADDDATE:
          case MySqlParser::ADDTIME:
          case MySqlParser::AES_DECRYPT:
          case MySqlParser::AES_ENCRYPT:
          case MySqlParser::AREA:
          case MySqlParser::ASBINARY:
          case MySqlParser::ASIN:
          case MySqlParser::ASTEXT:
          case MySqlParser::ASWKB:
          case MySqlParser::ASWKT:
          case MySqlParser::ASYMMETRIC_DECRYPT:
          case MySqlParser::ASYMMETRIC_DERIVE:
          case MySqlParser::ASYMMETRIC_ENCRYPT:
          case MySqlParser::ASYMMETRIC_SIGN:
          case MySqlParser::ASYMMETRIC_VERIFY:
          case MySqlParser::ATAN:
          case MySqlParser::ATAN2:
          case MySqlParser::BENCHMARK:
          case MySqlParser::BIN:
          case MySqlParser::BIT_COUNT:
          case MySqlParser::BIT_LENGTH:
          case MySqlParser::BUFFER:
          case MySqlParser::CATALOG_NAME:
          case MySqlParser::CEIL:
          case MySqlParser::CEILING:
          case MySqlParser::CENTROID:
          case MySqlParser::CHARACTER_LENGTH:
          case MySqlParser::CHARSET:
          case MySqlParser::CHAR_LENGTH:
          case MySqlParser::COERCIBILITY:
          case MySqlParser::COLLATION:
          case MySqlParser::COMPRESS:
          case MySqlParser::CONCAT:
          case MySqlParser::CONCAT_WS:
          case MySqlParser::CONNECTION_ID:
          case MySqlParser::CONV:
          case MySqlParser::CONVERT_TZ:
          case MySqlParser::COS:
          case MySqlParser::COT:
          case MySqlParser::CRC32:
          case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
          case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
          case MySqlParser::CREATE_DH_PARAMETERS:
          case MySqlParser::CREATE_DIGEST:
          case MySqlParser::CROSSES:
          case MySqlParser::DATEDIFF:
          case MySqlParser::DATE_FORMAT:
          case MySqlParser::DAYNAME:
          case MySqlParser::DAYOFMONTH:
          case MySqlParser::DAYOFWEEK:
          case MySqlParser::DAYOFYEAR:
          case MySqlParser::DECODE:
          case MySqlParser::DEGREES:
          case MySqlParser::DES_DECRYPT:
          case MySqlParser::DES_ENCRYPT:
          case MySqlParser::DIMENSION:
          case MySqlParser::DISJOINT:
          case MySqlParser::ELT:
          case MySqlParser::ENCODE:
          case MySqlParser::ENCRYPT:
          case MySqlParser::ENDPOINT:
          case MySqlParser::ENGINE_ATTRIBUTE:
          case MySqlParser::ENVELOPE:
          case MySqlParser::EQUALS:
          case MySqlParser::EXP:
          case MySqlParser::EXPORT_SET:
          case MySqlParser::EXTERIORRING:
          case MySqlParser::EXTRACTVALUE:
          case MySqlParser::FIELD:
          case MySqlParser::FIND_IN_SET:
          case MySqlParser::FLOOR:
          case MySqlParser::FORMAT:
          case MySqlParser::FOUND_ROWS:
          case MySqlParser::FROM_BASE64:
          case MySqlParser::FROM_DAYS:
          case MySqlParser::FROM_UNIXTIME:
          case MySqlParser::GEOMCOLLFROMTEXT:
          case MySqlParser::GEOMCOLLFROMWKB:
          case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::GEOMETRYFROMTEXT:
          case MySqlParser::GEOMETRYFROMWKB:
          case MySqlParser::GEOMETRYN:
          case MySqlParser::GEOMETRYTYPE:
          case MySqlParser::GEOMFROMTEXT:
          case MySqlParser::GEOMFROMWKB:
          case MySqlParser::GET_FORMAT:
          case MySqlParser::GET_LOCK:
          case MySqlParser::GLENGTH:
          case MySqlParser::GREATEST:
          case MySqlParser::GTID_SUBSET:
          case MySqlParser::GTID_SUBTRACT:
          case MySqlParser::HEX:
          case MySqlParser::IFNULL:
          case MySqlParser::INET6_ATON:
          case MySqlParser::INET6_NTOA:
          case MySqlParser::INET_ATON:
          case MySqlParser::INET_NTOA:
          case MySqlParser::INSTR:
          case MySqlParser::INTERIORRINGN:
          case MySqlParser::INTERSECTS:
          case MySqlParser::ISCLOSED:
          case MySqlParser::ISEMPTY:
          case MySqlParser::ISNULL:
          case MySqlParser::ISSIMPLE:
          case MySqlParser::IS_FREE_LOCK:
          case MySqlParser::IS_IPV4:
          case MySqlParser::IS_IPV4_COMPAT:
          case MySqlParser::IS_IPV4_MAPPED:
          case MySqlParser::IS_IPV6:
          case MySqlParser::IS_USED_LOCK:
          case MySqlParser::LAST_INSERT_ID:
          case MySqlParser::LCASE:
          case MySqlParser::LEAST:
          case MySqlParser::LENGTH:
          case MySqlParser::LINEFROMTEXT:
          case MySqlParser::LINEFROMWKB:
          case MySqlParser::LINESTRINGFROMTEXT:
          case MySqlParser::LINESTRINGFROMWKB:
          case MySqlParser::LN:
          case MySqlParser::LOAD_FILE:
          case MySqlParser::LOCATE:
          case MySqlParser::LOG:
          case MySqlParser::LOG10:
          case MySqlParser::LOG2:
          case MySqlParser::LOWER:
          case MySqlParser::LPAD:
          case MySqlParser::LTRIM:
          case MySqlParser::MAKEDATE:
          case MySqlParser::MAKETIME:
          case MySqlParser::MAKE_SET:
          case MySqlParser::MASTER_POS_WAIT:
          case MySqlParser::MBRCONTAINS:
          case MySqlParser::MBRDISJOINT:
          case MySqlParser::MBREQUAL:
          case MySqlParser::MBRINTERSECTS:
          case MySqlParser::MBROVERLAPS:
          case MySqlParser::MBRTOUCHES:
          case MySqlParser::MBRWITHIN:
          case MySqlParser::MD5:
          case MySqlParser::MLINEFROMTEXT:
          case MySqlParser::MLINEFROMWKB:
          case MySqlParser::MONTHNAME:
          case MySqlParser::MPOINTFROMTEXT:
          case MySqlParser::MPOINTFROMWKB:
          case MySqlParser::MPOLYFROMTEXT:
          case MySqlParser::MPOLYFROMWKB:
          case MySqlParser::MULTILINESTRINGFROMTEXT:
          case MySqlParser::MULTILINESTRINGFROMWKB:
          case MySqlParser::MULTIPOINTFROMTEXT:
          case MySqlParser::MULTIPOINTFROMWKB:
          case MySqlParser::MULTIPOLYGONFROMTEXT:
          case MySqlParser::MULTIPOLYGONFROMWKB:
          case MySqlParser::NAME_CONST:
          case MySqlParser::NULLIF:
          case MySqlParser::NUMGEOMETRIES:
          case MySqlParser::NUMINTERIORRINGS:
          case MySqlParser::NUMPOINTS:
          case MySqlParser::OCT:
          case MySqlParser::OCTET_LENGTH:
          case MySqlParser::ORD:
          case MySqlParser::OVERLAPS:
          case MySqlParser::PERIOD_ADD:
          case MySqlParser::PERIOD_DIFF:
          case MySqlParser::PI:
          case MySqlParser::POINTFROMTEXT:
          case MySqlParser::POINTFROMWKB:
          case MySqlParser::POINTN:
          case MySqlParser::POLYFROMTEXT:
          case MySqlParser::POLYFROMWKB:
          case MySqlParser::POLYGONFROMTEXT:
          case MySqlParser::POLYGONFROMWKB:
          case MySqlParser::POW:
          case MySqlParser::POWER:
          case MySqlParser::QUOTE:
          case MySqlParser::RADIANS:
          case MySqlParser::RAND:
          case MySqlParser::RANDOM_BYTES:
          case MySqlParser::RELEASE_LOCK:
          case MySqlParser::REVERSE:
          case MySqlParser::ROUND:
          case MySqlParser::ROW_COUNT:
          case MySqlParser::RPAD:
          case MySqlParser::RTRIM:
          case MySqlParser::SEC_TO_TIME:
          case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
          case MySqlParser::SESSION_USER:
          case MySqlParser::SHA:
          case MySqlParser::SHA1:
          case MySqlParser::SHA2:
          case MySqlParser::SCHEMA_NAME:
          case MySqlParser::SIGN:
          case MySqlParser::SIN:
          case MySqlParser::SLEEP:
          case MySqlParser::SOUNDEX:
          case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
          case MySqlParser::SQRT:
          case MySqlParser::SRID:
          case MySqlParser::STARTPOINT:
          case MySqlParser::STRCMP:
          case MySqlParser::STR_TO_DATE:
          case MySqlParser::ST_AREA:
          case MySqlParser::ST_ASBINARY:
          case MySqlParser::ST_ASTEXT:
          case MySqlParser::ST_ASWKB:
          case MySqlParser::ST_ASWKT:
          case MySqlParser::ST_BUFFER:
          case MySqlParser::ST_CENTROID:
          case MySqlParser::ST_CONTAINS:
          case MySqlParser::ST_CROSSES:
          case MySqlParser::ST_DIFFERENCE:
          case MySqlParser::ST_DIMENSION:
          case MySqlParser::ST_DISJOINT:
          case MySqlParser::ST_DISTANCE:
          case MySqlParser::ST_ENDPOINT:
          case MySqlParser::ST_ENVELOPE:
          case MySqlParser::ST_EQUALS:
          case MySqlParser::ST_EXTERIORRING:
          case MySqlParser::ST_GEOMCOLLFROMTEXT:
          case MySqlParser::ST_GEOMCOLLFROMTXT:
          case MySqlParser::ST_GEOMCOLLFROMWKB:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::ST_GEOMETRYFROMTEXT:
          case MySqlParser::ST_GEOMETRYFROMWKB:
          case MySqlParser::ST_GEOMETRYN:
          case MySqlParser::ST_GEOMETRYTYPE:
          case MySqlParser::ST_GEOMFROMTEXT:
          case MySqlParser::ST_GEOMFROMWKB:
          case MySqlParser::ST_INTERIORRINGN:
          case MySqlParser::ST_INTERSECTION:
          case MySqlParser::ST_INTERSECTS:
          case MySqlParser::ST_ISCLOSED:
          case MySqlParser::ST_ISEMPTY:
          case MySqlParser::ST_ISSIMPLE:
          case MySqlParser::ST_LINEFROMTEXT:
          case MySqlParser::ST_LINEFROMWKB:
          case MySqlParser::ST_LINESTRINGFROMTEXT:
          case MySqlParser::ST_LINESTRINGFROMWKB:
          case MySqlParser::ST_NUMGEOMETRIES:
          case MySqlParser::ST_NUMINTERIORRING:
          case MySqlParser::ST_NUMINTERIORRINGS:
          case MySqlParser::ST_NUMPOINTS:
          case MySqlParser::ST_OVERLAPS:
          case MySqlParser::ST_POINTFROMTEXT:
          case MySqlParser::ST_POINTFROMWKB:
          case MySqlParser::ST_POINTN:
          case MySqlParser::ST_POLYFROMTEXT:
          case MySqlParser::ST_POLYFROMWKB:
          case MySqlParser::ST_POLYGONFROMTEXT:
          case MySqlParser::ST_POLYGONFROMWKB:
          case MySqlParser::ST_SRID:
          case MySqlParser::ST_STARTPOINT:
          case MySqlParser::ST_SYMDIFFERENCE:
          case MySqlParser::ST_TOUCHES:
          case MySqlParser::ST_UNION:
          case MySqlParser::ST_WITHIN:
          case MySqlParser::ST_X:
          case MySqlParser::ST_Y:
          case MySqlParser::SUBDATE:
          case MySqlParser::SUBSTRING_INDEX:
          case MySqlParser::SUBTIME:
          case MySqlParser::SYSTEM_USER:
          case MySqlParser::TAN:
          case MySqlParser::TIMEDIFF:
          case MySqlParser::TIMESTAMPADD:
          case MySqlParser::TIMESTAMPDIFF:
          case MySqlParser::TIME_FORMAT:
          case MySqlParser::TIME_TO_SEC:
          case MySqlParser::TOUCHES:
          case MySqlParser::TO_BASE64:
          case MySqlParser::TO_DAYS:
          case MySqlParser::TO_SECONDS:
          case MySqlParser::TP_CONNECTION_ADMIN:
          case MySqlParser::UCASE:
          case MySqlParser::UNCOMPRESS:
          case MySqlParser::UNCOMPRESSED_LENGTH:
          case MySqlParser::UNHEX:
          case MySqlParser::UNIX_TIMESTAMP:
          case MySqlParser::UPDATEXML:
          case MySqlParser::UPPER:
          case MySqlParser::UUID:
          case MySqlParser::UUID_SHORT:
          case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
          case MySqlParser::VERSION:
          case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
          case MySqlParser::WEEKDAY:
          case MySqlParser::WEEKOFYEAR:
          case MySqlParser::WEIGHT_STRING:
          case MySqlParser::WITHIN:
          case MySqlParser::YEARWEEK:
          case MySqlParser::Y_FUNCTION:
          case MySqlParser::X_FUNCTION:
          case MySqlParser::MOD:
          case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
          case MySqlParser::STRING_LITERAL:
          case MySqlParser::ID: {
            setState(2891);
            uidList();
            break;
          }

          case MySqlParser::ALL: {
            setState(2892);
            match(MySqlParser::ALL);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(2895);
        match(MySqlParser::TABLESPACE);
        break;
      }

      case MySqlParser::TRUNCATE: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByTruncatePartitionContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(2896);
        match(MySqlParser::TRUNCATE);
        setState(2897);
        match(MySqlParser::PARTITION);
        setState(2900);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::ATTRIBUTE:
          case MySqlParser::BUCKETS:
          case MySqlParser::CONDITION:
          case MySqlParser::CURRENT:
          case MySqlParser::CURRENT_USER:
          case MySqlParser::DATABASE:
          case MySqlParser::DEFAULT:
          case MySqlParser::DIAGNOSTICS:
          case MySqlParser::EMPTY:
          case MySqlParser::ENFORCED:
          case MySqlParser::EXCEPT:
          case MySqlParser::GROUP:
          case MySqlParser::IF:
          case MySqlParser::IGNORED:
          case MySqlParser::INSERT:
          case MySqlParser::LATERAL:
          case MySqlParser::LEFT:
          case MySqlParser::NUMBER:
          case MySqlParser::OPTIONAL:
          case MySqlParser::ORDER:
          case MySqlParser::PRIMARY:
          case MySqlParser::REPLACE:
          case MySqlParser::RIGHT:
          case MySqlParser::SCHEMA:
          case MySqlParser::SKIP_QUERY_REWRITE:
          case MySqlParser::STACKED:
          case MySqlParser::DATE:
          case MySqlParser::TIME:
          case MySqlParser::TIMESTAMP:
          case MySqlParser::DATETIME:
          case MySqlParser::YEAR:
          case MySqlParser::BINARY:
          case MySqlParser::TEXT:
          case MySqlParser::ENUM:
          case MySqlParser::SERIAL:
          case MySqlParser::JSON_ARRAY:
          case MySqlParser::JSON_ARRAYAGG:
          case MySqlParser::JSON_ARRAY_APPEND:
          case MySqlParser::JSON_ARRAY_INSERT:
          case MySqlParser::JSON_CONTAINS:
          case MySqlParser::JSON_CONTAINS_PATH:
          case MySqlParser::JSON_DEPTH:
          case MySqlParser::JSON_EXTRACT:
          case MySqlParser::JSON_INSERT:
          case MySqlParser::JSON_KEYS:
          case MySqlParser::JSON_LENGTH:
          case MySqlParser::JSON_MERGE:
          case MySqlParser::JSON_MERGE_PATCH:
          case MySqlParser::JSON_MERGE_PRESERVE:
          case MySqlParser::JSON_OBJECT:
          case MySqlParser::JSON_OBJECTAGG:
          case MySqlParser::JSON_OVERLAPS:
          case MySqlParser::JSON_PRETTY:
          case MySqlParser::JSON_QUOTE:
          case MySqlParser::JSON_REMOVE:
          case MySqlParser::JSON_REPLACE:
          case MySqlParser::JSON_SCHEMA_VALID:
          case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
          case MySqlParser::JSON_SEARCH:
          case MySqlParser::JSON_SET:
          case MySqlParser::JSON_STORAGE_FREE:
          case MySqlParser::JSON_STORAGE_SIZE:
          case MySqlParser::JSON_TABLE:
          case MySqlParser::JSON_TYPE:
          case MySqlParser::JSON_UNQUOTE:
          case MySqlParser::JSON_VALID:
          case MySqlParser::JSON_VALUE:
          case MySqlParser::NESTED:
          case MySqlParser::ORDINALITY:
          case MySqlParser::PATH:
          case MySqlParser::AVG:
          case MySqlParser::BIT_AND:
          case MySqlParser::BIT_OR:
          case MySqlParser::BIT_XOR:
          case MySqlParser::COUNT:
          case MySqlParser::CUME_DIST:
          case MySqlParser::DENSE_RANK:
          case MySqlParser::FIRST_VALUE:
          case MySqlParser::GROUP_CONCAT:
          case MySqlParser::LAG:
          case MySqlParser::LAST_VALUE:
          case MySqlParser::LEAD:
          case MySqlParser::MAX:
          case MySqlParser::MIN:
          case MySqlParser::NTILE:
          case MySqlParser::NTH_VALUE:
          case MySqlParser::PERCENT_RANK:
          case MySqlParser::RANK:
          case MySqlParser::ROW_NUMBER:
          case MySqlParser::STD:
          case MySqlParser::STDDEV:
          case MySqlParser::STDDEV_POP:
          case MySqlParser::STDDEV_SAMP:
          case MySqlParser::SUM:
          case MySqlParser::VAR_POP:
          case MySqlParser::VAR_SAMP:
          case MySqlParser::VARIANCE:
          case MySqlParser::CURRENT_DATE:
          case MySqlParser::CURRENT_TIME:
          case MySqlParser::CURRENT_TIMESTAMP:
          case MySqlParser::LOCALTIME:
          case MySqlParser::CURDATE:
          case MySqlParser::CURTIME:
          case MySqlParser::DATE_ADD:
          case MySqlParser::DATE_SUB:
          case MySqlParser::LOCALTIMESTAMP:
          case MySqlParser::NOW:
          case MySqlParser::POSITION:
          case MySqlParser::SUBSTR:
          case MySqlParser::SUBSTRING:
          case MySqlParser::SYSDATE:
          case MySqlParser::TRIM:
          case MySqlParser::UTC_DATE:
          case MySqlParser::UTC_TIME:
          case MySqlParser::UTC_TIMESTAMP:
          case MySqlParser::ACCOUNT:
          case MySqlParser::ACTION:
          case MySqlParser::AFTER:
          case MySqlParser::AGGREGATE:
          case MySqlParser::ALGORITHM:
          case MySqlParser::ANY:
          case MySqlParser::AT:
          case MySqlParser::AUTHORS:
          case MySqlParser::AUTOCOMMIT:
          case MySqlParser::AUTOEXTEND_SIZE:
          case MySqlParser::AUTO_INCREMENT:
          case MySqlParser::AVG_ROW_LENGTH:
          case MySqlParser::BEGIN:
          case MySqlParser::BINLOG:
          case MySqlParser::BIT:
          case MySqlParser::BLOCK:
          case MySqlParser::BOOL:
          case MySqlParser::BOOLEAN:
          case MySqlParser::BTREE:
          case MySqlParser::CACHE:
          case MySqlParser::CASCADED:
          case MySqlParser::CHAIN:
          case MySqlParser::CHANGED:
          case MySqlParser::CHANNEL:
          case MySqlParser::CHECKSUM:
          case MySqlParser::PAGE_CHECKSUM:
          case MySqlParser::CIPHER:
          case MySqlParser::CLASS_ORIGIN:
          case MySqlParser::CLIENT:
          case MySqlParser::CLOSE:
          case MySqlParser::CLUSTERING:
          case MySqlParser::COALESCE:
          case MySqlParser::CODE:
          case MySqlParser::COLUMNS:
          case MySqlParser::COLUMN_FORMAT:
          case MySqlParser::COLUMN_NAME:
          case MySqlParser::COMMENT:
          case MySqlParser::COMMIT:
          case MySqlParser::COMPACT:
          case MySqlParser::COMPLETION:
          case MySqlParser::COMPRESSED:
          case MySqlParser::COMPRESSION:
          case MySqlParser::CONCURRENT:
          case MySqlParser::CONNECT:
          case MySqlParser::CONNECTION:
          case MySqlParser::CONSISTENT:
          case MySqlParser::CONSTRAINT_CATALOG:
          case MySqlParser::CONSTRAINT_SCHEMA:
          case MySqlParser::CONSTRAINT_NAME:
          case MySqlParser::CONTAINS:
          case MySqlParser::CONTEXT:
          case MySqlParser::CONTRIBUTORS:
          case MySqlParser::COPY:
          case MySqlParser::CPU:
          case MySqlParser::CURSOR_NAME:
          case MySqlParser::DATA:
          case MySqlParser::DATAFILE:
          case MySqlParser::DEALLOCATE:
          case MySqlParser::DEFAULT_AUTH:
          case MySqlParser::DEFINER:
          case MySqlParser::DELAY_KEY_WRITE:
          case MySqlParser::DES_KEY_FILE:
          case MySqlParser::DIRECTORY:
          case MySqlParser::DISABLE:
          case MySqlParser::DISCARD:
          case MySqlParser::DISK:
          case MySqlParser::DO:
          case MySqlParser::DUMPFILE:
          case MySqlParser::DUPLICATE:
          case MySqlParser::DYNAMIC:
          case MySqlParser::ENABLE:
          case MySqlParser::ENCRYPTION:
          case MySqlParser::END:
          case MySqlParser::ENDS:
          case MySqlParser::ENGINE:
          case MySqlParser::ENGINES:
          case MySqlParser::ERROR:
          case MySqlParser::ERRORS:
          case MySqlParser::ESCAPE:
          case MySqlParser::EVEN:
          case MySqlParser::EVENT:
          case MySqlParser::EVENTS:
          case MySqlParser::EVERY:
          case MySqlParser::EXCHANGE:
          case MySqlParser::EXCLUSIVE:
          case MySqlParser::EXPIRE:
          case MySqlParser::EXPORT:
          case MySqlParser::EXTENDED:
          case MySqlParser::EXTENT_SIZE:
          case MySqlParser::FAILED_LOGIN_ATTEMPTS:
          case MySqlParser::FAST:
          case MySqlParser::FAULTS:
          case MySqlParser::FIELDS:
          case MySqlParser::FILE_BLOCK_SIZE:
          case MySqlParser::FILTER:
          case MySqlParser::FIRST:
          case MySqlParser::FIXED:
          case MySqlParser::FLUSH:
          case MySqlParser::FOLLOWS:
          case MySqlParser::FOUND:
          case MySqlParser::FULL:
          case MySqlParser::FUNCTION:
          case MySqlParser::GENERAL:
          case MySqlParser::GLOBAL:
          case MySqlParser::GRANTS:
          case MySqlParser::GROUP_REPLICATION:
          case MySqlParser::HANDLER:
          case MySqlParser::HASH:
          case MySqlParser::HELP:
          case MySqlParser::HISTORY:
          case MySqlParser::HOST:
          case MySqlParser::HOSTS:
          case MySqlParser::IDENTIFIED:
          case MySqlParser::IGNORE_SERVER_IDS:
          case MySqlParser::IMPORT:
          case MySqlParser::INDEXES:
          case MySqlParser::INITIAL_SIZE:
          case MySqlParser::INPLACE:
          case MySqlParser::INSERT_METHOD:
          case MySqlParser::INSTALL:
          case MySqlParser::INSTANCE:
          case MySqlParser::INSTANT:
          case MySqlParser::INVISIBLE:
          case MySqlParser::INVOKER:
          case MySqlParser::IO:
          case MySqlParser::IO_THREAD:
          case MySqlParser::IPC:
          case MySqlParser::ISOLATION:
          case MySqlParser::ISSUER:
          case MySqlParser::JSON:
          case MySqlParser::KEY_BLOCK_SIZE:
          case MySqlParser::LANGUAGE:
          case MySqlParser::LAST:
          case MySqlParser::LEAVES:
          case MySqlParser::LESS:
          case MySqlParser::LEVEL:
          case MySqlParser::LIST:
          case MySqlParser::LOCAL:
          case MySqlParser::LOGFILE:
          case MySqlParser::LOGS:
          case MySqlParser::MASTER:
          case MySqlParser::MASTER_AUTO_POSITION:
          case MySqlParser::MASTER_CONNECT_RETRY:
          case MySqlParser::MASTER_DELAY:
          case MySqlParser::MASTER_HEARTBEAT_PERIOD:
          case MySqlParser::MASTER_HOST:
          case MySqlParser::MASTER_LOG_FILE:
          case MySqlParser::MASTER_LOG_POS:
          case MySqlParser::MASTER_PASSWORD:
          case MySqlParser::MASTER_PORT:
          case MySqlParser::MASTER_RETRY_COUNT:
          case MySqlParser::MASTER_SSL:
          case MySqlParser::MASTER_SSL_CA:
          case MySqlParser::MASTER_SSL_CAPATH:
          case MySqlParser::MASTER_SSL_CERT:
          case MySqlParser::MASTER_SSL_CIPHER:
          case MySqlParser::MASTER_SSL_CRL:
          case MySqlParser::MASTER_SSL_CRLPATH:
          case MySqlParser::MASTER_SSL_KEY:
          case MySqlParser::MASTER_TLS_VERSION:
          case MySqlParser::MASTER_USER:
          case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
          case MySqlParser::MAX_QUERIES_PER_HOUR:
          case MySqlParser::MAX_ROWS:
          case MySqlParser::MAX_SIZE:
          case MySqlParser::MAX_UPDATES_PER_HOUR:
          case MySqlParser::MAX_USER_CONNECTIONS:
          case MySqlParser::MEDIUM:
          case MySqlParser::MEMBER:
          case MySqlParser::MERGE:
          case MySqlParser::MESSAGE_TEXT:
          case MySqlParser::MID:
          case MySqlParser::MIGRATE:
          case MySqlParser::MIN_ROWS:
          case MySqlParser::MODE:
          case MySqlParser::MODIFY:
          case MySqlParser::MUTEX:
          case MySqlParser::MYSQL:
          case MySqlParser::MYSQL_ERRNO:
          case MySqlParser::NAME:
          case MySqlParser::NAMES:
          case MySqlParser::NCHAR:
          case MySqlParser::NEVER:
          case MySqlParser::NEXT:
          case MySqlParser::NO:
          case MySqlParser::NOCOPY:
          case MySqlParser::NOWAIT:
          case MySqlParser::NODEGROUP:
          case MySqlParser::NONE:
          case MySqlParser::ODBC:
          case MySqlParser::OFFLINE:
          case MySqlParser::OFFSET:
          case MySqlParser::OF:
          case MySqlParser::OJ:
          case MySqlParser::OLD_PASSWORD:
          case MySqlParser::ONE:
          case MySqlParser::ONLINE:
          case MySqlParser::ONLY:
          case MySqlParser::OPEN:
          case MySqlParser::OPTIMIZER_COSTS:
          case MySqlParser::OPTIONS:
          case MySqlParser::OWNER:
          case MySqlParser::PACK_KEYS:
          case MySqlParser::PAGE:
          case MySqlParser::PARSER:
          case MySqlParser::PARTIAL:
          case MySqlParser::PARTITIONING:
          case MySqlParser::PARTITIONS:
          case MySqlParser::PASSWORD:
          case MySqlParser::PASSWORD_LOCK_TIME:
          case MySqlParser::PHASE:
          case MySqlParser::PLUGIN:
          case MySqlParser::PLUGIN_DIR:
          case MySqlParser::PLUGINS:
          case MySqlParser::PORT:
          case MySqlParser::PRECEDES:
          case MySqlParser::PREPARE:
          case MySqlParser::PRESERVE:
          case MySqlParser::PREV:
          case MySqlParser::PROCESSLIST:
          case MySqlParser::PROFILE:
          case MySqlParser::PROFILES:
          case MySqlParser::PROXY:
          case MySqlParser::QUERY:
          case MySqlParser::QUICK:
          case MySqlParser::REBUILD:
          case MySqlParser::RECOVER:
          case MySqlParser::RECURSIVE:
          case MySqlParser::REDO_BUFFER_SIZE:
          case MySqlParser::REDUNDANT:
          case MySqlParser::RELAY:
          case MySqlParser::RELAY_LOG_FILE:
          case MySqlParser::RELAY_LOG_POS:
          case MySqlParser::RELAYLOG:
          case MySqlParser::REMOVE:
          case MySqlParser::REORGANIZE:
          case MySqlParser::REPAIR:
          case MySqlParser::REPLICATE_DO_DB:
          case MySqlParser::REPLICATE_DO_TABLE:
          case MySqlParser::REPLICATE_IGNORE_DB:
          case MySqlParser::REPLICATE_IGNORE_TABLE:
          case MySqlParser::REPLICATE_REWRITE_DB:
          case MySqlParser::REPLICATE_WILD_DO_TABLE:
          case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
          case MySqlParser::REPLICATION:
          case MySqlParser::RESET:
          case MySqlParser::RESUME:
          case MySqlParser::RETURNED_SQLSTATE:
          case MySqlParser::RETURNS:
          case MySqlParser::REUSE:
          case MySqlParser::ROLE:
          case MySqlParser::ROLLBACK:
          case MySqlParser::ROLLUP:
          case MySqlParser::ROTATE:
          case MySqlParser::ROW:
          case MySqlParser::ROWS:
          case MySqlParser::ROW_FORMAT:
          case MySqlParser::RTREE:
          case MySqlParser::SAVEPOINT:
          case MySqlParser::SCHEDULE:
          case MySqlParser::SECURITY:
          case MySqlParser::SERVER:
          case MySqlParser::SESSION:
          case MySqlParser::SHARE:
          case MySqlParser::SHARED:
          case MySqlParser::SIGNED:
          case MySqlParser::SIMPLE:
          case MySqlParser::SLAVE:
          case MySqlParser::SLOW:
          case MySqlParser::SNAPSHOT:
          case MySqlParser::SOCKET:
          case MySqlParser::SOME:
          case MySqlParser::SONAME:
          case MySqlParser::SOUNDS:
          case MySqlParser::SOURCE:
          case MySqlParser::SQL_AFTER_GTIDS:
          case MySqlParser::SQL_AFTER_MTS_GAPS:
          case MySqlParser::SQL_BEFORE_GTIDS:
          case MySqlParser::SQL_BUFFER_RESULT:
          case MySqlParser::SQL_CACHE:
          case MySqlParser::SQL_NO_CACHE:
          case MySqlParser::SQL_THREAD:
          case MySqlParser::START:
          case MySqlParser::STARTS:
          case MySqlParser::STATS_AUTO_RECALC:
          case MySqlParser::STATS_PERSISTENT:
          case MySqlParser::STATS_SAMPLE_PAGES:
          case MySqlParser::STATUS:
          case MySqlParser::STOP:
          case MySqlParser::STORAGE:
          case MySqlParser::STRING:
          case MySqlParser::SUBCLASS_ORIGIN:
          case MySqlParser::SUBJECT:
          case MySqlParser::SUBPARTITION:
          case MySqlParser::SUBPARTITIONS:
          case MySqlParser::SUSPEND:
          case MySqlParser::SWAPS:
          case MySqlParser::SWITCHES:
          case MySqlParser::TABLE_NAME:
          case MySqlParser::TABLESPACE:
          case MySqlParser::TABLE_TYPE:
          case MySqlParser::TEMPORARY:
          case MySqlParser::TEMPTABLE:
          case MySqlParser::THAN:
          case MySqlParser::TRADITIONAL:
          case MySqlParser::TRANSACTION:
          case MySqlParser::TRANSACTIONAL:
          case MySqlParser::TRIGGERS:
          case MySqlParser::TRUNCATE:
          case MySqlParser::UNBOUNDED:
          case MySqlParser::UNDEFINED:
          case MySqlParser::UNDOFILE:
          case MySqlParser::UNDO_BUFFER_SIZE:
          case MySqlParser::UNINSTALL:
          case MySqlParser::UNKNOWN:
          case MySqlParser::UNTIL:
          case MySqlParser::UPGRADE:
          case MySqlParser::USER:
          case MySqlParser::USE_FRM:
          case MySqlParser::USER_RESOURCES:
          case MySqlParser::VALIDATION:
          case MySqlParser::VALUE:
          case MySqlParser::VARIABLES:
          case MySqlParser::VIEW:
          case MySqlParser::VIRTUAL:
          case MySqlParser::VISIBLE:
          case MySqlParser::WAIT:
          case MySqlParser::WARNINGS:
          case MySqlParser::WITHOUT:
          case MySqlParser::WORK:
          case MySqlParser::WRAPPER:
          case MySqlParser::X509:
          case MySqlParser::XA:
          case MySqlParser::XML:
          case MySqlParser::EUR:
          case MySqlParser::USA:
          case MySqlParser::JIS:
          case MySqlParser::ISO:
          case MySqlParser::INTERNAL:
          case MySqlParser::QUARTER:
          case MySqlParser::MONTH:
          case MySqlParser::DAY:
          case MySqlParser::HOUR:
          case MySqlParser::MINUTE:
          case MySqlParser::WEEK:
          case MySqlParser::SECOND:
          case MySqlParser::MICROSECOND:
          case MySqlParser::ADMIN:
          case MySqlParser::AUDIT_ABORT_EXEMPT:
          case MySqlParser::AUDIT_ADMIN:
          case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
          case MySqlParser::BACKUP_ADMIN:
          case MySqlParser::BINLOG_ADMIN:
          case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
          case MySqlParser::CLONE_ADMIN:
          case MySqlParser::CONNECTION_ADMIN:
          case MySqlParser::ENCRYPTION_KEY_ADMIN:
          case MySqlParser::EXECUTE:
          case MySqlParser::FILE:
          case MySqlParser::FIREWALL_ADMIN:
          case MySqlParser::FIREWALL_EXEMPT:
          case MySqlParser::FIREWALL_USER:
          case MySqlParser::GROUP_REPLICATION_ADMIN:
          case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
          case MySqlParser::INVOKE:
          case MySqlParser::LAMBDA:
          case MySqlParser::NDB_STORED_USER:
          case MySqlParser::PASSWORDLESS_USER_ADMIN:
          case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
          case MySqlParser::PRIVILEGES:
          case MySqlParser::PROCESS:
          case MySqlParser::RELOAD:
          case MySqlParser::REPLICATION_APPLIER:
          case MySqlParser::REPLICATION_SLAVE_ADMIN:
          case MySqlParser::RESOURCE_GROUP_ADMIN:
          case MySqlParser::RESOURCE_GROUP_USER:
          case MySqlParser::ROLE_ADMIN:
          case MySqlParser::ROUTINE:
          case MySqlParser::S3:
          case MySqlParser::SESSION_VARIABLES_ADMIN:
          case MySqlParser::SET_USER_ID:
          case MySqlParser::SHOW_ROUTINE:
          case MySqlParser::SHUTDOWN:
          case MySqlParser::SUPER:
          case MySqlParser::SYSTEM_VARIABLES_ADMIN:
          case MySqlParser::TABLES:
          case MySqlParser::TABLE_ENCRYPTION_ADMIN:
          case MySqlParser::VERSION_TOKEN_ADMIN:
          case MySqlParser::XA_RECOVER_ADMIN:
          case MySqlParser::ARMSCII8:
          case MySqlParser::ASCII:
          case MySqlParser::BIG5:
          case MySqlParser::CP1250:
          case MySqlParser::CP1251:
          case MySqlParser::CP1256:
          case MySqlParser::CP1257:
          case MySqlParser::CP850:
          case MySqlParser::CP852:
          case MySqlParser::CP866:
          case MySqlParser::CP932:
          case MySqlParser::DEC8:
          case MySqlParser::EUCJPMS:
          case MySqlParser::EUCKR:
          case MySqlParser::GB18030:
          case MySqlParser::GB2312:
          case MySqlParser::GBK:
          case MySqlParser::GEOSTD8:
          case MySqlParser::GREEK:
          case MySqlParser::HEBREW:
          case MySqlParser::HP8:
          case MySqlParser::KEYBCS2:
          case MySqlParser::KOI8R:
          case MySqlParser::KOI8U:
          case MySqlParser::LATIN1:
          case MySqlParser::LATIN2:
          case MySqlParser::LATIN5:
          case MySqlParser::LATIN7:
          case MySqlParser::MACCE:
          case MySqlParser::MACROMAN:
          case MySqlParser::SJIS:
          case MySqlParser::SWE7:
          case MySqlParser::TIS620:
          case MySqlParser::UCS2:
          case MySqlParser::UJIS:
          case MySqlParser::UTF16:
          case MySqlParser::UTF16LE:
          case MySqlParser::UTF32:
          case MySqlParser::UTF8:
          case MySqlParser::UTF8MB3:
          case MySqlParser::UTF8MB4:
          case MySqlParser::ARCHIVE:
          case MySqlParser::BLACKHOLE:
          case MySqlParser::CSV:
          case MySqlParser::FEDERATED:
          case MySqlParser::INNODB:
          case MySqlParser::MEMORY:
          case MySqlParser::MRG_MYISAM:
          case MySqlParser::MYISAM:
          case MySqlParser::NDB:
          case MySqlParser::NDBCLUSTER:
          case MySqlParser::PERFORMANCE_SCHEMA:
          case MySqlParser::TOKUDB:
          case MySqlParser::REPEATABLE:
          case MySqlParser::COMMITTED:
          case MySqlParser::UNCOMMITTED:
          case MySqlParser::SERIALIZABLE:
          case MySqlParser::GEOMETRYCOLLECTION:
          case MySqlParser::LINESTRING:
          case MySqlParser::MULTILINESTRING:
          case MySqlParser::MULTIPOINT:
          case MySqlParser::MULTIPOLYGON:
          case MySqlParser::POINT:
          case MySqlParser::POLYGON:
          case MySqlParser::ABS:
          case MySqlParser::ACOS:
          case MySqlParser::ADDDATE:
          case MySqlParser::ADDTIME:
          case MySqlParser::AES_DECRYPT:
          case MySqlParser::AES_ENCRYPT:
          case MySqlParser::AREA:
          case MySqlParser::ASBINARY:
          case MySqlParser::ASIN:
          case MySqlParser::ASTEXT:
          case MySqlParser::ASWKB:
          case MySqlParser::ASWKT:
          case MySqlParser::ASYMMETRIC_DECRYPT:
          case MySqlParser::ASYMMETRIC_DERIVE:
          case MySqlParser::ASYMMETRIC_ENCRYPT:
          case MySqlParser::ASYMMETRIC_SIGN:
          case MySqlParser::ASYMMETRIC_VERIFY:
          case MySqlParser::ATAN:
          case MySqlParser::ATAN2:
          case MySqlParser::BENCHMARK:
          case MySqlParser::BIN:
          case MySqlParser::BIT_COUNT:
          case MySqlParser::BIT_LENGTH:
          case MySqlParser::BUFFER:
          case MySqlParser::CATALOG_NAME:
          case MySqlParser::CEIL:
          case MySqlParser::CEILING:
          case MySqlParser::CENTROID:
          case MySqlParser::CHARACTER_LENGTH:
          case MySqlParser::CHARSET:
          case MySqlParser::CHAR_LENGTH:
          case MySqlParser::COERCIBILITY:
          case MySqlParser::COLLATION:
          case MySqlParser::COMPRESS:
          case MySqlParser::CONCAT:
          case MySqlParser::CONCAT_WS:
          case MySqlParser::CONNECTION_ID:
          case MySqlParser::CONV:
          case MySqlParser::CONVERT_TZ:
          case MySqlParser::COS:
          case MySqlParser::COT:
          case MySqlParser::CRC32:
          case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
          case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
          case MySqlParser::CREATE_DH_PARAMETERS:
          case MySqlParser::CREATE_DIGEST:
          case MySqlParser::CROSSES:
          case MySqlParser::DATEDIFF:
          case MySqlParser::DATE_FORMAT:
          case MySqlParser::DAYNAME:
          case MySqlParser::DAYOFMONTH:
          case MySqlParser::DAYOFWEEK:
          case MySqlParser::DAYOFYEAR:
          case MySqlParser::DECODE:
          case MySqlParser::DEGREES:
          case MySqlParser::DES_DECRYPT:
          case MySqlParser::DES_ENCRYPT:
          case MySqlParser::DIMENSION:
          case MySqlParser::DISJOINT:
          case MySqlParser::ELT:
          case MySqlParser::ENCODE:
          case MySqlParser::ENCRYPT:
          case MySqlParser::ENDPOINT:
          case MySqlParser::ENGINE_ATTRIBUTE:
          case MySqlParser::ENVELOPE:
          case MySqlParser::EQUALS:
          case MySqlParser::EXP:
          case MySqlParser::EXPORT_SET:
          case MySqlParser::EXTERIORRING:
          case MySqlParser::EXTRACTVALUE:
          case MySqlParser::FIELD:
          case MySqlParser::FIND_IN_SET:
          case MySqlParser::FLOOR:
          case MySqlParser::FORMAT:
          case MySqlParser::FOUND_ROWS:
          case MySqlParser::FROM_BASE64:
          case MySqlParser::FROM_DAYS:
          case MySqlParser::FROM_UNIXTIME:
          case MySqlParser::GEOMCOLLFROMTEXT:
          case MySqlParser::GEOMCOLLFROMWKB:
          case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::GEOMETRYFROMTEXT:
          case MySqlParser::GEOMETRYFROMWKB:
          case MySqlParser::GEOMETRYN:
          case MySqlParser::GEOMETRYTYPE:
          case MySqlParser::GEOMFROMTEXT:
          case MySqlParser::GEOMFROMWKB:
          case MySqlParser::GET_FORMAT:
          case MySqlParser::GET_LOCK:
          case MySqlParser::GLENGTH:
          case MySqlParser::GREATEST:
          case MySqlParser::GTID_SUBSET:
          case MySqlParser::GTID_SUBTRACT:
          case MySqlParser::HEX:
          case MySqlParser::IFNULL:
          case MySqlParser::INET6_ATON:
          case MySqlParser::INET6_NTOA:
          case MySqlParser::INET_ATON:
          case MySqlParser::INET_NTOA:
          case MySqlParser::INSTR:
          case MySqlParser::INTERIORRINGN:
          case MySqlParser::INTERSECTS:
          case MySqlParser::ISCLOSED:
          case MySqlParser::ISEMPTY:
          case MySqlParser::ISNULL:
          case MySqlParser::ISSIMPLE:
          case MySqlParser::IS_FREE_LOCK:
          case MySqlParser::IS_IPV4:
          case MySqlParser::IS_IPV4_COMPAT:
          case MySqlParser::IS_IPV4_MAPPED:
          case MySqlParser::IS_IPV6:
          case MySqlParser::IS_USED_LOCK:
          case MySqlParser::LAST_INSERT_ID:
          case MySqlParser::LCASE:
          case MySqlParser::LEAST:
          case MySqlParser::LENGTH:
          case MySqlParser::LINEFROMTEXT:
          case MySqlParser::LINEFROMWKB:
          case MySqlParser::LINESTRINGFROMTEXT:
          case MySqlParser::LINESTRINGFROMWKB:
          case MySqlParser::LN:
          case MySqlParser::LOAD_FILE:
          case MySqlParser::LOCATE:
          case MySqlParser::LOG:
          case MySqlParser::LOG10:
          case MySqlParser::LOG2:
          case MySqlParser::LOWER:
          case MySqlParser::LPAD:
          case MySqlParser::LTRIM:
          case MySqlParser::MAKEDATE:
          case MySqlParser::MAKETIME:
          case MySqlParser::MAKE_SET:
          case MySqlParser::MASTER_POS_WAIT:
          case MySqlParser::MBRCONTAINS:
          case MySqlParser::MBRDISJOINT:
          case MySqlParser::MBREQUAL:
          case MySqlParser::MBRINTERSECTS:
          case MySqlParser::MBROVERLAPS:
          case MySqlParser::MBRTOUCHES:
          case MySqlParser::MBRWITHIN:
          case MySqlParser::MD5:
          case MySqlParser::MLINEFROMTEXT:
          case MySqlParser::MLINEFROMWKB:
          case MySqlParser::MONTHNAME:
          case MySqlParser::MPOINTFROMTEXT:
          case MySqlParser::MPOINTFROMWKB:
          case MySqlParser::MPOLYFROMTEXT:
          case MySqlParser::MPOLYFROMWKB:
          case MySqlParser::MULTILINESTRINGFROMTEXT:
          case MySqlParser::MULTILINESTRINGFROMWKB:
          case MySqlParser::MULTIPOINTFROMTEXT:
          case MySqlParser::MULTIPOINTFROMWKB:
          case MySqlParser::MULTIPOLYGONFROMTEXT:
          case MySqlParser::MULTIPOLYGONFROMWKB:
          case MySqlParser::NAME_CONST:
          case MySqlParser::NULLIF:
          case MySqlParser::NUMGEOMETRIES:
          case MySqlParser::NUMINTERIORRINGS:
          case MySqlParser::NUMPOINTS:
          case MySqlParser::OCT:
          case MySqlParser::OCTET_LENGTH:
          case MySqlParser::ORD:
          case MySqlParser::OVERLAPS:
          case MySqlParser::PERIOD_ADD:
          case MySqlParser::PERIOD_DIFF:
          case MySqlParser::PI:
          case MySqlParser::POINTFROMTEXT:
          case MySqlParser::POINTFROMWKB:
          case MySqlParser::POINTN:
          case MySqlParser::POLYFROMTEXT:
          case MySqlParser::POLYFROMWKB:
          case MySqlParser::POLYGONFROMTEXT:
          case MySqlParser::POLYGONFROMWKB:
          case MySqlParser::POW:
          case MySqlParser::POWER:
          case MySqlParser::QUOTE:
          case MySqlParser::RADIANS:
          case MySqlParser::RAND:
          case MySqlParser::RANDOM_BYTES:
          case MySqlParser::RELEASE_LOCK:
          case MySqlParser::REVERSE:
          case MySqlParser::ROUND:
          case MySqlParser::ROW_COUNT:
          case MySqlParser::RPAD:
          case MySqlParser::RTRIM:
          case MySqlParser::SEC_TO_TIME:
          case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
          case MySqlParser::SESSION_USER:
          case MySqlParser::SHA:
          case MySqlParser::SHA1:
          case MySqlParser::SHA2:
          case MySqlParser::SCHEMA_NAME:
          case MySqlParser::SIGN:
          case MySqlParser::SIN:
          case MySqlParser::SLEEP:
          case MySqlParser::SOUNDEX:
          case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
          case MySqlParser::SQRT:
          case MySqlParser::SRID:
          case MySqlParser::STARTPOINT:
          case MySqlParser::STRCMP:
          case MySqlParser::STR_TO_DATE:
          case MySqlParser::ST_AREA:
          case MySqlParser::ST_ASBINARY:
          case MySqlParser::ST_ASTEXT:
          case MySqlParser::ST_ASWKB:
          case MySqlParser::ST_ASWKT:
          case MySqlParser::ST_BUFFER:
          case MySqlParser::ST_CENTROID:
          case MySqlParser::ST_CONTAINS:
          case MySqlParser::ST_CROSSES:
          case MySqlParser::ST_DIFFERENCE:
          case MySqlParser::ST_DIMENSION:
          case MySqlParser::ST_DISJOINT:
          case MySqlParser::ST_DISTANCE:
          case MySqlParser::ST_ENDPOINT:
          case MySqlParser::ST_ENVELOPE:
          case MySqlParser::ST_EQUALS:
          case MySqlParser::ST_EXTERIORRING:
          case MySqlParser::ST_GEOMCOLLFROMTEXT:
          case MySqlParser::ST_GEOMCOLLFROMTXT:
          case MySqlParser::ST_GEOMCOLLFROMWKB:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::ST_GEOMETRYFROMTEXT:
          case MySqlParser::ST_GEOMETRYFROMWKB:
          case MySqlParser::ST_GEOMETRYN:
          case MySqlParser::ST_GEOMETRYTYPE:
          case MySqlParser::ST_GEOMFROMTEXT:
          case MySqlParser::ST_GEOMFROMWKB:
          case MySqlParser::ST_INTERIORRINGN:
          case MySqlParser::ST_INTERSECTION:
          case MySqlParser::ST_INTERSECTS:
          case MySqlParser::ST_ISCLOSED:
          case MySqlParser::ST_ISEMPTY:
          case MySqlParser::ST_ISSIMPLE:
          case MySqlParser::ST_LINEFROMTEXT:
          case MySqlParser::ST_LINEFROMWKB:
          case MySqlParser::ST_LINESTRINGFROMTEXT:
          case MySqlParser::ST_LINESTRINGFROMWKB:
          case MySqlParser::ST_NUMGEOMETRIES:
          case MySqlParser::ST_NUMINTERIORRING:
          case MySqlParser::ST_NUMINTERIORRINGS:
          case MySqlParser::ST_NUMPOINTS:
          case MySqlParser::ST_OVERLAPS:
          case MySqlParser::ST_POINTFROMTEXT:
          case MySqlParser::ST_POINTFROMWKB:
          case MySqlParser::ST_POINTN:
          case MySqlParser::ST_POLYFROMTEXT:
          case MySqlParser::ST_POLYFROMWKB:
          case MySqlParser::ST_POLYGONFROMTEXT:
          case MySqlParser::ST_POLYGONFROMWKB:
          case MySqlParser::ST_SRID:
          case MySqlParser::ST_STARTPOINT:
          case MySqlParser::ST_SYMDIFFERENCE:
          case MySqlParser::ST_TOUCHES:
          case MySqlParser::ST_UNION:
          case MySqlParser::ST_WITHIN:
          case MySqlParser::ST_X:
          case MySqlParser::ST_Y:
          case MySqlParser::SUBDATE:
          case MySqlParser::SUBSTRING_INDEX:
          case MySqlParser::SUBTIME:
          case MySqlParser::SYSTEM_USER:
          case MySqlParser::TAN:
          case MySqlParser::TIMEDIFF:
          case MySqlParser::TIMESTAMPADD:
          case MySqlParser::TIMESTAMPDIFF:
          case MySqlParser::TIME_FORMAT:
          case MySqlParser::TIME_TO_SEC:
          case MySqlParser::TOUCHES:
          case MySqlParser::TO_BASE64:
          case MySqlParser::TO_DAYS:
          case MySqlParser::TO_SECONDS:
          case MySqlParser::TP_CONNECTION_ADMIN:
          case MySqlParser::UCASE:
          case MySqlParser::UNCOMPRESS:
          case MySqlParser::UNCOMPRESSED_LENGTH:
          case MySqlParser::UNHEX:
          case MySqlParser::UNIX_TIMESTAMP:
          case MySqlParser::UPDATEXML:
          case MySqlParser::UPPER:
          case MySqlParser::UUID:
          case MySqlParser::UUID_SHORT:
          case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
          case MySqlParser::VERSION:
          case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
          case MySqlParser::WEEKDAY:
          case MySqlParser::WEEKOFYEAR:
          case MySqlParser::WEIGHT_STRING:
          case MySqlParser::WITHIN:
          case MySqlParser::YEARWEEK:
          case MySqlParser::Y_FUNCTION:
          case MySqlParser::X_FUNCTION:
          case MySqlParser::MOD:
          case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
          case MySqlParser::STRING_LITERAL:
          case MySqlParser::ID: {
            setState(2898);
            uidList();
            break;
          }

          case MySqlParser::ALL: {
            setState(2899);
            match(MySqlParser::ALL);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySqlParser::COALESCE: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByCoalescePartitionContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(2902);
        match(MySqlParser::COALESCE);
        setState(2903);
        match(MySqlParser::PARTITION);
        setState(2904);
        decimalLiteral();
        break;
      }

      case MySqlParser::REORGANIZE: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByReorganizePartitionContext>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(2905);
        match(MySqlParser::REORGANIZE);
        setState(2906);
        match(MySqlParser::PARTITION);
        setState(2907);
        uidList();
        setState(2908);
        match(MySqlParser::INTO);
        setState(2909);
        match(MySqlParser::LR_BRACKET);
        setState(2910);
        partitionDefinition();
        setState(2915);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(2911);
          match(MySqlParser::COMMA);
          setState(2912);
          partitionDefinition();
          setState(2917);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2918);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      case MySqlParser::EXCHANGE: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByExchangePartitionContext>(_localctx);
        enterOuterAlt(_localctx, 8);
        setState(2920);
        match(MySqlParser::EXCHANGE);
        setState(2921);
        match(MySqlParser::PARTITION);
        setState(2922);
        uid();
        setState(2923);
        match(MySqlParser::WITH);
        setState(2924);
        match(MySqlParser::TABLE);
        setState(2925);
        tableName();
        setState(2928);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 375, _ctx)) {
        case 1: {
          setState(2926);
          antlrcpp::downCast<AlterByExchangePartitionContext *>(_localctx)->validationFormat = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::WITH || _la == MySqlParser::WITHOUT)) {
            antlrcpp::downCast<AlterByExchangePartitionContext *>(_localctx)->validationFormat = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2927);
          match(MySqlParser::VALIDATION);
          break;
        }

        default:
          break;
        }
        break;
      }

      case MySqlParser::ANALYZE: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByAnalyzePartitionContext>(_localctx);
        enterOuterAlt(_localctx, 9);
        setState(2930);
        match(MySqlParser::ANALYZE);
        setState(2931);
        match(MySqlParser::PARTITION);
        setState(2934);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::ATTRIBUTE:
          case MySqlParser::BUCKETS:
          case MySqlParser::CONDITION:
          case MySqlParser::CURRENT:
          case MySqlParser::CURRENT_USER:
          case MySqlParser::DATABASE:
          case MySqlParser::DEFAULT:
          case MySqlParser::DIAGNOSTICS:
          case MySqlParser::EMPTY:
          case MySqlParser::ENFORCED:
          case MySqlParser::EXCEPT:
          case MySqlParser::GROUP:
          case MySqlParser::IF:
          case MySqlParser::IGNORED:
          case MySqlParser::INSERT:
          case MySqlParser::LATERAL:
          case MySqlParser::LEFT:
          case MySqlParser::NUMBER:
          case MySqlParser::OPTIONAL:
          case MySqlParser::ORDER:
          case MySqlParser::PRIMARY:
          case MySqlParser::REPLACE:
          case MySqlParser::RIGHT:
          case MySqlParser::SCHEMA:
          case MySqlParser::SKIP_QUERY_REWRITE:
          case MySqlParser::STACKED:
          case MySqlParser::DATE:
          case MySqlParser::TIME:
          case MySqlParser::TIMESTAMP:
          case MySqlParser::DATETIME:
          case MySqlParser::YEAR:
          case MySqlParser::BINARY:
          case MySqlParser::TEXT:
          case MySqlParser::ENUM:
          case MySqlParser::SERIAL:
          case MySqlParser::JSON_ARRAY:
          case MySqlParser::JSON_ARRAYAGG:
          case MySqlParser::JSON_ARRAY_APPEND:
          case MySqlParser::JSON_ARRAY_INSERT:
          case MySqlParser::JSON_CONTAINS:
          case MySqlParser::JSON_CONTAINS_PATH:
          case MySqlParser::JSON_DEPTH:
          case MySqlParser::JSON_EXTRACT:
          case MySqlParser::JSON_INSERT:
          case MySqlParser::JSON_KEYS:
          case MySqlParser::JSON_LENGTH:
          case MySqlParser::JSON_MERGE:
          case MySqlParser::JSON_MERGE_PATCH:
          case MySqlParser::JSON_MERGE_PRESERVE:
          case MySqlParser::JSON_OBJECT:
          case MySqlParser::JSON_OBJECTAGG:
          case MySqlParser::JSON_OVERLAPS:
          case MySqlParser::JSON_PRETTY:
          case MySqlParser::JSON_QUOTE:
          case MySqlParser::JSON_REMOVE:
          case MySqlParser::JSON_REPLACE:
          case MySqlParser::JSON_SCHEMA_VALID:
          case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
          case MySqlParser::JSON_SEARCH:
          case MySqlParser::JSON_SET:
          case MySqlParser::JSON_STORAGE_FREE:
          case MySqlParser::JSON_STORAGE_SIZE:
          case MySqlParser::JSON_TABLE:
          case MySqlParser::JSON_TYPE:
          case MySqlParser::JSON_UNQUOTE:
          case MySqlParser::JSON_VALID:
          case MySqlParser::JSON_VALUE:
          case MySqlParser::NESTED:
          case MySqlParser::ORDINALITY:
          case MySqlParser::PATH:
          case MySqlParser::AVG:
          case MySqlParser::BIT_AND:
          case MySqlParser::BIT_OR:
          case MySqlParser::BIT_XOR:
          case MySqlParser::COUNT:
          case MySqlParser::CUME_DIST:
          case MySqlParser::DENSE_RANK:
          case MySqlParser::FIRST_VALUE:
          case MySqlParser::GROUP_CONCAT:
          case MySqlParser::LAG:
          case MySqlParser::LAST_VALUE:
          case MySqlParser::LEAD:
          case MySqlParser::MAX:
          case MySqlParser::MIN:
          case MySqlParser::NTILE:
          case MySqlParser::NTH_VALUE:
          case MySqlParser::PERCENT_RANK:
          case MySqlParser::RANK:
          case MySqlParser::ROW_NUMBER:
          case MySqlParser::STD:
          case MySqlParser::STDDEV:
          case MySqlParser::STDDEV_POP:
          case MySqlParser::STDDEV_SAMP:
          case MySqlParser::SUM:
          case MySqlParser::VAR_POP:
          case MySqlParser::VAR_SAMP:
          case MySqlParser::VARIANCE:
          case MySqlParser::CURRENT_DATE:
          case MySqlParser::CURRENT_TIME:
          case MySqlParser::CURRENT_TIMESTAMP:
          case MySqlParser::LOCALTIME:
          case MySqlParser::CURDATE:
          case MySqlParser::CURTIME:
          case MySqlParser::DATE_ADD:
          case MySqlParser::DATE_SUB:
          case MySqlParser::LOCALTIMESTAMP:
          case MySqlParser::NOW:
          case MySqlParser::POSITION:
          case MySqlParser::SUBSTR:
          case MySqlParser::SUBSTRING:
          case MySqlParser::SYSDATE:
          case MySqlParser::TRIM:
          case MySqlParser::UTC_DATE:
          case MySqlParser::UTC_TIME:
          case MySqlParser::UTC_TIMESTAMP:
          case MySqlParser::ACCOUNT:
          case MySqlParser::ACTION:
          case MySqlParser::AFTER:
          case MySqlParser::AGGREGATE:
          case MySqlParser::ALGORITHM:
          case MySqlParser::ANY:
          case MySqlParser::AT:
          case MySqlParser::AUTHORS:
          case MySqlParser::AUTOCOMMIT:
          case MySqlParser::AUTOEXTEND_SIZE:
          case MySqlParser::AUTO_INCREMENT:
          case MySqlParser::AVG_ROW_LENGTH:
          case MySqlParser::BEGIN:
          case MySqlParser::BINLOG:
          case MySqlParser::BIT:
          case MySqlParser::BLOCK:
          case MySqlParser::BOOL:
          case MySqlParser::BOOLEAN:
          case MySqlParser::BTREE:
          case MySqlParser::CACHE:
          case MySqlParser::CASCADED:
          case MySqlParser::CHAIN:
          case MySqlParser::CHANGED:
          case MySqlParser::CHANNEL:
          case MySqlParser::CHECKSUM:
          case MySqlParser::PAGE_CHECKSUM:
          case MySqlParser::CIPHER:
          case MySqlParser::CLASS_ORIGIN:
          case MySqlParser::CLIENT:
          case MySqlParser::CLOSE:
          case MySqlParser::CLUSTERING:
          case MySqlParser::COALESCE:
          case MySqlParser::CODE:
          case MySqlParser::COLUMNS:
          case MySqlParser::COLUMN_FORMAT:
          case MySqlParser::COLUMN_NAME:
          case MySqlParser::COMMENT:
          case MySqlParser::COMMIT:
          case MySqlParser::COMPACT:
          case MySqlParser::COMPLETION:
          case MySqlParser::COMPRESSED:
          case MySqlParser::COMPRESSION:
          case MySqlParser::CONCURRENT:
          case MySqlParser::CONNECT:
          case MySqlParser::CONNECTION:
          case MySqlParser::CONSISTENT:
          case MySqlParser::CONSTRAINT_CATALOG:
          case MySqlParser::CONSTRAINT_SCHEMA:
          case MySqlParser::CONSTRAINT_NAME:
          case MySqlParser::CONTAINS:
          case MySqlParser::CONTEXT:
          case MySqlParser::CONTRIBUTORS:
          case MySqlParser::COPY:
          case MySqlParser::CPU:
          case MySqlParser::CURSOR_NAME:
          case MySqlParser::DATA:
          case MySqlParser::DATAFILE:
          case MySqlParser::DEALLOCATE:
          case MySqlParser::DEFAULT_AUTH:
          case MySqlParser::DEFINER:
          case MySqlParser::DELAY_KEY_WRITE:
          case MySqlParser::DES_KEY_FILE:
          case MySqlParser::DIRECTORY:
          case MySqlParser::DISABLE:
          case MySqlParser::DISCARD:
          case MySqlParser::DISK:
          case MySqlParser::DO:
          case MySqlParser::DUMPFILE:
          case MySqlParser::DUPLICATE:
          case MySqlParser::DYNAMIC:
          case MySqlParser::ENABLE:
          case MySqlParser::ENCRYPTION:
          case MySqlParser::END:
          case MySqlParser::ENDS:
          case MySqlParser::ENGINE:
          case MySqlParser::ENGINES:
          case MySqlParser::ERROR:
          case MySqlParser::ERRORS:
          case MySqlParser::ESCAPE:
          case MySqlParser::EVEN:
          case MySqlParser::EVENT:
          case MySqlParser::EVENTS:
          case MySqlParser::EVERY:
          case MySqlParser::EXCHANGE:
          case MySqlParser::EXCLUSIVE:
          case MySqlParser::EXPIRE:
          case MySqlParser::EXPORT:
          case MySqlParser::EXTENDED:
          case MySqlParser::EXTENT_SIZE:
          case MySqlParser::FAILED_LOGIN_ATTEMPTS:
          case MySqlParser::FAST:
          case MySqlParser::FAULTS:
          case MySqlParser::FIELDS:
          case MySqlParser::FILE_BLOCK_SIZE:
          case MySqlParser::FILTER:
          case MySqlParser::FIRST:
          case MySqlParser::FIXED:
          case MySqlParser::FLUSH:
          case MySqlParser::FOLLOWS:
          case MySqlParser::FOUND:
          case MySqlParser::FULL:
          case MySqlParser::FUNCTION:
          case MySqlParser::GENERAL:
          case MySqlParser::GLOBAL:
          case MySqlParser::GRANTS:
          case MySqlParser::GROUP_REPLICATION:
          case MySqlParser::HANDLER:
          case MySqlParser::HASH:
          case MySqlParser::HELP:
          case MySqlParser::HISTORY:
          case MySqlParser::HOST:
          case MySqlParser::HOSTS:
          case MySqlParser::IDENTIFIED:
          case MySqlParser::IGNORE_SERVER_IDS:
          case MySqlParser::IMPORT:
          case MySqlParser::INDEXES:
          case MySqlParser::INITIAL_SIZE:
          case MySqlParser::INPLACE:
          case MySqlParser::INSERT_METHOD:
          case MySqlParser::INSTALL:
          case MySqlParser::INSTANCE:
          case MySqlParser::INSTANT:
          case MySqlParser::INVISIBLE:
          case MySqlParser::INVOKER:
          case MySqlParser::IO:
          case MySqlParser::IO_THREAD:
          case MySqlParser::IPC:
          case MySqlParser::ISOLATION:
          case MySqlParser::ISSUER:
          case MySqlParser::JSON:
          case MySqlParser::KEY_BLOCK_SIZE:
          case MySqlParser::LANGUAGE:
          case MySqlParser::LAST:
          case MySqlParser::LEAVES:
          case MySqlParser::LESS:
          case MySqlParser::LEVEL:
          case MySqlParser::LIST:
          case MySqlParser::LOCAL:
          case MySqlParser::LOGFILE:
          case MySqlParser::LOGS:
          case MySqlParser::MASTER:
          case MySqlParser::MASTER_AUTO_POSITION:
          case MySqlParser::MASTER_CONNECT_RETRY:
          case MySqlParser::MASTER_DELAY:
          case MySqlParser::MASTER_HEARTBEAT_PERIOD:
          case MySqlParser::MASTER_HOST:
          case MySqlParser::MASTER_LOG_FILE:
          case MySqlParser::MASTER_LOG_POS:
          case MySqlParser::MASTER_PASSWORD:
          case MySqlParser::MASTER_PORT:
          case MySqlParser::MASTER_RETRY_COUNT:
          case MySqlParser::MASTER_SSL:
          case MySqlParser::MASTER_SSL_CA:
          case MySqlParser::MASTER_SSL_CAPATH:
          case MySqlParser::MASTER_SSL_CERT:
          case MySqlParser::MASTER_SSL_CIPHER:
          case MySqlParser::MASTER_SSL_CRL:
          case MySqlParser::MASTER_SSL_CRLPATH:
          case MySqlParser::MASTER_SSL_KEY:
          case MySqlParser::MASTER_TLS_VERSION:
          case MySqlParser::MASTER_USER:
          case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
          case MySqlParser::MAX_QUERIES_PER_HOUR:
          case MySqlParser::MAX_ROWS:
          case MySqlParser::MAX_SIZE:
          case MySqlParser::MAX_UPDATES_PER_HOUR:
          case MySqlParser::MAX_USER_CONNECTIONS:
          case MySqlParser::MEDIUM:
          case MySqlParser::MEMBER:
          case MySqlParser::MERGE:
          case MySqlParser::MESSAGE_TEXT:
          case MySqlParser::MID:
          case MySqlParser::MIGRATE:
          case MySqlParser::MIN_ROWS:
          case MySqlParser::MODE:
          case MySqlParser::MODIFY:
          case MySqlParser::MUTEX:
          case MySqlParser::MYSQL:
          case MySqlParser::MYSQL_ERRNO:
          case MySqlParser::NAME:
          case MySqlParser::NAMES:
          case MySqlParser::NCHAR:
          case MySqlParser::NEVER:
          case MySqlParser::NEXT:
          case MySqlParser::NO:
          case MySqlParser::NOCOPY:
          case MySqlParser::NOWAIT:
          case MySqlParser::NODEGROUP:
          case MySqlParser::NONE:
          case MySqlParser::ODBC:
          case MySqlParser::OFFLINE:
          case MySqlParser::OFFSET:
          case MySqlParser::OF:
          case MySqlParser::OJ:
          case MySqlParser::OLD_PASSWORD:
          case MySqlParser::ONE:
          case MySqlParser::ONLINE:
          case MySqlParser::ONLY:
          case MySqlParser::OPEN:
          case MySqlParser::OPTIMIZER_COSTS:
          case MySqlParser::OPTIONS:
          case MySqlParser::OWNER:
          case MySqlParser::PACK_KEYS:
          case MySqlParser::PAGE:
          case MySqlParser::PARSER:
          case MySqlParser::PARTIAL:
          case MySqlParser::PARTITIONING:
          case MySqlParser::PARTITIONS:
          case MySqlParser::PASSWORD:
          case MySqlParser::PASSWORD_LOCK_TIME:
          case MySqlParser::PHASE:
          case MySqlParser::PLUGIN:
          case MySqlParser::PLUGIN_DIR:
          case MySqlParser::PLUGINS:
          case MySqlParser::PORT:
          case MySqlParser::PRECEDES:
          case MySqlParser::PREPARE:
          case MySqlParser::PRESERVE:
          case MySqlParser::PREV:
          case MySqlParser::PROCESSLIST:
          case MySqlParser::PROFILE:
          case MySqlParser::PROFILES:
          case MySqlParser::PROXY:
          case MySqlParser::QUERY:
          case MySqlParser::QUICK:
          case MySqlParser::REBUILD:
          case MySqlParser::RECOVER:
          case MySqlParser::RECURSIVE:
          case MySqlParser::REDO_BUFFER_SIZE:
          case MySqlParser::REDUNDANT:
          case MySqlParser::RELAY:
          case MySqlParser::RELAY_LOG_FILE:
          case MySqlParser::RELAY_LOG_POS:
          case MySqlParser::RELAYLOG:
          case MySqlParser::REMOVE:
          case MySqlParser::REORGANIZE:
          case MySqlParser::REPAIR:
          case MySqlParser::REPLICATE_DO_DB:
          case MySqlParser::REPLICATE_DO_TABLE:
          case MySqlParser::REPLICATE_IGNORE_DB:
          case MySqlParser::REPLICATE_IGNORE_TABLE:
          case MySqlParser::REPLICATE_REWRITE_DB:
          case MySqlParser::REPLICATE_WILD_DO_TABLE:
          case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
          case MySqlParser::REPLICATION:
          case MySqlParser::RESET:
          case MySqlParser::RESUME:
          case MySqlParser::RETURNED_SQLSTATE:
          case MySqlParser::RETURNS:
          case MySqlParser::REUSE:
          case MySqlParser::ROLE:
          case MySqlParser::ROLLBACK:
          case MySqlParser::ROLLUP:
          case MySqlParser::ROTATE:
          case MySqlParser::ROW:
          case MySqlParser::ROWS:
          case MySqlParser::ROW_FORMAT:
          case MySqlParser::RTREE:
          case MySqlParser::SAVEPOINT:
          case MySqlParser::SCHEDULE:
          case MySqlParser::SECURITY:
          case MySqlParser::SERVER:
          case MySqlParser::SESSION:
          case MySqlParser::SHARE:
          case MySqlParser::SHARED:
          case MySqlParser::SIGNED:
          case MySqlParser::SIMPLE:
          case MySqlParser::SLAVE:
          case MySqlParser::SLOW:
          case MySqlParser::SNAPSHOT:
          case MySqlParser::SOCKET:
          case MySqlParser::SOME:
          case MySqlParser::SONAME:
          case MySqlParser::SOUNDS:
          case MySqlParser::SOURCE:
          case MySqlParser::SQL_AFTER_GTIDS:
          case MySqlParser::SQL_AFTER_MTS_GAPS:
          case MySqlParser::SQL_BEFORE_GTIDS:
          case MySqlParser::SQL_BUFFER_RESULT:
          case MySqlParser::SQL_CACHE:
          case MySqlParser::SQL_NO_CACHE:
          case MySqlParser::SQL_THREAD:
          case MySqlParser::START:
          case MySqlParser::STARTS:
          case MySqlParser::STATS_AUTO_RECALC:
          case MySqlParser::STATS_PERSISTENT:
          case MySqlParser::STATS_SAMPLE_PAGES:
          case MySqlParser::STATUS:
          case MySqlParser::STOP:
          case MySqlParser::STORAGE:
          case MySqlParser::STRING:
          case MySqlParser::SUBCLASS_ORIGIN:
          case MySqlParser::SUBJECT:
          case MySqlParser::SUBPARTITION:
          case MySqlParser::SUBPARTITIONS:
          case MySqlParser::SUSPEND:
          case MySqlParser::SWAPS:
          case MySqlParser::SWITCHES:
          case MySqlParser::TABLE_NAME:
          case MySqlParser::TABLESPACE:
          case MySqlParser::TABLE_TYPE:
          case MySqlParser::TEMPORARY:
          case MySqlParser::TEMPTABLE:
          case MySqlParser::THAN:
          case MySqlParser::TRADITIONAL:
          case MySqlParser::TRANSACTION:
          case MySqlParser::TRANSACTIONAL:
          case MySqlParser::TRIGGERS:
          case MySqlParser::TRUNCATE:
          case MySqlParser::UNBOUNDED:
          case MySqlParser::UNDEFINED:
          case MySqlParser::UNDOFILE:
          case MySqlParser::UNDO_BUFFER_SIZE:
          case MySqlParser::UNINSTALL:
          case MySqlParser::UNKNOWN:
          case MySqlParser::UNTIL:
          case MySqlParser::UPGRADE:
          case MySqlParser::USER:
          case MySqlParser::USE_FRM:
          case MySqlParser::USER_RESOURCES:
          case MySqlParser::VALIDATION:
          case MySqlParser::VALUE:
          case MySqlParser::VARIABLES:
          case MySqlParser::VIEW:
          case MySqlParser::VIRTUAL:
          case MySqlParser::VISIBLE:
          case MySqlParser::WAIT:
          case MySqlParser::WARNINGS:
          case MySqlParser::WITHOUT:
          case MySqlParser::WORK:
          case MySqlParser::WRAPPER:
          case MySqlParser::X509:
          case MySqlParser::XA:
          case MySqlParser::XML:
          case MySqlParser::EUR:
          case MySqlParser::USA:
          case MySqlParser::JIS:
          case MySqlParser::ISO:
          case MySqlParser::INTERNAL:
          case MySqlParser::QUARTER:
          case MySqlParser::MONTH:
          case MySqlParser::DAY:
          case MySqlParser::HOUR:
          case MySqlParser::MINUTE:
          case MySqlParser::WEEK:
          case MySqlParser::SECOND:
          case MySqlParser::MICROSECOND:
          case MySqlParser::ADMIN:
          case MySqlParser::AUDIT_ABORT_EXEMPT:
          case MySqlParser::AUDIT_ADMIN:
          case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
          case MySqlParser::BACKUP_ADMIN:
          case MySqlParser::BINLOG_ADMIN:
          case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
          case MySqlParser::CLONE_ADMIN:
          case MySqlParser::CONNECTION_ADMIN:
          case MySqlParser::ENCRYPTION_KEY_ADMIN:
          case MySqlParser::EXECUTE:
          case MySqlParser::FILE:
          case MySqlParser::FIREWALL_ADMIN:
          case MySqlParser::FIREWALL_EXEMPT:
          case MySqlParser::FIREWALL_USER:
          case MySqlParser::GROUP_REPLICATION_ADMIN:
          case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
          case MySqlParser::INVOKE:
          case MySqlParser::LAMBDA:
          case MySqlParser::NDB_STORED_USER:
          case MySqlParser::PASSWORDLESS_USER_ADMIN:
          case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
          case MySqlParser::PRIVILEGES:
          case MySqlParser::PROCESS:
          case MySqlParser::RELOAD:
          case MySqlParser::REPLICATION_APPLIER:
          case MySqlParser::REPLICATION_SLAVE_ADMIN:
          case MySqlParser::RESOURCE_GROUP_ADMIN:
          case MySqlParser::RESOURCE_GROUP_USER:
          case MySqlParser::ROLE_ADMIN:
          case MySqlParser::ROUTINE:
          case MySqlParser::S3:
          case MySqlParser::SESSION_VARIABLES_ADMIN:
          case MySqlParser::SET_USER_ID:
          case MySqlParser::SHOW_ROUTINE:
          case MySqlParser::SHUTDOWN:
          case MySqlParser::SUPER:
          case MySqlParser::SYSTEM_VARIABLES_ADMIN:
          case MySqlParser::TABLES:
          case MySqlParser::TABLE_ENCRYPTION_ADMIN:
          case MySqlParser::VERSION_TOKEN_ADMIN:
          case MySqlParser::XA_RECOVER_ADMIN:
          case MySqlParser::ARMSCII8:
          case MySqlParser::ASCII:
          case MySqlParser::BIG5:
          case MySqlParser::CP1250:
          case MySqlParser::CP1251:
          case MySqlParser::CP1256:
          case MySqlParser::CP1257:
          case MySqlParser::CP850:
          case MySqlParser::CP852:
          case MySqlParser::CP866:
          case MySqlParser::CP932:
          case MySqlParser::DEC8:
          case MySqlParser::EUCJPMS:
          case MySqlParser::EUCKR:
          case MySqlParser::GB18030:
          case MySqlParser::GB2312:
          case MySqlParser::GBK:
          case MySqlParser::GEOSTD8:
          case MySqlParser::GREEK:
          case MySqlParser::HEBREW:
          case MySqlParser::HP8:
          case MySqlParser::KEYBCS2:
          case MySqlParser::KOI8R:
          case MySqlParser::KOI8U:
          case MySqlParser::LATIN1:
          case MySqlParser::LATIN2:
          case MySqlParser::LATIN5:
          case MySqlParser::LATIN7:
          case MySqlParser::MACCE:
          case MySqlParser::MACROMAN:
          case MySqlParser::SJIS:
          case MySqlParser::SWE7:
          case MySqlParser::TIS620:
          case MySqlParser::UCS2:
          case MySqlParser::UJIS:
          case MySqlParser::UTF16:
          case MySqlParser::UTF16LE:
          case MySqlParser::UTF32:
          case MySqlParser::UTF8:
          case MySqlParser::UTF8MB3:
          case MySqlParser::UTF8MB4:
          case MySqlParser::ARCHIVE:
          case MySqlParser::BLACKHOLE:
          case MySqlParser::CSV:
          case MySqlParser::FEDERATED:
          case MySqlParser::INNODB:
          case MySqlParser::MEMORY:
          case MySqlParser::MRG_MYISAM:
          case MySqlParser::MYISAM:
          case MySqlParser::NDB:
          case MySqlParser::NDBCLUSTER:
          case MySqlParser::PERFORMANCE_SCHEMA:
          case MySqlParser::TOKUDB:
          case MySqlParser::REPEATABLE:
          case MySqlParser::COMMITTED:
          case MySqlParser::UNCOMMITTED:
          case MySqlParser::SERIALIZABLE:
          case MySqlParser::GEOMETRYCOLLECTION:
          case MySqlParser::LINESTRING:
          case MySqlParser::MULTILINESTRING:
          case MySqlParser::MULTIPOINT:
          case MySqlParser::MULTIPOLYGON:
          case MySqlParser::POINT:
          case MySqlParser::POLYGON:
          case MySqlParser::ABS:
          case MySqlParser::ACOS:
          case MySqlParser::ADDDATE:
          case MySqlParser::ADDTIME:
          case MySqlParser::AES_DECRYPT:
          case MySqlParser::AES_ENCRYPT:
          case MySqlParser::AREA:
          case MySqlParser::ASBINARY:
          case MySqlParser::ASIN:
          case MySqlParser::ASTEXT:
          case MySqlParser::ASWKB:
          case MySqlParser::ASWKT:
          case MySqlParser::ASYMMETRIC_DECRYPT:
          case MySqlParser::ASYMMETRIC_DERIVE:
          case MySqlParser::ASYMMETRIC_ENCRYPT:
          case MySqlParser::ASYMMETRIC_SIGN:
          case MySqlParser::ASYMMETRIC_VERIFY:
          case MySqlParser::ATAN:
          case MySqlParser::ATAN2:
          case MySqlParser::BENCHMARK:
          case MySqlParser::BIN:
          case MySqlParser::BIT_COUNT:
          case MySqlParser::BIT_LENGTH:
          case MySqlParser::BUFFER:
          case MySqlParser::CATALOG_NAME:
          case MySqlParser::CEIL:
          case MySqlParser::CEILING:
          case MySqlParser::CENTROID:
          case MySqlParser::CHARACTER_LENGTH:
          case MySqlParser::CHARSET:
          case MySqlParser::CHAR_LENGTH:
          case MySqlParser::COERCIBILITY:
          case MySqlParser::COLLATION:
          case MySqlParser::COMPRESS:
          case MySqlParser::CONCAT:
          case MySqlParser::CONCAT_WS:
          case MySqlParser::CONNECTION_ID:
          case MySqlParser::CONV:
          case MySqlParser::CONVERT_TZ:
          case MySqlParser::COS:
          case MySqlParser::COT:
          case MySqlParser::CRC32:
          case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
          case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
          case MySqlParser::CREATE_DH_PARAMETERS:
          case MySqlParser::CREATE_DIGEST:
          case MySqlParser::CROSSES:
          case MySqlParser::DATEDIFF:
          case MySqlParser::DATE_FORMAT:
          case MySqlParser::DAYNAME:
          case MySqlParser::DAYOFMONTH:
          case MySqlParser::DAYOFWEEK:
          case MySqlParser::DAYOFYEAR:
          case MySqlParser::DECODE:
          case MySqlParser::DEGREES:
          case MySqlParser::DES_DECRYPT:
          case MySqlParser::DES_ENCRYPT:
          case MySqlParser::DIMENSION:
          case MySqlParser::DISJOINT:
          case MySqlParser::ELT:
          case MySqlParser::ENCODE:
          case MySqlParser::ENCRYPT:
          case MySqlParser::ENDPOINT:
          case MySqlParser::ENGINE_ATTRIBUTE:
          case MySqlParser::ENVELOPE:
          case MySqlParser::EQUALS:
          case MySqlParser::EXP:
          case MySqlParser::EXPORT_SET:
          case MySqlParser::EXTERIORRING:
          case MySqlParser::EXTRACTVALUE:
          case MySqlParser::FIELD:
          case MySqlParser::FIND_IN_SET:
          case MySqlParser::FLOOR:
          case MySqlParser::FORMAT:
          case MySqlParser::FOUND_ROWS:
          case MySqlParser::FROM_BASE64:
          case MySqlParser::FROM_DAYS:
          case MySqlParser::FROM_UNIXTIME:
          case MySqlParser::GEOMCOLLFROMTEXT:
          case MySqlParser::GEOMCOLLFROMWKB:
          case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::GEOMETRYFROMTEXT:
          case MySqlParser::GEOMETRYFROMWKB:
          case MySqlParser::GEOMETRYN:
          case MySqlParser::GEOMETRYTYPE:
          case MySqlParser::GEOMFROMTEXT:
          case MySqlParser::GEOMFROMWKB:
          case MySqlParser::GET_FORMAT:
          case MySqlParser::GET_LOCK:
          case MySqlParser::GLENGTH:
          case MySqlParser::GREATEST:
          case MySqlParser::GTID_SUBSET:
          case MySqlParser::GTID_SUBTRACT:
          case MySqlParser::HEX:
          case MySqlParser::IFNULL:
          case MySqlParser::INET6_ATON:
          case MySqlParser::INET6_NTOA:
          case MySqlParser::INET_ATON:
          case MySqlParser::INET_NTOA:
          case MySqlParser::INSTR:
          case MySqlParser::INTERIORRINGN:
          case MySqlParser::INTERSECTS:
          case MySqlParser::ISCLOSED:
          case MySqlParser::ISEMPTY:
          case MySqlParser::ISNULL:
          case MySqlParser::ISSIMPLE:
          case MySqlParser::IS_FREE_LOCK:
          case MySqlParser::IS_IPV4:
          case MySqlParser::IS_IPV4_COMPAT:
          case MySqlParser::IS_IPV4_MAPPED:
          case MySqlParser::IS_IPV6:
          case MySqlParser::IS_USED_LOCK:
          case MySqlParser::LAST_INSERT_ID:
          case MySqlParser::LCASE:
          case MySqlParser::LEAST:
          case MySqlParser::LENGTH:
          case MySqlParser::LINEFROMTEXT:
          case MySqlParser::LINEFROMWKB:
          case MySqlParser::LINESTRINGFROMTEXT:
          case MySqlParser::LINESTRINGFROMWKB:
          case MySqlParser::LN:
          case MySqlParser::LOAD_FILE:
          case MySqlParser::LOCATE:
          case MySqlParser::LOG:
          case MySqlParser::LOG10:
          case MySqlParser::LOG2:
          case MySqlParser::LOWER:
          case MySqlParser::LPAD:
          case MySqlParser::LTRIM:
          case MySqlParser::MAKEDATE:
          case MySqlParser::MAKETIME:
          case MySqlParser::MAKE_SET:
          case MySqlParser::MASTER_POS_WAIT:
          case MySqlParser::MBRCONTAINS:
          case MySqlParser::MBRDISJOINT:
          case MySqlParser::MBREQUAL:
          case MySqlParser::MBRINTERSECTS:
          case MySqlParser::MBROVERLAPS:
          case MySqlParser::MBRTOUCHES:
          case MySqlParser::MBRWITHIN:
          case MySqlParser::MD5:
          case MySqlParser::MLINEFROMTEXT:
          case MySqlParser::MLINEFROMWKB:
          case MySqlParser::MONTHNAME:
          case MySqlParser::MPOINTFROMTEXT:
          case MySqlParser::MPOINTFROMWKB:
          case MySqlParser::MPOLYFROMTEXT:
          case MySqlParser::MPOLYFROMWKB:
          case MySqlParser::MULTILINESTRINGFROMTEXT:
          case MySqlParser::MULTILINESTRINGFROMWKB:
          case MySqlParser::MULTIPOINTFROMTEXT:
          case MySqlParser::MULTIPOINTFROMWKB:
          case MySqlParser::MULTIPOLYGONFROMTEXT:
          case MySqlParser::MULTIPOLYGONFROMWKB:
          case MySqlParser::NAME_CONST:
          case MySqlParser::NULLIF:
          case MySqlParser::NUMGEOMETRIES:
          case MySqlParser::NUMINTERIORRINGS:
          case MySqlParser::NUMPOINTS:
          case MySqlParser::OCT:
          case MySqlParser::OCTET_LENGTH:
          case MySqlParser::ORD:
          case MySqlParser::OVERLAPS:
          case MySqlParser::PERIOD_ADD:
          case MySqlParser::PERIOD_DIFF:
          case MySqlParser::PI:
          case MySqlParser::POINTFROMTEXT:
          case MySqlParser::POINTFROMWKB:
          case MySqlParser::POINTN:
          case MySqlParser::POLYFROMTEXT:
          case MySqlParser::POLYFROMWKB:
          case MySqlParser::POLYGONFROMTEXT:
          case MySqlParser::POLYGONFROMWKB:
          case MySqlParser::POW:
          case MySqlParser::POWER:
          case MySqlParser::QUOTE:
          case MySqlParser::RADIANS:
          case MySqlParser::RAND:
          case MySqlParser::RANDOM_BYTES:
          case MySqlParser::RELEASE_LOCK:
          case MySqlParser::REVERSE:
          case MySqlParser::ROUND:
          case MySqlParser::ROW_COUNT:
          case MySqlParser::RPAD:
          case MySqlParser::RTRIM:
          case MySqlParser::SEC_TO_TIME:
          case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
          case MySqlParser::SESSION_USER:
          case MySqlParser::SHA:
          case MySqlParser::SHA1:
          case MySqlParser::SHA2:
          case MySqlParser::SCHEMA_NAME:
          case MySqlParser::SIGN:
          case MySqlParser::SIN:
          case MySqlParser::SLEEP:
          case MySqlParser::SOUNDEX:
          case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
          case MySqlParser::SQRT:
          case MySqlParser::SRID:
          case MySqlParser::STARTPOINT:
          case MySqlParser::STRCMP:
          case MySqlParser::STR_TO_DATE:
          case MySqlParser::ST_AREA:
          case MySqlParser::ST_ASBINARY:
          case MySqlParser::ST_ASTEXT:
          case MySqlParser::ST_ASWKB:
          case MySqlParser::ST_ASWKT:
          case MySqlParser::ST_BUFFER:
          case MySqlParser::ST_CENTROID:
          case MySqlParser::ST_CONTAINS:
          case MySqlParser::ST_CROSSES:
          case MySqlParser::ST_DIFFERENCE:
          case MySqlParser::ST_DIMENSION:
          case MySqlParser::ST_DISJOINT:
          case MySqlParser::ST_DISTANCE:
          case MySqlParser::ST_ENDPOINT:
          case MySqlParser::ST_ENVELOPE:
          case MySqlParser::ST_EQUALS:
          case MySqlParser::ST_EXTERIORRING:
          case MySqlParser::ST_GEOMCOLLFROMTEXT:
          case MySqlParser::ST_GEOMCOLLFROMTXT:
          case MySqlParser::ST_GEOMCOLLFROMWKB:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::ST_GEOMETRYFROMTEXT:
          case MySqlParser::ST_GEOMETRYFROMWKB:
          case MySqlParser::ST_GEOMETRYN:
          case MySqlParser::ST_GEOMETRYTYPE:
          case MySqlParser::ST_GEOMFROMTEXT:
          case MySqlParser::ST_GEOMFROMWKB:
          case MySqlParser::ST_INTERIORRINGN:
          case MySqlParser::ST_INTERSECTION:
          case MySqlParser::ST_INTERSECTS:
          case MySqlParser::ST_ISCLOSED:
          case MySqlParser::ST_ISEMPTY:
          case MySqlParser::ST_ISSIMPLE:
          case MySqlParser::ST_LINEFROMTEXT:
          case MySqlParser::ST_LINEFROMWKB:
          case MySqlParser::ST_LINESTRINGFROMTEXT:
          case MySqlParser::ST_LINESTRINGFROMWKB:
          case MySqlParser::ST_NUMGEOMETRIES:
          case MySqlParser::ST_NUMINTERIORRING:
          case MySqlParser::ST_NUMINTERIORRINGS:
          case MySqlParser::ST_NUMPOINTS:
          case MySqlParser::ST_OVERLAPS:
          case MySqlParser::ST_POINTFROMTEXT:
          case MySqlParser::ST_POINTFROMWKB:
          case MySqlParser::ST_POINTN:
          case MySqlParser::ST_POLYFROMTEXT:
          case MySqlParser::ST_POLYFROMWKB:
          case MySqlParser::ST_POLYGONFROMTEXT:
          case MySqlParser::ST_POLYGONFROMWKB:
          case MySqlParser::ST_SRID:
          case MySqlParser::ST_STARTPOINT:
          case MySqlParser::ST_SYMDIFFERENCE:
          case MySqlParser::ST_TOUCHES:
          case MySqlParser::ST_UNION:
          case MySqlParser::ST_WITHIN:
          case MySqlParser::ST_X:
          case MySqlParser::ST_Y:
          case MySqlParser::SUBDATE:
          case MySqlParser::SUBSTRING_INDEX:
          case MySqlParser::SUBTIME:
          case MySqlParser::SYSTEM_USER:
          case MySqlParser::TAN:
          case MySqlParser::TIMEDIFF:
          case MySqlParser::TIMESTAMPADD:
          case MySqlParser::TIMESTAMPDIFF:
          case MySqlParser::TIME_FORMAT:
          case MySqlParser::TIME_TO_SEC:
          case MySqlParser::TOUCHES:
          case MySqlParser::TO_BASE64:
          case MySqlParser::TO_DAYS:
          case MySqlParser::TO_SECONDS:
          case MySqlParser::TP_CONNECTION_ADMIN:
          case MySqlParser::UCASE:
          case MySqlParser::UNCOMPRESS:
          case MySqlParser::UNCOMPRESSED_LENGTH:
          case MySqlParser::UNHEX:
          case MySqlParser::UNIX_TIMESTAMP:
          case MySqlParser::UPDATEXML:
          case MySqlParser::UPPER:
          case MySqlParser::UUID:
          case MySqlParser::UUID_SHORT:
          case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
          case MySqlParser::VERSION:
          case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
          case MySqlParser::WEEKDAY:
          case MySqlParser::WEEKOFYEAR:
          case MySqlParser::WEIGHT_STRING:
          case MySqlParser::WITHIN:
          case MySqlParser::YEARWEEK:
          case MySqlParser::Y_FUNCTION:
          case MySqlParser::X_FUNCTION:
          case MySqlParser::MOD:
          case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
          case MySqlParser::STRING_LITERAL:
          case MySqlParser::ID: {
            setState(2932);
            uidList();
            break;
          }

          case MySqlParser::ALL: {
            setState(2933);
            match(MySqlParser::ALL);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySqlParser::CHECK: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByCheckPartitionContext>(_localctx);
        enterOuterAlt(_localctx, 10);
        setState(2936);
        match(MySqlParser::CHECK);
        setState(2937);
        match(MySqlParser::PARTITION);
        setState(2940);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::ATTRIBUTE:
          case MySqlParser::BUCKETS:
          case MySqlParser::CONDITION:
          case MySqlParser::CURRENT:
          case MySqlParser::CURRENT_USER:
          case MySqlParser::DATABASE:
          case MySqlParser::DEFAULT:
          case MySqlParser::DIAGNOSTICS:
          case MySqlParser::EMPTY:
          case MySqlParser::ENFORCED:
          case MySqlParser::EXCEPT:
          case MySqlParser::GROUP:
          case MySqlParser::IF:
          case MySqlParser::IGNORED:
          case MySqlParser::INSERT:
          case MySqlParser::LATERAL:
          case MySqlParser::LEFT:
          case MySqlParser::NUMBER:
          case MySqlParser::OPTIONAL:
          case MySqlParser::ORDER:
          case MySqlParser::PRIMARY:
          case MySqlParser::REPLACE:
          case MySqlParser::RIGHT:
          case MySqlParser::SCHEMA:
          case MySqlParser::SKIP_QUERY_REWRITE:
          case MySqlParser::STACKED:
          case MySqlParser::DATE:
          case MySqlParser::TIME:
          case MySqlParser::TIMESTAMP:
          case MySqlParser::DATETIME:
          case MySqlParser::YEAR:
          case MySqlParser::BINARY:
          case MySqlParser::TEXT:
          case MySqlParser::ENUM:
          case MySqlParser::SERIAL:
          case MySqlParser::JSON_ARRAY:
          case MySqlParser::JSON_ARRAYAGG:
          case MySqlParser::JSON_ARRAY_APPEND:
          case MySqlParser::JSON_ARRAY_INSERT:
          case MySqlParser::JSON_CONTAINS:
          case MySqlParser::JSON_CONTAINS_PATH:
          case MySqlParser::JSON_DEPTH:
          case MySqlParser::JSON_EXTRACT:
          case MySqlParser::JSON_INSERT:
          case MySqlParser::JSON_KEYS:
          case MySqlParser::JSON_LENGTH:
          case MySqlParser::JSON_MERGE:
          case MySqlParser::JSON_MERGE_PATCH:
          case MySqlParser::JSON_MERGE_PRESERVE:
          case MySqlParser::JSON_OBJECT:
          case MySqlParser::JSON_OBJECTAGG:
          case MySqlParser::JSON_OVERLAPS:
          case MySqlParser::JSON_PRETTY:
          case MySqlParser::JSON_QUOTE:
          case MySqlParser::JSON_REMOVE:
          case MySqlParser::JSON_REPLACE:
          case MySqlParser::JSON_SCHEMA_VALID:
          case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
          case MySqlParser::JSON_SEARCH:
          case MySqlParser::JSON_SET:
          case MySqlParser::JSON_STORAGE_FREE:
          case MySqlParser::JSON_STORAGE_SIZE:
          case MySqlParser::JSON_TABLE:
          case MySqlParser::JSON_TYPE:
          case MySqlParser::JSON_UNQUOTE:
          case MySqlParser::JSON_VALID:
          case MySqlParser::JSON_VALUE:
          case MySqlParser::NESTED:
          case MySqlParser::ORDINALITY:
          case MySqlParser::PATH:
          case MySqlParser::AVG:
          case MySqlParser::BIT_AND:
          case MySqlParser::BIT_OR:
          case MySqlParser::BIT_XOR:
          case MySqlParser::COUNT:
          case MySqlParser::CUME_DIST:
          case MySqlParser::DENSE_RANK:
          case MySqlParser::FIRST_VALUE:
          case MySqlParser::GROUP_CONCAT:
          case MySqlParser::LAG:
          case MySqlParser::LAST_VALUE:
          case MySqlParser::LEAD:
          case MySqlParser::MAX:
          case MySqlParser::MIN:
          case MySqlParser::NTILE:
          case MySqlParser::NTH_VALUE:
          case MySqlParser::PERCENT_RANK:
          case MySqlParser::RANK:
          case MySqlParser::ROW_NUMBER:
          case MySqlParser::STD:
          case MySqlParser::STDDEV:
          case MySqlParser::STDDEV_POP:
          case MySqlParser::STDDEV_SAMP:
          case MySqlParser::SUM:
          case MySqlParser::VAR_POP:
          case MySqlParser::VAR_SAMP:
          case MySqlParser::VARIANCE:
          case MySqlParser::CURRENT_DATE:
          case MySqlParser::CURRENT_TIME:
          case MySqlParser::CURRENT_TIMESTAMP:
          case MySqlParser::LOCALTIME:
          case MySqlParser::CURDATE:
          case MySqlParser::CURTIME:
          case MySqlParser::DATE_ADD:
          case MySqlParser::DATE_SUB:
          case MySqlParser::LOCALTIMESTAMP:
          case MySqlParser::NOW:
          case MySqlParser::POSITION:
          case MySqlParser::SUBSTR:
          case MySqlParser::SUBSTRING:
          case MySqlParser::SYSDATE:
          case MySqlParser::TRIM:
          case MySqlParser::UTC_DATE:
          case MySqlParser::UTC_TIME:
          case MySqlParser::UTC_TIMESTAMP:
          case MySqlParser::ACCOUNT:
          case MySqlParser::ACTION:
          case MySqlParser::AFTER:
          case MySqlParser::AGGREGATE:
          case MySqlParser::ALGORITHM:
          case MySqlParser::ANY:
          case MySqlParser::AT:
          case MySqlParser::AUTHORS:
          case MySqlParser::AUTOCOMMIT:
          case MySqlParser::AUTOEXTEND_SIZE:
          case MySqlParser::AUTO_INCREMENT:
          case MySqlParser::AVG_ROW_LENGTH:
          case MySqlParser::BEGIN:
          case MySqlParser::BINLOG:
          case MySqlParser::BIT:
          case MySqlParser::BLOCK:
          case MySqlParser::BOOL:
          case MySqlParser::BOOLEAN:
          case MySqlParser::BTREE:
          case MySqlParser::CACHE:
          case MySqlParser::CASCADED:
          case MySqlParser::CHAIN:
          case MySqlParser::CHANGED:
          case MySqlParser::CHANNEL:
          case MySqlParser::CHECKSUM:
          case MySqlParser::PAGE_CHECKSUM:
          case MySqlParser::CIPHER:
          case MySqlParser::CLASS_ORIGIN:
          case MySqlParser::CLIENT:
          case MySqlParser::CLOSE:
          case MySqlParser::CLUSTERING:
          case MySqlParser::COALESCE:
          case MySqlParser::CODE:
          case MySqlParser::COLUMNS:
          case MySqlParser::COLUMN_FORMAT:
          case MySqlParser::COLUMN_NAME:
          case MySqlParser::COMMENT:
          case MySqlParser::COMMIT:
          case MySqlParser::COMPACT:
          case MySqlParser::COMPLETION:
          case MySqlParser::COMPRESSED:
          case MySqlParser::COMPRESSION:
          case MySqlParser::CONCURRENT:
          case MySqlParser::CONNECT:
          case MySqlParser::CONNECTION:
          case MySqlParser::CONSISTENT:
          case MySqlParser::CONSTRAINT_CATALOG:
          case MySqlParser::CONSTRAINT_SCHEMA:
          case MySqlParser::CONSTRAINT_NAME:
          case MySqlParser::CONTAINS:
          case MySqlParser::CONTEXT:
          case MySqlParser::CONTRIBUTORS:
          case MySqlParser::COPY:
          case MySqlParser::CPU:
          case MySqlParser::CURSOR_NAME:
          case MySqlParser::DATA:
          case MySqlParser::DATAFILE:
          case MySqlParser::DEALLOCATE:
          case MySqlParser::DEFAULT_AUTH:
          case MySqlParser::DEFINER:
          case MySqlParser::DELAY_KEY_WRITE:
          case MySqlParser::DES_KEY_FILE:
          case MySqlParser::DIRECTORY:
          case MySqlParser::DISABLE:
          case MySqlParser::DISCARD:
          case MySqlParser::DISK:
          case MySqlParser::DO:
          case MySqlParser::DUMPFILE:
          case MySqlParser::DUPLICATE:
          case MySqlParser::DYNAMIC:
          case MySqlParser::ENABLE:
          case MySqlParser::ENCRYPTION:
          case MySqlParser::END:
          case MySqlParser::ENDS:
          case MySqlParser::ENGINE:
          case MySqlParser::ENGINES:
          case MySqlParser::ERROR:
          case MySqlParser::ERRORS:
          case MySqlParser::ESCAPE:
          case MySqlParser::EVEN:
          case MySqlParser::EVENT:
          case MySqlParser::EVENTS:
          case MySqlParser::EVERY:
          case MySqlParser::EXCHANGE:
          case MySqlParser::EXCLUSIVE:
          case MySqlParser::EXPIRE:
          case MySqlParser::EXPORT:
          case MySqlParser::EXTENDED:
          case MySqlParser::EXTENT_SIZE:
          case MySqlParser::FAILED_LOGIN_ATTEMPTS:
          case MySqlParser::FAST:
          case MySqlParser::FAULTS:
          case MySqlParser::FIELDS:
          case MySqlParser::FILE_BLOCK_SIZE:
          case MySqlParser::FILTER:
          case MySqlParser::FIRST:
          case MySqlParser::FIXED:
          case MySqlParser::FLUSH:
          case MySqlParser::FOLLOWS:
          case MySqlParser::FOUND:
          case MySqlParser::FULL:
          case MySqlParser::FUNCTION:
          case MySqlParser::GENERAL:
          case MySqlParser::GLOBAL:
          case MySqlParser::GRANTS:
          case MySqlParser::GROUP_REPLICATION:
          case MySqlParser::HANDLER:
          case MySqlParser::HASH:
          case MySqlParser::HELP:
          case MySqlParser::HISTORY:
          case MySqlParser::HOST:
          case MySqlParser::HOSTS:
          case MySqlParser::IDENTIFIED:
          case MySqlParser::IGNORE_SERVER_IDS:
          case MySqlParser::IMPORT:
          case MySqlParser::INDEXES:
          case MySqlParser::INITIAL_SIZE:
          case MySqlParser::INPLACE:
          case MySqlParser::INSERT_METHOD:
          case MySqlParser::INSTALL:
          case MySqlParser::INSTANCE:
          case MySqlParser::INSTANT:
          case MySqlParser::INVISIBLE:
          case MySqlParser::INVOKER:
          case MySqlParser::IO:
          case MySqlParser::IO_THREAD:
          case MySqlParser::IPC:
          case MySqlParser::ISOLATION:
          case MySqlParser::ISSUER:
          case MySqlParser::JSON:
          case MySqlParser::KEY_BLOCK_SIZE:
          case MySqlParser::LANGUAGE:
          case MySqlParser::LAST:
          case MySqlParser::LEAVES:
          case MySqlParser::LESS:
          case MySqlParser::LEVEL:
          case MySqlParser::LIST:
          case MySqlParser::LOCAL:
          case MySqlParser::LOGFILE:
          case MySqlParser::LOGS:
          case MySqlParser::MASTER:
          case MySqlParser::MASTER_AUTO_POSITION:
          case MySqlParser::MASTER_CONNECT_RETRY:
          case MySqlParser::MASTER_DELAY:
          case MySqlParser::MASTER_HEARTBEAT_PERIOD:
          case MySqlParser::MASTER_HOST:
          case MySqlParser::MASTER_LOG_FILE:
          case MySqlParser::MASTER_LOG_POS:
          case MySqlParser::MASTER_PASSWORD:
          case MySqlParser::MASTER_PORT:
          case MySqlParser::MASTER_RETRY_COUNT:
          case MySqlParser::MASTER_SSL:
          case MySqlParser::MASTER_SSL_CA:
          case MySqlParser::MASTER_SSL_CAPATH:
          case MySqlParser::MASTER_SSL_CERT:
          case MySqlParser::MASTER_SSL_CIPHER:
          case MySqlParser::MASTER_SSL_CRL:
          case MySqlParser::MASTER_SSL_CRLPATH:
          case MySqlParser::MASTER_SSL_KEY:
          case MySqlParser::MASTER_TLS_VERSION:
          case MySqlParser::MASTER_USER:
          case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
          case MySqlParser::MAX_QUERIES_PER_HOUR:
          case MySqlParser::MAX_ROWS:
          case MySqlParser::MAX_SIZE:
          case MySqlParser::MAX_UPDATES_PER_HOUR:
          case MySqlParser::MAX_USER_CONNECTIONS:
          case MySqlParser::MEDIUM:
          case MySqlParser::MEMBER:
          case MySqlParser::MERGE:
          case MySqlParser::MESSAGE_TEXT:
          case MySqlParser::MID:
          case MySqlParser::MIGRATE:
          case MySqlParser::MIN_ROWS:
          case MySqlParser::MODE:
          case MySqlParser::MODIFY:
          case MySqlParser::MUTEX:
          case MySqlParser::MYSQL:
          case MySqlParser::MYSQL_ERRNO:
          case MySqlParser::NAME:
          case MySqlParser::NAMES:
          case MySqlParser::NCHAR:
          case MySqlParser::NEVER:
          case MySqlParser::NEXT:
          case MySqlParser::NO:
          case MySqlParser::NOCOPY:
          case MySqlParser::NOWAIT:
          case MySqlParser::NODEGROUP:
          case MySqlParser::NONE:
          case MySqlParser::ODBC:
          case MySqlParser::OFFLINE:
          case MySqlParser::OFFSET:
          case MySqlParser::OF:
          case MySqlParser::OJ:
          case MySqlParser::OLD_PASSWORD:
          case MySqlParser::ONE:
          case MySqlParser::ONLINE:
          case MySqlParser::ONLY:
          case MySqlParser::OPEN:
          case MySqlParser::OPTIMIZER_COSTS:
          case MySqlParser::OPTIONS:
          case MySqlParser::OWNER:
          case MySqlParser::PACK_KEYS:
          case MySqlParser::PAGE:
          case MySqlParser::PARSER:
          case MySqlParser::PARTIAL:
          case MySqlParser::PARTITIONING:
          case MySqlParser::PARTITIONS:
          case MySqlParser::PASSWORD:
          case MySqlParser::PASSWORD_LOCK_TIME:
          case MySqlParser::PHASE:
          case MySqlParser::PLUGIN:
          case MySqlParser::PLUGIN_DIR:
          case MySqlParser::PLUGINS:
          case MySqlParser::PORT:
          case MySqlParser::PRECEDES:
          case MySqlParser::PREPARE:
          case MySqlParser::PRESERVE:
          case MySqlParser::PREV:
          case MySqlParser::PROCESSLIST:
          case MySqlParser::PROFILE:
          case MySqlParser::PROFILES:
          case MySqlParser::PROXY:
          case MySqlParser::QUERY:
          case MySqlParser::QUICK:
          case MySqlParser::REBUILD:
          case MySqlParser::RECOVER:
          case MySqlParser::RECURSIVE:
          case MySqlParser::REDO_BUFFER_SIZE:
          case MySqlParser::REDUNDANT:
          case MySqlParser::RELAY:
          case MySqlParser::RELAY_LOG_FILE:
          case MySqlParser::RELAY_LOG_POS:
          case MySqlParser::RELAYLOG:
          case MySqlParser::REMOVE:
          case MySqlParser::REORGANIZE:
          case MySqlParser::REPAIR:
          case MySqlParser::REPLICATE_DO_DB:
          case MySqlParser::REPLICATE_DO_TABLE:
          case MySqlParser::REPLICATE_IGNORE_DB:
          case MySqlParser::REPLICATE_IGNORE_TABLE:
          case MySqlParser::REPLICATE_REWRITE_DB:
          case MySqlParser::REPLICATE_WILD_DO_TABLE:
          case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
          case MySqlParser::REPLICATION:
          case MySqlParser::RESET:
          case MySqlParser::RESUME:
          case MySqlParser::RETURNED_SQLSTATE:
          case MySqlParser::RETURNS:
          case MySqlParser::REUSE:
          case MySqlParser::ROLE:
          case MySqlParser::ROLLBACK:
          case MySqlParser::ROLLUP:
          case MySqlParser::ROTATE:
          case MySqlParser::ROW:
          case MySqlParser::ROWS:
          case MySqlParser::ROW_FORMAT:
          case MySqlParser::RTREE:
          case MySqlParser::SAVEPOINT:
          case MySqlParser::SCHEDULE:
          case MySqlParser::SECURITY:
          case MySqlParser::SERVER:
          case MySqlParser::SESSION:
          case MySqlParser::SHARE:
          case MySqlParser::SHARED:
          case MySqlParser::SIGNED:
          case MySqlParser::SIMPLE:
          case MySqlParser::SLAVE:
          case MySqlParser::SLOW:
          case MySqlParser::SNAPSHOT:
          case MySqlParser::SOCKET:
          case MySqlParser::SOME:
          case MySqlParser::SONAME:
          case MySqlParser::SOUNDS:
          case MySqlParser::SOURCE:
          case MySqlParser::SQL_AFTER_GTIDS:
          case MySqlParser::SQL_AFTER_MTS_GAPS:
          case MySqlParser::SQL_BEFORE_GTIDS:
          case MySqlParser::SQL_BUFFER_RESULT:
          case MySqlParser::SQL_CACHE:
          case MySqlParser::SQL_NO_CACHE:
          case MySqlParser::SQL_THREAD:
          case MySqlParser::START:
          case MySqlParser::STARTS:
          case MySqlParser::STATS_AUTO_RECALC:
          case MySqlParser::STATS_PERSISTENT:
          case MySqlParser::STATS_SAMPLE_PAGES:
          case MySqlParser::STATUS:
          case MySqlParser::STOP:
          case MySqlParser::STORAGE:
          case MySqlParser::STRING:
          case MySqlParser::SUBCLASS_ORIGIN:
          case MySqlParser::SUBJECT:
          case MySqlParser::SUBPARTITION:
          case MySqlParser::SUBPARTITIONS:
          case MySqlParser::SUSPEND:
          case MySqlParser::SWAPS:
          case MySqlParser::SWITCHES:
          case MySqlParser::TABLE_NAME:
          case MySqlParser::TABLESPACE:
          case MySqlParser::TABLE_TYPE:
          case MySqlParser::TEMPORARY:
          case MySqlParser::TEMPTABLE:
          case MySqlParser::THAN:
          case MySqlParser::TRADITIONAL:
          case MySqlParser::TRANSACTION:
          case MySqlParser::TRANSACTIONAL:
          case MySqlParser::TRIGGERS:
          case MySqlParser::TRUNCATE:
          case MySqlParser::UNBOUNDED:
          case MySqlParser::UNDEFINED:
          case MySqlParser::UNDOFILE:
          case MySqlParser::UNDO_BUFFER_SIZE:
          case MySqlParser::UNINSTALL:
          case MySqlParser::UNKNOWN:
          case MySqlParser::UNTIL:
          case MySqlParser::UPGRADE:
          case MySqlParser::USER:
          case MySqlParser::USE_FRM:
          case MySqlParser::USER_RESOURCES:
          case MySqlParser::VALIDATION:
          case MySqlParser::VALUE:
          case MySqlParser::VARIABLES:
          case MySqlParser::VIEW:
          case MySqlParser::VIRTUAL:
          case MySqlParser::VISIBLE:
          case MySqlParser::WAIT:
          case MySqlParser::WARNINGS:
          case MySqlParser::WITHOUT:
          case MySqlParser::WORK:
          case MySqlParser::WRAPPER:
          case MySqlParser::X509:
          case MySqlParser::XA:
          case MySqlParser::XML:
          case MySqlParser::EUR:
          case MySqlParser::USA:
          case MySqlParser::JIS:
          case MySqlParser::ISO:
          case MySqlParser::INTERNAL:
          case MySqlParser::QUARTER:
          case MySqlParser::MONTH:
          case MySqlParser::DAY:
          case MySqlParser::HOUR:
          case MySqlParser::MINUTE:
          case MySqlParser::WEEK:
          case MySqlParser::SECOND:
          case MySqlParser::MICROSECOND:
          case MySqlParser::ADMIN:
          case MySqlParser::AUDIT_ABORT_EXEMPT:
          case MySqlParser::AUDIT_ADMIN:
          case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
          case MySqlParser::BACKUP_ADMIN:
          case MySqlParser::BINLOG_ADMIN:
          case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
          case MySqlParser::CLONE_ADMIN:
          case MySqlParser::CONNECTION_ADMIN:
          case MySqlParser::ENCRYPTION_KEY_ADMIN:
          case MySqlParser::EXECUTE:
          case MySqlParser::FILE:
          case MySqlParser::FIREWALL_ADMIN:
          case MySqlParser::FIREWALL_EXEMPT:
          case MySqlParser::FIREWALL_USER:
          case MySqlParser::GROUP_REPLICATION_ADMIN:
          case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
          case MySqlParser::INVOKE:
          case MySqlParser::LAMBDA:
          case MySqlParser::NDB_STORED_USER:
          case MySqlParser::PASSWORDLESS_USER_ADMIN:
          case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
          case MySqlParser::PRIVILEGES:
          case MySqlParser::PROCESS:
          case MySqlParser::RELOAD:
          case MySqlParser::REPLICATION_APPLIER:
          case MySqlParser::REPLICATION_SLAVE_ADMIN:
          case MySqlParser::RESOURCE_GROUP_ADMIN:
          case MySqlParser::RESOURCE_GROUP_USER:
          case MySqlParser::ROLE_ADMIN:
          case MySqlParser::ROUTINE:
          case MySqlParser::S3:
          case MySqlParser::SESSION_VARIABLES_ADMIN:
          case MySqlParser::SET_USER_ID:
          case MySqlParser::SHOW_ROUTINE:
          case MySqlParser::SHUTDOWN:
          case MySqlParser::SUPER:
          case MySqlParser::SYSTEM_VARIABLES_ADMIN:
          case MySqlParser::TABLES:
          case MySqlParser::TABLE_ENCRYPTION_ADMIN:
          case MySqlParser::VERSION_TOKEN_ADMIN:
          case MySqlParser::XA_RECOVER_ADMIN:
          case MySqlParser::ARMSCII8:
          case MySqlParser::ASCII:
          case MySqlParser::BIG5:
          case MySqlParser::CP1250:
          case MySqlParser::CP1251:
          case MySqlParser::CP1256:
          case MySqlParser::CP1257:
          case MySqlParser::CP850:
          case MySqlParser::CP852:
          case MySqlParser::CP866:
          case MySqlParser::CP932:
          case MySqlParser::DEC8:
          case MySqlParser::EUCJPMS:
          case MySqlParser::EUCKR:
          case MySqlParser::GB18030:
          case MySqlParser::GB2312:
          case MySqlParser::GBK:
          case MySqlParser::GEOSTD8:
          case MySqlParser::GREEK:
          case MySqlParser::HEBREW:
          case MySqlParser::HP8:
          case MySqlParser::KEYBCS2:
          case MySqlParser::KOI8R:
          case MySqlParser::KOI8U:
          case MySqlParser::LATIN1:
          case MySqlParser::LATIN2:
          case MySqlParser::LATIN5:
          case MySqlParser::LATIN7:
          case MySqlParser::MACCE:
          case MySqlParser::MACROMAN:
          case MySqlParser::SJIS:
          case MySqlParser::SWE7:
          case MySqlParser::TIS620:
          case MySqlParser::UCS2:
          case MySqlParser::UJIS:
          case MySqlParser::UTF16:
          case MySqlParser::UTF16LE:
          case MySqlParser::UTF32:
          case MySqlParser::UTF8:
          case MySqlParser::UTF8MB3:
          case MySqlParser::UTF8MB4:
          case MySqlParser::ARCHIVE:
          case MySqlParser::BLACKHOLE:
          case MySqlParser::CSV:
          case MySqlParser::FEDERATED:
          case MySqlParser::INNODB:
          case MySqlParser::MEMORY:
          case MySqlParser::MRG_MYISAM:
          case MySqlParser::MYISAM:
          case MySqlParser::NDB:
          case MySqlParser::NDBCLUSTER:
          case MySqlParser::PERFORMANCE_SCHEMA:
          case MySqlParser::TOKUDB:
          case MySqlParser::REPEATABLE:
          case MySqlParser::COMMITTED:
          case MySqlParser::UNCOMMITTED:
          case MySqlParser::SERIALIZABLE:
          case MySqlParser::GEOMETRYCOLLECTION:
          case MySqlParser::LINESTRING:
          case MySqlParser::MULTILINESTRING:
          case MySqlParser::MULTIPOINT:
          case MySqlParser::MULTIPOLYGON:
          case MySqlParser::POINT:
          case MySqlParser::POLYGON:
          case MySqlParser::ABS:
          case MySqlParser::ACOS:
          case MySqlParser::ADDDATE:
          case MySqlParser::ADDTIME:
          case MySqlParser::AES_DECRYPT:
          case MySqlParser::AES_ENCRYPT:
          case MySqlParser::AREA:
          case MySqlParser::ASBINARY:
          case MySqlParser::ASIN:
          case MySqlParser::ASTEXT:
          case MySqlParser::ASWKB:
          case MySqlParser::ASWKT:
          case MySqlParser::ASYMMETRIC_DECRYPT:
          case MySqlParser::ASYMMETRIC_DERIVE:
          case MySqlParser::ASYMMETRIC_ENCRYPT:
          case MySqlParser::ASYMMETRIC_SIGN:
          case MySqlParser::ASYMMETRIC_VERIFY:
          case MySqlParser::ATAN:
          case MySqlParser::ATAN2:
          case MySqlParser::BENCHMARK:
          case MySqlParser::BIN:
          case MySqlParser::BIT_COUNT:
          case MySqlParser::BIT_LENGTH:
          case MySqlParser::BUFFER:
          case MySqlParser::CATALOG_NAME:
          case MySqlParser::CEIL:
          case MySqlParser::CEILING:
          case MySqlParser::CENTROID:
          case MySqlParser::CHARACTER_LENGTH:
          case MySqlParser::CHARSET:
          case MySqlParser::CHAR_LENGTH:
          case MySqlParser::COERCIBILITY:
          case MySqlParser::COLLATION:
          case MySqlParser::COMPRESS:
          case MySqlParser::CONCAT:
          case MySqlParser::CONCAT_WS:
          case MySqlParser::CONNECTION_ID:
          case MySqlParser::CONV:
          case MySqlParser::CONVERT_TZ:
          case MySqlParser::COS:
          case MySqlParser::COT:
          case MySqlParser::CRC32:
          case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
          case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
          case MySqlParser::CREATE_DH_PARAMETERS:
          case MySqlParser::CREATE_DIGEST:
          case MySqlParser::CROSSES:
          case MySqlParser::DATEDIFF:
          case MySqlParser::DATE_FORMAT:
          case MySqlParser::DAYNAME:
          case MySqlParser::DAYOFMONTH:
          case MySqlParser::DAYOFWEEK:
          case MySqlParser::DAYOFYEAR:
          case MySqlParser::DECODE:
          case MySqlParser::DEGREES:
          case MySqlParser::DES_DECRYPT:
          case MySqlParser::DES_ENCRYPT:
          case MySqlParser::DIMENSION:
          case MySqlParser::DISJOINT:
          case MySqlParser::ELT:
          case MySqlParser::ENCODE:
          case MySqlParser::ENCRYPT:
          case MySqlParser::ENDPOINT:
          case MySqlParser::ENGINE_ATTRIBUTE:
          case MySqlParser::ENVELOPE:
          case MySqlParser::EQUALS:
          case MySqlParser::EXP:
          case MySqlParser::EXPORT_SET:
          case MySqlParser::EXTERIORRING:
          case MySqlParser::EXTRACTVALUE:
          case MySqlParser::FIELD:
          case MySqlParser::FIND_IN_SET:
          case MySqlParser::FLOOR:
          case MySqlParser::FORMAT:
          case MySqlParser::FOUND_ROWS:
          case MySqlParser::FROM_BASE64:
          case MySqlParser::FROM_DAYS:
          case MySqlParser::FROM_UNIXTIME:
          case MySqlParser::GEOMCOLLFROMTEXT:
          case MySqlParser::GEOMCOLLFROMWKB:
          case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::GEOMETRYFROMTEXT:
          case MySqlParser::GEOMETRYFROMWKB:
          case MySqlParser::GEOMETRYN:
          case MySqlParser::GEOMETRYTYPE:
          case MySqlParser::GEOMFROMTEXT:
          case MySqlParser::GEOMFROMWKB:
          case MySqlParser::GET_FORMAT:
          case MySqlParser::GET_LOCK:
          case MySqlParser::GLENGTH:
          case MySqlParser::GREATEST:
          case MySqlParser::GTID_SUBSET:
          case MySqlParser::GTID_SUBTRACT:
          case MySqlParser::HEX:
          case MySqlParser::IFNULL:
          case MySqlParser::INET6_ATON:
          case MySqlParser::INET6_NTOA:
          case MySqlParser::INET_ATON:
          case MySqlParser::INET_NTOA:
          case MySqlParser::INSTR:
          case MySqlParser::INTERIORRINGN:
          case MySqlParser::INTERSECTS:
          case MySqlParser::ISCLOSED:
          case MySqlParser::ISEMPTY:
          case MySqlParser::ISNULL:
          case MySqlParser::ISSIMPLE:
          case MySqlParser::IS_FREE_LOCK:
          case MySqlParser::IS_IPV4:
          case MySqlParser::IS_IPV4_COMPAT:
          case MySqlParser::IS_IPV4_MAPPED:
          case MySqlParser::IS_IPV6:
          case MySqlParser::IS_USED_LOCK:
          case MySqlParser::LAST_INSERT_ID:
          case MySqlParser::LCASE:
          case MySqlParser::LEAST:
          case MySqlParser::LENGTH:
          case MySqlParser::LINEFROMTEXT:
          case MySqlParser::LINEFROMWKB:
          case MySqlParser::LINESTRINGFROMTEXT:
          case MySqlParser::LINESTRINGFROMWKB:
          case MySqlParser::LN:
          case MySqlParser::LOAD_FILE:
          case MySqlParser::LOCATE:
          case MySqlParser::LOG:
          case MySqlParser::LOG10:
          case MySqlParser::LOG2:
          case MySqlParser::LOWER:
          case MySqlParser::LPAD:
          case MySqlParser::LTRIM:
          case MySqlParser::MAKEDATE:
          case MySqlParser::MAKETIME:
          case MySqlParser::MAKE_SET:
          case MySqlParser::MASTER_POS_WAIT:
          case MySqlParser::MBRCONTAINS:
          case MySqlParser::MBRDISJOINT:
          case MySqlParser::MBREQUAL:
          case MySqlParser::MBRINTERSECTS:
          case MySqlParser::MBROVERLAPS:
          case MySqlParser::MBRTOUCHES:
          case MySqlParser::MBRWITHIN:
          case MySqlParser::MD5:
          case MySqlParser::MLINEFROMTEXT:
          case MySqlParser::MLINEFROMWKB:
          case MySqlParser::MONTHNAME:
          case MySqlParser::MPOINTFROMTEXT:
          case MySqlParser::MPOINTFROMWKB:
          case MySqlParser::MPOLYFROMTEXT:
          case MySqlParser::MPOLYFROMWKB:
          case MySqlParser::MULTILINESTRINGFROMTEXT:
          case MySqlParser::MULTILINESTRINGFROMWKB:
          case MySqlParser::MULTIPOINTFROMTEXT:
          case MySqlParser::MULTIPOINTFROMWKB:
          case MySqlParser::MULTIPOLYGONFROMTEXT:
          case MySqlParser::MULTIPOLYGONFROMWKB:
          case MySqlParser::NAME_CONST:
          case MySqlParser::NULLIF:
          case MySqlParser::NUMGEOMETRIES:
          case MySqlParser::NUMINTERIORRINGS:
          case MySqlParser::NUMPOINTS:
          case MySqlParser::OCT:
          case MySqlParser::OCTET_LENGTH:
          case MySqlParser::ORD:
          case MySqlParser::OVERLAPS:
          case MySqlParser::PERIOD_ADD:
          case MySqlParser::PERIOD_DIFF:
          case MySqlParser::PI:
          case MySqlParser::POINTFROMTEXT:
          case MySqlParser::POINTFROMWKB:
          case MySqlParser::POINTN:
          case MySqlParser::POLYFROMTEXT:
          case MySqlParser::POLYFROMWKB:
          case MySqlParser::POLYGONFROMTEXT:
          case MySqlParser::POLYGONFROMWKB:
          case MySqlParser::POW:
          case MySqlParser::POWER:
          case MySqlParser::QUOTE:
          case MySqlParser::RADIANS:
          case MySqlParser::RAND:
          case MySqlParser::RANDOM_BYTES:
          case MySqlParser::RELEASE_LOCK:
          case MySqlParser::REVERSE:
          case MySqlParser::ROUND:
          case MySqlParser::ROW_COUNT:
          case MySqlParser::RPAD:
          case MySqlParser::RTRIM:
          case MySqlParser::SEC_TO_TIME:
          case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
          case MySqlParser::SESSION_USER:
          case MySqlParser::SHA:
          case MySqlParser::SHA1:
          case MySqlParser::SHA2:
          case MySqlParser::SCHEMA_NAME:
          case MySqlParser::SIGN:
          case MySqlParser::SIN:
          case MySqlParser::SLEEP:
          case MySqlParser::SOUNDEX:
          case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
          case MySqlParser::SQRT:
          case MySqlParser::SRID:
          case MySqlParser::STARTPOINT:
          case MySqlParser::STRCMP:
          case MySqlParser::STR_TO_DATE:
          case MySqlParser::ST_AREA:
          case MySqlParser::ST_ASBINARY:
          case MySqlParser::ST_ASTEXT:
          case MySqlParser::ST_ASWKB:
          case MySqlParser::ST_ASWKT:
          case MySqlParser::ST_BUFFER:
          case MySqlParser::ST_CENTROID:
          case MySqlParser::ST_CONTAINS:
          case MySqlParser::ST_CROSSES:
          case MySqlParser::ST_DIFFERENCE:
          case MySqlParser::ST_DIMENSION:
          case MySqlParser::ST_DISJOINT:
          case MySqlParser::ST_DISTANCE:
          case MySqlParser::ST_ENDPOINT:
          case MySqlParser::ST_ENVELOPE:
          case MySqlParser::ST_EQUALS:
          case MySqlParser::ST_EXTERIORRING:
          case MySqlParser::ST_GEOMCOLLFROMTEXT:
          case MySqlParser::ST_GEOMCOLLFROMTXT:
          case MySqlParser::ST_GEOMCOLLFROMWKB:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::ST_GEOMETRYFROMTEXT:
          case MySqlParser::ST_GEOMETRYFROMWKB:
          case MySqlParser::ST_GEOMETRYN:
          case MySqlParser::ST_GEOMETRYTYPE:
          case MySqlParser::ST_GEOMFROMTEXT:
          case MySqlParser::ST_GEOMFROMWKB:
          case MySqlParser::ST_INTERIORRINGN:
          case MySqlParser::ST_INTERSECTION:
          case MySqlParser::ST_INTERSECTS:
          case MySqlParser::ST_ISCLOSED:
          case MySqlParser::ST_ISEMPTY:
          case MySqlParser::ST_ISSIMPLE:
          case MySqlParser::ST_LINEFROMTEXT:
          case MySqlParser::ST_LINEFROMWKB:
          case MySqlParser::ST_LINESTRINGFROMTEXT:
          case MySqlParser::ST_LINESTRINGFROMWKB:
          case MySqlParser::ST_NUMGEOMETRIES:
          case MySqlParser::ST_NUMINTERIORRING:
          case MySqlParser::ST_NUMINTERIORRINGS:
          case MySqlParser::ST_NUMPOINTS:
          case MySqlParser::ST_OVERLAPS:
          case MySqlParser::ST_POINTFROMTEXT:
          case MySqlParser::ST_POINTFROMWKB:
          case MySqlParser::ST_POINTN:
          case MySqlParser::ST_POLYFROMTEXT:
          case MySqlParser::ST_POLYFROMWKB:
          case MySqlParser::ST_POLYGONFROMTEXT:
          case MySqlParser::ST_POLYGONFROMWKB:
          case MySqlParser::ST_SRID:
          case MySqlParser::ST_STARTPOINT:
          case MySqlParser::ST_SYMDIFFERENCE:
          case MySqlParser::ST_TOUCHES:
          case MySqlParser::ST_UNION:
          case MySqlParser::ST_WITHIN:
          case MySqlParser::ST_X:
          case MySqlParser::ST_Y:
          case MySqlParser::SUBDATE:
          case MySqlParser::SUBSTRING_INDEX:
          case MySqlParser::SUBTIME:
          case MySqlParser::SYSTEM_USER:
          case MySqlParser::TAN:
          case MySqlParser::TIMEDIFF:
          case MySqlParser::TIMESTAMPADD:
          case MySqlParser::TIMESTAMPDIFF:
          case MySqlParser::TIME_FORMAT:
          case MySqlParser::TIME_TO_SEC:
          case MySqlParser::TOUCHES:
          case MySqlParser::TO_BASE64:
          case MySqlParser::TO_DAYS:
          case MySqlParser::TO_SECONDS:
          case MySqlParser::TP_CONNECTION_ADMIN:
          case MySqlParser::UCASE:
          case MySqlParser::UNCOMPRESS:
          case MySqlParser::UNCOMPRESSED_LENGTH:
          case MySqlParser::UNHEX:
          case MySqlParser::UNIX_TIMESTAMP:
          case MySqlParser::UPDATEXML:
          case MySqlParser::UPPER:
          case MySqlParser::UUID:
          case MySqlParser::UUID_SHORT:
          case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
          case MySqlParser::VERSION:
          case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
          case MySqlParser::WEEKDAY:
          case MySqlParser::WEEKOFYEAR:
          case MySqlParser::WEIGHT_STRING:
          case MySqlParser::WITHIN:
          case MySqlParser::YEARWEEK:
          case MySqlParser::Y_FUNCTION:
          case MySqlParser::X_FUNCTION:
          case MySqlParser::MOD:
          case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
          case MySqlParser::STRING_LITERAL:
          case MySqlParser::ID: {
            setState(2938);
            uidList();
            break;
          }

          case MySqlParser::ALL: {
            setState(2939);
            match(MySqlParser::ALL);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySqlParser::OPTIMIZE: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByOptimizePartitionContext>(_localctx);
        enterOuterAlt(_localctx, 11);
        setState(2942);
        match(MySqlParser::OPTIMIZE);
        setState(2943);
        match(MySqlParser::PARTITION);
        setState(2946);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::ATTRIBUTE:
          case MySqlParser::BUCKETS:
          case MySqlParser::CONDITION:
          case MySqlParser::CURRENT:
          case MySqlParser::CURRENT_USER:
          case MySqlParser::DATABASE:
          case MySqlParser::DEFAULT:
          case MySqlParser::DIAGNOSTICS:
          case MySqlParser::EMPTY:
          case MySqlParser::ENFORCED:
          case MySqlParser::EXCEPT:
          case MySqlParser::GROUP:
          case MySqlParser::IF:
          case MySqlParser::IGNORED:
          case MySqlParser::INSERT:
          case MySqlParser::LATERAL:
          case MySqlParser::LEFT:
          case MySqlParser::NUMBER:
          case MySqlParser::OPTIONAL:
          case MySqlParser::ORDER:
          case MySqlParser::PRIMARY:
          case MySqlParser::REPLACE:
          case MySqlParser::RIGHT:
          case MySqlParser::SCHEMA:
          case MySqlParser::SKIP_QUERY_REWRITE:
          case MySqlParser::STACKED:
          case MySqlParser::DATE:
          case MySqlParser::TIME:
          case MySqlParser::TIMESTAMP:
          case MySqlParser::DATETIME:
          case MySqlParser::YEAR:
          case MySqlParser::BINARY:
          case MySqlParser::TEXT:
          case MySqlParser::ENUM:
          case MySqlParser::SERIAL:
          case MySqlParser::JSON_ARRAY:
          case MySqlParser::JSON_ARRAYAGG:
          case MySqlParser::JSON_ARRAY_APPEND:
          case MySqlParser::JSON_ARRAY_INSERT:
          case MySqlParser::JSON_CONTAINS:
          case MySqlParser::JSON_CONTAINS_PATH:
          case MySqlParser::JSON_DEPTH:
          case MySqlParser::JSON_EXTRACT:
          case MySqlParser::JSON_INSERT:
          case MySqlParser::JSON_KEYS:
          case MySqlParser::JSON_LENGTH:
          case MySqlParser::JSON_MERGE:
          case MySqlParser::JSON_MERGE_PATCH:
          case MySqlParser::JSON_MERGE_PRESERVE:
          case MySqlParser::JSON_OBJECT:
          case MySqlParser::JSON_OBJECTAGG:
          case MySqlParser::JSON_OVERLAPS:
          case MySqlParser::JSON_PRETTY:
          case MySqlParser::JSON_QUOTE:
          case MySqlParser::JSON_REMOVE:
          case MySqlParser::JSON_REPLACE:
          case MySqlParser::JSON_SCHEMA_VALID:
          case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
          case MySqlParser::JSON_SEARCH:
          case MySqlParser::JSON_SET:
          case MySqlParser::JSON_STORAGE_FREE:
          case MySqlParser::JSON_STORAGE_SIZE:
          case MySqlParser::JSON_TABLE:
          case MySqlParser::JSON_TYPE:
          case MySqlParser::JSON_UNQUOTE:
          case MySqlParser::JSON_VALID:
          case MySqlParser::JSON_VALUE:
          case MySqlParser::NESTED:
          case MySqlParser::ORDINALITY:
          case MySqlParser::PATH:
          case MySqlParser::AVG:
          case MySqlParser::BIT_AND:
          case MySqlParser::BIT_OR:
          case MySqlParser::BIT_XOR:
          case MySqlParser::COUNT:
          case MySqlParser::CUME_DIST:
          case MySqlParser::DENSE_RANK:
          case MySqlParser::FIRST_VALUE:
          case MySqlParser::GROUP_CONCAT:
          case MySqlParser::LAG:
          case MySqlParser::LAST_VALUE:
          case MySqlParser::LEAD:
          case MySqlParser::MAX:
          case MySqlParser::MIN:
          case MySqlParser::NTILE:
          case MySqlParser::NTH_VALUE:
          case MySqlParser::PERCENT_RANK:
          case MySqlParser::RANK:
          case MySqlParser::ROW_NUMBER:
          case MySqlParser::STD:
          case MySqlParser::STDDEV:
          case MySqlParser::STDDEV_POP:
          case MySqlParser::STDDEV_SAMP:
          case MySqlParser::SUM:
          case MySqlParser::VAR_POP:
          case MySqlParser::VAR_SAMP:
          case MySqlParser::VARIANCE:
          case MySqlParser::CURRENT_DATE:
          case MySqlParser::CURRENT_TIME:
          case MySqlParser::CURRENT_TIMESTAMP:
          case MySqlParser::LOCALTIME:
          case MySqlParser::CURDATE:
          case MySqlParser::CURTIME:
          case MySqlParser::DATE_ADD:
          case MySqlParser::DATE_SUB:
          case MySqlParser::LOCALTIMESTAMP:
          case MySqlParser::NOW:
          case MySqlParser::POSITION:
          case MySqlParser::SUBSTR:
          case MySqlParser::SUBSTRING:
          case MySqlParser::SYSDATE:
          case MySqlParser::TRIM:
          case MySqlParser::UTC_DATE:
          case MySqlParser::UTC_TIME:
          case MySqlParser::UTC_TIMESTAMP:
          case MySqlParser::ACCOUNT:
          case MySqlParser::ACTION:
          case MySqlParser::AFTER:
          case MySqlParser::AGGREGATE:
          case MySqlParser::ALGORITHM:
          case MySqlParser::ANY:
          case MySqlParser::AT:
          case MySqlParser::AUTHORS:
          case MySqlParser::AUTOCOMMIT:
          case MySqlParser::AUTOEXTEND_SIZE:
          case MySqlParser::AUTO_INCREMENT:
          case MySqlParser::AVG_ROW_LENGTH:
          case MySqlParser::BEGIN:
          case MySqlParser::BINLOG:
          case MySqlParser::BIT:
          case MySqlParser::BLOCK:
          case MySqlParser::BOOL:
          case MySqlParser::BOOLEAN:
          case MySqlParser::BTREE:
          case MySqlParser::CACHE:
          case MySqlParser::CASCADED:
          case MySqlParser::CHAIN:
          case MySqlParser::CHANGED:
          case MySqlParser::CHANNEL:
          case MySqlParser::CHECKSUM:
          case MySqlParser::PAGE_CHECKSUM:
          case MySqlParser::CIPHER:
          case MySqlParser::CLASS_ORIGIN:
          case MySqlParser::CLIENT:
          case MySqlParser::CLOSE:
          case MySqlParser::CLUSTERING:
          case MySqlParser::COALESCE:
          case MySqlParser::CODE:
          case MySqlParser::COLUMNS:
          case MySqlParser::COLUMN_FORMAT:
          case MySqlParser::COLUMN_NAME:
          case MySqlParser::COMMENT:
          case MySqlParser::COMMIT:
          case MySqlParser::COMPACT:
          case MySqlParser::COMPLETION:
          case MySqlParser::COMPRESSED:
          case MySqlParser::COMPRESSION:
          case MySqlParser::CONCURRENT:
          case MySqlParser::CONNECT:
          case MySqlParser::CONNECTION:
          case MySqlParser::CONSISTENT:
          case MySqlParser::CONSTRAINT_CATALOG:
          case MySqlParser::CONSTRAINT_SCHEMA:
          case MySqlParser::CONSTRAINT_NAME:
          case MySqlParser::CONTAINS:
          case MySqlParser::CONTEXT:
          case MySqlParser::CONTRIBUTORS:
          case MySqlParser::COPY:
          case MySqlParser::CPU:
          case MySqlParser::CURSOR_NAME:
          case MySqlParser::DATA:
          case MySqlParser::DATAFILE:
          case MySqlParser::DEALLOCATE:
          case MySqlParser::DEFAULT_AUTH:
          case MySqlParser::DEFINER:
          case MySqlParser::DELAY_KEY_WRITE:
          case MySqlParser::DES_KEY_FILE:
          case MySqlParser::DIRECTORY:
          case MySqlParser::DISABLE:
          case MySqlParser::DISCARD:
          case MySqlParser::DISK:
          case MySqlParser::DO:
          case MySqlParser::DUMPFILE:
          case MySqlParser::DUPLICATE:
          case MySqlParser::DYNAMIC:
          case MySqlParser::ENABLE:
          case MySqlParser::ENCRYPTION:
          case MySqlParser::END:
          case MySqlParser::ENDS:
          case MySqlParser::ENGINE:
          case MySqlParser::ENGINES:
          case MySqlParser::ERROR:
          case MySqlParser::ERRORS:
          case MySqlParser::ESCAPE:
          case MySqlParser::EVEN:
          case MySqlParser::EVENT:
          case MySqlParser::EVENTS:
          case MySqlParser::EVERY:
          case MySqlParser::EXCHANGE:
          case MySqlParser::EXCLUSIVE:
          case MySqlParser::EXPIRE:
          case MySqlParser::EXPORT:
          case MySqlParser::EXTENDED:
          case MySqlParser::EXTENT_SIZE:
          case MySqlParser::FAILED_LOGIN_ATTEMPTS:
          case MySqlParser::FAST:
          case MySqlParser::FAULTS:
          case MySqlParser::FIELDS:
          case MySqlParser::FILE_BLOCK_SIZE:
          case MySqlParser::FILTER:
          case MySqlParser::FIRST:
          case MySqlParser::FIXED:
          case MySqlParser::FLUSH:
          case MySqlParser::FOLLOWS:
          case MySqlParser::FOUND:
          case MySqlParser::FULL:
          case MySqlParser::FUNCTION:
          case MySqlParser::GENERAL:
          case MySqlParser::GLOBAL:
          case MySqlParser::GRANTS:
          case MySqlParser::GROUP_REPLICATION:
          case MySqlParser::HANDLER:
          case MySqlParser::HASH:
          case MySqlParser::HELP:
          case MySqlParser::HISTORY:
          case MySqlParser::HOST:
          case MySqlParser::HOSTS:
          case MySqlParser::IDENTIFIED:
          case MySqlParser::IGNORE_SERVER_IDS:
          case MySqlParser::IMPORT:
          case MySqlParser::INDEXES:
          case MySqlParser::INITIAL_SIZE:
          case MySqlParser::INPLACE:
          case MySqlParser::INSERT_METHOD:
          case MySqlParser::INSTALL:
          case MySqlParser::INSTANCE:
          case MySqlParser::INSTANT:
          case MySqlParser::INVISIBLE:
          case MySqlParser::INVOKER:
          case MySqlParser::IO:
          case MySqlParser::IO_THREAD:
          case MySqlParser::IPC:
          case MySqlParser::ISOLATION:
          case MySqlParser::ISSUER:
          case MySqlParser::JSON:
          case MySqlParser::KEY_BLOCK_SIZE:
          case MySqlParser::LANGUAGE:
          case MySqlParser::LAST:
          case MySqlParser::LEAVES:
          case MySqlParser::LESS:
          case MySqlParser::LEVEL:
          case MySqlParser::LIST:
          case MySqlParser::LOCAL:
          case MySqlParser::LOGFILE:
          case MySqlParser::LOGS:
          case MySqlParser::MASTER:
          case MySqlParser::MASTER_AUTO_POSITION:
          case MySqlParser::MASTER_CONNECT_RETRY:
          case MySqlParser::MASTER_DELAY:
          case MySqlParser::MASTER_HEARTBEAT_PERIOD:
          case MySqlParser::MASTER_HOST:
          case MySqlParser::MASTER_LOG_FILE:
          case MySqlParser::MASTER_LOG_POS:
          case MySqlParser::MASTER_PASSWORD:
          case MySqlParser::MASTER_PORT:
          case MySqlParser::MASTER_RETRY_COUNT:
          case MySqlParser::MASTER_SSL:
          case MySqlParser::MASTER_SSL_CA:
          case MySqlParser::MASTER_SSL_CAPATH:
          case MySqlParser::MASTER_SSL_CERT:
          case MySqlParser::MASTER_SSL_CIPHER:
          case MySqlParser::MASTER_SSL_CRL:
          case MySqlParser::MASTER_SSL_CRLPATH:
          case MySqlParser::MASTER_SSL_KEY:
          case MySqlParser::MASTER_TLS_VERSION:
          case MySqlParser::MASTER_USER:
          case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
          case MySqlParser::MAX_QUERIES_PER_HOUR:
          case MySqlParser::MAX_ROWS:
          case MySqlParser::MAX_SIZE:
          case MySqlParser::MAX_UPDATES_PER_HOUR:
          case MySqlParser::MAX_USER_CONNECTIONS:
          case MySqlParser::MEDIUM:
          case MySqlParser::MEMBER:
          case MySqlParser::MERGE:
          case MySqlParser::MESSAGE_TEXT:
          case MySqlParser::MID:
          case MySqlParser::MIGRATE:
          case MySqlParser::MIN_ROWS:
          case MySqlParser::MODE:
          case MySqlParser::MODIFY:
          case MySqlParser::MUTEX:
          case MySqlParser::MYSQL:
          case MySqlParser::MYSQL_ERRNO:
          case MySqlParser::NAME:
          case MySqlParser::NAMES:
          case MySqlParser::NCHAR:
          case MySqlParser::NEVER:
          case MySqlParser::NEXT:
          case MySqlParser::NO:
          case MySqlParser::NOCOPY:
          case MySqlParser::NOWAIT:
          case MySqlParser::NODEGROUP:
          case MySqlParser::NONE:
          case MySqlParser::ODBC:
          case MySqlParser::OFFLINE:
          case MySqlParser::OFFSET:
          case MySqlParser::OF:
          case MySqlParser::OJ:
          case MySqlParser::OLD_PASSWORD:
          case MySqlParser::ONE:
          case MySqlParser::ONLINE:
          case MySqlParser::ONLY:
          case MySqlParser::OPEN:
          case MySqlParser::OPTIMIZER_COSTS:
          case MySqlParser::OPTIONS:
          case MySqlParser::OWNER:
          case MySqlParser::PACK_KEYS:
          case MySqlParser::PAGE:
          case MySqlParser::PARSER:
          case MySqlParser::PARTIAL:
          case MySqlParser::PARTITIONING:
          case MySqlParser::PARTITIONS:
          case MySqlParser::PASSWORD:
          case MySqlParser::PASSWORD_LOCK_TIME:
          case MySqlParser::PHASE:
          case MySqlParser::PLUGIN:
          case MySqlParser::PLUGIN_DIR:
          case MySqlParser::PLUGINS:
          case MySqlParser::PORT:
          case MySqlParser::PRECEDES:
          case MySqlParser::PREPARE:
          case MySqlParser::PRESERVE:
          case MySqlParser::PREV:
          case MySqlParser::PROCESSLIST:
          case MySqlParser::PROFILE:
          case MySqlParser::PROFILES:
          case MySqlParser::PROXY:
          case MySqlParser::QUERY:
          case MySqlParser::QUICK:
          case MySqlParser::REBUILD:
          case MySqlParser::RECOVER:
          case MySqlParser::RECURSIVE:
          case MySqlParser::REDO_BUFFER_SIZE:
          case MySqlParser::REDUNDANT:
          case MySqlParser::RELAY:
          case MySqlParser::RELAY_LOG_FILE:
          case MySqlParser::RELAY_LOG_POS:
          case MySqlParser::RELAYLOG:
          case MySqlParser::REMOVE:
          case MySqlParser::REORGANIZE:
          case MySqlParser::REPAIR:
          case MySqlParser::REPLICATE_DO_DB:
          case MySqlParser::REPLICATE_DO_TABLE:
          case MySqlParser::REPLICATE_IGNORE_DB:
          case MySqlParser::REPLICATE_IGNORE_TABLE:
          case MySqlParser::REPLICATE_REWRITE_DB:
          case MySqlParser::REPLICATE_WILD_DO_TABLE:
          case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
          case MySqlParser::REPLICATION:
          case MySqlParser::RESET:
          case MySqlParser::RESUME:
          case MySqlParser::RETURNED_SQLSTATE:
          case MySqlParser::RETURNS:
          case MySqlParser::REUSE:
          case MySqlParser::ROLE:
          case MySqlParser::ROLLBACK:
          case MySqlParser::ROLLUP:
          case MySqlParser::ROTATE:
          case MySqlParser::ROW:
          case MySqlParser::ROWS:
          case MySqlParser::ROW_FORMAT:
          case MySqlParser::RTREE:
          case MySqlParser::SAVEPOINT:
          case MySqlParser::SCHEDULE:
          case MySqlParser::SECURITY:
          case MySqlParser::SERVER:
          case MySqlParser::SESSION:
          case MySqlParser::SHARE:
          case MySqlParser::SHARED:
          case MySqlParser::SIGNED:
          case MySqlParser::SIMPLE:
          case MySqlParser::SLAVE:
          case MySqlParser::SLOW:
          case MySqlParser::SNAPSHOT:
          case MySqlParser::SOCKET:
          case MySqlParser::SOME:
          case MySqlParser::SONAME:
          case MySqlParser::SOUNDS:
          case MySqlParser::SOURCE:
          case MySqlParser::SQL_AFTER_GTIDS:
          case MySqlParser::SQL_AFTER_MTS_GAPS:
          case MySqlParser::SQL_BEFORE_GTIDS:
          case MySqlParser::SQL_BUFFER_RESULT:
          case MySqlParser::SQL_CACHE:
          case MySqlParser::SQL_NO_CACHE:
          case MySqlParser::SQL_THREAD:
          case MySqlParser::START:
          case MySqlParser::STARTS:
          case MySqlParser::STATS_AUTO_RECALC:
          case MySqlParser::STATS_PERSISTENT:
          case MySqlParser::STATS_SAMPLE_PAGES:
          case MySqlParser::STATUS:
          case MySqlParser::STOP:
          case MySqlParser::STORAGE:
          case MySqlParser::STRING:
          case MySqlParser::SUBCLASS_ORIGIN:
          case MySqlParser::SUBJECT:
          case MySqlParser::SUBPARTITION:
          case MySqlParser::SUBPARTITIONS:
          case MySqlParser::SUSPEND:
          case MySqlParser::SWAPS:
          case MySqlParser::SWITCHES:
          case MySqlParser::TABLE_NAME:
          case MySqlParser::TABLESPACE:
          case MySqlParser::TABLE_TYPE:
          case MySqlParser::TEMPORARY:
          case MySqlParser::TEMPTABLE:
          case MySqlParser::THAN:
          case MySqlParser::TRADITIONAL:
          case MySqlParser::TRANSACTION:
          case MySqlParser::TRANSACTIONAL:
          case MySqlParser::TRIGGERS:
          case MySqlParser::TRUNCATE:
          case MySqlParser::UNBOUNDED:
          case MySqlParser::UNDEFINED:
          case MySqlParser::UNDOFILE:
          case MySqlParser::UNDO_BUFFER_SIZE:
          case MySqlParser::UNINSTALL:
          case MySqlParser::UNKNOWN:
          case MySqlParser::UNTIL:
          case MySqlParser::UPGRADE:
          case MySqlParser::USER:
          case MySqlParser::USE_FRM:
          case MySqlParser::USER_RESOURCES:
          case MySqlParser::VALIDATION:
          case MySqlParser::VALUE:
          case MySqlParser::VARIABLES:
          case MySqlParser::VIEW:
          case MySqlParser::VIRTUAL:
          case MySqlParser::VISIBLE:
          case MySqlParser::WAIT:
          case MySqlParser::WARNINGS:
          case MySqlParser::WITHOUT:
          case MySqlParser::WORK:
          case MySqlParser::WRAPPER:
          case MySqlParser::X509:
          case MySqlParser::XA:
          case MySqlParser::XML:
          case MySqlParser::EUR:
          case MySqlParser::USA:
          case MySqlParser::JIS:
          case MySqlParser::ISO:
          case MySqlParser::INTERNAL:
          case MySqlParser::QUARTER:
          case MySqlParser::MONTH:
          case MySqlParser::DAY:
          case MySqlParser::HOUR:
          case MySqlParser::MINUTE:
          case MySqlParser::WEEK:
          case MySqlParser::SECOND:
          case MySqlParser::MICROSECOND:
          case MySqlParser::ADMIN:
          case MySqlParser::AUDIT_ABORT_EXEMPT:
          case MySqlParser::AUDIT_ADMIN:
          case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
          case MySqlParser::BACKUP_ADMIN:
          case MySqlParser::BINLOG_ADMIN:
          case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
          case MySqlParser::CLONE_ADMIN:
          case MySqlParser::CONNECTION_ADMIN:
          case MySqlParser::ENCRYPTION_KEY_ADMIN:
          case MySqlParser::EXECUTE:
          case MySqlParser::FILE:
          case MySqlParser::FIREWALL_ADMIN:
          case MySqlParser::FIREWALL_EXEMPT:
          case MySqlParser::FIREWALL_USER:
          case MySqlParser::GROUP_REPLICATION_ADMIN:
          case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
          case MySqlParser::INVOKE:
          case MySqlParser::LAMBDA:
          case MySqlParser::NDB_STORED_USER:
          case MySqlParser::PASSWORDLESS_USER_ADMIN:
          case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
          case MySqlParser::PRIVILEGES:
          case MySqlParser::PROCESS:
          case MySqlParser::RELOAD:
          case MySqlParser::REPLICATION_APPLIER:
          case MySqlParser::REPLICATION_SLAVE_ADMIN:
          case MySqlParser::RESOURCE_GROUP_ADMIN:
          case MySqlParser::RESOURCE_GROUP_USER:
          case MySqlParser::ROLE_ADMIN:
          case MySqlParser::ROUTINE:
          case MySqlParser::S3:
          case MySqlParser::SESSION_VARIABLES_ADMIN:
          case MySqlParser::SET_USER_ID:
          case MySqlParser::SHOW_ROUTINE:
          case MySqlParser::SHUTDOWN:
          case MySqlParser::SUPER:
          case MySqlParser::SYSTEM_VARIABLES_ADMIN:
          case MySqlParser::TABLES:
          case MySqlParser::TABLE_ENCRYPTION_ADMIN:
          case MySqlParser::VERSION_TOKEN_ADMIN:
          case MySqlParser::XA_RECOVER_ADMIN:
          case MySqlParser::ARMSCII8:
          case MySqlParser::ASCII:
          case MySqlParser::BIG5:
          case MySqlParser::CP1250:
          case MySqlParser::CP1251:
          case MySqlParser::CP1256:
          case MySqlParser::CP1257:
          case MySqlParser::CP850:
          case MySqlParser::CP852:
          case MySqlParser::CP866:
          case MySqlParser::CP932:
          case MySqlParser::DEC8:
          case MySqlParser::EUCJPMS:
          case MySqlParser::EUCKR:
          case MySqlParser::GB18030:
          case MySqlParser::GB2312:
          case MySqlParser::GBK:
          case MySqlParser::GEOSTD8:
          case MySqlParser::GREEK:
          case MySqlParser::HEBREW:
          case MySqlParser::HP8:
          case MySqlParser::KEYBCS2:
          case MySqlParser::KOI8R:
          case MySqlParser::KOI8U:
          case MySqlParser::LATIN1:
          case MySqlParser::LATIN2:
          case MySqlParser::LATIN5:
          case MySqlParser::LATIN7:
          case MySqlParser::MACCE:
          case MySqlParser::MACROMAN:
          case MySqlParser::SJIS:
          case MySqlParser::SWE7:
          case MySqlParser::TIS620:
          case MySqlParser::UCS2:
          case MySqlParser::UJIS:
          case MySqlParser::UTF16:
          case MySqlParser::UTF16LE:
          case MySqlParser::UTF32:
          case MySqlParser::UTF8:
          case MySqlParser::UTF8MB3:
          case MySqlParser::UTF8MB4:
          case MySqlParser::ARCHIVE:
          case MySqlParser::BLACKHOLE:
          case MySqlParser::CSV:
          case MySqlParser::FEDERATED:
          case MySqlParser::INNODB:
          case MySqlParser::MEMORY:
          case MySqlParser::MRG_MYISAM:
          case MySqlParser::MYISAM:
          case MySqlParser::NDB:
          case MySqlParser::NDBCLUSTER:
          case MySqlParser::PERFORMANCE_SCHEMA:
          case MySqlParser::TOKUDB:
          case MySqlParser::REPEATABLE:
          case MySqlParser::COMMITTED:
          case MySqlParser::UNCOMMITTED:
          case MySqlParser::SERIALIZABLE:
          case MySqlParser::GEOMETRYCOLLECTION:
          case MySqlParser::LINESTRING:
          case MySqlParser::MULTILINESTRING:
          case MySqlParser::MULTIPOINT:
          case MySqlParser::MULTIPOLYGON:
          case MySqlParser::POINT:
          case MySqlParser::POLYGON:
          case MySqlParser::ABS:
          case MySqlParser::ACOS:
          case MySqlParser::ADDDATE:
          case MySqlParser::ADDTIME:
          case MySqlParser::AES_DECRYPT:
          case MySqlParser::AES_ENCRYPT:
          case MySqlParser::AREA:
          case MySqlParser::ASBINARY:
          case MySqlParser::ASIN:
          case MySqlParser::ASTEXT:
          case MySqlParser::ASWKB:
          case MySqlParser::ASWKT:
          case MySqlParser::ASYMMETRIC_DECRYPT:
          case MySqlParser::ASYMMETRIC_DERIVE:
          case MySqlParser::ASYMMETRIC_ENCRYPT:
          case MySqlParser::ASYMMETRIC_SIGN:
          case MySqlParser::ASYMMETRIC_VERIFY:
          case MySqlParser::ATAN:
          case MySqlParser::ATAN2:
          case MySqlParser::BENCHMARK:
          case MySqlParser::BIN:
          case MySqlParser::BIT_COUNT:
          case MySqlParser::BIT_LENGTH:
          case MySqlParser::BUFFER:
          case MySqlParser::CATALOG_NAME:
          case MySqlParser::CEIL:
          case MySqlParser::CEILING:
          case MySqlParser::CENTROID:
          case MySqlParser::CHARACTER_LENGTH:
          case MySqlParser::CHARSET:
          case MySqlParser::CHAR_LENGTH:
          case MySqlParser::COERCIBILITY:
          case MySqlParser::COLLATION:
          case MySqlParser::COMPRESS:
          case MySqlParser::CONCAT:
          case MySqlParser::CONCAT_WS:
          case MySqlParser::CONNECTION_ID:
          case MySqlParser::CONV:
          case MySqlParser::CONVERT_TZ:
          case MySqlParser::COS:
          case MySqlParser::COT:
          case MySqlParser::CRC32:
          case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
          case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
          case MySqlParser::CREATE_DH_PARAMETERS:
          case MySqlParser::CREATE_DIGEST:
          case MySqlParser::CROSSES:
          case MySqlParser::DATEDIFF:
          case MySqlParser::DATE_FORMAT:
          case MySqlParser::DAYNAME:
          case MySqlParser::DAYOFMONTH:
          case MySqlParser::DAYOFWEEK:
          case MySqlParser::DAYOFYEAR:
          case MySqlParser::DECODE:
          case MySqlParser::DEGREES:
          case MySqlParser::DES_DECRYPT:
          case MySqlParser::DES_ENCRYPT:
          case MySqlParser::DIMENSION:
          case MySqlParser::DISJOINT:
          case MySqlParser::ELT:
          case MySqlParser::ENCODE:
          case MySqlParser::ENCRYPT:
          case MySqlParser::ENDPOINT:
          case MySqlParser::ENGINE_ATTRIBUTE:
          case MySqlParser::ENVELOPE:
          case MySqlParser::EQUALS:
          case MySqlParser::EXP:
          case MySqlParser::EXPORT_SET:
          case MySqlParser::EXTERIORRING:
          case MySqlParser::EXTRACTVALUE:
          case MySqlParser::FIELD:
          case MySqlParser::FIND_IN_SET:
          case MySqlParser::FLOOR:
          case MySqlParser::FORMAT:
          case MySqlParser::FOUND_ROWS:
          case MySqlParser::FROM_BASE64:
          case MySqlParser::FROM_DAYS:
          case MySqlParser::FROM_UNIXTIME:
          case MySqlParser::GEOMCOLLFROMTEXT:
          case MySqlParser::GEOMCOLLFROMWKB:
          case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::GEOMETRYFROMTEXT:
          case MySqlParser::GEOMETRYFROMWKB:
          case MySqlParser::GEOMETRYN:
          case MySqlParser::GEOMETRYTYPE:
          case MySqlParser::GEOMFROMTEXT:
          case MySqlParser::GEOMFROMWKB:
          case MySqlParser::GET_FORMAT:
          case MySqlParser::GET_LOCK:
          case MySqlParser::GLENGTH:
          case MySqlParser::GREATEST:
          case MySqlParser::GTID_SUBSET:
          case MySqlParser::GTID_SUBTRACT:
          case MySqlParser::HEX:
          case MySqlParser::IFNULL:
          case MySqlParser::INET6_ATON:
          case MySqlParser::INET6_NTOA:
          case MySqlParser::INET_ATON:
          case MySqlParser::INET_NTOA:
          case MySqlParser::INSTR:
          case MySqlParser::INTERIORRINGN:
          case MySqlParser::INTERSECTS:
          case MySqlParser::ISCLOSED:
          case MySqlParser::ISEMPTY:
          case MySqlParser::ISNULL:
          case MySqlParser::ISSIMPLE:
          case MySqlParser::IS_FREE_LOCK:
          case MySqlParser::IS_IPV4:
          case MySqlParser::IS_IPV4_COMPAT:
          case MySqlParser::IS_IPV4_MAPPED:
          case MySqlParser::IS_IPV6:
          case MySqlParser::IS_USED_LOCK:
          case MySqlParser::LAST_INSERT_ID:
          case MySqlParser::LCASE:
          case MySqlParser::LEAST:
          case MySqlParser::LENGTH:
          case MySqlParser::LINEFROMTEXT:
          case MySqlParser::LINEFROMWKB:
          case MySqlParser::LINESTRINGFROMTEXT:
          case MySqlParser::LINESTRINGFROMWKB:
          case MySqlParser::LN:
          case MySqlParser::LOAD_FILE:
          case MySqlParser::LOCATE:
          case MySqlParser::LOG:
          case MySqlParser::LOG10:
          case MySqlParser::LOG2:
          case MySqlParser::LOWER:
          case MySqlParser::LPAD:
          case MySqlParser::LTRIM:
          case MySqlParser::MAKEDATE:
          case MySqlParser::MAKETIME:
          case MySqlParser::MAKE_SET:
          case MySqlParser::MASTER_POS_WAIT:
          case MySqlParser::MBRCONTAINS:
          case MySqlParser::MBRDISJOINT:
          case MySqlParser::MBREQUAL:
          case MySqlParser::MBRINTERSECTS:
          case MySqlParser::MBROVERLAPS:
          case MySqlParser::MBRTOUCHES:
          case MySqlParser::MBRWITHIN:
          case MySqlParser::MD5:
          case MySqlParser::MLINEFROMTEXT:
          case MySqlParser::MLINEFROMWKB:
          case MySqlParser::MONTHNAME:
          case MySqlParser::MPOINTFROMTEXT:
          case MySqlParser::MPOINTFROMWKB:
          case MySqlParser::MPOLYFROMTEXT:
          case MySqlParser::MPOLYFROMWKB:
          case MySqlParser::MULTILINESTRINGFROMTEXT:
          case MySqlParser::MULTILINESTRINGFROMWKB:
          case MySqlParser::MULTIPOINTFROMTEXT:
          case MySqlParser::MULTIPOINTFROMWKB:
          case MySqlParser::MULTIPOLYGONFROMTEXT:
          case MySqlParser::MULTIPOLYGONFROMWKB:
          case MySqlParser::NAME_CONST:
          case MySqlParser::NULLIF:
          case MySqlParser::NUMGEOMETRIES:
          case MySqlParser::NUMINTERIORRINGS:
          case MySqlParser::NUMPOINTS:
          case MySqlParser::OCT:
          case MySqlParser::OCTET_LENGTH:
          case MySqlParser::ORD:
          case MySqlParser::OVERLAPS:
          case MySqlParser::PERIOD_ADD:
          case MySqlParser::PERIOD_DIFF:
          case MySqlParser::PI:
          case MySqlParser::POINTFROMTEXT:
          case MySqlParser::POINTFROMWKB:
          case MySqlParser::POINTN:
          case MySqlParser::POLYFROMTEXT:
          case MySqlParser::POLYFROMWKB:
          case MySqlParser::POLYGONFROMTEXT:
          case MySqlParser::POLYGONFROMWKB:
          case MySqlParser::POW:
          case MySqlParser::POWER:
          case MySqlParser::QUOTE:
          case MySqlParser::RADIANS:
          case MySqlParser::RAND:
          case MySqlParser::RANDOM_BYTES:
          case MySqlParser::RELEASE_LOCK:
          case MySqlParser::REVERSE:
          case MySqlParser::ROUND:
          case MySqlParser::ROW_COUNT:
          case MySqlParser::RPAD:
          case MySqlParser::RTRIM:
          case MySqlParser::SEC_TO_TIME:
          case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
          case MySqlParser::SESSION_USER:
          case MySqlParser::SHA:
          case MySqlParser::SHA1:
          case MySqlParser::SHA2:
          case MySqlParser::SCHEMA_NAME:
          case MySqlParser::SIGN:
          case MySqlParser::SIN:
          case MySqlParser::SLEEP:
          case MySqlParser::SOUNDEX:
          case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
          case MySqlParser::SQRT:
          case MySqlParser::SRID:
          case MySqlParser::STARTPOINT:
          case MySqlParser::STRCMP:
          case MySqlParser::STR_TO_DATE:
          case MySqlParser::ST_AREA:
          case MySqlParser::ST_ASBINARY:
          case MySqlParser::ST_ASTEXT:
          case MySqlParser::ST_ASWKB:
          case MySqlParser::ST_ASWKT:
          case MySqlParser::ST_BUFFER:
          case MySqlParser::ST_CENTROID:
          case MySqlParser::ST_CONTAINS:
          case MySqlParser::ST_CROSSES:
          case MySqlParser::ST_DIFFERENCE:
          case MySqlParser::ST_DIMENSION:
          case MySqlParser::ST_DISJOINT:
          case MySqlParser::ST_DISTANCE:
          case MySqlParser::ST_ENDPOINT:
          case MySqlParser::ST_ENVELOPE:
          case MySqlParser::ST_EQUALS:
          case MySqlParser::ST_EXTERIORRING:
          case MySqlParser::ST_GEOMCOLLFROMTEXT:
          case MySqlParser::ST_GEOMCOLLFROMTXT:
          case MySqlParser::ST_GEOMCOLLFROMWKB:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::ST_GEOMETRYFROMTEXT:
          case MySqlParser::ST_GEOMETRYFROMWKB:
          case MySqlParser::ST_GEOMETRYN:
          case MySqlParser::ST_GEOMETRYTYPE:
          case MySqlParser::ST_GEOMFROMTEXT:
          case MySqlParser::ST_GEOMFROMWKB:
          case MySqlParser::ST_INTERIORRINGN:
          case MySqlParser::ST_INTERSECTION:
          case MySqlParser::ST_INTERSECTS:
          case MySqlParser::ST_ISCLOSED:
          case MySqlParser::ST_ISEMPTY:
          case MySqlParser::ST_ISSIMPLE:
          case MySqlParser::ST_LINEFROMTEXT:
          case MySqlParser::ST_LINEFROMWKB:
          case MySqlParser::ST_LINESTRINGFROMTEXT:
          case MySqlParser::ST_LINESTRINGFROMWKB:
          case MySqlParser::ST_NUMGEOMETRIES:
          case MySqlParser::ST_NUMINTERIORRING:
          case MySqlParser::ST_NUMINTERIORRINGS:
          case MySqlParser::ST_NUMPOINTS:
          case MySqlParser::ST_OVERLAPS:
          case MySqlParser::ST_POINTFROMTEXT:
          case MySqlParser::ST_POINTFROMWKB:
          case MySqlParser::ST_POINTN:
          case MySqlParser::ST_POLYFROMTEXT:
          case MySqlParser::ST_POLYFROMWKB:
          case MySqlParser::ST_POLYGONFROMTEXT:
          case MySqlParser::ST_POLYGONFROMWKB:
          case MySqlParser::ST_SRID:
          case MySqlParser::ST_STARTPOINT:
          case MySqlParser::ST_SYMDIFFERENCE:
          case MySqlParser::ST_TOUCHES:
          case MySqlParser::ST_UNION:
          case MySqlParser::ST_WITHIN:
          case MySqlParser::ST_X:
          case MySqlParser::ST_Y:
          case MySqlParser::SUBDATE:
          case MySqlParser::SUBSTRING_INDEX:
          case MySqlParser::SUBTIME:
          case MySqlParser::SYSTEM_USER:
          case MySqlParser::TAN:
          case MySqlParser::TIMEDIFF:
          case MySqlParser::TIMESTAMPADD:
          case MySqlParser::TIMESTAMPDIFF:
          case MySqlParser::TIME_FORMAT:
          case MySqlParser::TIME_TO_SEC:
          case MySqlParser::TOUCHES:
          case MySqlParser::TO_BASE64:
          case MySqlParser::TO_DAYS:
          case MySqlParser::TO_SECONDS:
          case MySqlParser::TP_CONNECTION_ADMIN:
          case MySqlParser::UCASE:
          case MySqlParser::UNCOMPRESS:
          case MySqlParser::UNCOMPRESSED_LENGTH:
          case MySqlParser::UNHEX:
          case MySqlParser::UNIX_TIMESTAMP:
          case MySqlParser::UPDATEXML:
          case MySqlParser::UPPER:
          case MySqlParser::UUID:
          case MySqlParser::UUID_SHORT:
          case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
          case MySqlParser::VERSION:
          case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
          case MySqlParser::WEEKDAY:
          case MySqlParser::WEEKOFYEAR:
          case MySqlParser::WEIGHT_STRING:
          case MySqlParser::WITHIN:
          case MySqlParser::YEARWEEK:
          case MySqlParser::Y_FUNCTION:
          case MySqlParser::X_FUNCTION:
          case MySqlParser::MOD:
          case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
          case MySqlParser::STRING_LITERAL:
          case MySqlParser::ID: {
            setState(2944);
            uidList();
            break;
          }

          case MySqlParser::ALL: {
            setState(2945);
            match(MySqlParser::ALL);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySqlParser::REBUILD: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByRebuildPartitionContext>(_localctx);
        enterOuterAlt(_localctx, 12);
        setState(2948);
        match(MySqlParser::REBUILD);
        setState(2949);
        match(MySqlParser::PARTITION);
        setState(2952);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::ATTRIBUTE:
          case MySqlParser::BUCKETS:
          case MySqlParser::CONDITION:
          case MySqlParser::CURRENT:
          case MySqlParser::CURRENT_USER:
          case MySqlParser::DATABASE:
          case MySqlParser::DEFAULT:
          case MySqlParser::DIAGNOSTICS:
          case MySqlParser::EMPTY:
          case MySqlParser::ENFORCED:
          case MySqlParser::EXCEPT:
          case MySqlParser::GROUP:
          case MySqlParser::IF:
          case MySqlParser::IGNORED:
          case MySqlParser::INSERT:
          case MySqlParser::LATERAL:
          case MySqlParser::LEFT:
          case MySqlParser::NUMBER:
          case MySqlParser::OPTIONAL:
          case MySqlParser::ORDER:
          case MySqlParser::PRIMARY:
          case MySqlParser::REPLACE:
          case MySqlParser::RIGHT:
          case MySqlParser::SCHEMA:
          case MySqlParser::SKIP_QUERY_REWRITE:
          case MySqlParser::STACKED:
          case MySqlParser::DATE:
          case MySqlParser::TIME:
          case MySqlParser::TIMESTAMP:
          case MySqlParser::DATETIME:
          case MySqlParser::YEAR:
          case MySqlParser::BINARY:
          case MySqlParser::TEXT:
          case MySqlParser::ENUM:
          case MySqlParser::SERIAL:
          case MySqlParser::JSON_ARRAY:
          case MySqlParser::JSON_ARRAYAGG:
          case MySqlParser::JSON_ARRAY_APPEND:
          case MySqlParser::JSON_ARRAY_INSERT:
          case MySqlParser::JSON_CONTAINS:
          case MySqlParser::JSON_CONTAINS_PATH:
          case MySqlParser::JSON_DEPTH:
          case MySqlParser::JSON_EXTRACT:
          case MySqlParser::JSON_INSERT:
          case MySqlParser::JSON_KEYS:
          case MySqlParser::JSON_LENGTH:
          case MySqlParser::JSON_MERGE:
          case MySqlParser::JSON_MERGE_PATCH:
          case MySqlParser::JSON_MERGE_PRESERVE:
          case MySqlParser::JSON_OBJECT:
          case MySqlParser::JSON_OBJECTAGG:
          case MySqlParser::JSON_OVERLAPS:
          case MySqlParser::JSON_PRETTY:
          case MySqlParser::JSON_QUOTE:
          case MySqlParser::JSON_REMOVE:
          case MySqlParser::JSON_REPLACE:
          case MySqlParser::JSON_SCHEMA_VALID:
          case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
          case MySqlParser::JSON_SEARCH:
          case MySqlParser::JSON_SET:
          case MySqlParser::JSON_STORAGE_FREE:
          case MySqlParser::JSON_STORAGE_SIZE:
          case MySqlParser::JSON_TABLE:
          case MySqlParser::JSON_TYPE:
          case MySqlParser::JSON_UNQUOTE:
          case MySqlParser::JSON_VALID:
          case MySqlParser::JSON_VALUE:
          case MySqlParser::NESTED:
          case MySqlParser::ORDINALITY:
          case MySqlParser::PATH:
          case MySqlParser::AVG:
          case MySqlParser::BIT_AND:
          case MySqlParser::BIT_OR:
          case MySqlParser::BIT_XOR:
          case MySqlParser::COUNT:
          case MySqlParser::CUME_DIST:
          case MySqlParser::DENSE_RANK:
          case MySqlParser::FIRST_VALUE:
          case MySqlParser::GROUP_CONCAT:
          case MySqlParser::LAG:
          case MySqlParser::LAST_VALUE:
          case MySqlParser::LEAD:
          case MySqlParser::MAX:
          case MySqlParser::MIN:
          case MySqlParser::NTILE:
          case MySqlParser::NTH_VALUE:
          case MySqlParser::PERCENT_RANK:
          case MySqlParser::RANK:
          case MySqlParser::ROW_NUMBER:
          case MySqlParser::STD:
          case MySqlParser::STDDEV:
          case MySqlParser::STDDEV_POP:
          case MySqlParser::STDDEV_SAMP:
          case MySqlParser::SUM:
          case MySqlParser::VAR_POP:
          case MySqlParser::VAR_SAMP:
          case MySqlParser::VARIANCE:
          case MySqlParser::CURRENT_DATE:
          case MySqlParser::CURRENT_TIME:
          case MySqlParser::CURRENT_TIMESTAMP:
          case MySqlParser::LOCALTIME:
          case MySqlParser::CURDATE:
          case MySqlParser::CURTIME:
          case MySqlParser::DATE_ADD:
          case MySqlParser::DATE_SUB:
          case MySqlParser::LOCALTIMESTAMP:
          case MySqlParser::NOW:
          case MySqlParser::POSITION:
          case MySqlParser::SUBSTR:
          case MySqlParser::SUBSTRING:
          case MySqlParser::SYSDATE:
          case MySqlParser::TRIM:
          case MySqlParser::UTC_DATE:
          case MySqlParser::UTC_TIME:
          case MySqlParser::UTC_TIMESTAMP:
          case MySqlParser::ACCOUNT:
          case MySqlParser::ACTION:
          case MySqlParser::AFTER:
          case MySqlParser::AGGREGATE:
          case MySqlParser::ALGORITHM:
          case MySqlParser::ANY:
          case MySqlParser::AT:
          case MySqlParser::AUTHORS:
          case MySqlParser::AUTOCOMMIT:
          case MySqlParser::AUTOEXTEND_SIZE:
          case MySqlParser::AUTO_INCREMENT:
          case MySqlParser::AVG_ROW_LENGTH:
          case MySqlParser::BEGIN:
          case MySqlParser::BINLOG:
          case MySqlParser::BIT:
          case MySqlParser::BLOCK:
          case MySqlParser::BOOL:
          case MySqlParser::BOOLEAN:
          case MySqlParser::BTREE:
          case MySqlParser::CACHE:
          case MySqlParser::CASCADED:
          case MySqlParser::CHAIN:
          case MySqlParser::CHANGED:
          case MySqlParser::CHANNEL:
          case MySqlParser::CHECKSUM:
          case MySqlParser::PAGE_CHECKSUM:
          case MySqlParser::CIPHER:
          case MySqlParser::CLASS_ORIGIN:
          case MySqlParser::CLIENT:
          case MySqlParser::CLOSE:
          case MySqlParser::CLUSTERING:
          case MySqlParser::COALESCE:
          case MySqlParser::CODE:
          case MySqlParser::COLUMNS:
          case MySqlParser::COLUMN_FORMAT:
          case MySqlParser::COLUMN_NAME:
          case MySqlParser::COMMENT:
          case MySqlParser::COMMIT:
          case MySqlParser::COMPACT:
          case MySqlParser::COMPLETION:
          case MySqlParser::COMPRESSED:
          case MySqlParser::COMPRESSION:
          case MySqlParser::CONCURRENT:
          case MySqlParser::CONNECT:
          case MySqlParser::CONNECTION:
          case MySqlParser::CONSISTENT:
          case MySqlParser::CONSTRAINT_CATALOG:
          case MySqlParser::CONSTRAINT_SCHEMA:
          case MySqlParser::CONSTRAINT_NAME:
          case MySqlParser::CONTAINS:
          case MySqlParser::CONTEXT:
          case MySqlParser::CONTRIBUTORS:
          case MySqlParser::COPY:
          case MySqlParser::CPU:
          case MySqlParser::CURSOR_NAME:
          case MySqlParser::DATA:
          case MySqlParser::DATAFILE:
          case MySqlParser::DEALLOCATE:
          case MySqlParser::DEFAULT_AUTH:
          case MySqlParser::DEFINER:
          case MySqlParser::DELAY_KEY_WRITE:
          case MySqlParser::DES_KEY_FILE:
          case MySqlParser::DIRECTORY:
          case MySqlParser::DISABLE:
          case MySqlParser::DISCARD:
          case MySqlParser::DISK:
          case MySqlParser::DO:
          case MySqlParser::DUMPFILE:
          case MySqlParser::DUPLICATE:
          case MySqlParser::DYNAMIC:
          case MySqlParser::ENABLE:
          case MySqlParser::ENCRYPTION:
          case MySqlParser::END:
          case MySqlParser::ENDS:
          case MySqlParser::ENGINE:
          case MySqlParser::ENGINES:
          case MySqlParser::ERROR:
          case MySqlParser::ERRORS:
          case MySqlParser::ESCAPE:
          case MySqlParser::EVEN:
          case MySqlParser::EVENT:
          case MySqlParser::EVENTS:
          case MySqlParser::EVERY:
          case MySqlParser::EXCHANGE:
          case MySqlParser::EXCLUSIVE:
          case MySqlParser::EXPIRE:
          case MySqlParser::EXPORT:
          case MySqlParser::EXTENDED:
          case MySqlParser::EXTENT_SIZE:
          case MySqlParser::FAILED_LOGIN_ATTEMPTS:
          case MySqlParser::FAST:
          case MySqlParser::FAULTS:
          case MySqlParser::FIELDS:
          case MySqlParser::FILE_BLOCK_SIZE:
          case MySqlParser::FILTER:
          case MySqlParser::FIRST:
          case MySqlParser::FIXED:
          case MySqlParser::FLUSH:
          case MySqlParser::FOLLOWS:
          case MySqlParser::FOUND:
          case MySqlParser::FULL:
          case MySqlParser::FUNCTION:
          case MySqlParser::GENERAL:
          case MySqlParser::GLOBAL:
          case MySqlParser::GRANTS:
          case MySqlParser::GROUP_REPLICATION:
          case MySqlParser::HANDLER:
          case MySqlParser::HASH:
          case MySqlParser::HELP:
          case MySqlParser::HISTORY:
          case MySqlParser::HOST:
          case MySqlParser::HOSTS:
          case MySqlParser::IDENTIFIED:
          case MySqlParser::IGNORE_SERVER_IDS:
          case MySqlParser::IMPORT:
          case MySqlParser::INDEXES:
          case MySqlParser::INITIAL_SIZE:
          case MySqlParser::INPLACE:
          case MySqlParser::INSERT_METHOD:
          case MySqlParser::INSTALL:
          case MySqlParser::INSTANCE:
          case MySqlParser::INSTANT:
          case MySqlParser::INVISIBLE:
          case MySqlParser::INVOKER:
          case MySqlParser::IO:
          case MySqlParser::IO_THREAD:
          case MySqlParser::IPC:
          case MySqlParser::ISOLATION:
          case MySqlParser::ISSUER:
          case MySqlParser::JSON:
          case MySqlParser::KEY_BLOCK_SIZE:
          case MySqlParser::LANGUAGE:
          case MySqlParser::LAST:
          case MySqlParser::LEAVES:
          case MySqlParser::LESS:
          case MySqlParser::LEVEL:
          case MySqlParser::LIST:
          case MySqlParser::LOCAL:
          case MySqlParser::LOGFILE:
          case MySqlParser::LOGS:
          case MySqlParser::MASTER:
          case MySqlParser::MASTER_AUTO_POSITION:
          case MySqlParser::MASTER_CONNECT_RETRY:
          case MySqlParser::MASTER_DELAY:
          case MySqlParser::MASTER_HEARTBEAT_PERIOD:
          case MySqlParser::MASTER_HOST:
          case MySqlParser::MASTER_LOG_FILE:
          case MySqlParser::MASTER_LOG_POS:
          case MySqlParser::MASTER_PASSWORD:
          case MySqlParser::MASTER_PORT:
          case MySqlParser::MASTER_RETRY_COUNT:
          case MySqlParser::MASTER_SSL:
          case MySqlParser::MASTER_SSL_CA:
          case MySqlParser::MASTER_SSL_CAPATH:
          case MySqlParser::MASTER_SSL_CERT:
          case MySqlParser::MASTER_SSL_CIPHER:
          case MySqlParser::MASTER_SSL_CRL:
          case MySqlParser::MASTER_SSL_CRLPATH:
          case MySqlParser::MASTER_SSL_KEY:
          case MySqlParser::MASTER_TLS_VERSION:
          case MySqlParser::MASTER_USER:
          case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
          case MySqlParser::MAX_QUERIES_PER_HOUR:
          case MySqlParser::MAX_ROWS:
          case MySqlParser::MAX_SIZE:
          case MySqlParser::MAX_UPDATES_PER_HOUR:
          case MySqlParser::MAX_USER_CONNECTIONS:
          case MySqlParser::MEDIUM:
          case MySqlParser::MEMBER:
          case MySqlParser::MERGE:
          case MySqlParser::MESSAGE_TEXT:
          case MySqlParser::MID:
          case MySqlParser::MIGRATE:
          case MySqlParser::MIN_ROWS:
          case MySqlParser::MODE:
          case MySqlParser::MODIFY:
          case MySqlParser::MUTEX:
          case MySqlParser::MYSQL:
          case MySqlParser::MYSQL_ERRNO:
          case MySqlParser::NAME:
          case MySqlParser::NAMES:
          case MySqlParser::NCHAR:
          case MySqlParser::NEVER:
          case MySqlParser::NEXT:
          case MySqlParser::NO:
          case MySqlParser::NOCOPY:
          case MySqlParser::NOWAIT:
          case MySqlParser::NODEGROUP:
          case MySqlParser::NONE:
          case MySqlParser::ODBC:
          case MySqlParser::OFFLINE:
          case MySqlParser::OFFSET:
          case MySqlParser::OF:
          case MySqlParser::OJ:
          case MySqlParser::OLD_PASSWORD:
          case MySqlParser::ONE:
          case MySqlParser::ONLINE:
          case MySqlParser::ONLY:
          case MySqlParser::OPEN:
          case MySqlParser::OPTIMIZER_COSTS:
          case MySqlParser::OPTIONS:
          case MySqlParser::OWNER:
          case MySqlParser::PACK_KEYS:
          case MySqlParser::PAGE:
          case MySqlParser::PARSER:
          case MySqlParser::PARTIAL:
          case MySqlParser::PARTITIONING:
          case MySqlParser::PARTITIONS:
          case MySqlParser::PASSWORD:
          case MySqlParser::PASSWORD_LOCK_TIME:
          case MySqlParser::PHASE:
          case MySqlParser::PLUGIN:
          case MySqlParser::PLUGIN_DIR:
          case MySqlParser::PLUGINS:
          case MySqlParser::PORT:
          case MySqlParser::PRECEDES:
          case MySqlParser::PREPARE:
          case MySqlParser::PRESERVE:
          case MySqlParser::PREV:
          case MySqlParser::PROCESSLIST:
          case MySqlParser::PROFILE:
          case MySqlParser::PROFILES:
          case MySqlParser::PROXY:
          case MySqlParser::QUERY:
          case MySqlParser::QUICK:
          case MySqlParser::REBUILD:
          case MySqlParser::RECOVER:
          case MySqlParser::RECURSIVE:
          case MySqlParser::REDO_BUFFER_SIZE:
          case MySqlParser::REDUNDANT:
          case MySqlParser::RELAY:
          case MySqlParser::RELAY_LOG_FILE:
          case MySqlParser::RELAY_LOG_POS:
          case MySqlParser::RELAYLOG:
          case MySqlParser::REMOVE:
          case MySqlParser::REORGANIZE:
          case MySqlParser::REPAIR:
          case MySqlParser::REPLICATE_DO_DB:
          case MySqlParser::REPLICATE_DO_TABLE:
          case MySqlParser::REPLICATE_IGNORE_DB:
          case MySqlParser::REPLICATE_IGNORE_TABLE:
          case MySqlParser::REPLICATE_REWRITE_DB:
          case MySqlParser::REPLICATE_WILD_DO_TABLE:
          case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
          case MySqlParser::REPLICATION:
          case MySqlParser::RESET:
          case MySqlParser::RESUME:
          case MySqlParser::RETURNED_SQLSTATE:
          case MySqlParser::RETURNS:
          case MySqlParser::REUSE:
          case MySqlParser::ROLE:
          case MySqlParser::ROLLBACK:
          case MySqlParser::ROLLUP:
          case MySqlParser::ROTATE:
          case MySqlParser::ROW:
          case MySqlParser::ROWS:
          case MySqlParser::ROW_FORMAT:
          case MySqlParser::RTREE:
          case MySqlParser::SAVEPOINT:
          case MySqlParser::SCHEDULE:
          case MySqlParser::SECURITY:
          case MySqlParser::SERVER:
          case MySqlParser::SESSION:
          case MySqlParser::SHARE:
          case MySqlParser::SHARED:
          case MySqlParser::SIGNED:
          case MySqlParser::SIMPLE:
          case MySqlParser::SLAVE:
          case MySqlParser::SLOW:
          case MySqlParser::SNAPSHOT:
          case MySqlParser::SOCKET:
          case MySqlParser::SOME:
          case MySqlParser::SONAME:
          case MySqlParser::SOUNDS:
          case MySqlParser::SOURCE:
          case MySqlParser::SQL_AFTER_GTIDS:
          case MySqlParser::SQL_AFTER_MTS_GAPS:
          case MySqlParser::SQL_BEFORE_GTIDS:
          case MySqlParser::SQL_BUFFER_RESULT:
          case MySqlParser::SQL_CACHE:
          case MySqlParser::SQL_NO_CACHE:
          case MySqlParser::SQL_THREAD:
          case MySqlParser::START:
          case MySqlParser::STARTS:
          case MySqlParser::STATS_AUTO_RECALC:
          case MySqlParser::STATS_PERSISTENT:
          case MySqlParser::STATS_SAMPLE_PAGES:
          case MySqlParser::STATUS:
          case MySqlParser::STOP:
          case MySqlParser::STORAGE:
          case MySqlParser::STRING:
          case MySqlParser::SUBCLASS_ORIGIN:
          case MySqlParser::SUBJECT:
          case MySqlParser::SUBPARTITION:
          case MySqlParser::SUBPARTITIONS:
          case MySqlParser::SUSPEND:
          case MySqlParser::SWAPS:
          case MySqlParser::SWITCHES:
          case MySqlParser::TABLE_NAME:
          case MySqlParser::TABLESPACE:
          case MySqlParser::TABLE_TYPE:
          case MySqlParser::TEMPORARY:
          case MySqlParser::TEMPTABLE:
          case MySqlParser::THAN:
          case MySqlParser::TRADITIONAL:
          case MySqlParser::TRANSACTION:
          case MySqlParser::TRANSACTIONAL:
          case MySqlParser::TRIGGERS:
          case MySqlParser::TRUNCATE:
          case MySqlParser::UNBOUNDED:
          case MySqlParser::UNDEFINED:
          case MySqlParser::UNDOFILE:
          case MySqlParser::UNDO_BUFFER_SIZE:
          case MySqlParser::UNINSTALL:
          case MySqlParser::UNKNOWN:
          case MySqlParser::UNTIL:
          case MySqlParser::UPGRADE:
          case MySqlParser::USER:
          case MySqlParser::USE_FRM:
          case MySqlParser::USER_RESOURCES:
          case MySqlParser::VALIDATION:
          case MySqlParser::VALUE:
          case MySqlParser::VARIABLES:
          case MySqlParser::VIEW:
          case MySqlParser::VIRTUAL:
          case MySqlParser::VISIBLE:
          case MySqlParser::WAIT:
          case MySqlParser::WARNINGS:
          case MySqlParser::WITHOUT:
          case MySqlParser::WORK:
          case MySqlParser::WRAPPER:
          case MySqlParser::X509:
          case MySqlParser::XA:
          case MySqlParser::XML:
          case MySqlParser::EUR:
          case MySqlParser::USA:
          case MySqlParser::JIS:
          case MySqlParser::ISO:
          case MySqlParser::INTERNAL:
          case MySqlParser::QUARTER:
          case MySqlParser::MONTH:
          case MySqlParser::DAY:
          case MySqlParser::HOUR:
          case MySqlParser::MINUTE:
          case MySqlParser::WEEK:
          case MySqlParser::SECOND:
          case MySqlParser::MICROSECOND:
          case MySqlParser::ADMIN:
          case MySqlParser::AUDIT_ABORT_EXEMPT:
          case MySqlParser::AUDIT_ADMIN:
          case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
          case MySqlParser::BACKUP_ADMIN:
          case MySqlParser::BINLOG_ADMIN:
          case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
          case MySqlParser::CLONE_ADMIN:
          case MySqlParser::CONNECTION_ADMIN:
          case MySqlParser::ENCRYPTION_KEY_ADMIN:
          case MySqlParser::EXECUTE:
          case MySqlParser::FILE:
          case MySqlParser::FIREWALL_ADMIN:
          case MySqlParser::FIREWALL_EXEMPT:
          case MySqlParser::FIREWALL_USER:
          case MySqlParser::GROUP_REPLICATION_ADMIN:
          case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
          case MySqlParser::INVOKE:
          case MySqlParser::LAMBDA:
          case MySqlParser::NDB_STORED_USER:
          case MySqlParser::PASSWORDLESS_USER_ADMIN:
          case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
          case MySqlParser::PRIVILEGES:
          case MySqlParser::PROCESS:
          case MySqlParser::RELOAD:
          case MySqlParser::REPLICATION_APPLIER:
          case MySqlParser::REPLICATION_SLAVE_ADMIN:
          case MySqlParser::RESOURCE_GROUP_ADMIN:
          case MySqlParser::RESOURCE_GROUP_USER:
          case MySqlParser::ROLE_ADMIN:
          case MySqlParser::ROUTINE:
          case MySqlParser::S3:
          case MySqlParser::SESSION_VARIABLES_ADMIN:
          case MySqlParser::SET_USER_ID:
          case MySqlParser::SHOW_ROUTINE:
          case MySqlParser::SHUTDOWN:
          case MySqlParser::SUPER:
          case MySqlParser::SYSTEM_VARIABLES_ADMIN:
          case MySqlParser::TABLES:
          case MySqlParser::TABLE_ENCRYPTION_ADMIN:
          case MySqlParser::VERSION_TOKEN_ADMIN:
          case MySqlParser::XA_RECOVER_ADMIN:
          case MySqlParser::ARMSCII8:
          case MySqlParser::ASCII:
          case MySqlParser::BIG5:
          case MySqlParser::CP1250:
          case MySqlParser::CP1251:
          case MySqlParser::CP1256:
          case MySqlParser::CP1257:
          case MySqlParser::CP850:
          case MySqlParser::CP852:
          case MySqlParser::CP866:
          case MySqlParser::CP932:
          case MySqlParser::DEC8:
          case MySqlParser::EUCJPMS:
          case MySqlParser::EUCKR:
          case MySqlParser::GB18030:
          case MySqlParser::GB2312:
          case MySqlParser::GBK:
          case MySqlParser::GEOSTD8:
          case MySqlParser::GREEK:
          case MySqlParser::HEBREW:
          case MySqlParser::HP8:
          case MySqlParser::KEYBCS2:
          case MySqlParser::KOI8R:
          case MySqlParser::KOI8U:
          case MySqlParser::LATIN1:
          case MySqlParser::LATIN2:
          case MySqlParser::LATIN5:
          case MySqlParser::LATIN7:
          case MySqlParser::MACCE:
          case MySqlParser::MACROMAN:
          case MySqlParser::SJIS:
          case MySqlParser::SWE7:
          case MySqlParser::TIS620:
          case MySqlParser::UCS2:
          case MySqlParser::UJIS:
          case MySqlParser::UTF16:
          case MySqlParser::UTF16LE:
          case MySqlParser::UTF32:
          case MySqlParser::UTF8:
          case MySqlParser::UTF8MB3:
          case MySqlParser::UTF8MB4:
          case MySqlParser::ARCHIVE:
          case MySqlParser::BLACKHOLE:
          case MySqlParser::CSV:
          case MySqlParser::FEDERATED:
          case MySqlParser::INNODB:
          case MySqlParser::MEMORY:
          case MySqlParser::MRG_MYISAM:
          case MySqlParser::MYISAM:
          case MySqlParser::NDB:
          case MySqlParser::NDBCLUSTER:
          case MySqlParser::PERFORMANCE_SCHEMA:
          case MySqlParser::TOKUDB:
          case MySqlParser::REPEATABLE:
          case MySqlParser::COMMITTED:
          case MySqlParser::UNCOMMITTED:
          case MySqlParser::SERIALIZABLE:
          case MySqlParser::GEOMETRYCOLLECTION:
          case MySqlParser::LINESTRING:
          case MySqlParser::MULTILINESTRING:
          case MySqlParser::MULTIPOINT:
          case MySqlParser::MULTIPOLYGON:
          case MySqlParser::POINT:
          case MySqlParser::POLYGON:
          case MySqlParser::ABS:
          case MySqlParser::ACOS:
          case MySqlParser::ADDDATE:
          case MySqlParser::ADDTIME:
          case MySqlParser::AES_DECRYPT:
          case MySqlParser::AES_ENCRYPT:
          case MySqlParser::AREA:
          case MySqlParser::ASBINARY:
          case MySqlParser::ASIN:
          case MySqlParser::ASTEXT:
          case MySqlParser::ASWKB:
          case MySqlParser::ASWKT:
          case MySqlParser::ASYMMETRIC_DECRYPT:
          case MySqlParser::ASYMMETRIC_DERIVE:
          case MySqlParser::ASYMMETRIC_ENCRYPT:
          case MySqlParser::ASYMMETRIC_SIGN:
          case MySqlParser::ASYMMETRIC_VERIFY:
          case MySqlParser::ATAN:
          case MySqlParser::ATAN2:
          case MySqlParser::BENCHMARK:
          case MySqlParser::BIN:
          case MySqlParser::BIT_COUNT:
          case MySqlParser::BIT_LENGTH:
          case MySqlParser::BUFFER:
          case MySqlParser::CATALOG_NAME:
          case MySqlParser::CEIL:
          case MySqlParser::CEILING:
          case MySqlParser::CENTROID:
          case MySqlParser::CHARACTER_LENGTH:
          case MySqlParser::CHARSET:
          case MySqlParser::CHAR_LENGTH:
          case MySqlParser::COERCIBILITY:
          case MySqlParser::COLLATION:
          case MySqlParser::COMPRESS:
          case MySqlParser::CONCAT:
          case MySqlParser::CONCAT_WS:
          case MySqlParser::CONNECTION_ID:
          case MySqlParser::CONV:
          case MySqlParser::CONVERT_TZ:
          case MySqlParser::COS:
          case MySqlParser::COT:
          case MySqlParser::CRC32:
          case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
          case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
          case MySqlParser::CREATE_DH_PARAMETERS:
          case MySqlParser::CREATE_DIGEST:
          case MySqlParser::CROSSES:
          case MySqlParser::DATEDIFF:
          case MySqlParser::DATE_FORMAT:
          case MySqlParser::DAYNAME:
          case MySqlParser::DAYOFMONTH:
          case MySqlParser::DAYOFWEEK:
          case MySqlParser::DAYOFYEAR:
          case MySqlParser::DECODE:
          case MySqlParser::DEGREES:
          case MySqlParser::DES_DECRYPT:
          case MySqlParser::DES_ENCRYPT:
          case MySqlParser::DIMENSION:
          case MySqlParser::DISJOINT:
          case MySqlParser::ELT:
          case MySqlParser::ENCODE:
          case MySqlParser::ENCRYPT:
          case MySqlParser::ENDPOINT:
          case MySqlParser::ENGINE_ATTRIBUTE:
          case MySqlParser::ENVELOPE:
          case MySqlParser::EQUALS:
          case MySqlParser::EXP:
          case MySqlParser::EXPORT_SET:
          case MySqlParser::EXTERIORRING:
          case MySqlParser::EXTRACTVALUE:
          case MySqlParser::FIELD:
          case MySqlParser::FIND_IN_SET:
          case MySqlParser::FLOOR:
          case MySqlParser::FORMAT:
          case MySqlParser::FOUND_ROWS:
          case MySqlParser::FROM_BASE64:
          case MySqlParser::FROM_DAYS:
          case MySqlParser::FROM_UNIXTIME:
          case MySqlParser::GEOMCOLLFROMTEXT:
          case MySqlParser::GEOMCOLLFROMWKB:
          case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::GEOMETRYFROMTEXT:
          case MySqlParser::GEOMETRYFROMWKB:
          case MySqlParser::GEOMETRYN:
          case MySqlParser::GEOMETRYTYPE:
          case MySqlParser::GEOMFROMTEXT:
          case MySqlParser::GEOMFROMWKB:
          case MySqlParser::GET_FORMAT:
          case MySqlParser::GET_LOCK:
          case MySqlParser::GLENGTH:
          case MySqlParser::GREATEST:
          case MySqlParser::GTID_SUBSET:
          case MySqlParser::GTID_SUBTRACT:
          case MySqlParser::HEX:
          case MySqlParser::IFNULL:
          case MySqlParser::INET6_ATON:
          case MySqlParser::INET6_NTOA:
          case MySqlParser::INET_ATON:
          case MySqlParser::INET_NTOA:
          case MySqlParser::INSTR:
          case MySqlParser::INTERIORRINGN:
          case MySqlParser::INTERSECTS:
          case MySqlParser::ISCLOSED:
          case MySqlParser::ISEMPTY:
          case MySqlParser::ISNULL:
          case MySqlParser::ISSIMPLE:
          case MySqlParser::IS_FREE_LOCK:
          case MySqlParser::IS_IPV4:
          case MySqlParser::IS_IPV4_COMPAT:
          case MySqlParser::IS_IPV4_MAPPED:
          case MySqlParser::IS_IPV6:
          case MySqlParser::IS_USED_LOCK:
          case MySqlParser::LAST_INSERT_ID:
          case MySqlParser::LCASE:
          case MySqlParser::LEAST:
          case MySqlParser::LENGTH:
          case MySqlParser::LINEFROMTEXT:
          case MySqlParser::LINEFROMWKB:
          case MySqlParser::LINESTRINGFROMTEXT:
          case MySqlParser::LINESTRINGFROMWKB:
          case MySqlParser::LN:
          case MySqlParser::LOAD_FILE:
          case MySqlParser::LOCATE:
          case MySqlParser::LOG:
          case MySqlParser::LOG10:
          case MySqlParser::LOG2:
          case MySqlParser::LOWER:
          case MySqlParser::LPAD:
          case MySqlParser::LTRIM:
          case MySqlParser::MAKEDATE:
          case MySqlParser::MAKETIME:
          case MySqlParser::MAKE_SET:
          case MySqlParser::MASTER_POS_WAIT:
          case MySqlParser::MBRCONTAINS:
          case MySqlParser::MBRDISJOINT:
          case MySqlParser::MBREQUAL:
          case MySqlParser::MBRINTERSECTS:
          case MySqlParser::MBROVERLAPS:
          case MySqlParser::MBRTOUCHES:
          case MySqlParser::MBRWITHIN:
          case MySqlParser::MD5:
          case MySqlParser::MLINEFROMTEXT:
          case MySqlParser::MLINEFROMWKB:
          case MySqlParser::MONTHNAME:
          case MySqlParser::MPOINTFROMTEXT:
          case MySqlParser::MPOINTFROMWKB:
          case MySqlParser::MPOLYFROMTEXT:
          case MySqlParser::MPOLYFROMWKB:
          case MySqlParser::MULTILINESTRINGFROMTEXT:
          case MySqlParser::MULTILINESTRINGFROMWKB:
          case MySqlParser::MULTIPOINTFROMTEXT:
          case MySqlParser::MULTIPOINTFROMWKB:
          case MySqlParser::MULTIPOLYGONFROMTEXT:
          case MySqlParser::MULTIPOLYGONFROMWKB:
          case MySqlParser::NAME_CONST:
          case MySqlParser::NULLIF:
          case MySqlParser::NUMGEOMETRIES:
          case MySqlParser::NUMINTERIORRINGS:
          case MySqlParser::NUMPOINTS:
          case MySqlParser::OCT:
          case MySqlParser::OCTET_LENGTH:
          case MySqlParser::ORD:
          case MySqlParser::OVERLAPS:
          case MySqlParser::PERIOD_ADD:
          case MySqlParser::PERIOD_DIFF:
          case MySqlParser::PI:
          case MySqlParser::POINTFROMTEXT:
          case MySqlParser::POINTFROMWKB:
          case MySqlParser::POINTN:
          case MySqlParser::POLYFROMTEXT:
          case MySqlParser::POLYFROMWKB:
          case MySqlParser::POLYGONFROMTEXT:
          case MySqlParser::POLYGONFROMWKB:
          case MySqlParser::POW:
          case MySqlParser::POWER:
          case MySqlParser::QUOTE:
          case MySqlParser::RADIANS:
          case MySqlParser::RAND:
          case MySqlParser::RANDOM_BYTES:
          case MySqlParser::RELEASE_LOCK:
          case MySqlParser::REVERSE:
          case MySqlParser::ROUND:
          case MySqlParser::ROW_COUNT:
          case MySqlParser::RPAD:
          case MySqlParser::RTRIM:
          case MySqlParser::SEC_TO_TIME:
          case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
          case MySqlParser::SESSION_USER:
          case MySqlParser::SHA:
          case MySqlParser::SHA1:
          case MySqlParser::SHA2:
          case MySqlParser::SCHEMA_NAME:
          case MySqlParser::SIGN:
          case MySqlParser::SIN:
          case MySqlParser::SLEEP:
          case MySqlParser::SOUNDEX:
          case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
          case MySqlParser::SQRT:
          case MySqlParser::SRID:
          case MySqlParser::STARTPOINT:
          case MySqlParser::STRCMP:
          case MySqlParser::STR_TO_DATE:
          case MySqlParser::ST_AREA:
          case MySqlParser::ST_ASBINARY:
          case MySqlParser::ST_ASTEXT:
          case MySqlParser::ST_ASWKB:
          case MySqlParser::ST_ASWKT:
          case MySqlParser::ST_BUFFER:
          case MySqlParser::ST_CENTROID:
          case MySqlParser::ST_CONTAINS:
          case MySqlParser::ST_CROSSES:
          case MySqlParser::ST_DIFFERENCE:
          case MySqlParser::ST_DIMENSION:
          case MySqlParser::ST_DISJOINT:
          case MySqlParser::ST_DISTANCE:
          case MySqlParser::ST_ENDPOINT:
          case MySqlParser::ST_ENVELOPE:
          case MySqlParser::ST_EQUALS:
          case MySqlParser::ST_EXTERIORRING:
          case MySqlParser::ST_GEOMCOLLFROMTEXT:
          case MySqlParser::ST_GEOMCOLLFROMTXT:
          case MySqlParser::ST_GEOMCOLLFROMWKB:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::ST_GEOMETRYFROMTEXT:
          case MySqlParser::ST_GEOMETRYFROMWKB:
          case MySqlParser::ST_GEOMETRYN:
          case MySqlParser::ST_GEOMETRYTYPE:
          case MySqlParser::ST_GEOMFROMTEXT:
          case MySqlParser::ST_GEOMFROMWKB:
          case MySqlParser::ST_INTERIORRINGN:
          case MySqlParser::ST_INTERSECTION:
          case MySqlParser::ST_INTERSECTS:
          case MySqlParser::ST_ISCLOSED:
          case MySqlParser::ST_ISEMPTY:
          case MySqlParser::ST_ISSIMPLE:
          case MySqlParser::ST_LINEFROMTEXT:
          case MySqlParser::ST_LINEFROMWKB:
          case MySqlParser::ST_LINESTRINGFROMTEXT:
          case MySqlParser::ST_LINESTRINGFROMWKB:
          case MySqlParser::ST_NUMGEOMETRIES:
          case MySqlParser::ST_NUMINTERIORRING:
          case MySqlParser::ST_NUMINTERIORRINGS:
          case MySqlParser::ST_NUMPOINTS:
          case MySqlParser::ST_OVERLAPS:
          case MySqlParser::ST_POINTFROMTEXT:
          case MySqlParser::ST_POINTFROMWKB:
          case MySqlParser::ST_POINTN:
          case MySqlParser::ST_POLYFROMTEXT:
          case MySqlParser::ST_POLYFROMWKB:
          case MySqlParser::ST_POLYGONFROMTEXT:
          case MySqlParser::ST_POLYGONFROMWKB:
          case MySqlParser::ST_SRID:
          case MySqlParser::ST_STARTPOINT:
          case MySqlParser::ST_SYMDIFFERENCE:
          case MySqlParser::ST_TOUCHES:
          case MySqlParser::ST_UNION:
          case MySqlParser::ST_WITHIN:
          case MySqlParser::ST_X:
          case MySqlParser::ST_Y:
          case MySqlParser::SUBDATE:
          case MySqlParser::SUBSTRING_INDEX:
          case MySqlParser::SUBTIME:
          case MySqlParser::SYSTEM_USER:
          case MySqlParser::TAN:
          case MySqlParser::TIMEDIFF:
          case MySqlParser::TIMESTAMPADD:
          case MySqlParser::TIMESTAMPDIFF:
          case MySqlParser::TIME_FORMAT:
          case MySqlParser::TIME_TO_SEC:
          case MySqlParser::TOUCHES:
          case MySqlParser::TO_BASE64:
          case MySqlParser::TO_DAYS:
          case MySqlParser::TO_SECONDS:
          case MySqlParser::TP_CONNECTION_ADMIN:
          case MySqlParser::UCASE:
          case MySqlParser::UNCOMPRESS:
          case MySqlParser::UNCOMPRESSED_LENGTH:
          case MySqlParser::UNHEX:
          case MySqlParser::UNIX_TIMESTAMP:
          case MySqlParser::UPDATEXML:
          case MySqlParser::UPPER:
          case MySqlParser::UUID:
          case MySqlParser::UUID_SHORT:
          case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
          case MySqlParser::VERSION:
          case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
          case MySqlParser::WEEKDAY:
          case MySqlParser::WEEKOFYEAR:
          case MySqlParser::WEIGHT_STRING:
          case MySqlParser::WITHIN:
          case MySqlParser::YEARWEEK:
          case MySqlParser::Y_FUNCTION:
          case MySqlParser::X_FUNCTION:
          case MySqlParser::MOD:
          case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
          case MySqlParser::STRING_LITERAL:
          case MySqlParser::ID: {
            setState(2950);
            uidList();
            break;
          }

          case MySqlParser::ALL: {
            setState(2951);
            match(MySqlParser::ALL);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySqlParser::REPAIR: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByRepairPartitionContext>(_localctx);
        enterOuterAlt(_localctx, 13);
        setState(2954);
        match(MySqlParser::REPAIR);
        setState(2955);
        match(MySqlParser::PARTITION);
        setState(2958);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::ATTRIBUTE:
          case MySqlParser::BUCKETS:
          case MySqlParser::CONDITION:
          case MySqlParser::CURRENT:
          case MySqlParser::CURRENT_USER:
          case MySqlParser::DATABASE:
          case MySqlParser::DEFAULT:
          case MySqlParser::DIAGNOSTICS:
          case MySqlParser::EMPTY:
          case MySqlParser::ENFORCED:
          case MySqlParser::EXCEPT:
          case MySqlParser::GROUP:
          case MySqlParser::IF:
          case MySqlParser::IGNORED:
          case MySqlParser::INSERT:
          case MySqlParser::LATERAL:
          case MySqlParser::LEFT:
          case MySqlParser::NUMBER:
          case MySqlParser::OPTIONAL:
          case MySqlParser::ORDER:
          case MySqlParser::PRIMARY:
          case MySqlParser::REPLACE:
          case MySqlParser::RIGHT:
          case MySqlParser::SCHEMA:
          case MySqlParser::SKIP_QUERY_REWRITE:
          case MySqlParser::STACKED:
          case MySqlParser::DATE:
          case MySqlParser::TIME:
          case MySqlParser::TIMESTAMP:
          case MySqlParser::DATETIME:
          case MySqlParser::YEAR:
          case MySqlParser::BINARY:
          case MySqlParser::TEXT:
          case MySqlParser::ENUM:
          case MySqlParser::SERIAL:
          case MySqlParser::JSON_ARRAY:
          case MySqlParser::JSON_ARRAYAGG:
          case MySqlParser::JSON_ARRAY_APPEND:
          case MySqlParser::JSON_ARRAY_INSERT:
          case MySqlParser::JSON_CONTAINS:
          case MySqlParser::JSON_CONTAINS_PATH:
          case MySqlParser::JSON_DEPTH:
          case MySqlParser::JSON_EXTRACT:
          case MySqlParser::JSON_INSERT:
          case MySqlParser::JSON_KEYS:
          case MySqlParser::JSON_LENGTH:
          case MySqlParser::JSON_MERGE:
          case MySqlParser::JSON_MERGE_PATCH:
          case MySqlParser::JSON_MERGE_PRESERVE:
          case MySqlParser::JSON_OBJECT:
          case MySqlParser::JSON_OBJECTAGG:
          case MySqlParser::JSON_OVERLAPS:
          case MySqlParser::JSON_PRETTY:
          case MySqlParser::JSON_QUOTE:
          case MySqlParser::JSON_REMOVE:
          case MySqlParser::JSON_REPLACE:
          case MySqlParser::JSON_SCHEMA_VALID:
          case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
          case MySqlParser::JSON_SEARCH:
          case MySqlParser::JSON_SET:
          case MySqlParser::JSON_STORAGE_FREE:
          case MySqlParser::JSON_STORAGE_SIZE:
          case MySqlParser::JSON_TABLE:
          case MySqlParser::JSON_TYPE:
          case MySqlParser::JSON_UNQUOTE:
          case MySqlParser::JSON_VALID:
          case MySqlParser::JSON_VALUE:
          case MySqlParser::NESTED:
          case MySqlParser::ORDINALITY:
          case MySqlParser::PATH:
          case MySqlParser::AVG:
          case MySqlParser::BIT_AND:
          case MySqlParser::BIT_OR:
          case MySqlParser::BIT_XOR:
          case MySqlParser::COUNT:
          case MySqlParser::CUME_DIST:
          case MySqlParser::DENSE_RANK:
          case MySqlParser::FIRST_VALUE:
          case MySqlParser::GROUP_CONCAT:
          case MySqlParser::LAG:
          case MySqlParser::LAST_VALUE:
          case MySqlParser::LEAD:
          case MySqlParser::MAX:
          case MySqlParser::MIN:
          case MySqlParser::NTILE:
          case MySqlParser::NTH_VALUE:
          case MySqlParser::PERCENT_RANK:
          case MySqlParser::RANK:
          case MySqlParser::ROW_NUMBER:
          case MySqlParser::STD:
          case MySqlParser::STDDEV:
          case MySqlParser::STDDEV_POP:
          case MySqlParser::STDDEV_SAMP:
          case MySqlParser::SUM:
          case MySqlParser::VAR_POP:
          case MySqlParser::VAR_SAMP:
          case MySqlParser::VARIANCE:
          case MySqlParser::CURRENT_DATE:
          case MySqlParser::CURRENT_TIME:
          case MySqlParser::CURRENT_TIMESTAMP:
          case MySqlParser::LOCALTIME:
          case MySqlParser::CURDATE:
          case MySqlParser::CURTIME:
          case MySqlParser::DATE_ADD:
          case MySqlParser::DATE_SUB:
          case MySqlParser::LOCALTIMESTAMP:
          case MySqlParser::NOW:
          case MySqlParser::POSITION:
          case MySqlParser::SUBSTR:
          case MySqlParser::SUBSTRING:
          case MySqlParser::SYSDATE:
          case MySqlParser::TRIM:
          case MySqlParser::UTC_DATE:
          case MySqlParser::UTC_TIME:
          case MySqlParser::UTC_TIMESTAMP:
          case MySqlParser::ACCOUNT:
          case MySqlParser::ACTION:
          case MySqlParser::AFTER:
          case MySqlParser::AGGREGATE:
          case MySqlParser::ALGORITHM:
          case MySqlParser::ANY:
          case MySqlParser::AT:
          case MySqlParser::AUTHORS:
          case MySqlParser::AUTOCOMMIT:
          case MySqlParser::AUTOEXTEND_SIZE:
          case MySqlParser::AUTO_INCREMENT:
          case MySqlParser::AVG_ROW_LENGTH:
          case MySqlParser::BEGIN:
          case MySqlParser::BINLOG:
          case MySqlParser::BIT:
          case MySqlParser::BLOCK:
          case MySqlParser::BOOL:
          case MySqlParser::BOOLEAN:
          case MySqlParser::BTREE:
          case MySqlParser::CACHE:
          case MySqlParser::CASCADED:
          case MySqlParser::CHAIN:
          case MySqlParser::CHANGED:
          case MySqlParser::CHANNEL:
          case MySqlParser::CHECKSUM:
          case MySqlParser::PAGE_CHECKSUM:
          case MySqlParser::CIPHER:
          case MySqlParser::CLASS_ORIGIN:
          case MySqlParser::CLIENT:
          case MySqlParser::CLOSE:
          case MySqlParser::CLUSTERING:
          case MySqlParser::COALESCE:
          case MySqlParser::CODE:
          case MySqlParser::COLUMNS:
          case MySqlParser::COLUMN_FORMAT:
          case MySqlParser::COLUMN_NAME:
          case MySqlParser::COMMENT:
          case MySqlParser::COMMIT:
          case MySqlParser::COMPACT:
          case MySqlParser::COMPLETION:
          case MySqlParser::COMPRESSED:
          case MySqlParser::COMPRESSION:
          case MySqlParser::CONCURRENT:
          case MySqlParser::CONNECT:
          case MySqlParser::CONNECTION:
          case MySqlParser::CONSISTENT:
          case MySqlParser::CONSTRAINT_CATALOG:
          case MySqlParser::CONSTRAINT_SCHEMA:
          case MySqlParser::CONSTRAINT_NAME:
          case MySqlParser::CONTAINS:
          case MySqlParser::CONTEXT:
          case MySqlParser::CONTRIBUTORS:
          case MySqlParser::COPY:
          case MySqlParser::CPU:
          case MySqlParser::CURSOR_NAME:
          case MySqlParser::DATA:
          case MySqlParser::DATAFILE:
          case MySqlParser::DEALLOCATE:
          case MySqlParser::DEFAULT_AUTH:
          case MySqlParser::DEFINER:
          case MySqlParser::DELAY_KEY_WRITE:
          case MySqlParser::DES_KEY_FILE:
          case MySqlParser::DIRECTORY:
          case MySqlParser::DISABLE:
          case MySqlParser::DISCARD:
          case MySqlParser::DISK:
          case MySqlParser::DO:
          case MySqlParser::DUMPFILE:
          case MySqlParser::DUPLICATE:
          case MySqlParser::DYNAMIC:
          case MySqlParser::ENABLE:
          case MySqlParser::ENCRYPTION:
          case MySqlParser::END:
          case MySqlParser::ENDS:
          case MySqlParser::ENGINE:
          case MySqlParser::ENGINES:
          case MySqlParser::ERROR:
          case MySqlParser::ERRORS:
          case MySqlParser::ESCAPE:
          case MySqlParser::EVEN:
          case MySqlParser::EVENT:
          case MySqlParser::EVENTS:
          case MySqlParser::EVERY:
          case MySqlParser::EXCHANGE:
          case MySqlParser::EXCLUSIVE:
          case MySqlParser::EXPIRE:
          case MySqlParser::EXPORT:
          case MySqlParser::EXTENDED:
          case MySqlParser::EXTENT_SIZE:
          case MySqlParser::FAILED_LOGIN_ATTEMPTS:
          case MySqlParser::FAST:
          case MySqlParser::FAULTS:
          case MySqlParser::FIELDS:
          case MySqlParser::FILE_BLOCK_SIZE:
          case MySqlParser::FILTER:
          case MySqlParser::FIRST:
          case MySqlParser::FIXED:
          case MySqlParser::FLUSH:
          case MySqlParser::FOLLOWS:
          case MySqlParser::FOUND:
          case MySqlParser::FULL:
          case MySqlParser::FUNCTION:
          case MySqlParser::GENERAL:
          case MySqlParser::GLOBAL:
          case MySqlParser::GRANTS:
          case MySqlParser::GROUP_REPLICATION:
          case MySqlParser::HANDLER:
          case MySqlParser::HASH:
          case MySqlParser::HELP:
          case MySqlParser::HISTORY:
          case MySqlParser::HOST:
          case MySqlParser::HOSTS:
          case MySqlParser::IDENTIFIED:
          case MySqlParser::IGNORE_SERVER_IDS:
          case MySqlParser::IMPORT:
          case MySqlParser::INDEXES:
          case MySqlParser::INITIAL_SIZE:
          case MySqlParser::INPLACE:
          case MySqlParser::INSERT_METHOD:
          case MySqlParser::INSTALL:
          case MySqlParser::INSTANCE:
          case MySqlParser::INSTANT:
          case MySqlParser::INVISIBLE:
          case MySqlParser::INVOKER:
          case MySqlParser::IO:
          case MySqlParser::IO_THREAD:
          case MySqlParser::IPC:
          case MySqlParser::ISOLATION:
          case MySqlParser::ISSUER:
          case MySqlParser::JSON:
          case MySqlParser::KEY_BLOCK_SIZE:
          case MySqlParser::LANGUAGE:
          case MySqlParser::LAST:
          case MySqlParser::LEAVES:
          case MySqlParser::LESS:
          case MySqlParser::LEVEL:
          case MySqlParser::LIST:
          case MySqlParser::LOCAL:
          case MySqlParser::LOGFILE:
          case MySqlParser::LOGS:
          case MySqlParser::MASTER:
          case MySqlParser::MASTER_AUTO_POSITION:
          case MySqlParser::MASTER_CONNECT_RETRY:
          case MySqlParser::MASTER_DELAY:
          case MySqlParser::MASTER_HEARTBEAT_PERIOD:
          case MySqlParser::MASTER_HOST:
          case MySqlParser::MASTER_LOG_FILE:
          case MySqlParser::MASTER_LOG_POS:
          case MySqlParser::MASTER_PASSWORD:
          case MySqlParser::MASTER_PORT:
          case MySqlParser::MASTER_RETRY_COUNT:
          case MySqlParser::MASTER_SSL:
          case MySqlParser::MASTER_SSL_CA:
          case MySqlParser::MASTER_SSL_CAPATH:
          case MySqlParser::MASTER_SSL_CERT:
          case MySqlParser::MASTER_SSL_CIPHER:
          case MySqlParser::MASTER_SSL_CRL:
          case MySqlParser::MASTER_SSL_CRLPATH:
          case MySqlParser::MASTER_SSL_KEY:
          case MySqlParser::MASTER_TLS_VERSION:
          case MySqlParser::MASTER_USER:
          case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
          case MySqlParser::MAX_QUERIES_PER_HOUR:
          case MySqlParser::MAX_ROWS:
          case MySqlParser::MAX_SIZE:
          case MySqlParser::MAX_UPDATES_PER_HOUR:
          case MySqlParser::MAX_USER_CONNECTIONS:
          case MySqlParser::MEDIUM:
          case MySqlParser::MEMBER:
          case MySqlParser::MERGE:
          case MySqlParser::MESSAGE_TEXT:
          case MySqlParser::MID:
          case MySqlParser::MIGRATE:
          case MySqlParser::MIN_ROWS:
          case MySqlParser::MODE:
          case MySqlParser::MODIFY:
          case MySqlParser::MUTEX:
          case MySqlParser::MYSQL:
          case MySqlParser::MYSQL_ERRNO:
          case MySqlParser::NAME:
          case MySqlParser::NAMES:
          case MySqlParser::NCHAR:
          case MySqlParser::NEVER:
          case MySqlParser::NEXT:
          case MySqlParser::NO:
          case MySqlParser::NOCOPY:
          case MySqlParser::NOWAIT:
          case MySqlParser::NODEGROUP:
          case MySqlParser::NONE:
          case MySqlParser::ODBC:
          case MySqlParser::OFFLINE:
          case MySqlParser::OFFSET:
          case MySqlParser::OF:
          case MySqlParser::OJ:
          case MySqlParser::OLD_PASSWORD:
          case MySqlParser::ONE:
          case MySqlParser::ONLINE:
          case MySqlParser::ONLY:
          case MySqlParser::OPEN:
          case MySqlParser::OPTIMIZER_COSTS:
          case MySqlParser::OPTIONS:
          case MySqlParser::OWNER:
          case MySqlParser::PACK_KEYS:
          case MySqlParser::PAGE:
          case MySqlParser::PARSER:
          case MySqlParser::PARTIAL:
          case MySqlParser::PARTITIONING:
          case MySqlParser::PARTITIONS:
          case MySqlParser::PASSWORD:
          case MySqlParser::PASSWORD_LOCK_TIME:
          case MySqlParser::PHASE:
          case MySqlParser::PLUGIN:
          case MySqlParser::PLUGIN_DIR:
          case MySqlParser::PLUGINS:
          case MySqlParser::PORT:
          case MySqlParser::PRECEDES:
          case MySqlParser::PREPARE:
          case MySqlParser::PRESERVE:
          case MySqlParser::PREV:
          case MySqlParser::PROCESSLIST:
          case MySqlParser::PROFILE:
          case MySqlParser::PROFILES:
          case MySqlParser::PROXY:
          case MySqlParser::QUERY:
          case MySqlParser::QUICK:
          case MySqlParser::REBUILD:
          case MySqlParser::RECOVER:
          case MySqlParser::RECURSIVE:
          case MySqlParser::REDO_BUFFER_SIZE:
          case MySqlParser::REDUNDANT:
          case MySqlParser::RELAY:
          case MySqlParser::RELAY_LOG_FILE:
          case MySqlParser::RELAY_LOG_POS:
          case MySqlParser::RELAYLOG:
          case MySqlParser::REMOVE:
          case MySqlParser::REORGANIZE:
          case MySqlParser::REPAIR:
          case MySqlParser::REPLICATE_DO_DB:
          case MySqlParser::REPLICATE_DO_TABLE:
          case MySqlParser::REPLICATE_IGNORE_DB:
          case MySqlParser::REPLICATE_IGNORE_TABLE:
          case MySqlParser::REPLICATE_REWRITE_DB:
          case MySqlParser::REPLICATE_WILD_DO_TABLE:
          case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
          case MySqlParser::REPLICATION:
          case MySqlParser::RESET:
          case MySqlParser::RESUME:
          case MySqlParser::RETURNED_SQLSTATE:
          case MySqlParser::RETURNS:
          case MySqlParser::REUSE:
          case MySqlParser::ROLE:
          case MySqlParser::ROLLBACK:
          case MySqlParser::ROLLUP:
          case MySqlParser::ROTATE:
          case MySqlParser::ROW:
          case MySqlParser::ROWS:
          case MySqlParser::ROW_FORMAT:
          case MySqlParser::RTREE:
          case MySqlParser::SAVEPOINT:
          case MySqlParser::SCHEDULE:
          case MySqlParser::SECURITY:
          case MySqlParser::SERVER:
          case MySqlParser::SESSION:
          case MySqlParser::SHARE:
          case MySqlParser::SHARED:
          case MySqlParser::SIGNED:
          case MySqlParser::SIMPLE:
          case MySqlParser::SLAVE:
          case MySqlParser::SLOW:
          case MySqlParser::SNAPSHOT:
          case MySqlParser::SOCKET:
          case MySqlParser::SOME:
          case MySqlParser::SONAME:
          case MySqlParser::SOUNDS:
          case MySqlParser::SOURCE:
          case MySqlParser::SQL_AFTER_GTIDS:
          case MySqlParser::SQL_AFTER_MTS_GAPS:
          case MySqlParser::SQL_BEFORE_GTIDS:
          case MySqlParser::SQL_BUFFER_RESULT:
          case MySqlParser::SQL_CACHE:
          case MySqlParser::SQL_NO_CACHE:
          case MySqlParser::SQL_THREAD:
          case MySqlParser::START:
          case MySqlParser::STARTS:
          case MySqlParser::STATS_AUTO_RECALC:
          case MySqlParser::STATS_PERSISTENT:
          case MySqlParser::STATS_SAMPLE_PAGES:
          case MySqlParser::STATUS:
          case MySqlParser::STOP:
          case MySqlParser::STORAGE:
          case MySqlParser::STRING:
          case MySqlParser::SUBCLASS_ORIGIN:
          case MySqlParser::SUBJECT:
          case MySqlParser::SUBPARTITION:
          case MySqlParser::SUBPARTITIONS:
          case MySqlParser::SUSPEND:
          case MySqlParser::SWAPS:
          case MySqlParser::SWITCHES:
          case MySqlParser::TABLE_NAME:
          case MySqlParser::TABLESPACE:
          case MySqlParser::TABLE_TYPE:
          case MySqlParser::TEMPORARY:
          case MySqlParser::TEMPTABLE:
          case MySqlParser::THAN:
          case MySqlParser::TRADITIONAL:
          case MySqlParser::TRANSACTION:
          case MySqlParser::TRANSACTIONAL:
          case MySqlParser::TRIGGERS:
          case MySqlParser::TRUNCATE:
          case MySqlParser::UNBOUNDED:
          case MySqlParser::UNDEFINED:
          case MySqlParser::UNDOFILE:
          case MySqlParser::UNDO_BUFFER_SIZE:
          case MySqlParser::UNINSTALL:
          case MySqlParser::UNKNOWN:
          case MySqlParser::UNTIL:
          case MySqlParser::UPGRADE:
          case MySqlParser::USER:
          case MySqlParser::USE_FRM:
          case MySqlParser::USER_RESOURCES:
          case MySqlParser::VALIDATION:
          case MySqlParser::VALUE:
          case MySqlParser::VARIABLES:
          case MySqlParser::VIEW:
          case MySqlParser::VIRTUAL:
          case MySqlParser::VISIBLE:
          case MySqlParser::WAIT:
          case MySqlParser::WARNINGS:
          case MySqlParser::WITHOUT:
          case MySqlParser::WORK:
          case MySqlParser::WRAPPER:
          case MySqlParser::X509:
          case MySqlParser::XA:
          case MySqlParser::XML:
          case MySqlParser::EUR:
          case MySqlParser::USA:
          case MySqlParser::JIS:
          case MySqlParser::ISO:
          case MySqlParser::INTERNAL:
          case MySqlParser::QUARTER:
          case MySqlParser::MONTH:
          case MySqlParser::DAY:
          case MySqlParser::HOUR:
          case MySqlParser::MINUTE:
          case MySqlParser::WEEK:
          case MySqlParser::SECOND:
          case MySqlParser::MICROSECOND:
          case MySqlParser::ADMIN:
          case MySqlParser::AUDIT_ABORT_EXEMPT:
          case MySqlParser::AUDIT_ADMIN:
          case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
          case MySqlParser::BACKUP_ADMIN:
          case MySqlParser::BINLOG_ADMIN:
          case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
          case MySqlParser::CLONE_ADMIN:
          case MySqlParser::CONNECTION_ADMIN:
          case MySqlParser::ENCRYPTION_KEY_ADMIN:
          case MySqlParser::EXECUTE:
          case MySqlParser::FILE:
          case MySqlParser::FIREWALL_ADMIN:
          case MySqlParser::FIREWALL_EXEMPT:
          case MySqlParser::FIREWALL_USER:
          case MySqlParser::GROUP_REPLICATION_ADMIN:
          case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
          case MySqlParser::INVOKE:
          case MySqlParser::LAMBDA:
          case MySqlParser::NDB_STORED_USER:
          case MySqlParser::PASSWORDLESS_USER_ADMIN:
          case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
          case MySqlParser::PRIVILEGES:
          case MySqlParser::PROCESS:
          case MySqlParser::RELOAD:
          case MySqlParser::REPLICATION_APPLIER:
          case MySqlParser::REPLICATION_SLAVE_ADMIN:
          case MySqlParser::RESOURCE_GROUP_ADMIN:
          case MySqlParser::RESOURCE_GROUP_USER:
          case MySqlParser::ROLE_ADMIN:
          case MySqlParser::ROUTINE:
          case MySqlParser::S3:
          case MySqlParser::SESSION_VARIABLES_ADMIN:
          case MySqlParser::SET_USER_ID:
          case MySqlParser::SHOW_ROUTINE:
          case MySqlParser::SHUTDOWN:
          case MySqlParser::SUPER:
          case MySqlParser::SYSTEM_VARIABLES_ADMIN:
          case MySqlParser::TABLES:
          case MySqlParser::TABLE_ENCRYPTION_ADMIN:
          case MySqlParser::VERSION_TOKEN_ADMIN:
          case MySqlParser::XA_RECOVER_ADMIN:
          case MySqlParser::ARMSCII8:
          case MySqlParser::ASCII:
          case MySqlParser::BIG5:
          case MySqlParser::CP1250:
          case MySqlParser::CP1251:
          case MySqlParser::CP1256:
          case MySqlParser::CP1257:
          case MySqlParser::CP850:
          case MySqlParser::CP852:
          case MySqlParser::CP866:
          case MySqlParser::CP932:
          case MySqlParser::DEC8:
          case MySqlParser::EUCJPMS:
          case MySqlParser::EUCKR:
          case MySqlParser::GB18030:
          case MySqlParser::GB2312:
          case MySqlParser::GBK:
          case MySqlParser::GEOSTD8:
          case MySqlParser::GREEK:
          case MySqlParser::HEBREW:
          case MySqlParser::HP8:
          case MySqlParser::KEYBCS2:
          case MySqlParser::KOI8R:
          case MySqlParser::KOI8U:
          case MySqlParser::LATIN1:
          case MySqlParser::LATIN2:
          case MySqlParser::LATIN5:
          case MySqlParser::LATIN7:
          case MySqlParser::MACCE:
          case MySqlParser::MACROMAN:
          case MySqlParser::SJIS:
          case MySqlParser::SWE7:
          case MySqlParser::TIS620:
          case MySqlParser::UCS2:
          case MySqlParser::UJIS:
          case MySqlParser::UTF16:
          case MySqlParser::UTF16LE:
          case MySqlParser::UTF32:
          case MySqlParser::UTF8:
          case MySqlParser::UTF8MB3:
          case MySqlParser::UTF8MB4:
          case MySqlParser::ARCHIVE:
          case MySqlParser::BLACKHOLE:
          case MySqlParser::CSV:
          case MySqlParser::FEDERATED:
          case MySqlParser::INNODB:
          case MySqlParser::MEMORY:
          case MySqlParser::MRG_MYISAM:
          case MySqlParser::MYISAM:
          case MySqlParser::NDB:
          case MySqlParser::NDBCLUSTER:
          case MySqlParser::PERFORMANCE_SCHEMA:
          case MySqlParser::TOKUDB:
          case MySqlParser::REPEATABLE:
          case MySqlParser::COMMITTED:
          case MySqlParser::UNCOMMITTED:
          case MySqlParser::SERIALIZABLE:
          case MySqlParser::GEOMETRYCOLLECTION:
          case MySqlParser::LINESTRING:
          case MySqlParser::MULTILINESTRING:
          case MySqlParser::MULTIPOINT:
          case MySqlParser::MULTIPOLYGON:
          case MySqlParser::POINT:
          case MySqlParser::POLYGON:
          case MySqlParser::ABS:
          case MySqlParser::ACOS:
          case MySqlParser::ADDDATE:
          case MySqlParser::ADDTIME:
          case MySqlParser::AES_DECRYPT:
          case MySqlParser::AES_ENCRYPT:
          case MySqlParser::AREA:
          case MySqlParser::ASBINARY:
          case MySqlParser::ASIN:
          case MySqlParser::ASTEXT:
          case MySqlParser::ASWKB:
          case MySqlParser::ASWKT:
          case MySqlParser::ASYMMETRIC_DECRYPT:
          case MySqlParser::ASYMMETRIC_DERIVE:
          case MySqlParser::ASYMMETRIC_ENCRYPT:
          case MySqlParser::ASYMMETRIC_SIGN:
          case MySqlParser::ASYMMETRIC_VERIFY:
          case MySqlParser::ATAN:
          case MySqlParser::ATAN2:
          case MySqlParser::BENCHMARK:
          case MySqlParser::BIN:
          case MySqlParser::BIT_COUNT:
          case MySqlParser::BIT_LENGTH:
          case MySqlParser::BUFFER:
          case MySqlParser::CATALOG_NAME:
          case MySqlParser::CEIL:
          case MySqlParser::CEILING:
          case MySqlParser::CENTROID:
          case MySqlParser::CHARACTER_LENGTH:
          case MySqlParser::CHARSET:
          case MySqlParser::CHAR_LENGTH:
          case MySqlParser::COERCIBILITY:
          case MySqlParser::COLLATION:
          case MySqlParser::COMPRESS:
          case MySqlParser::CONCAT:
          case MySqlParser::CONCAT_WS:
          case MySqlParser::CONNECTION_ID:
          case MySqlParser::CONV:
          case MySqlParser::CONVERT_TZ:
          case MySqlParser::COS:
          case MySqlParser::COT:
          case MySqlParser::CRC32:
          case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
          case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
          case MySqlParser::CREATE_DH_PARAMETERS:
          case MySqlParser::CREATE_DIGEST:
          case MySqlParser::CROSSES:
          case MySqlParser::DATEDIFF:
          case MySqlParser::DATE_FORMAT:
          case MySqlParser::DAYNAME:
          case MySqlParser::DAYOFMONTH:
          case MySqlParser::DAYOFWEEK:
          case MySqlParser::DAYOFYEAR:
          case MySqlParser::DECODE:
          case MySqlParser::DEGREES:
          case MySqlParser::DES_DECRYPT:
          case MySqlParser::DES_ENCRYPT:
          case MySqlParser::DIMENSION:
          case MySqlParser::DISJOINT:
          case MySqlParser::ELT:
          case MySqlParser::ENCODE:
          case MySqlParser::ENCRYPT:
          case MySqlParser::ENDPOINT:
          case MySqlParser::ENGINE_ATTRIBUTE:
          case MySqlParser::ENVELOPE:
          case MySqlParser::EQUALS:
          case MySqlParser::EXP:
          case MySqlParser::EXPORT_SET:
          case MySqlParser::EXTERIORRING:
          case MySqlParser::EXTRACTVALUE:
          case MySqlParser::FIELD:
          case MySqlParser::FIND_IN_SET:
          case MySqlParser::FLOOR:
          case MySqlParser::FORMAT:
          case MySqlParser::FOUND_ROWS:
          case MySqlParser::FROM_BASE64:
          case MySqlParser::FROM_DAYS:
          case MySqlParser::FROM_UNIXTIME:
          case MySqlParser::GEOMCOLLFROMTEXT:
          case MySqlParser::GEOMCOLLFROMWKB:
          case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::GEOMETRYFROMTEXT:
          case MySqlParser::GEOMETRYFROMWKB:
          case MySqlParser::GEOMETRYN:
          case MySqlParser::GEOMETRYTYPE:
          case MySqlParser::GEOMFROMTEXT:
          case MySqlParser::GEOMFROMWKB:
          case MySqlParser::GET_FORMAT:
          case MySqlParser::GET_LOCK:
          case MySqlParser::GLENGTH:
          case MySqlParser::GREATEST:
          case MySqlParser::GTID_SUBSET:
          case MySqlParser::GTID_SUBTRACT:
          case MySqlParser::HEX:
          case MySqlParser::IFNULL:
          case MySqlParser::INET6_ATON:
          case MySqlParser::INET6_NTOA:
          case MySqlParser::INET_ATON:
          case MySqlParser::INET_NTOA:
          case MySqlParser::INSTR:
          case MySqlParser::INTERIORRINGN:
          case MySqlParser::INTERSECTS:
          case MySqlParser::ISCLOSED:
          case MySqlParser::ISEMPTY:
          case MySqlParser::ISNULL:
          case MySqlParser::ISSIMPLE:
          case MySqlParser::IS_FREE_LOCK:
          case MySqlParser::IS_IPV4:
          case MySqlParser::IS_IPV4_COMPAT:
          case MySqlParser::IS_IPV4_MAPPED:
          case MySqlParser::IS_IPV6:
          case MySqlParser::IS_USED_LOCK:
          case MySqlParser::LAST_INSERT_ID:
          case MySqlParser::LCASE:
          case MySqlParser::LEAST:
          case MySqlParser::LENGTH:
          case MySqlParser::LINEFROMTEXT:
          case MySqlParser::LINEFROMWKB:
          case MySqlParser::LINESTRINGFROMTEXT:
          case MySqlParser::LINESTRINGFROMWKB:
          case MySqlParser::LN:
          case MySqlParser::LOAD_FILE:
          case MySqlParser::LOCATE:
          case MySqlParser::LOG:
          case MySqlParser::LOG10:
          case MySqlParser::LOG2:
          case MySqlParser::LOWER:
          case MySqlParser::LPAD:
          case MySqlParser::LTRIM:
          case MySqlParser::MAKEDATE:
          case MySqlParser::MAKETIME:
          case MySqlParser::MAKE_SET:
          case MySqlParser::MASTER_POS_WAIT:
          case MySqlParser::MBRCONTAINS:
          case MySqlParser::MBRDISJOINT:
          case MySqlParser::MBREQUAL:
          case MySqlParser::MBRINTERSECTS:
          case MySqlParser::MBROVERLAPS:
          case MySqlParser::MBRTOUCHES:
          case MySqlParser::MBRWITHIN:
          case MySqlParser::MD5:
          case MySqlParser::MLINEFROMTEXT:
          case MySqlParser::MLINEFROMWKB:
          case MySqlParser::MONTHNAME:
          case MySqlParser::MPOINTFROMTEXT:
          case MySqlParser::MPOINTFROMWKB:
          case MySqlParser::MPOLYFROMTEXT:
          case MySqlParser::MPOLYFROMWKB:
          case MySqlParser::MULTILINESTRINGFROMTEXT:
          case MySqlParser::MULTILINESTRINGFROMWKB:
          case MySqlParser::MULTIPOINTFROMTEXT:
          case MySqlParser::MULTIPOINTFROMWKB:
          case MySqlParser::MULTIPOLYGONFROMTEXT:
          case MySqlParser::MULTIPOLYGONFROMWKB:
          case MySqlParser::NAME_CONST:
          case MySqlParser::NULLIF:
          case MySqlParser::NUMGEOMETRIES:
          case MySqlParser::NUMINTERIORRINGS:
          case MySqlParser::NUMPOINTS:
          case MySqlParser::OCT:
          case MySqlParser::OCTET_LENGTH:
          case MySqlParser::ORD:
          case MySqlParser::OVERLAPS:
          case MySqlParser::PERIOD_ADD:
          case MySqlParser::PERIOD_DIFF:
          case MySqlParser::PI:
          case MySqlParser::POINTFROMTEXT:
          case MySqlParser::POINTFROMWKB:
          case MySqlParser::POINTN:
          case MySqlParser::POLYFROMTEXT:
          case MySqlParser::POLYFROMWKB:
          case MySqlParser::POLYGONFROMTEXT:
          case MySqlParser::POLYGONFROMWKB:
          case MySqlParser::POW:
          case MySqlParser::POWER:
          case MySqlParser::QUOTE:
          case MySqlParser::RADIANS:
          case MySqlParser::RAND:
          case MySqlParser::RANDOM_BYTES:
          case MySqlParser::RELEASE_LOCK:
          case MySqlParser::REVERSE:
          case MySqlParser::ROUND:
          case MySqlParser::ROW_COUNT:
          case MySqlParser::RPAD:
          case MySqlParser::RTRIM:
          case MySqlParser::SEC_TO_TIME:
          case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
          case MySqlParser::SESSION_USER:
          case MySqlParser::SHA:
          case MySqlParser::SHA1:
          case MySqlParser::SHA2:
          case MySqlParser::SCHEMA_NAME:
          case MySqlParser::SIGN:
          case MySqlParser::SIN:
          case MySqlParser::SLEEP:
          case MySqlParser::SOUNDEX:
          case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
          case MySqlParser::SQRT:
          case MySqlParser::SRID:
          case MySqlParser::STARTPOINT:
          case MySqlParser::STRCMP:
          case MySqlParser::STR_TO_DATE:
          case MySqlParser::ST_AREA:
          case MySqlParser::ST_ASBINARY:
          case MySqlParser::ST_ASTEXT:
          case MySqlParser::ST_ASWKB:
          case MySqlParser::ST_ASWKT:
          case MySqlParser::ST_BUFFER:
          case MySqlParser::ST_CENTROID:
          case MySqlParser::ST_CONTAINS:
          case MySqlParser::ST_CROSSES:
          case MySqlParser::ST_DIFFERENCE:
          case MySqlParser::ST_DIMENSION:
          case MySqlParser::ST_DISJOINT:
          case MySqlParser::ST_DISTANCE:
          case MySqlParser::ST_ENDPOINT:
          case MySqlParser::ST_ENVELOPE:
          case MySqlParser::ST_EQUALS:
          case MySqlParser::ST_EXTERIORRING:
          case MySqlParser::ST_GEOMCOLLFROMTEXT:
          case MySqlParser::ST_GEOMCOLLFROMTXT:
          case MySqlParser::ST_GEOMCOLLFROMWKB:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
          case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
          case MySqlParser::ST_GEOMETRYFROMTEXT:
          case MySqlParser::ST_GEOMETRYFROMWKB:
          case MySqlParser::ST_GEOMETRYN:
          case MySqlParser::ST_GEOMETRYTYPE:
          case MySqlParser::ST_GEOMFROMTEXT:
          case MySqlParser::ST_GEOMFROMWKB:
          case MySqlParser::ST_INTERIORRINGN:
          case MySqlParser::ST_INTERSECTION:
          case MySqlParser::ST_INTERSECTS:
          case MySqlParser::ST_ISCLOSED:
          case MySqlParser::ST_ISEMPTY:
          case MySqlParser::ST_ISSIMPLE:
          case MySqlParser::ST_LINEFROMTEXT:
          case MySqlParser::ST_LINEFROMWKB:
          case MySqlParser::ST_LINESTRINGFROMTEXT:
          case MySqlParser::ST_LINESTRINGFROMWKB:
          case MySqlParser::ST_NUMGEOMETRIES:
          case MySqlParser::ST_NUMINTERIORRING:
          case MySqlParser::ST_NUMINTERIORRINGS:
          case MySqlParser::ST_NUMPOINTS:
          case MySqlParser::ST_OVERLAPS:
          case MySqlParser::ST_POINTFROMTEXT:
          case MySqlParser::ST_POINTFROMWKB:
          case MySqlParser::ST_POINTN:
          case MySqlParser::ST_POLYFROMTEXT:
          case MySqlParser::ST_POLYFROMWKB:
          case MySqlParser::ST_POLYGONFROMTEXT:
          case MySqlParser::ST_POLYGONFROMWKB:
          case MySqlParser::ST_SRID:
          case MySqlParser::ST_STARTPOINT:
          case MySqlParser::ST_SYMDIFFERENCE:
          case MySqlParser::ST_TOUCHES:
          case MySqlParser::ST_UNION:
          case MySqlParser::ST_WITHIN:
          case MySqlParser::ST_X:
          case MySqlParser::ST_Y:
          case MySqlParser::SUBDATE:
          case MySqlParser::SUBSTRING_INDEX:
          case MySqlParser::SUBTIME:
          case MySqlParser::SYSTEM_USER:
          case MySqlParser::TAN:
          case MySqlParser::TIMEDIFF:
          case MySqlParser::TIMESTAMPADD:
          case MySqlParser::TIMESTAMPDIFF:
          case MySqlParser::TIME_FORMAT:
          case MySqlParser::TIME_TO_SEC:
          case MySqlParser::TOUCHES:
          case MySqlParser::TO_BASE64:
          case MySqlParser::TO_DAYS:
          case MySqlParser::TO_SECONDS:
          case MySqlParser::TP_CONNECTION_ADMIN:
          case MySqlParser::UCASE:
          case MySqlParser::UNCOMPRESS:
          case MySqlParser::UNCOMPRESSED_LENGTH:
          case MySqlParser::UNHEX:
          case MySqlParser::UNIX_TIMESTAMP:
          case MySqlParser::UPDATEXML:
          case MySqlParser::UPPER:
          case MySqlParser::UUID:
          case MySqlParser::UUID_SHORT:
          case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
          case MySqlParser::VERSION:
          case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
          case MySqlParser::WEEKDAY:
          case MySqlParser::WEEKOFYEAR:
          case MySqlParser::WEIGHT_STRING:
          case MySqlParser::WITHIN:
          case MySqlParser::YEARWEEK:
          case MySqlParser::Y_FUNCTION:
          case MySqlParser::X_FUNCTION:
          case MySqlParser::MOD:
          case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
          case MySqlParser::STRING_LITERAL:
          case MySqlParser::ID: {
            setState(2956);
            uidList();
            break;
          }

          case MySqlParser::ALL: {
            setState(2957);
            match(MySqlParser::ALL);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySqlParser::REMOVE: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByRemovePartitioningContext>(_localctx);
        enterOuterAlt(_localctx, 14);
        setState(2960);
        match(MySqlParser::REMOVE);
        setState(2961);
        match(MySqlParser::PARTITIONING);
        break;
      }

      case MySqlParser::UPGRADE: {
        _localctx = _tracker.createInstance<MySqlParser::AlterByUpgradePartitioningContext>(_localctx);
        enterOuterAlt(_localctx, 15);
        setState(2962);
        match(MySqlParser::UPGRADE);
        setState(2963);
        match(MySqlParser::PARTITIONING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropDatabaseContext ------------------------------------------------------------------

MySqlParser::DropDatabaseContext::DropDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DropDatabaseContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

MySqlParser::UidContext* MySqlParser::DropDatabaseContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::DropDatabaseContext::DATABASE() {
  return getToken(MySqlParser::DATABASE, 0);
}

tree::TerminalNode* MySqlParser::DropDatabaseContext::SCHEMA() {
  return getToken(MySqlParser::SCHEMA, 0);
}

MySqlParser::IfExistsContext* MySqlParser::DropDatabaseContext::ifExists() {
  return getRuleContext<MySqlParser::IfExistsContext>(0);
}


size_t MySqlParser::DropDatabaseContext::getRuleIndex() const {
  return MySqlParser::RuleDropDatabase;
}

void MySqlParser::DropDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropDatabase(this);
}

void MySqlParser::DropDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropDatabase(this);
}


std::any MySqlParser::DropDatabaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDropDatabase(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DropDatabaseContext* MySqlParser::dropDatabase() {
  DropDatabaseContext *_localctx = _tracker.createInstance<DropDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 150, MySqlParser::RuleDropDatabase);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2966);
    match(MySqlParser::DROP);
    setState(2967);
    antlrcpp::downCast<DropDatabaseContext *>(_localctx)->dbFormat = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::DATABASE || _la == MySqlParser::SCHEMA)) {
      antlrcpp::downCast<DropDatabaseContext *>(_localctx)->dbFormat = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2969);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 382, _ctx)) {
    case 1: {
      setState(2968);
      ifExists();
      break;
    }

    default:
      break;
    }
    setState(2971);
    uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropEventContext ------------------------------------------------------------------

MySqlParser::DropEventContext::DropEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DropEventContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::DropEventContext::EVENT() {
  return getToken(MySqlParser::EVENT, 0);
}

MySqlParser::FullIdContext* MySqlParser::DropEventContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

MySqlParser::IfExistsContext* MySqlParser::DropEventContext::ifExists() {
  return getRuleContext<MySqlParser::IfExistsContext>(0);
}


size_t MySqlParser::DropEventContext::getRuleIndex() const {
  return MySqlParser::RuleDropEvent;
}

void MySqlParser::DropEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropEvent(this);
}

void MySqlParser::DropEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropEvent(this);
}


std::any MySqlParser::DropEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDropEvent(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DropEventContext* MySqlParser::dropEvent() {
  DropEventContext *_localctx = _tracker.createInstance<DropEventContext>(_ctx, getState());
  enterRule(_localctx, 152, MySqlParser::RuleDropEvent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2973);
    match(MySqlParser::DROP);
    setState(2974);
    match(MySqlParser::EVENT);
    setState(2976);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 383, _ctx)) {
    case 1: {
      setState(2975);
      ifExists();
      break;
    }

    default:
      break;
    }
    setState(2978);
    fullId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropIndexContext ------------------------------------------------------------------

MySqlParser::DropIndexContext::DropIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DropIndexContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::DropIndexContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

MySqlParser::UidContext* MySqlParser::DropIndexContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::DropIndexContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

MySqlParser::TableNameContext* MySqlParser::DropIndexContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::DropIndexContext::ALGORITHM() {
  return getTokens(MySqlParser::ALGORITHM);
}

tree::TerminalNode* MySqlParser::DropIndexContext::ALGORITHM(size_t i) {
  return getToken(MySqlParser::ALGORITHM, i);
}

std::vector<tree::TerminalNode *> MySqlParser::DropIndexContext::LOCK() {
  return getTokens(MySqlParser::LOCK);
}

tree::TerminalNode* MySqlParser::DropIndexContext::LOCK(size_t i) {
  return getToken(MySqlParser::LOCK, i);
}

tree::TerminalNode* MySqlParser::DropIndexContext::ONLINE() {
  return getToken(MySqlParser::ONLINE, 0);
}

tree::TerminalNode* MySqlParser::DropIndexContext::OFFLINE() {
  return getToken(MySqlParser::OFFLINE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::DropIndexContext::DEFAULT() {
  return getTokens(MySqlParser::DEFAULT);
}

tree::TerminalNode* MySqlParser::DropIndexContext::DEFAULT(size_t i) {
  return getToken(MySqlParser::DEFAULT, i);
}

std::vector<tree::TerminalNode *> MySqlParser::DropIndexContext::INPLACE() {
  return getTokens(MySqlParser::INPLACE);
}

tree::TerminalNode* MySqlParser::DropIndexContext::INPLACE(size_t i) {
  return getToken(MySqlParser::INPLACE, i);
}

std::vector<tree::TerminalNode *> MySqlParser::DropIndexContext::COPY() {
  return getTokens(MySqlParser::COPY);
}

tree::TerminalNode* MySqlParser::DropIndexContext::COPY(size_t i) {
  return getToken(MySqlParser::COPY, i);
}

std::vector<tree::TerminalNode *> MySqlParser::DropIndexContext::NONE() {
  return getTokens(MySqlParser::NONE);
}

tree::TerminalNode* MySqlParser::DropIndexContext::NONE(size_t i) {
  return getToken(MySqlParser::NONE, i);
}

std::vector<tree::TerminalNode *> MySqlParser::DropIndexContext::SHARED() {
  return getTokens(MySqlParser::SHARED);
}

tree::TerminalNode* MySqlParser::DropIndexContext::SHARED(size_t i) {
  return getToken(MySqlParser::SHARED, i);
}

std::vector<tree::TerminalNode *> MySqlParser::DropIndexContext::EXCLUSIVE() {
  return getTokens(MySqlParser::EXCLUSIVE);
}

tree::TerminalNode* MySqlParser::DropIndexContext::EXCLUSIVE(size_t i) {
  return getToken(MySqlParser::EXCLUSIVE, i);
}

std::vector<tree::TerminalNode *> MySqlParser::DropIndexContext::EQUAL_SYMBOL() {
  return getTokens(MySqlParser::EQUAL_SYMBOL);
}

tree::TerminalNode* MySqlParser::DropIndexContext::EQUAL_SYMBOL(size_t i) {
  return getToken(MySqlParser::EQUAL_SYMBOL, i);
}


size_t MySqlParser::DropIndexContext::getRuleIndex() const {
  return MySqlParser::RuleDropIndex;
}

void MySqlParser::DropIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropIndex(this);
}

void MySqlParser::DropIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropIndex(this);
}


std::any MySqlParser::DropIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDropIndex(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DropIndexContext* MySqlParser::dropIndex() {
  DropIndexContext *_localctx = _tracker.createInstance<DropIndexContext>(_ctx, getState());
  enterRule(_localctx, 154, MySqlParser::RuleDropIndex);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2980);
    match(MySqlParser::DROP);
    setState(2981);
    match(MySqlParser::INDEX);
    setState(2983);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 384, _ctx)) {
    case 1: {
      setState(2982);
      antlrcpp::downCast<DropIndexContext *>(_localctx)->intimeAction = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::OFFLINE

      || _la == MySqlParser::ONLINE)) {
        antlrcpp::downCast<DropIndexContext *>(_localctx)->intimeAction = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(2985);
    uid();
    setState(2986);
    match(MySqlParser::ON);
    setState(2987);
    tableName();
    setState(3000);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 388, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2998);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::ALGORITHM: {
            setState(2988);
            match(MySqlParser::ALGORITHM);
            setState(2990);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySqlParser::EQUAL_SYMBOL) {
              setState(2989);
              match(MySqlParser::EQUAL_SYMBOL);
            }
            setState(2992);
            antlrcpp::downCast<DropIndexContext *>(_localctx)->algType = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::COPY || _la == MySqlParser::INPLACE)) {
              antlrcpp::downCast<DropIndexContext *>(_localctx)->algType = _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
            break;
          }

          case MySqlParser::LOCK: {
            setState(2993);
            match(MySqlParser::LOCK);
            setState(2995);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySqlParser::EQUAL_SYMBOL) {
              setState(2994);
              match(MySqlParser::EQUAL_SYMBOL);
            }
            setState(2997);
            antlrcpp::downCast<DropIndexContext *>(_localctx)->lockType = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::EXCLUSIVE || _la == MySqlParser::NONE || _la == MySqlParser::SHARED)) {
              antlrcpp::downCast<DropIndexContext *>(_localctx)->lockType = _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(3002);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 388, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropLogfileGroupContext ------------------------------------------------------------------

MySqlParser::DropLogfileGroupContext::DropLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DropLogfileGroupContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::DropLogfileGroupContext::LOGFILE() {
  return getToken(MySqlParser::LOGFILE, 0);
}

tree::TerminalNode* MySqlParser::DropLogfileGroupContext::GROUP() {
  return getToken(MySqlParser::GROUP, 0);
}

MySqlParser::UidContext* MySqlParser::DropLogfileGroupContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::DropLogfileGroupContext::ENGINE() {
  return getToken(MySqlParser::ENGINE, 0);
}

tree::TerminalNode* MySqlParser::DropLogfileGroupContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::EngineNameContext* MySqlParser::DropLogfileGroupContext::engineName() {
  return getRuleContext<MySqlParser::EngineNameContext>(0);
}


size_t MySqlParser::DropLogfileGroupContext::getRuleIndex() const {
  return MySqlParser::RuleDropLogfileGroup;
}

void MySqlParser::DropLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropLogfileGroup(this);
}

void MySqlParser::DropLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropLogfileGroup(this);
}


std::any MySqlParser::DropLogfileGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDropLogfileGroup(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DropLogfileGroupContext* MySqlParser::dropLogfileGroup() {
  DropLogfileGroupContext *_localctx = _tracker.createInstance<DropLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 156, MySqlParser::RuleDropLogfileGroup);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3003);
    match(MySqlParser::DROP);
    setState(3004);
    match(MySqlParser::LOGFILE);
    setState(3005);
    match(MySqlParser::GROUP);
    setState(3006);
    uid();
    setState(3007);
    match(MySqlParser::ENGINE);
    setState(3008);
    match(MySqlParser::EQUAL_SYMBOL);
    setState(3009);
    engineName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropProcedureContext ------------------------------------------------------------------

MySqlParser::DropProcedureContext::DropProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DropProcedureContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::DropProcedureContext::PROCEDURE() {
  return getToken(MySqlParser::PROCEDURE, 0);
}

MySqlParser::FullIdContext* MySqlParser::DropProcedureContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

MySqlParser::IfExistsContext* MySqlParser::DropProcedureContext::ifExists() {
  return getRuleContext<MySqlParser::IfExistsContext>(0);
}


size_t MySqlParser::DropProcedureContext::getRuleIndex() const {
  return MySqlParser::RuleDropProcedure;
}

void MySqlParser::DropProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropProcedure(this);
}

void MySqlParser::DropProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropProcedure(this);
}


std::any MySqlParser::DropProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDropProcedure(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DropProcedureContext* MySqlParser::dropProcedure() {
  DropProcedureContext *_localctx = _tracker.createInstance<DropProcedureContext>(_ctx, getState());
  enterRule(_localctx, 158, MySqlParser::RuleDropProcedure);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3011);
    match(MySqlParser::DROP);
    setState(3012);
    match(MySqlParser::PROCEDURE);
    setState(3014);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 389, _ctx)) {
    case 1: {
      setState(3013);
      ifExists();
      break;
    }

    default:
      break;
    }
    setState(3016);
    fullId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropFunctionContext ------------------------------------------------------------------

MySqlParser::DropFunctionContext::DropFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DropFunctionContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::DropFunctionContext::FUNCTION() {
  return getToken(MySqlParser::FUNCTION, 0);
}

MySqlParser::FullIdContext* MySqlParser::DropFunctionContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

MySqlParser::IfExistsContext* MySqlParser::DropFunctionContext::ifExists() {
  return getRuleContext<MySqlParser::IfExistsContext>(0);
}


size_t MySqlParser::DropFunctionContext::getRuleIndex() const {
  return MySqlParser::RuleDropFunction;
}

void MySqlParser::DropFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropFunction(this);
}

void MySqlParser::DropFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropFunction(this);
}


std::any MySqlParser::DropFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDropFunction(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DropFunctionContext* MySqlParser::dropFunction() {
  DropFunctionContext *_localctx = _tracker.createInstance<DropFunctionContext>(_ctx, getState());
  enterRule(_localctx, 160, MySqlParser::RuleDropFunction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3018);
    match(MySqlParser::DROP);
    setState(3019);
    match(MySqlParser::FUNCTION);
    setState(3021);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 390, _ctx)) {
    case 1: {
      setState(3020);
      ifExists();
      break;
    }

    default:
      break;
    }
    setState(3023);
    fullId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropServerContext ------------------------------------------------------------------

MySqlParser::DropServerContext::DropServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DropServerContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::DropServerContext::SERVER() {
  return getToken(MySqlParser::SERVER, 0);
}

MySqlParser::UidContext* MySqlParser::DropServerContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::IfExistsContext* MySqlParser::DropServerContext::ifExists() {
  return getRuleContext<MySqlParser::IfExistsContext>(0);
}


size_t MySqlParser::DropServerContext::getRuleIndex() const {
  return MySqlParser::RuleDropServer;
}

void MySqlParser::DropServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropServer(this);
}

void MySqlParser::DropServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropServer(this);
}


std::any MySqlParser::DropServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDropServer(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DropServerContext* MySqlParser::dropServer() {
  DropServerContext *_localctx = _tracker.createInstance<DropServerContext>(_ctx, getState());
  enterRule(_localctx, 162, MySqlParser::RuleDropServer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3025);
    match(MySqlParser::DROP);
    setState(3026);
    match(MySqlParser::SERVER);
    setState(3028);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 391, _ctx)) {
    case 1: {
      setState(3027);
      ifExists();
      break;
    }

    default:
      break;
    }
    setState(3030);
    uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTableContext ------------------------------------------------------------------

MySqlParser::DropTableContext::DropTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DropTableContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::DropTableContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

MySqlParser::TablesContext* MySqlParser::DropTableContext::tables() {
  return getRuleContext<MySqlParser::TablesContext>(0);
}

tree::TerminalNode* MySqlParser::DropTableContext::TEMPORARY() {
  return getToken(MySqlParser::TEMPORARY, 0);
}

MySqlParser::IfExistsContext* MySqlParser::DropTableContext::ifExists() {
  return getRuleContext<MySqlParser::IfExistsContext>(0);
}

tree::TerminalNode* MySqlParser::DropTableContext::RESTRICT() {
  return getToken(MySqlParser::RESTRICT, 0);
}

tree::TerminalNode* MySqlParser::DropTableContext::CASCADE() {
  return getToken(MySqlParser::CASCADE, 0);
}


size_t MySqlParser::DropTableContext::getRuleIndex() const {
  return MySqlParser::RuleDropTable;
}

void MySqlParser::DropTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTable(this);
}

void MySqlParser::DropTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTable(this);
}


std::any MySqlParser::DropTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDropTable(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DropTableContext* MySqlParser::dropTable() {
  DropTableContext *_localctx = _tracker.createInstance<DropTableContext>(_ctx, getState());
  enterRule(_localctx, 164, MySqlParser::RuleDropTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3032);
    match(MySqlParser::DROP);
    setState(3034);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::TEMPORARY) {
      setState(3033);
      match(MySqlParser::TEMPORARY);
    }
    setState(3036);
    match(MySqlParser::TABLE);
    setState(3038);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 393, _ctx)) {
    case 1: {
      setState(3037);
      ifExists();
      break;
    }

    default:
      break;
    }
    setState(3040);
    tables();
    setState(3042);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::CASCADE || _la == MySqlParser::RESTRICT) {
      setState(3041);
      antlrcpp::downCast<DropTableContext *>(_localctx)->dropType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::CASCADE || _la == MySqlParser::RESTRICT)) {
        antlrcpp::downCast<DropTableContext *>(_localctx)->dropType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTablespaceContext ------------------------------------------------------------------

MySqlParser::DropTablespaceContext::DropTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DropTablespaceContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::DropTablespaceContext::TABLESPACE() {
  return getToken(MySqlParser::TABLESPACE, 0);
}

MySqlParser::UidContext* MySqlParser::DropTablespaceContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::DropTablespaceContext::ENGINE() {
  return getToken(MySqlParser::ENGINE, 0);
}

MySqlParser::EngineNameContext* MySqlParser::DropTablespaceContext::engineName() {
  return getRuleContext<MySqlParser::EngineNameContext>(0);
}

tree::TerminalNode* MySqlParser::DropTablespaceContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}


size_t MySqlParser::DropTablespaceContext::getRuleIndex() const {
  return MySqlParser::RuleDropTablespace;
}

void MySqlParser::DropTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTablespace(this);
}

void MySqlParser::DropTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTablespace(this);
}


std::any MySqlParser::DropTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDropTablespace(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DropTablespaceContext* MySqlParser::dropTablespace() {
  DropTablespaceContext *_localctx = _tracker.createInstance<DropTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 166, MySqlParser::RuleDropTablespace);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3044);
    match(MySqlParser::DROP);
    setState(3045);
    match(MySqlParser::TABLESPACE);
    setState(3046);
    uid();
    setState(3052);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ENGINE) {
      setState(3047);
      match(MySqlParser::ENGINE);
      setState(3049);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EQUAL_SYMBOL) {
        setState(3048);
        match(MySqlParser::EQUAL_SYMBOL);
      }
      setState(3051);
      engineName();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTriggerContext ------------------------------------------------------------------

MySqlParser::DropTriggerContext::DropTriggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DropTriggerContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::DropTriggerContext::TRIGGER() {
  return getToken(MySqlParser::TRIGGER, 0);
}

MySqlParser::FullIdContext* MySqlParser::DropTriggerContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

MySqlParser::IfExistsContext* MySqlParser::DropTriggerContext::ifExists() {
  return getRuleContext<MySqlParser::IfExistsContext>(0);
}


size_t MySqlParser::DropTriggerContext::getRuleIndex() const {
  return MySqlParser::RuleDropTrigger;
}

void MySqlParser::DropTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTrigger(this);
}

void MySqlParser::DropTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTrigger(this);
}


std::any MySqlParser::DropTriggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDropTrigger(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DropTriggerContext* MySqlParser::dropTrigger() {
  DropTriggerContext *_localctx = _tracker.createInstance<DropTriggerContext>(_ctx, getState());
  enterRule(_localctx, 168, MySqlParser::RuleDropTrigger);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3054);
    match(MySqlParser::DROP);
    setState(3055);
    match(MySqlParser::TRIGGER);
    setState(3057);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 397, _ctx)) {
    case 1: {
      setState(3056);
      ifExists();
      break;
    }

    default:
      break;
    }
    setState(3059);
    fullId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropViewContext ------------------------------------------------------------------

MySqlParser::DropViewContext::DropViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DropViewContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::DropViewContext::VIEW() {
  return getToken(MySqlParser::VIEW, 0);
}

std::vector<MySqlParser::FullIdContext *> MySqlParser::DropViewContext::fullId() {
  return getRuleContexts<MySqlParser::FullIdContext>();
}

MySqlParser::FullIdContext* MySqlParser::DropViewContext::fullId(size_t i) {
  return getRuleContext<MySqlParser::FullIdContext>(i);
}

MySqlParser::IfExistsContext* MySqlParser::DropViewContext::ifExists() {
  return getRuleContext<MySqlParser::IfExistsContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::DropViewContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::DropViewContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::DropViewContext::RESTRICT() {
  return getToken(MySqlParser::RESTRICT, 0);
}

tree::TerminalNode* MySqlParser::DropViewContext::CASCADE() {
  return getToken(MySqlParser::CASCADE, 0);
}


size_t MySqlParser::DropViewContext::getRuleIndex() const {
  return MySqlParser::RuleDropView;
}

void MySqlParser::DropViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropView(this);
}

void MySqlParser::DropViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropView(this);
}


std::any MySqlParser::DropViewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDropView(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DropViewContext* MySqlParser::dropView() {
  DropViewContext *_localctx = _tracker.createInstance<DropViewContext>(_ctx, getState());
  enterRule(_localctx, 170, MySqlParser::RuleDropView);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3061);
    match(MySqlParser::DROP);
    setState(3062);
    match(MySqlParser::VIEW);
    setState(3064);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 398, _ctx)) {
    case 1: {
      setState(3063);
      ifExists();
      break;
    }

    default:
      break;
    }
    setState(3066);
    fullId();
    setState(3071);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(3067);
      match(MySqlParser::COMMA);
      setState(3068);
      fullId();
      setState(3073);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3075);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::CASCADE || _la == MySqlParser::RESTRICT) {
      setState(3074);
      antlrcpp::downCast<DropViewContext *>(_localctx)->dropType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::CASCADE || _la == MySqlParser::RESTRICT)) {
        antlrcpp::downCast<DropViewContext *>(_localctx)->dropType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropRoleContext ------------------------------------------------------------------

MySqlParser::DropRoleContext::DropRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DropRoleContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::DropRoleContext::ROLE() {
  return getToken(MySqlParser::ROLE, 0);
}

std::vector<MySqlParser::RoleNameContext *> MySqlParser::DropRoleContext::roleName() {
  return getRuleContexts<MySqlParser::RoleNameContext>();
}

MySqlParser::RoleNameContext* MySqlParser::DropRoleContext::roleName(size_t i) {
  return getRuleContext<MySqlParser::RoleNameContext>(i);
}

MySqlParser::IfExistsContext* MySqlParser::DropRoleContext::ifExists() {
  return getRuleContext<MySqlParser::IfExistsContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::DropRoleContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::DropRoleContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::DropRoleContext::getRuleIndex() const {
  return MySqlParser::RuleDropRole;
}

void MySqlParser::DropRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropRole(this);
}

void MySqlParser::DropRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropRole(this);
}


std::any MySqlParser::DropRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDropRole(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DropRoleContext* MySqlParser::dropRole() {
  DropRoleContext *_localctx = _tracker.createInstance<DropRoleContext>(_ctx, getState());
  enterRule(_localctx, 172, MySqlParser::RuleDropRole);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3077);
    match(MySqlParser::DROP);
    setState(3078);
    match(MySqlParser::ROLE);
    setState(3080);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx)) {
    case 1: {
      setState(3079);
      ifExists();
      break;
    }

    default:
      break;
    }
    setState(3082);
    roleName();
    setState(3087);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(3083);
      match(MySqlParser::COMMA);
      setState(3084);
      roleName();
      setState(3089);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetRoleContext ------------------------------------------------------------------

MySqlParser::SetRoleContext::SetRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SetRoleContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::SetRoleContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::SetRoleContext::ROLE() {
  return getToken(MySqlParser::ROLE, 0);
}

tree::TerminalNode* MySqlParser::SetRoleContext::TO() {
  return getToken(MySqlParser::TO, 0);
}

tree::TerminalNode* MySqlParser::SetRoleContext::NONE() {
  return getToken(MySqlParser::NONE, 0);
}

tree::TerminalNode* MySqlParser::SetRoleContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

std::vector<MySqlParser::RoleNameContext *> MySqlParser::SetRoleContext::roleName() {
  return getRuleContexts<MySqlParser::RoleNameContext>();
}

MySqlParser::RoleNameContext* MySqlParser::SetRoleContext::roleName(size_t i) {
  return getRuleContext<MySqlParser::RoleNameContext>(i);
}

std::vector<MySqlParser::UserNameContext *> MySqlParser::SetRoleContext::userName() {
  return getRuleContexts<MySqlParser::UserNameContext>();
}

MySqlParser::UserNameContext* MySqlParser::SetRoleContext::userName(size_t i) {
  return getRuleContext<MySqlParser::UserNameContext>(i);
}

std::vector<MySqlParser::UidContext *> MySqlParser::SetRoleContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::SetRoleContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::SetRoleContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::SetRoleContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::RoleOptionContext* MySqlParser::SetRoleContext::roleOption() {
  return getRuleContext<MySqlParser::RoleOptionContext>(0);
}


size_t MySqlParser::SetRoleContext::getRuleIndex() const {
  return MySqlParser::RuleSetRole;
}

void MySqlParser::SetRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetRole(this);
}

void MySqlParser::SetRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetRole(this);
}


std::any MySqlParser::SetRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSetRole(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SetRoleContext* MySqlParser::setRole() {
  SetRoleContext *_localctx = _tracker.createInstance<SetRoleContext>(_ctx, getState());
  enterRule(_localctx, 174, MySqlParser::RuleSetRole);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3123);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 408, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3090);
      match(MySqlParser::SET);
      setState(3091);
      match(MySqlParser::DEFAULT);
      setState(3092);
      match(MySqlParser::ROLE);
      setState(3103);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 404, _ctx)) {
      case 1: {
        setState(3093);
        match(MySqlParser::NONE);
        break;
      }

      case 2: {
        setState(3094);
        match(MySqlParser::ALL);
        break;
      }

      case 3: {
        setState(3095);
        roleName();
        setState(3100);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(3096);
          match(MySqlParser::COMMA);
          setState(3097);
          roleName();
          setState(3102);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        break;
      }
      setState(3105);
      match(MySqlParser::TO);
      setState(3108);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 405, _ctx)) {
      case 1: {
        setState(3106);
        userName();
        break;
      }

      case 2: {
        setState(3107);
        uid();
        break;
      }

      default:
        break;
      }
      setState(3117);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(3110);
        match(MySqlParser::COMMA);
        setState(3113);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx)) {
        case 1: {
          setState(3111);
          userName();
          break;
        }

        case 2: {
          setState(3112);
          uid();
          break;
        }

        default:
          break;
        }
        setState(3119);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3120);
      match(MySqlParser::SET);
      setState(3121);
      match(MySqlParser::ROLE);
      setState(3122);
      roleOption();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenameTableContext ------------------------------------------------------------------

MySqlParser::RenameTableContext::RenameTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::RenameTableContext::RENAME() {
  return getToken(MySqlParser::RENAME, 0);
}

tree::TerminalNode* MySqlParser::RenameTableContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

std::vector<MySqlParser::RenameTableClauseContext *> MySqlParser::RenameTableContext::renameTableClause() {
  return getRuleContexts<MySqlParser::RenameTableClauseContext>();
}

MySqlParser::RenameTableClauseContext* MySqlParser::RenameTableContext::renameTableClause(size_t i) {
  return getRuleContext<MySqlParser::RenameTableClauseContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::RenameTableContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::RenameTableContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::RenameTableContext::getRuleIndex() const {
  return MySqlParser::RuleRenameTable;
}

void MySqlParser::RenameTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameTable(this);
}

void MySqlParser::RenameTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameTable(this);
}


std::any MySqlParser::RenameTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRenameTable(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::RenameTableContext* MySqlParser::renameTable() {
  RenameTableContext *_localctx = _tracker.createInstance<RenameTableContext>(_ctx, getState());
  enterRule(_localctx, 176, MySqlParser::RuleRenameTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3125);
    match(MySqlParser::RENAME);
    setState(3126);
    match(MySqlParser::TABLE);
    setState(3127);
    renameTableClause();
    setState(3132);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(3128);
      match(MySqlParser::COMMA);
      setState(3129);
      renameTableClause();
      setState(3134);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenameTableClauseContext ------------------------------------------------------------------

MySqlParser::RenameTableClauseContext::RenameTableClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::TableNameContext *> MySqlParser::RenameTableClauseContext::tableName() {
  return getRuleContexts<MySqlParser::TableNameContext>();
}

MySqlParser::TableNameContext* MySqlParser::RenameTableClauseContext::tableName(size_t i) {
  return getRuleContext<MySqlParser::TableNameContext>(i);
}

tree::TerminalNode* MySqlParser::RenameTableClauseContext::TO() {
  return getToken(MySqlParser::TO, 0);
}


size_t MySqlParser::RenameTableClauseContext::getRuleIndex() const {
  return MySqlParser::RuleRenameTableClause;
}

void MySqlParser::RenameTableClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameTableClause(this);
}

void MySqlParser::RenameTableClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameTableClause(this);
}


std::any MySqlParser::RenameTableClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRenameTableClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::RenameTableClauseContext* MySqlParser::renameTableClause() {
  RenameTableClauseContext *_localctx = _tracker.createInstance<RenameTableClauseContext>(_ctx, getState());
  enterRule(_localctx, 178, MySqlParser::RuleRenameTableClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3135);
    tableName();
    setState(3136);
    match(MySqlParser::TO);
    setState(3137);
    tableName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TruncateTableContext ------------------------------------------------------------------

MySqlParser::TruncateTableContext::TruncateTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::TruncateTableContext::TRUNCATE() {
  return getToken(MySqlParser::TRUNCATE, 0);
}

MySqlParser::TableNameContext* MySqlParser::TruncateTableContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::TruncateTableContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}


size_t MySqlParser::TruncateTableContext::getRuleIndex() const {
  return MySqlParser::RuleTruncateTable;
}

void MySqlParser::TruncateTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTruncateTable(this);
}

void MySqlParser::TruncateTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTruncateTable(this);
}


std::any MySqlParser::TruncateTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTruncateTable(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TruncateTableContext* MySqlParser::truncateTable() {
  TruncateTableContext *_localctx = _tracker.createInstance<TruncateTableContext>(_ctx, getState());
  enterRule(_localctx, 180, MySqlParser::RuleTruncateTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3139);
    match(MySqlParser::TRUNCATE);
    setState(3141);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::TABLE) {
      setState(3140);
      match(MySqlParser::TABLE);
    }
    setState(3143);
    tableName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallStatementContext ------------------------------------------------------------------

MySqlParser::CallStatementContext::CallStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CallStatementContext::CALL() {
  return getToken(MySqlParser::CALL, 0);
}

MySqlParser::FullIdContext* MySqlParser::CallStatementContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

tree::TerminalNode* MySqlParser::CallStatementContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::CallStatementContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::ConstantsContext* MySqlParser::CallStatementContext::constants() {
  return getRuleContext<MySqlParser::ConstantsContext>(0);
}

MySqlParser::ExpressionsContext* MySqlParser::CallStatementContext::expressions() {
  return getRuleContext<MySqlParser::ExpressionsContext>(0);
}


size_t MySqlParser::CallStatementContext::getRuleIndex() const {
  return MySqlParser::RuleCallStatement;
}

void MySqlParser::CallStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCallStatement(this);
}

void MySqlParser::CallStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCallStatement(this);
}


std::any MySqlParser::CallStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCallStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CallStatementContext* MySqlParser::callStatement() {
  CallStatementContext *_localctx = _tracker.createInstance<CallStatementContext>(_ctx, getState());
  enterRule(_localctx, 182, MySqlParser::RuleCallStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3145);
    match(MySqlParser::CALL);
    setState(3146);
    fullId();
    setState(3153);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 412, _ctx)) {
    case 1: {
      setState(3147);
      match(MySqlParser::LR_BRACKET);
      setState(3150);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx)) {
      case 1: {
        setState(3148);
        constants();
        break;
      }

      case 2: {
        setState(3149);
        expressions();
        break;
      }

      default:
        break;
      }
      setState(3152);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteStatementContext ------------------------------------------------------------------

MySqlParser::DeleteStatementContext::DeleteStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::SingleDeleteStatementContext* MySqlParser::DeleteStatementContext::singleDeleteStatement() {
  return getRuleContext<MySqlParser::SingleDeleteStatementContext>(0);
}

MySqlParser::MultipleDeleteStatementContext* MySqlParser::DeleteStatementContext::multipleDeleteStatement() {
  return getRuleContext<MySqlParser::MultipleDeleteStatementContext>(0);
}


size_t MySqlParser::DeleteStatementContext::getRuleIndex() const {
  return MySqlParser::RuleDeleteStatement;
}

void MySqlParser::DeleteStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteStatement(this);
}

void MySqlParser::DeleteStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteStatement(this);
}


std::any MySqlParser::DeleteStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDeleteStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DeleteStatementContext* MySqlParser::deleteStatement() {
  DeleteStatementContext *_localctx = _tracker.createInstance<DeleteStatementContext>(_ctx, getState());
  enterRule(_localctx, 184, MySqlParser::RuleDeleteStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3157);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 413, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3155);
      singleDeleteStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3156);
      multipleDeleteStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DoStatementContext ------------------------------------------------------------------

MySqlParser::DoStatementContext::DoStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DoStatementContext::DO() {
  return getToken(MySqlParser::DO, 0);
}

MySqlParser::ExpressionsContext* MySqlParser::DoStatementContext::expressions() {
  return getRuleContext<MySqlParser::ExpressionsContext>(0);
}


size_t MySqlParser::DoStatementContext::getRuleIndex() const {
  return MySqlParser::RuleDoStatement;
}

void MySqlParser::DoStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoStatement(this);
}

void MySqlParser::DoStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoStatement(this);
}


std::any MySqlParser::DoStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDoStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DoStatementContext* MySqlParser::doStatement() {
  DoStatementContext *_localctx = _tracker.createInstance<DoStatementContext>(_ctx, getState());
  enterRule(_localctx, 186, MySqlParser::RuleDoStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3159);
    match(MySqlParser::DO);
    setState(3160);
    expressions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerStatementContext ------------------------------------------------------------------

MySqlParser::HandlerStatementContext::HandlerStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::HandlerOpenStatementContext* MySqlParser::HandlerStatementContext::handlerOpenStatement() {
  return getRuleContext<MySqlParser::HandlerOpenStatementContext>(0);
}

MySqlParser::HandlerReadIndexStatementContext* MySqlParser::HandlerStatementContext::handlerReadIndexStatement() {
  return getRuleContext<MySqlParser::HandlerReadIndexStatementContext>(0);
}

MySqlParser::HandlerReadStatementContext* MySqlParser::HandlerStatementContext::handlerReadStatement() {
  return getRuleContext<MySqlParser::HandlerReadStatementContext>(0);
}

MySqlParser::HandlerCloseStatementContext* MySqlParser::HandlerStatementContext::handlerCloseStatement() {
  return getRuleContext<MySqlParser::HandlerCloseStatementContext>(0);
}


size_t MySqlParser::HandlerStatementContext::getRuleIndex() const {
  return MySqlParser::RuleHandlerStatement;
}

void MySqlParser::HandlerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerStatement(this);
}

void MySqlParser::HandlerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerStatement(this);
}


std::any MySqlParser::HandlerStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHandlerStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::HandlerStatementContext* MySqlParser::handlerStatement() {
  HandlerStatementContext *_localctx = _tracker.createInstance<HandlerStatementContext>(_ctx, getState());
  enterRule(_localctx, 188, MySqlParser::RuleHandlerStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3166);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 414, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3162);
      handlerOpenStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3163);
      handlerReadIndexStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3164);
      handlerReadStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3165);
      handlerCloseStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertStatementContext ------------------------------------------------------------------

MySqlParser::InsertStatementContext::InsertStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::InsertStatementContext::INSERT() {
  return getToken(MySqlParser::INSERT, 0);
}

MySqlParser::TableNameContext* MySqlParser::InsertStatementContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

MySqlParser::InsertStatementValueContext* MySqlParser::InsertStatementContext::insertStatementValue() {
  return getRuleContext<MySqlParser::InsertStatementValueContext>(0);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::IGNORE() {
  return getToken(MySqlParser::IGNORE, 0);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::INTO() {
  return getToken(MySqlParser::INTO, 0);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::InsertStatementContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> MySqlParser::InsertStatementContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

std::vector<MySqlParser::UpdatedElementContext *> MySqlParser::InsertStatementContext::updatedElement() {
  return getRuleContexts<MySqlParser::UpdatedElementContext>();
}

MySqlParser::UpdatedElementContext* MySqlParser::InsertStatementContext::updatedElement(size_t i) {
  return getRuleContext<MySqlParser::UpdatedElementContext>(i);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::DUPLICATE() {
  return getToken(MySqlParser::DUPLICATE, 0);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::UPDATE() {
  return getToken(MySqlParser::UPDATE, 0);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::LOW_PRIORITY() {
  return getToken(MySqlParser::LOW_PRIORITY, 0);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::DELAYED() {
  return getToken(MySqlParser::DELAYED, 0);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::HIGH_PRIORITY() {
  return getToken(MySqlParser::HIGH_PRIORITY, 0);
}

MySqlParser::UidContext* MySqlParser::InsertStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::InsertStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::FullColumnNameListContext* MySqlParser::InsertStatementContext::fullColumnNameList() {
  return getRuleContext<MySqlParser::FullColumnNameListContext>(0);
}

MySqlParser::UidListContext* MySqlParser::InsertStatementContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::InsertStatementContext::AS() {
  return getToken(MySqlParser::AS, 0);
}


size_t MySqlParser::InsertStatementContext::getRuleIndex() const {
  return MySqlParser::RuleInsertStatement;
}

void MySqlParser::InsertStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertStatement(this);
}

void MySqlParser::InsertStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertStatement(this);
}


std::any MySqlParser::InsertStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitInsertStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::InsertStatementContext* MySqlParser::insertStatement() {
  InsertStatementContext *_localctx = _tracker.createInstance<InsertStatementContext>(_ctx, getState());
  enterRule(_localctx, 190, MySqlParser::RuleInsertStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3168);
    match(MySqlParser::INSERT);
    setState(3170);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 43) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 43)) & -9223372032559808511) != 0)) {
      setState(3169);
      antlrcpp::downCast<InsertStatementContext *>(_localctx)->priority = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 43) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 43)) & -9223372032559808511) != 0))) {
        antlrcpp::downCast<InsertStatementContext *>(_localctx)->priority = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3173);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IGNORE) {
      setState(3172);
      match(MySqlParser::IGNORE);
    }
    setState(3176);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::INTO) {
      setState(3175);
      match(MySqlParser::INTO);
    }
    setState(3178);
    tableName();
    setState(3185);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::PARTITION) {
      setState(3179);
      match(MySqlParser::PARTITION);
      setState(3180);
      match(MySqlParser::LR_BRACKET);
      setState(3182);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
        setState(3181);
        antlrcpp::downCast<InsertStatementContext *>(_localctx)->partitions = uidList();
      }
      setState(3184);
      match(MySqlParser::RR_BRACKET);
    }
    setState(3209);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::SELECT:
      case MySqlParser::VALUES:
      case MySqlParser::VALUE:
      case MySqlParser::LR_BRACKET: {
        setState(3191);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 420, _ctx)) {
        case 1: {
          setState(3187);
          match(MySqlParser::LR_BRACKET);
          setState(3188);
          antlrcpp::downCast<InsertStatementContext *>(_localctx)->columns = fullColumnNameList();
          setState(3189);
          match(MySqlParser::RR_BRACKET);
          break;
        }

        default:
          break;
        }
        setState(3193);
        insertStatementValue();
        setState(3198);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx)) {
        case 1: {
          setState(3195);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::AS) {
            setState(3194);
            match(MySqlParser::AS);
          }
          setState(3197);
          uid();
          break;
        }

        default:
          break;
        }
        break;
      }

      case MySqlParser::SET: {
        setState(3200);
        match(MySqlParser::SET);
        setState(3201);
        antlrcpp::downCast<InsertStatementContext *>(_localctx)->setFirst = updatedElement();
        setState(3206);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(3202);
          match(MySqlParser::COMMA);
          setState(3203);
          antlrcpp::downCast<InsertStatementContext *>(_localctx)->updatedElementContext = updatedElement();
          antlrcpp::downCast<InsertStatementContext *>(_localctx)->setElements.push_back(antlrcpp::downCast<InsertStatementContext *>(_localctx)->updatedElementContext);
          setState(3208);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3223);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ON) {
      setState(3211);
      match(MySqlParser::ON);
      setState(3212);
      match(MySqlParser::DUPLICATE);
      setState(3213);
      match(MySqlParser::KEY);
      setState(3214);
      match(MySqlParser::UPDATE);
      setState(3215);
      antlrcpp::downCast<InsertStatementContext *>(_localctx)->duplicatedFirst = updatedElement();
      setState(3220);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(3216);
        match(MySqlParser::COMMA);
        setState(3217);
        antlrcpp::downCast<InsertStatementContext *>(_localctx)->updatedElementContext = updatedElement();
        antlrcpp::downCast<InsertStatementContext *>(_localctx)->duplicatedElements.push_back(antlrcpp::downCast<InsertStatementContext *>(_localctx)->updatedElementContext);
        setState(3222);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadDataStatementContext ------------------------------------------------------------------

MySqlParser::LoadDataStatementContext::LoadDataStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::LOAD() {
  return getToken(MySqlParser::LOAD, 0);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::DATA() {
  return getToken(MySqlParser::DATA, 0);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::INFILE() {
  return getToken(MySqlParser::INFILE, 0);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::INTO() {
  return getToken(MySqlParser::INTO, 0);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

MySqlParser::TableNameContext* MySqlParser::LoadDataStatementContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::LOCAL() {
  return getToken(MySqlParser::LOCAL, 0);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadDataStatementContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

MySqlParser::UidListContext* MySqlParser::LoadDataStatementContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadDataStatementContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::CHARACTER() {
  return getToken(MySqlParser::CHARACTER, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadDataStatementContext::SET() {
  return getTokens(MySqlParser::SET);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::SET(size_t i) {
  return getToken(MySqlParser::SET, i);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadDataStatementContext::LINES() {
  return getTokens(MySqlParser::LINES);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::LINES(size_t i) {
  return getToken(MySqlParser::LINES, i);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadDataStatementContext::IGNORE() {
  return getTokens(MySqlParser::IGNORE);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::IGNORE(size_t i) {
  return getToken(MySqlParser::IGNORE, i);
}

MySqlParser::DecimalLiteralContext* MySqlParser::LoadDataStatementContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

std::vector<MySqlParser::AssignmentFieldContext *> MySqlParser::LoadDataStatementContext::assignmentField() {
  return getRuleContexts<MySqlParser::AssignmentFieldContext>();
}

MySqlParser::AssignmentFieldContext* MySqlParser::LoadDataStatementContext::assignmentField(size_t i) {
  return getRuleContext<MySqlParser::AssignmentFieldContext>(i);
}

std::vector<MySqlParser::UpdatedElementContext *> MySqlParser::LoadDataStatementContext::updatedElement() {
  return getRuleContexts<MySqlParser::UpdatedElementContext>();
}

MySqlParser::UpdatedElementContext* MySqlParser::LoadDataStatementContext::updatedElement(size_t i) {
  return getRuleContext<MySqlParser::UpdatedElementContext>(i);
}

MySqlParser::CharsetNameContext* MySqlParser::LoadDataStatementContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::LOW_PRIORITY() {
  return getToken(MySqlParser::LOW_PRIORITY, 0);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::CONCURRENT() {
  return getToken(MySqlParser::CONCURRENT, 0);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::REPLACE() {
  return getToken(MySqlParser::REPLACE, 0);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::FIELDS() {
  return getToken(MySqlParser::FIELDS, 0);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::COLUMNS() {
  return getToken(MySqlParser::COLUMNS, 0);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::ROWS() {
  return getToken(MySqlParser::ROWS, 0);
}

std::vector<MySqlParser::SelectFieldsIntoContext *> MySqlParser::LoadDataStatementContext::selectFieldsInto() {
  return getRuleContexts<MySqlParser::SelectFieldsIntoContext>();
}

MySqlParser::SelectFieldsIntoContext* MySqlParser::LoadDataStatementContext::selectFieldsInto(size_t i) {
  return getRuleContext<MySqlParser::SelectFieldsIntoContext>(i);
}

std::vector<MySqlParser::SelectLinesIntoContext *> MySqlParser::LoadDataStatementContext::selectLinesInto() {
  return getRuleContexts<MySqlParser::SelectLinesIntoContext>();
}

MySqlParser::SelectLinesIntoContext* MySqlParser::LoadDataStatementContext::selectLinesInto(size_t i) {
  return getRuleContext<MySqlParser::SelectLinesIntoContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadDataStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::LoadDataStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::LoadDataStatementContext::getRuleIndex() const {
  return MySqlParser::RuleLoadDataStatement;
}

void MySqlParser::LoadDataStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadDataStatement(this);
}

void MySqlParser::LoadDataStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadDataStatement(this);
}


std::any MySqlParser::LoadDataStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLoadDataStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LoadDataStatementContext* MySqlParser::loadDataStatement() {
  LoadDataStatementContext *_localctx = _tracker.createInstance<LoadDataStatementContext>(_ctx, getState());
  enterRule(_localctx, 192, MySqlParser::RuleLoadDataStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3225);
    match(MySqlParser::LOAD);
    setState(3226);
    match(MySqlParser::DATA);
    setState(3228);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LOW_PRIORITY || _la == MySqlParser::CONCURRENT) {
      setState(3227);
      antlrcpp::downCast<LoadDataStatementContext *>(_localctx)->priority = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::LOW_PRIORITY || _la == MySqlParser::CONCURRENT)) {
        antlrcpp::downCast<LoadDataStatementContext *>(_localctx)->priority = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3231);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LOCAL) {
      setState(3230);
      match(MySqlParser::LOCAL);
    }
    setState(3233);
    match(MySqlParser::INFILE);
    setState(3234);
    antlrcpp::downCast<LoadDataStatementContext *>(_localctx)->filename = match(MySqlParser::STRING_LITERAL);
    setState(3236);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IGNORE

    || _la == MySqlParser::REPLACE) {
      setState(3235);
      antlrcpp::downCast<LoadDataStatementContext *>(_localctx)->violation = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::IGNORE

      || _la == MySqlParser::REPLACE)) {
        antlrcpp::downCast<LoadDataStatementContext *>(_localctx)->violation = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3238);
    match(MySqlParser::INTO);
    setState(3239);
    match(MySqlParser::TABLE);
    setState(3240);
    tableName();
    setState(3246);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::PARTITION) {
      setState(3241);
      match(MySqlParser::PARTITION);
      setState(3242);
      match(MySqlParser::LR_BRACKET);
      setState(3243);
      uidList();
      setState(3244);
      match(MySqlParser::RR_BRACKET);
    }
    setState(3251);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::CHARACTER) {
      setState(3248);
      match(MySqlParser::CHARACTER);
      setState(3249);
      match(MySqlParser::SET);
      setState(3250);
      antlrcpp::downCast<LoadDataStatementContext *>(_localctx)->charset = charsetName();
    }
    setState(3259);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::COLUMNS

    || _la == MySqlParser::FIELDS) {
      setState(3253);
      antlrcpp::downCast<LoadDataStatementContext *>(_localctx)->fieldsFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::COLUMNS

      || _la == MySqlParser::FIELDS)) {
        antlrcpp::downCast<LoadDataStatementContext *>(_localctx)->fieldsFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3255); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(3254);
        selectFieldsInto();
        setState(3257); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MySqlParser::ENCLOSED

      || _la == MySqlParser::ESCAPED || _la == MySqlParser::OPTIONALLY

      || _la == MySqlParser::TERMINATED);
    }
    setState(3267);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LINES) {
      setState(3261);
      match(MySqlParser::LINES);
      setState(3263); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(3262);
        selectLinesInto();
        setState(3265); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MySqlParser::STARTING

      || _la == MySqlParser::TERMINATED);
    }
    setState(3273);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IGNORE) {
      setState(3269);
      match(MySqlParser::IGNORE);
      setState(3270);
      decimalLiteral();
      setState(3271);
      antlrcpp::downCast<LoadDataStatementContext *>(_localctx)->linesFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::LINES || _la == MySqlParser::ROWS)) {
        antlrcpp::downCast<LoadDataStatementContext *>(_localctx)->linesFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3286);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 438, _ctx)) {
    case 1: {
      setState(3275);
      match(MySqlParser::LR_BRACKET);
      setState(3276);
      assignmentField();
      setState(3281);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(3277);
        match(MySqlParser::COMMA);
        setState(3278);
        assignmentField();
        setState(3283);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3284);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(3297);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx)) {
    case 1: {
      setState(3288);
      match(MySqlParser::SET);
      setState(3289);
      updatedElement();
      setState(3294);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(3290);
        match(MySqlParser::COMMA);
        setState(3291);
        updatedElement();
        setState(3296);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadXmlStatementContext ------------------------------------------------------------------

MySqlParser::LoadXmlStatementContext::LoadXmlStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::LOAD() {
  return getToken(MySqlParser::LOAD, 0);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::XML() {
  return getToken(MySqlParser::XML, 0);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::INFILE() {
  return getToken(MySqlParser::INFILE, 0);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::INTO() {
  return getToken(MySqlParser::INTO, 0);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

MySqlParser::TableNameContext* MySqlParser::LoadXmlStatementContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadXmlStatementContext::STRING_LITERAL() {
  return getTokens(MySqlParser::STRING_LITERAL);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::STRING_LITERAL(size_t i) {
  return getToken(MySqlParser::STRING_LITERAL, i);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::LOCAL() {
  return getToken(MySqlParser::LOCAL, 0);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::CHARACTER() {
  return getToken(MySqlParser::CHARACTER, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadXmlStatementContext::SET() {
  return getTokens(MySqlParser::SET);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::SET(size_t i) {
  return getToken(MySqlParser::SET, i);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadXmlStatementContext::ROWS() {
  return getTokens(MySqlParser::ROWS);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::ROWS(size_t i) {
  return getToken(MySqlParser::ROWS, i);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::IDENTIFIED() {
  return getToken(MySqlParser::IDENTIFIED, 0);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::BY() {
  return getToken(MySqlParser::BY, 0);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::LESS_SYMBOL() {
  return getToken(MySqlParser::LESS_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::GREATER_SYMBOL() {
  return getToken(MySqlParser::GREATER_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadXmlStatementContext::IGNORE() {
  return getTokens(MySqlParser::IGNORE);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::IGNORE(size_t i) {
  return getToken(MySqlParser::IGNORE, i);
}

MySqlParser::DecimalLiteralContext* MySqlParser::LoadXmlStatementContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::AssignmentFieldContext *> MySqlParser::LoadXmlStatementContext::assignmentField() {
  return getRuleContexts<MySqlParser::AssignmentFieldContext>();
}

MySqlParser::AssignmentFieldContext* MySqlParser::LoadXmlStatementContext::assignmentField(size_t i) {
  return getRuleContext<MySqlParser::AssignmentFieldContext>(i);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<MySqlParser::UpdatedElementContext *> MySqlParser::LoadXmlStatementContext::updatedElement() {
  return getRuleContexts<MySqlParser::UpdatedElementContext>();
}

MySqlParser::UpdatedElementContext* MySqlParser::LoadXmlStatementContext::updatedElement(size_t i) {
  return getRuleContext<MySqlParser::UpdatedElementContext>(i);
}

MySqlParser::CharsetNameContext* MySqlParser::LoadXmlStatementContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::LOW_PRIORITY() {
  return getToken(MySqlParser::LOW_PRIORITY, 0);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::CONCURRENT() {
  return getToken(MySqlParser::CONCURRENT, 0);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::REPLACE() {
  return getToken(MySqlParser::REPLACE, 0);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::LINES() {
  return getToken(MySqlParser::LINES, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadXmlStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::LoadXmlStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::LoadXmlStatementContext::getRuleIndex() const {
  return MySqlParser::RuleLoadXmlStatement;
}

void MySqlParser::LoadXmlStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadXmlStatement(this);
}

void MySqlParser::LoadXmlStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadXmlStatement(this);
}


std::any MySqlParser::LoadXmlStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLoadXmlStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LoadXmlStatementContext* MySqlParser::loadXmlStatement() {
  LoadXmlStatementContext *_localctx = _tracker.createInstance<LoadXmlStatementContext>(_ctx, getState());
  enterRule(_localctx, 194, MySqlParser::RuleLoadXmlStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3299);
    match(MySqlParser::LOAD);
    setState(3300);
    match(MySqlParser::XML);
    setState(3302);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LOW_PRIORITY || _la == MySqlParser::CONCURRENT) {
      setState(3301);
      antlrcpp::downCast<LoadXmlStatementContext *>(_localctx)->priority = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::LOW_PRIORITY || _la == MySqlParser::CONCURRENT)) {
        antlrcpp::downCast<LoadXmlStatementContext *>(_localctx)->priority = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3305);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LOCAL) {
      setState(3304);
      match(MySqlParser::LOCAL);
    }
    setState(3307);
    match(MySqlParser::INFILE);
    setState(3308);
    antlrcpp::downCast<LoadXmlStatementContext *>(_localctx)->filename = match(MySqlParser::STRING_LITERAL);
    setState(3310);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IGNORE

    || _la == MySqlParser::REPLACE) {
      setState(3309);
      antlrcpp::downCast<LoadXmlStatementContext *>(_localctx)->violation = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::IGNORE

      || _la == MySqlParser::REPLACE)) {
        antlrcpp::downCast<LoadXmlStatementContext *>(_localctx)->violation = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3312);
    match(MySqlParser::INTO);
    setState(3313);
    match(MySqlParser::TABLE);
    setState(3314);
    tableName();
    setState(3318);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::CHARACTER) {
      setState(3315);
      match(MySqlParser::CHARACTER);
      setState(3316);
      match(MySqlParser::SET);
      setState(3317);
      antlrcpp::downCast<LoadXmlStatementContext *>(_localctx)->charset = charsetName();
    }
    setState(3326);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ROWS) {
      setState(3320);
      match(MySqlParser::ROWS);
      setState(3321);
      match(MySqlParser::IDENTIFIED);
      setState(3322);
      match(MySqlParser::BY);
      setState(3323);
      match(MySqlParser::LESS_SYMBOL);
      setState(3324);
      antlrcpp::downCast<LoadXmlStatementContext *>(_localctx)->tag = match(MySqlParser::STRING_LITERAL);
      setState(3325);
      match(MySqlParser::GREATER_SYMBOL);
    }
    setState(3332);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IGNORE) {
      setState(3328);
      match(MySqlParser::IGNORE);
      setState(3329);
      decimalLiteral();
      setState(3330);
      antlrcpp::downCast<LoadXmlStatementContext *>(_localctx)->linesFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::LINES || _la == MySqlParser::ROWS)) {
        antlrcpp::downCast<LoadXmlStatementContext *>(_localctx)->linesFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3345);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx)) {
    case 1: {
      setState(3334);
      match(MySqlParser::LR_BRACKET);
      setState(3335);
      assignmentField();
      setState(3340);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(3336);
        match(MySqlParser::COMMA);
        setState(3337);
        assignmentField();
        setState(3342);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3343);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(3356);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 450, _ctx)) {
    case 1: {
      setState(3347);
      match(MySqlParser::SET);
      setState(3348);
      updatedElement();
      setState(3353);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(3349);
        match(MySqlParser::COMMA);
        setState(3350);
        updatedElement();
        setState(3355);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplaceStatementContext ------------------------------------------------------------------

MySqlParser::ReplaceStatementContext::ReplaceStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ReplaceStatementContext::REPLACE() {
  return getToken(MySqlParser::REPLACE, 0);
}

MySqlParser::TableNameContext* MySqlParser::ReplaceStatementContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

MySqlParser::InsertStatementValueContext* MySqlParser::ReplaceStatementContext::insertStatementValue() {
  return getRuleContext<MySqlParser::InsertStatementValueContext>(0);
}

tree::TerminalNode* MySqlParser::ReplaceStatementContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::ReplaceStatementContext::INTO() {
  return getToken(MySqlParser::INTO, 0);
}

tree::TerminalNode* MySqlParser::ReplaceStatementContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::ReplaceStatementContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::ReplaceStatementContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> MySqlParser::ReplaceStatementContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::ReplaceStatementContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

std::vector<MySqlParser::UpdatedElementContext *> MySqlParser::ReplaceStatementContext::updatedElement() {
  return getRuleContexts<MySqlParser::UpdatedElementContext>();
}

MySqlParser::UpdatedElementContext* MySqlParser::ReplaceStatementContext::updatedElement(size_t i) {
  return getRuleContext<MySqlParser::UpdatedElementContext>(i);
}

std::vector<MySqlParser::UidListContext *> MySqlParser::ReplaceStatementContext::uidList() {
  return getRuleContexts<MySqlParser::UidListContext>();
}

MySqlParser::UidListContext* MySqlParser::ReplaceStatementContext::uidList(size_t i) {
  return getRuleContext<MySqlParser::UidListContext>(i);
}

tree::TerminalNode* MySqlParser::ReplaceStatementContext::LOW_PRIORITY() {
  return getToken(MySqlParser::LOW_PRIORITY, 0);
}

tree::TerminalNode* MySqlParser::ReplaceStatementContext::DELAYED() {
  return getToken(MySqlParser::DELAYED, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::ReplaceStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::ReplaceStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::ReplaceStatementContext::getRuleIndex() const {
  return MySqlParser::RuleReplaceStatement;
}

void MySqlParser::ReplaceStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplaceStatement(this);
}

void MySqlParser::ReplaceStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplaceStatement(this);
}


std::any MySqlParser::ReplaceStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitReplaceStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ReplaceStatementContext* MySqlParser::replaceStatement() {
  ReplaceStatementContext *_localctx = _tracker.createInstance<ReplaceStatementContext>(_ctx, getState());
  enterRule(_localctx, 196, MySqlParser::RuleReplaceStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3358);
    match(MySqlParser::REPLACE);
    setState(3360);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::DELAYED

    || _la == MySqlParser::LOW_PRIORITY) {
      setState(3359);
      antlrcpp::downCast<ReplaceStatementContext *>(_localctx)->priority = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DELAYED

      || _la == MySqlParser::LOW_PRIORITY)) {
        antlrcpp::downCast<ReplaceStatementContext *>(_localctx)->priority = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3363);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::INTO) {
      setState(3362);
      match(MySqlParser::INTO);
    }
    setState(3365);
    tableName();
    setState(3371);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::PARTITION) {
      setState(3366);
      match(MySqlParser::PARTITION);
      setState(3367);
      match(MySqlParser::LR_BRACKET);
      setState(3368);
      antlrcpp::downCast<ReplaceStatementContext *>(_localctx)->partitions = uidList();
      setState(3369);
      match(MySqlParser::RR_BRACKET);
    }
    setState(3389);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::SELECT:
      case MySqlParser::VALUES:
      case MySqlParser::VALUE:
      case MySqlParser::LR_BRACKET: {
        setState(3377);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 454, _ctx)) {
        case 1: {
          setState(3373);
          match(MySqlParser::LR_BRACKET);
          setState(3374);
          antlrcpp::downCast<ReplaceStatementContext *>(_localctx)->columns = uidList();
          setState(3375);
          match(MySqlParser::RR_BRACKET);
          break;
        }

        default:
          break;
        }
        setState(3379);
        insertStatementValue();
        break;
      }

      case MySqlParser::SET: {
        setState(3380);
        match(MySqlParser::SET);
        setState(3381);
        antlrcpp::downCast<ReplaceStatementContext *>(_localctx)->setFirst = updatedElement();
        setState(3386);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(3382);
          match(MySqlParser::COMMA);
          setState(3383);
          antlrcpp::downCast<ReplaceStatementContext *>(_localctx)->updatedElementContext = updatedElement();
          antlrcpp::downCast<ReplaceStatementContext *>(_localctx)->setElements.push_back(antlrcpp::downCast<ReplaceStatementContext *>(_localctx)->updatedElementContext);
          setState(3388);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectStatementContext ------------------------------------------------------------------

MySqlParser::SelectStatementContext::SelectStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::SelectStatementContext::getRuleIndex() const {
  return MySqlParser::RuleSelectStatement;
}

void MySqlParser::SelectStatementContext::copyFrom(SelectStatementContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- UnionSelectContext ------------------------------------------------------------------

MySqlParser::QuerySpecificationNointoContext* MySqlParser::UnionSelectContext::querySpecificationNointo() {
  return getRuleContext<MySqlParser::QuerySpecificationNointoContext>(0);
}

std::vector<MySqlParser::UnionStatementContext *> MySqlParser::UnionSelectContext::unionStatement() {
  return getRuleContexts<MySqlParser::UnionStatementContext>();
}

MySqlParser::UnionStatementContext* MySqlParser::UnionSelectContext::unionStatement(size_t i) {
  return getRuleContext<MySqlParser::UnionStatementContext>(i);
}

tree::TerminalNode* MySqlParser::UnionSelectContext::UNION() {
  return getToken(MySqlParser::UNION, 0);
}

MySqlParser::OrderByClauseContext* MySqlParser::UnionSelectContext::orderByClause() {
  return getRuleContext<MySqlParser::OrderByClauseContext>(0);
}

MySqlParser::LimitClauseContext* MySqlParser::UnionSelectContext::limitClause() {
  return getRuleContext<MySqlParser::LimitClauseContext>(0);
}

MySqlParser::LockClauseContext* MySqlParser::UnionSelectContext::lockClause() {
  return getRuleContext<MySqlParser::LockClauseContext>(0);
}

MySqlParser::QuerySpecificationContext* MySqlParser::UnionSelectContext::querySpecification() {
  return getRuleContext<MySqlParser::QuerySpecificationContext>(0);
}

MySqlParser::QueryExpressionContext* MySqlParser::UnionSelectContext::queryExpression() {
  return getRuleContext<MySqlParser::QueryExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::UnionSelectContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

tree::TerminalNode* MySqlParser::UnionSelectContext::DISTINCT() {
  return getToken(MySqlParser::DISTINCT, 0);
}

MySqlParser::UnionSelectContext::UnionSelectContext(SelectStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::UnionSelectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnionSelect(this);
}
void MySqlParser::UnionSelectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnionSelect(this);
}

std::any MySqlParser::UnionSelectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUnionSelect(this);
  else
    return visitor->visitChildren(this);
}
//----------------- UnionParenthesisSelectContext ------------------------------------------------------------------

MySqlParser::QueryExpressionNointoContext* MySqlParser::UnionParenthesisSelectContext::queryExpressionNointo() {
  return getRuleContext<MySqlParser::QueryExpressionNointoContext>(0);
}

std::vector<MySqlParser::UnionParenthesisContext *> MySqlParser::UnionParenthesisSelectContext::unionParenthesis() {
  return getRuleContexts<MySqlParser::UnionParenthesisContext>();
}

MySqlParser::UnionParenthesisContext* MySqlParser::UnionParenthesisSelectContext::unionParenthesis(size_t i) {
  return getRuleContext<MySqlParser::UnionParenthesisContext>(i);
}

tree::TerminalNode* MySqlParser::UnionParenthesisSelectContext::UNION() {
  return getToken(MySqlParser::UNION, 0);
}

MySqlParser::QueryExpressionContext* MySqlParser::UnionParenthesisSelectContext::queryExpression() {
  return getRuleContext<MySqlParser::QueryExpressionContext>(0);
}

MySqlParser::OrderByClauseContext* MySqlParser::UnionParenthesisSelectContext::orderByClause() {
  return getRuleContext<MySqlParser::OrderByClauseContext>(0);
}

MySqlParser::LimitClauseContext* MySqlParser::UnionParenthesisSelectContext::limitClause() {
  return getRuleContext<MySqlParser::LimitClauseContext>(0);
}

MySqlParser::LockClauseContext* MySqlParser::UnionParenthesisSelectContext::lockClause() {
  return getRuleContext<MySqlParser::LockClauseContext>(0);
}

tree::TerminalNode* MySqlParser::UnionParenthesisSelectContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

tree::TerminalNode* MySqlParser::UnionParenthesisSelectContext::DISTINCT() {
  return getToken(MySqlParser::DISTINCT, 0);
}

MySqlParser::UnionParenthesisSelectContext::UnionParenthesisSelectContext(SelectStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::UnionParenthesisSelectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnionParenthesisSelect(this);
}
void MySqlParser::UnionParenthesisSelectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnionParenthesisSelect(this);
}

std::any MySqlParser::UnionParenthesisSelectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUnionParenthesisSelect(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleSelectContext ------------------------------------------------------------------

MySqlParser::QuerySpecificationContext* MySqlParser::SimpleSelectContext::querySpecification() {
  return getRuleContext<MySqlParser::QuerySpecificationContext>(0);
}

MySqlParser::LockClauseContext* MySqlParser::SimpleSelectContext::lockClause() {
  return getRuleContext<MySqlParser::LockClauseContext>(0);
}

MySqlParser::SimpleSelectContext::SimpleSelectContext(SelectStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::SimpleSelectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleSelect(this);
}
void MySqlParser::SimpleSelectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleSelect(this);
}

std::any MySqlParser::SimpleSelectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSimpleSelect(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ParenthesisSelectContext ------------------------------------------------------------------

MySqlParser::QueryExpressionContext* MySqlParser::ParenthesisSelectContext::queryExpression() {
  return getRuleContext<MySqlParser::QueryExpressionContext>(0);
}

MySqlParser::LockClauseContext* MySqlParser::ParenthesisSelectContext::lockClause() {
  return getRuleContext<MySqlParser::LockClauseContext>(0);
}

MySqlParser::ParenthesisSelectContext::ParenthesisSelectContext(SelectStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ParenthesisSelectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenthesisSelect(this);
}
void MySqlParser::ParenthesisSelectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenthesisSelect(this);
}

std::any MySqlParser::ParenthesisSelectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitParenthesisSelect(this);
  else
    return visitor->visitChildren(this);
}
//----------------- WithLateralStatementContext ------------------------------------------------------------------

MySqlParser::QuerySpecificationNointoContext* MySqlParser::WithLateralStatementContext::querySpecificationNointo() {
  return getRuleContext<MySqlParser::QuerySpecificationNointoContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::WithLateralStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::WithLateralStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

std::vector<MySqlParser::LateralStatementContext *> MySqlParser::WithLateralStatementContext::lateralStatement() {
  return getRuleContexts<MySqlParser::LateralStatementContext>();
}

MySqlParser::LateralStatementContext* MySqlParser::WithLateralStatementContext::lateralStatement(size_t i) {
  return getRuleContext<MySqlParser::LateralStatementContext>(i);
}

MySqlParser::WithLateralStatementContext::WithLateralStatementContext(SelectStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::WithLateralStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithLateralStatement(this);
}
void MySqlParser::WithLateralStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithLateralStatement(this);
}

std::any MySqlParser::WithLateralStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitWithLateralStatement(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::SelectStatementContext* MySqlParser::selectStatement() {
  SelectStatementContext *_localctx = _tracker.createInstance<SelectStatementContext>(_ctx, getState());
  enterRule(_localctx, 198, MySqlParser::RuleSelectStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(3453);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 473, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::SimpleSelectContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(3391);
      querySpecification();
      setState(3393);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 457, _ctx)) {
      case 1: {
        setState(3392);
        lockClause();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::ParenthesisSelectContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(3395);
      queryExpression();
      setState(3397);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 458, _ctx)) {
      case 1: {
        setState(3396);
        lockClause();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::UnionSelectContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(3399);
      querySpecificationNointo();
      setState(3401); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(3400);
                unionStatement();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(3403); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 459, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(3413);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::UNION) {
        setState(3405);
        match(MySqlParser::UNION);
        setState(3407);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::ALL

        || _la == MySqlParser::DISTINCT) {
          setState(3406);
          antlrcpp::downCast<UnionSelectContext *>(_localctx)->unionType = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::ALL

          || _la == MySqlParser::DISTINCT)) {
            antlrcpp::downCast<UnionSelectContext *>(_localctx)->unionType = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(3411);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::SELECT: {
            setState(3409);
            querySpecification();
            break;
          }

          case MySqlParser::LR_BRACKET: {
            setState(3410);
            queryExpression();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
      }
      setState(3416);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 463, _ctx)) {
      case 1: {
        setState(3415);
        orderByClause();
        break;
      }

      default:
        break;
      }
      setState(3419);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LIMIT) {
        setState(3418);
        limitClause();
      }
      setState(3422);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 465, _ctx)) {
      case 1: {
        setState(3421);
        lockClause();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::UnionParenthesisSelectContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(3424);
      queryExpressionNointo();
      setState(3426); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(3425);
                unionParenthesis();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(3428); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 466, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(3435);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::UNION) {
        setState(3430);
        match(MySqlParser::UNION);
        setState(3432);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::ALL

        || _la == MySqlParser::DISTINCT) {
          setState(3431);
          antlrcpp::downCast<UnionParenthesisSelectContext *>(_localctx)->unionType = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::ALL

          || _la == MySqlParser::DISTINCT)) {
            antlrcpp::downCast<UnionParenthesisSelectContext *>(_localctx)->unionType = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(3434);
        queryExpression();
      }
      setState(3438);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 469, _ctx)) {
      case 1: {
        setState(3437);
        orderByClause();
        break;
      }

      default:
        break;
      }
      setState(3441);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LIMIT) {
        setState(3440);
        limitClause();
      }
      setState(3444);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 471, _ctx)) {
      case 1: {
        setState(3443);
        lockClause();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<MySqlParser::WithLateralStatementContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(3446);
      querySpecificationNointo();
      setState(3449); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(3447);
        match(MySqlParser::COMMA);
        setState(3448);
        lateralStatement();
        setState(3451); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MySqlParser::COMMA);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateStatementContext ------------------------------------------------------------------

MySqlParser::UpdateStatementContext::UpdateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::SingleUpdateStatementContext* MySqlParser::UpdateStatementContext::singleUpdateStatement() {
  return getRuleContext<MySqlParser::SingleUpdateStatementContext>(0);
}

MySqlParser::MultipleUpdateStatementContext* MySqlParser::UpdateStatementContext::multipleUpdateStatement() {
  return getRuleContext<MySqlParser::MultipleUpdateStatementContext>(0);
}


size_t MySqlParser::UpdateStatementContext::getRuleIndex() const {
  return MySqlParser::RuleUpdateStatement;
}

void MySqlParser::UpdateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdateStatement(this);
}

void MySqlParser::UpdateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdateStatement(this);
}


std::any MySqlParser::UpdateStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUpdateStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UpdateStatementContext* MySqlParser::updateStatement() {
  UpdateStatementContext *_localctx = _tracker.createInstance<UpdateStatementContext>(_ctx, getState());
  enterRule(_localctx, 200, MySqlParser::RuleUpdateStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3457);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 474, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3455);
      singleUpdateStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3456);
      multipleUpdateStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValuesStatementContext ------------------------------------------------------------------

MySqlParser::ValuesStatementContext::ValuesStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ValuesStatementContext::VALUES() {
  return getToken(MySqlParser::VALUES, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::ValuesStatementContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::ValuesStatementContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> MySqlParser::ValuesStatementContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::ValuesStatementContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

std::vector<MySqlParser::ExpressionsWithDefaultsContext *> MySqlParser::ValuesStatementContext::expressionsWithDefaults() {
  return getRuleContexts<MySqlParser::ExpressionsWithDefaultsContext>();
}

MySqlParser::ExpressionsWithDefaultsContext* MySqlParser::ValuesStatementContext::expressionsWithDefaults(size_t i) {
  return getRuleContext<MySqlParser::ExpressionsWithDefaultsContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::ValuesStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::ValuesStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::ValuesStatementContext::getRuleIndex() const {
  return MySqlParser::RuleValuesStatement;
}

void MySqlParser::ValuesStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValuesStatement(this);
}

void MySqlParser::ValuesStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValuesStatement(this);
}


std::any MySqlParser::ValuesStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitValuesStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ValuesStatementContext* MySqlParser::valuesStatement() {
  ValuesStatementContext *_localctx = _tracker.createInstance<ValuesStatementContext>(_ctx, getState());
  enterRule(_localctx, 202, MySqlParser::RuleValuesStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3459);
    match(MySqlParser::VALUES);
    setState(3460);
    match(MySqlParser::LR_BRACKET);
    setState(3462);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 475, _ctx)) {
    case 1: {
      setState(3461);
      expressionsWithDefaults();
      break;
    }

    default:
      break;
    }
    setState(3464);
    match(MySqlParser::RR_BRACKET);
    setState(3473);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(3465);
      match(MySqlParser::COMMA);
      setState(3466);
      match(MySqlParser::LR_BRACKET);
      setState(3468);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 476, _ctx)) {
      case 1: {
        setState(3467);
        expressionsWithDefaults();
        break;
      }

      default:
        break;
      }
      setState(3470);
      match(MySqlParser::RR_BRACKET);
      setState(3475);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertStatementValueContext ------------------------------------------------------------------

MySqlParser::InsertStatementValueContext::InsertStatementValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::SelectStatementContext* MySqlParser::InsertStatementValueContext::selectStatement() {
  return getRuleContext<MySqlParser::SelectStatementContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::InsertStatementValueContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::InsertStatementValueContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> MySqlParser::InsertStatementValueContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::InsertStatementValueContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

tree::TerminalNode* MySqlParser::InsertStatementValueContext::VALUES() {
  return getToken(MySqlParser::VALUES, 0);
}

tree::TerminalNode* MySqlParser::InsertStatementValueContext::VALUE() {
  return getToken(MySqlParser::VALUE, 0);
}

std::vector<MySqlParser::ExpressionsWithDefaultsContext *> MySqlParser::InsertStatementValueContext::expressionsWithDefaults() {
  return getRuleContexts<MySqlParser::ExpressionsWithDefaultsContext>();
}

MySqlParser::ExpressionsWithDefaultsContext* MySqlParser::InsertStatementValueContext::expressionsWithDefaults(size_t i) {
  return getRuleContext<MySqlParser::ExpressionsWithDefaultsContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::InsertStatementValueContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::InsertStatementValueContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::InsertStatementValueContext::getRuleIndex() const {
  return MySqlParser::RuleInsertStatementValue;
}

void MySqlParser::InsertStatementValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertStatementValue(this);
}

void MySqlParser::InsertStatementValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertStatementValue(this);
}


std::any MySqlParser::InsertStatementValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitInsertStatementValue(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::InsertStatementValueContext* MySqlParser::insertStatementValue() {
  InsertStatementValueContext *_localctx = _tracker.createInstance<InsertStatementValueContext>(_ctx, getState());
  enterRule(_localctx, 204, MySqlParser::RuleInsertStatementValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3494);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::SELECT:
      case MySqlParser::LR_BRACKET: {
        enterOuterAlt(_localctx, 1);
        setState(3476);
        selectStatement();
        break;
      }

      case MySqlParser::VALUES:
      case MySqlParser::VALUE: {
        enterOuterAlt(_localctx, 2);
        setState(3477);
        antlrcpp::downCast<InsertStatementValueContext *>(_localctx)->insertFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::VALUES || _la == MySqlParser::VALUE)) {
          antlrcpp::downCast<InsertStatementValueContext *>(_localctx)->insertFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3478);
        match(MySqlParser::LR_BRACKET);
        setState(3480);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 478, _ctx)) {
        case 1: {
          setState(3479);
          expressionsWithDefaults();
          break;
        }

        default:
          break;
        }
        setState(3482);
        match(MySqlParser::RR_BRACKET);
        setState(3491);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(3483);
          match(MySqlParser::COMMA);
          setState(3484);
          match(MySqlParser::LR_BRACKET);
          setState(3486);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 479, _ctx)) {
          case 1: {
            setState(3485);
            expressionsWithDefaults();
            break;
          }

          default:
            break;
          }
          setState(3488);
          match(MySqlParser::RR_BRACKET);
          setState(3493);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdatedElementContext ------------------------------------------------------------------

MySqlParser::UpdatedElementContext::UpdatedElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::FullColumnNameContext* MySqlParser::UpdatedElementContext::fullColumnName() {
  return getRuleContext<MySqlParser::FullColumnNameContext>(0);
}

tree::TerminalNode* MySqlParser::UpdatedElementContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::ExpressionContext* MySqlParser::UpdatedElementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::UpdatedElementContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}


size_t MySqlParser::UpdatedElementContext::getRuleIndex() const {
  return MySqlParser::RuleUpdatedElement;
}

void MySqlParser::UpdatedElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdatedElement(this);
}

void MySqlParser::UpdatedElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdatedElement(this);
}


std::any MySqlParser::UpdatedElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUpdatedElement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UpdatedElementContext* MySqlParser::updatedElement() {
  UpdatedElementContext *_localctx = _tracker.createInstance<UpdatedElementContext>(_ctx, getState());
  enterRule(_localctx, 206, MySqlParser::RuleUpdatedElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3496);
    fullColumnName();
    setState(3497);
    match(MySqlParser::EQUAL_SYMBOL);
    setState(3500);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 482, _ctx)) {
    case 1: {
      setState(3498);
      expression(0);
      break;
    }

    case 2: {
      setState(3499);
      match(MySqlParser::DEFAULT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentFieldContext ------------------------------------------------------------------

MySqlParser::AssignmentFieldContext::AssignmentFieldContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::UidContext* MySqlParser::AssignmentFieldContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::AssignmentFieldContext::LOCAL_ID() {
  return getToken(MySqlParser::LOCAL_ID, 0);
}


size_t MySqlParser::AssignmentFieldContext::getRuleIndex() const {
  return MySqlParser::RuleAssignmentField;
}

void MySqlParser::AssignmentFieldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentField(this);
}

void MySqlParser::AssignmentFieldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentField(this);
}


std::any MySqlParser::AssignmentFieldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAssignmentField(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AssignmentFieldContext* MySqlParser::assignmentField() {
  AssignmentFieldContext *_localctx = _tracker.createInstance<AssignmentFieldContext>(_ctx, getState());
  enterRule(_localctx, 208, MySqlParser::RuleAssignmentField);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3504);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::ATTRIBUTE:
      case MySqlParser::BUCKETS:
      case MySqlParser::CONDITION:
      case MySqlParser::CURRENT:
      case MySqlParser::CURRENT_USER:
      case MySqlParser::DATABASE:
      case MySqlParser::DEFAULT:
      case MySqlParser::DIAGNOSTICS:
      case MySqlParser::EMPTY:
      case MySqlParser::ENFORCED:
      case MySqlParser::EXCEPT:
      case MySqlParser::GROUP:
      case MySqlParser::IF:
      case MySqlParser::IGNORED:
      case MySqlParser::INSERT:
      case MySqlParser::LATERAL:
      case MySqlParser::LEFT:
      case MySqlParser::NUMBER:
      case MySqlParser::OPTIONAL:
      case MySqlParser::ORDER:
      case MySqlParser::PRIMARY:
      case MySqlParser::REPLACE:
      case MySqlParser::RIGHT:
      case MySqlParser::SCHEMA:
      case MySqlParser::SKIP_QUERY_REWRITE:
      case MySqlParser::STACKED:
      case MySqlParser::DATE:
      case MySqlParser::TIME:
      case MySqlParser::TIMESTAMP:
      case MySqlParser::DATETIME:
      case MySqlParser::YEAR:
      case MySqlParser::BINARY:
      case MySqlParser::TEXT:
      case MySqlParser::ENUM:
      case MySqlParser::SERIAL:
      case MySqlParser::JSON_ARRAY:
      case MySqlParser::JSON_ARRAYAGG:
      case MySqlParser::JSON_ARRAY_APPEND:
      case MySqlParser::JSON_ARRAY_INSERT:
      case MySqlParser::JSON_CONTAINS:
      case MySqlParser::JSON_CONTAINS_PATH:
      case MySqlParser::JSON_DEPTH:
      case MySqlParser::JSON_EXTRACT:
      case MySqlParser::JSON_INSERT:
      case MySqlParser::JSON_KEYS:
      case MySqlParser::JSON_LENGTH:
      case MySqlParser::JSON_MERGE:
      case MySqlParser::JSON_MERGE_PATCH:
      case MySqlParser::JSON_MERGE_PRESERVE:
      case MySqlParser::JSON_OBJECT:
      case MySqlParser::JSON_OBJECTAGG:
      case MySqlParser::JSON_OVERLAPS:
      case MySqlParser::JSON_PRETTY:
      case MySqlParser::JSON_QUOTE:
      case MySqlParser::JSON_REMOVE:
      case MySqlParser::JSON_REPLACE:
      case MySqlParser::JSON_SCHEMA_VALID:
      case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
      case MySqlParser::JSON_SEARCH:
      case MySqlParser::JSON_SET:
      case MySqlParser::JSON_STORAGE_FREE:
      case MySqlParser::JSON_STORAGE_SIZE:
      case MySqlParser::JSON_TABLE:
      case MySqlParser::JSON_TYPE:
      case MySqlParser::JSON_UNQUOTE:
      case MySqlParser::JSON_VALID:
      case MySqlParser::JSON_VALUE:
      case MySqlParser::NESTED:
      case MySqlParser::ORDINALITY:
      case MySqlParser::PATH:
      case MySqlParser::AVG:
      case MySqlParser::BIT_AND:
      case MySqlParser::BIT_OR:
      case MySqlParser::BIT_XOR:
      case MySqlParser::COUNT:
      case MySqlParser::CUME_DIST:
      case MySqlParser::DENSE_RANK:
      case MySqlParser::FIRST_VALUE:
      case MySqlParser::GROUP_CONCAT:
      case MySqlParser::LAG:
      case MySqlParser::LAST_VALUE:
      case MySqlParser::LEAD:
      case MySqlParser::MAX:
      case MySqlParser::MIN:
      case MySqlParser::NTILE:
      case MySqlParser::NTH_VALUE:
      case MySqlParser::PERCENT_RANK:
      case MySqlParser::RANK:
      case MySqlParser::ROW_NUMBER:
      case MySqlParser::STD:
      case MySqlParser::STDDEV:
      case MySqlParser::STDDEV_POP:
      case MySqlParser::STDDEV_SAMP:
      case MySqlParser::SUM:
      case MySqlParser::VAR_POP:
      case MySqlParser::VAR_SAMP:
      case MySqlParser::VARIANCE:
      case MySqlParser::CURRENT_DATE:
      case MySqlParser::CURRENT_TIME:
      case MySqlParser::CURRENT_TIMESTAMP:
      case MySqlParser::LOCALTIME:
      case MySqlParser::CURDATE:
      case MySqlParser::CURTIME:
      case MySqlParser::DATE_ADD:
      case MySqlParser::DATE_SUB:
      case MySqlParser::LOCALTIMESTAMP:
      case MySqlParser::NOW:
      case MySqlParser::POSITION:
      case MySqlParser::SUBSTR:
      case MySqlParser::SUBSTRING:
      case MySqlParser::SYSDATE:
      case MySqlParser::TRIM:
      case MySqlParser::UTC_DATE:
      case MySqlParser::UTC_TIME:
      case MySqlParser::UTC_TIMESTAMP:
      case MySqlParser::ACCOUNT:
      case MySqlParser::ACTION:
      case MySqlParser::AFTER:
      case MySqlParser::AGGREGATE:
      case MySqlParser::ALGORITHM:
      case MySqlParser::ANY:
      case MySqlParser::AT:
      case MySqlParser::AUTHORS:
      case MySqlParser::AUTOCOMMIT:
      case MySqlParser::AUTOEXTEND_SIZE:
      case MySqlParser::AUTO_INCREMENT:
      case MySqlParser::AVG_ROW_LENGTH:
      case MySqlParser::BEGIN:
      case MySqlParser::BINLOG:
      case MySqlParser::BIT:
      case MySqlParser::BLOCK:
      case MySqlParser::BOOL:
      case MySqlParser::BOOLEAN:
      case MySqlParser::BTREE:
      case MySqlParser::CACHE:
      case MySqlParser::CASCADED:
      case MySqlParser::CHAIN:
      case MySqlParser::CHANGED:
      case MySqlParser::CHANNEL:
      case MySqlParser::CHECKSUM:
      case MySqlParser::PAGE_CHECKSUM:
      case MySqlParser::CIPHER:
      case MySqlParser::CLASS_ORIGIN:
      case MySqlParser::CLIENT:
      case MySqlParser::CLOSE:
      case MySqlParser::CLUSTERING:
      case MySqlParser::COALESCE:
      case MySqlParser::CODE:
      case MySqlParser::COLUMNS:
      case MySqlParser::COLUMN_FORMAT:
      case MySqlParser::COLUMN_NAME:
      case MySqlParser::COMMENT:
      case MySqlParser::COMMIT:
      case MySqlParser::COMPACT:
      case MySqlParser::COMPLETION:
      case MySqlParser::COMPRESSED:
      case MySqlParser::COMPRESSION:
      case MySqlParser::CONCURRENT:
      case MySqlParser::CONNECT:
      case MySqlParser::CONNECTION:
      case MySqlParser::CONSISTENT:
      case MySqlParser::CONSTRAINT_CATALOG:
      case MySqlParser::CONSTRAINT_SCHEMA:
      case MySqlParser::CONSTRAINT_NAME:
      case MySqlParser::CONTAINS:
      case MySqlParser::CONTEXT:
      case MySqlParser::CONTRIBUTORS:
      case MySqlParser::COPY:
      case MySqlParser::CPU:
      case MySqlParser::CURSOR_NAME:
      case MySqlParser::DATA:
      case MySqlParser::DATAFILE:
      case MySqlParser::DEALLOCATE:
      case MySqlParser::DEFAULT_AUTH:
      case MySqlParser::DEFINER:
      case MySqlParser::DELAY_KEY_WRITE:
      case MySqlParser::DES_KEY_FILE:
      case MySqlParser::DIRECTORY:
      case MySqlParser::DISABLE:
      case MySqlParser::DISCARD:
      case MySqlParser::DISK:
      case MySqlParser::DO:
      case MySqlParser::DUMPFILE:
      case MySqlParser::DUPLICATE:
      case MySqlParser::DYNAMIC:
      case MySqlParser::ENABLE:
      case MySqlParser::ENCRYPTION:
      case MySqlParser::END:
      case MySqlParser::ENDS:
      case MySqlParser::ENGINE:
      case MySqlParser::ENGINES:
      case MySqlParser::ERROR:
      case MySqlParser::ERRORS:
      case MySqlParser::ESCAPE:
      case MySqlParser::EVEN:
      case MySqlParser::EVENT:
      case MySqlParser::EVENTS:
      case MySqlParser::EVERY:
      case MySqlParser::EXCHANGE:
      case MySqlParser::EXCLUSIVE:
      case MySqlParser::EXPIRE:
      case MySqlParser::EXPORT:
      case MySqlParser::EXTENDED:
      case MySqlParser::EXTENT_SIZE:
      case MySqlParser::FAILED_LOGIN_ATTEMPTS:
      case MySqlParser::FAST:
      case MySqlParser::FAULTS:
      case MySqlParser::FIELDS:
      case MySqlParser::FILE_BLOCK_SIZE:
      case MySqlParser::FILTER:
      case MySqlParser::FIRST:
      case MySqlParser::FIXED:
      case MySqlParser::FLUSH:
      case MySqlParser::FOLLOWS:
      case MySqlParser::FOUND:
      case MySqlParser::FULL:
      case MySqlParser::FUNCTION:
      case MySqlParser::GENERAL:
      case MySqlParser::GLOBAL:
      case MySqlParser::GRANTS:
      case MySqlParser::GROUP_REPLICATION:
      case MySqlParser::HANDLER:
      case MySqlParser::HASH:
      case MySqlParser::HELP:
      case MySqlParser::HISTORY:
      case MySqlParser::HOST:
      case MySqlParser::HOSTS:
      case MySqlParser::IDENTIFIED:
      case MySqlParser::IGNORE_SERVER_IDS:
      case MySqlParser::IMPORT:
      case MySqlParser::INDEXES:
      case MySqlParser::INITIAL_SIZE:
      case MySqlParser::INPLACE:
      case MySqlParser::INSERT_METHOD:
      case MySqlParser::INSTALL:
      case MySqlParser::INSTANCE:
      case MySqlParser::INSTANT:
      case MySqlParser::INVISIBLE:
      case MySqlParser::INVOKER:
      case MySqlParser::IO:
      case MySqlParser::IO_THREAD:
      case MySqlParser::IPC:
      case MySqlParser::ISOLATION:
      case MySqlParser::ISSUER:
      case MySqlParser::JSON:
      case MySqlParser::KEY_BLOCK_SIZE:
      case MySqlParser::LANGUAGE:
      case MySqlParser::LAST:
      case MySqlParser::LEAVES:
      case MySqlParser::LESS:
      case MySqlParser::LEVEL:
      case MySqlParser::LIST:
      case MySqlParser::LOCAL:
      case MySqlParser::LOGFILE:
      case MySqlParser::LOGS:
      case MySqlParser::MASTER:
      case MySqlParser::MASTER_AUTO_POSITION:
      case MySqlParser::MASTER_CONNECT_RETRY:
      case MySqlParser::MASTER_DELAY:
      case MySqlParser::MASTER_HEARTBEAT_PERIOD:
      case MySqlParser::MASTER_HOST:
      case MySqlParser::MASTER_LOG_FILE:
      case MySqlParser::MASTER_LOG_POS:
      case MySqlParser::MASTER_PASSWORD:
      case MySqlParser::MASTER_PORT:
      case MySqlParser::MASTER_RETRY_COUNT:
      case MySqlParser::MASTER_SSL:
      case MySqlParser::MASTER_SSL_CA:
      case MySqlParser::MASTER_SSL_CAPATH:
      case MySqlParser::MASTER_SSL_CERT:
      case MySqlParser::MASTER_SSL_CIPHER:
      case MySqlParser::MASTER_SSL_CRL:
      case MySqlParser::MASTER_SSL_CRLPATH:
      case MySqlParser::MASTER_SSL_KEY:
      case MySqlParser::MASTER_TLS_VERSION:
      case MySqlParser::MASTER_USER:
      case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
      case MySqlParser::MAX_QUERIES_PER_HOUR:
      case MySqlParser::MAX_ROWS:
      case MySqlParser::MAX_SIZE:
      case MySqlParser::MAX_UPDATES_PER_HOUR:
      case MySqlParser::MAX_USER_CONNECTIONS:
      case MySqlParser::MEDIUM:
      case MySqlParser::MEMBER:
      case MySqlParser::MERGE:
      case MySqlParser::MESSAGE_TEXT:
      case MySqlParser::MID:
      case MySqlParser::MIGRATE:
      case MySqlParser::MIN_ROWS:
      case MySqlParser::MODE:
      case MySqlParser::MODIFY:
      case MySqlParser::MUTEX:
      case MySqlParser::MYSQL:
      case MySqlParser::MYSQL_ERRNO:
      case MySqlParser::NAME:
      case MySqlParser::NAMES:
      case MySqlParser::NCHAR:
      case MySqlParser::NEVER:
      case MySqlParser::NEXT:
      case MySqlParser::NO:
      case MySqlParser::NOCOPY:
      case MySqlParser::NOWAIT:
      case MySqlParser::NODEGROUP:
      case MySqlParser::NONE:
      case MySqlParser::ODBC:
      case MySqlParser::OFFLINE:
      case MySqlParser::OFFSET:
      case MySqlParser::OF:
      case MySqlParser::OJ:
      case MySqlParser::OLD_PASSWORD:
      case MySqlParser::ONE:
      case MySqlParser::ONLINE:
      case MySqlParser::ONLY:
      case MySqlParser::OPEN:
      case MySqlParser::OPTIMIZER_COSTS:
      case MySqlParser::OPTIONS:
      case MySqlParser::OWNER:
      case MySqlParser::PACK_KEYS:
      case MySqlParser::PAGE:
      case MySqlParser::PARSER:
      case MySqlParser::PARTIAL:
      case MySqlParser::PARTITIONING:
      case MySqlParser::PARTITIONS:
      case MySqlParser::PASSWORD:
      case MySqlParser::PASSWORD_LOCK_TIME:
      case MySqlParser::PHASE:
      case MySqlParser::PLUGIN:
      case MySqlParser::PLUGIN_DIR:
      case MySqlParser::PLUGINS:
      case MySqlParser::PORT:
      case MySqlParser::PRECEDES:
      case MySqlParser::PREPARE:
      case MySqlParser::PRESERVE:
      case MySqlParser::PREV:
      case MySqlParser::PROCESSLIST:
      case MySqlParser::PROFILE:
      case MySqlParser::PROFILES:
      case MySqlParser::PROXY:
      case MySqlParser::QUERY:
      case MySqlParser::QUICK:
      case MySqlParser::REBUILD:
      case MySqlParser::RECOVER:
      case MySqlParser::RECURSIVE:
      case MySqlParser::REDO_BUFFER_SIZE:
      case MySqlParser::REDUNDANT:
      case MySqlParser::RELAY:
      case MySqlParser::RELAY_LOG_FILE:
      case MySqlParser::RELAY_LOG_POS:
      case MySqlParser::RELAYLOG:
      case MySqlParser::REMOVE:
      case MySqlParser::REORGANIZE:
      case MySqlParser::REPAIR:
      case MySqlParser::REPLICATE_DO_DB:
      case MySqlParser::REPLICATE_DO_TABLE:
      case MySqlParser::REPLICATE_IGNORE_DB:
      case MySqlParser::REPLICATE_IGNORE_TABLE:
      case MySqlParser::REPLICATE_REWRITE_DB:
      case MySqlParser::REPLICATE_WILD_DO_TABLE:
      case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySqlParser::REPLICATION:
      case MySqlParser::RESET:
      case MySqlParser::RESUME:
      case MySqlParser::RETURNED_SQLSTATE:
      case MySqlParser::RETURNS:
      case MySqlParser::REUSE:
      case MySqlParser::ROLE:
      case MySqlParser::ROLLBACK:
      case MySqlParser::ROLLUP:
      case MySqlParser::ROTATE:
      case MySqlParser::ROW:
      case MySqlParser::ROWS:
      case MySqlParser::ROW_FORMAT:
      case MySqlParser::RTREE:
      case MySqlParser::SAVEPOINT:
      case MySqlParser::SCHEDULE:
      case MySqlParser::SECURITY:
      case MySqlParser::SERVER:
      case MySqlParser::SESSION:
      case MySqlParser::SHARE:
      case MySqlParser::SHARED:
      case MySqlParser::SIGNED:
      case MySqlParser::SIMPLE:
      case MySqlParser::SLAVE:
      case MySqlParser::SLOW:
      case MySqlParser::SNAPSHOT:
      case MySqlParser::SOCKET:
      case MySqlParser::SOME:
      case MySqlParser::SONAME:
      case MySqlParser::SOUNDS:
      case MySqlParser::SOURCE:
      case MySqlParser::SQL_AFTER_GTIDS:
      case MySqlParser::SQL_AFTER_MTS_GAPS:
      case MySqlParser::SQL_BEFORE_GTIDS:
      case MySqlParser::SQL_BUFFER_RESULT:
      case MySqlParser::SQL_CACHE:
      case MySqlParser::SQL_NO_CACHE:
      case MySqlParser::SQL_THREAD:
      case MySqlParser::START:
      case MySqlParser::STARTS:
      case MySqlParser::STATS_AUTO_RECALC:
      case MySqlParser::STATS_PERSISTENT:
      case MySqlParser::STATS_SAMPLE_PAGES:
      case MySqlParser::STATUS:
      case MySqlParser::STOP:
      case MySqlParser::STORAGE:
      case MySqlParser::STRING:
      case MySqlParser::SUBCLASS_ORIGIN:
      case MySqlParser::SUBJECT:
      case MySqlParser::SUBPARTITION:
      case MySqlParser::SUBPARTITIONS:
      case MySqlParser::SUSPEND:
      case MySqlParser::SWAPS:
      case MySqlParser::SWITCHES:
      case MySqlParser::TABLE_NAME:
      case MySqlParser::TABLESPACE:
      case MySqlParser::TABLE_TYPE:
      case MySqlParser::TEMPORARY:
      case MySqlParser::TEMPTABLE:
      case MySqlParser::THAN:
      case MySqlParser::TRADITIONAL:
      case MySqlParser::TRANSACTION:
      case MySqlParser::TRANSACTIONAL:
      case MySqlParser::TRIGGERS:
      case MySqlParser::TRUNCATE:
      case MySqlParser::UNBOUNDED:
      case MySqlParser::UNDEFINED:
      case MySqlParser::UNDOFILE:
      case MySqlParser::UNDO_BUFFER_SIZE:
      case MySqlParser::UNINSTALL:
      case MySqlParser::UNKNOWN:
      case MySqlParser::UNTIL:
      case MySqlParser::UPGRADE:
      case MySqlParser::USER:
      case MySqlParser::USE_FRM:
      case MySqlParser::USER_RESOURCES:
      case MySqlParser::VALIDATION:
      case MySqlParser::VALUE:
      case MySqlParser::VARIABLES:
      case MySqlParser::VIEW:
      case MySqlParser::VIRTUAL:
      case MySqlParser::VISIBLE:
      case MySqlParser::WAIT:
      case MySqlParser::WARNINGS:
      case MySqlParser::WITHOUT:
      case MySqlParser::WORK:
      case MySqlParser::WRAPPER:
      case MySqlParser::X509:
      case MySqlParser::XA:
      case MySqlParser::XML:
      case MySqlParser::EUR:
      case MySqlParser::USA:
      case MySqlParser::JIS:
      case MySqlParser::ISO:
      case MySqlParser::INTERNAL:
      case MySqlParser::QUARTER:
      case MySqlParser::MONTH:
      case MySqlParser::DAY:
      case MySqlParser::HOUR:
      case MySqlParser::MINUTE:
      case MySqlParser::WEEK:
      case MySqlParser::SECOND:
      case MySqlParser::MICROSECOND:
      case MySqlParser::ADMIN:
      case MySqlParser::AUDIT_ABORT_EXEMPT:
      case MySqlParser::AUDIT_ADMIN:
      case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
      case MySqlParser::BACKUP_ADMIN:
      case MySqlParser::BINLOG_ADMIN:
      case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
      case MySqlParser::CLONE_ADMIN:
      case MySqlParser::CONNECTION_ADMIN:
      case MySqlParser::ENCRYPTION_KEY_ADMIN:
      case MySqlParser::EXECUTE:
      case MySqlParser::FILE:
      case MySqlParser::FIREWALL_ADMIN:
      case MySqlParser::FIREWALL_EXEMPT:
      case MySqlParser::FIREWALL_USER:
      case MySqlParser::GROUP_REPLICATION_ADMIN:
      case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
      case MySqlParser::INVOKE:
      case MySqlParser::LAMBDA:
      case MySqlParser::NDB_STORED_USER:
      case MySqlParser::PASSWORDLESS_USER_ADMIN:
      case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
      case MySqlParser::PRIVILEGES:
      case MySqlParser::PROCESS:
      case MySqlParser::RELOAD:
      case MySqlParser::REPLICATION_APPLIER:
      case MySqlParser::REPLICATION_SLAVE_ADMIN:
      case MySqlParser::RESOURCE_GROUP_ADMIN:
      case MySqlParser::RESOURCE_GROUP_USER:
      case MySqlParser::ROLE_ADMIN:
      case MySqlParser::ROUTINE:
      case MySqlParser::S3:
      case MySqlParser::SESSION_VARIABLES_ADMIN:
      case MySqlParser::SET_USER_ID:
      case MySqlParser::SHOW_ROUTINE:
      case MySqlParser::SHUTDOWN:
      case MySqlParser::SUPER:
      case MySqlParser::SYSTEM_VARIABLES_ADMIN:
      case MySqlParser::TABLES:
      case MySqlParser::TABLE_ENCRYPTION_ADMIN:
      case MySqlParser::VERSION_TOKEN_ADMIN:
      case MySqlParser::XA_RECOVER_ADMIN:
      case MySqlParser::ARMSCII8:
      case MySqlParser::ASCII:
      case MySqlParser::BIG5:
      case MySqlParser::CP1250:
      case MySqlParser::CP1251:
      case MySqlParser::CP1256:
      case MySqlParser::CP1257:
      case MySqlParser::CP850:
      case MySqlParser::CP852:
      case MySqlParser::CP866:
      case MySqlParser::CP932:
      case MySqlParser::DEC8:
      case MySqlParser::EUCJPMS:
      case MySqlParser::EUCKR:
      case MySqlParser::GB18030:
      case MySqlParser::GB2312:
      case MySqlParser::GBK:
      case MySqlParser::GEOSTD8:
      case MySqlParser::GREEK:
      case MySqlParser::HEBREW:
      case MySqlParser::HP8:
      case MySqlParser::KEYBCS2:
      case MySqlParser::KOI8R:
      case MySqlParser::KOI8U:
      case MySqlParser::LATIN1:
      case MySqlParser::LATIN2:
      case MySqlParser::LATIN5:
      case MySqlParser::LATIN7:
      case MySqlParser::MACCE:
      case MySqlParser::MACROMAN:
      case MySqlParser::SJIS:
      case MySqlParser::SWE7:
      case MySqlParser::TIS620:
      case MySqlParser::UCS2:
      case MySqlParser::UJIS:
      case MySqlParser::UTF16:
      case MySqlParser::UTF16LE:
      case MySqlParser::UTF32:
      case MySqlParser::UTF8:
      case MySqlParser::UTF8MB3:
      case MySqlParser::UTF8MB4:
      case MySqlParser::ARCHIVE:
      case MySqlParser::BLACKHOLE:
      case MySqlParser::CSV:
      case MySqlParser::FEDERATED:
      case MySqlParser::INNODB:
      case MySqlParser::MEMORY:
      case MySqlParser::MRG_MYISAM:
      case MySqlParser::MYISAM:
      case MySqlParser::NDB:
      case MySqlParser::NDBCLUSTER:
      case MySqlParser::PERFORMANCE_SCHEMA:
      case MySqlParser::TOKUDB:
      case MySqlParser::REPEATABLE:
      case MySqlParser::COMMITTED:
      case MySqlParser::UNCOMMITTED:
      case MySqlParser::SERIALIZABLE:
      case MySqlParser::GEOMETRYCOLLECTION:
      case MySqlParser::LINESTRING:
      case MySqlParser::MULTILINESTRING:
      case MySqlParser::MULTIPOINT:
      case MySqlParser::MULTIPOLYGON:
      case MySqlParser::POINT:
      case MySqlParser::POLYGON:
      case MySqlParser::ABS:
      case MySqlParser::ACOS:
      case MySqlParser::ADDDATE:
      case MySqlParser::ADDTIME:
      case MySqlParser::AES_DECRYPT:
      case MySqlParser::AES_ENCRYPT:
      case MySqlParser::AREA:
      case MySqlParser::ASBINARY:
      case MySqlParser::ASIN:
      case MySqlParser::ASTEXT:
      case MySqlParser::ASWKB:
      case MySqlParser::ASWKT:
      case MySqlParser::ASYMMETRIC_DECRYPT:
      case MySqlParser::ASYMMETRIC_DERIVE:
      case MySqlParser::ASYMMETRIC_ENCRYPT:
      case MySqlParser::ASYMMETRIC_SIGN:
      case MySqlParser::ASYMMETRIC_VERIFY:
      case MySqlParser::ATAN:
      case MySqlParser::ATAN2:
      case MySqlParser::BENCHMARK:
      case MySqlParser::BIN:
      case MySqlParser::BIT_COUNT:
      case MySqlParser::BIT_LENGTH:
      case MySqlParser::BUFFER:
      case MySqlParser::CATALOG_NAME:
      case MySqlParser::CEIL:
      case MySqlParser::CEILING:
      case MySqlParser::CENTROID:
      case MySqlParser::CHARACTER_LENGTH:
      case MySqlParser::CHARSET:
      case MySqlParser::CHAR_LENGTH:
      case MySqlParser::COERCIBILITY:
      case MySqlParser::COLLATION:
      case MySqlParser::COMPRESS:
      case MySqlParser::CONCAT:
      case MySqlParser::CONCAT_WS:
      case MySqlParser::CONNECTION_ID:
      case MySqlParser::CONV:
      case MySqlParser::CONVERT_TZ:
      case MySqlParser::COS:
      case MySqlParser::COT:
      case MySqlParser::CRC32:
      case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
      case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
      case MySqlParser::CREATE_DH_PARAMETERS:
      case MySqlParser::CREATE_DIGEST:
      case MySqlParser::CROSSES:
      case MySqlParser::DATEDIFF:
      case MySqlParser::DATE_FORMAT:
      case MySqlParser::DAYNAME:
      case MySqlParser::DAYOFMONTH:
      case MySqlParser::DAYOFWEEK:
      case MySqlParser::DAYOFYEAR:
      case MySqlParser::DECODE:
      case MySqlParser::DEGREES:
      case MySqlParser::DES_DECRYPT:
      case MySqlParser::DES_ENCRYPT:
      case MySqlParser::DIMENSION:
      case MySqlParser::DISJOINT:
      case MySqlParser::ELT:
      case MySqlParser::ENCODE:
      case MySqlParser::ENCRYPT:
      case MySqlParser::ENDPOINT:
      case MySqlParser::ENGINE_ATTRIBUTE:
      case MySqlParser::ENVELOPE:
      case MySqlParser::EQUALS:
      case MySqlParser::EXP:
      case MySqlParser::EXPORT_SET:
      case MySqlParser::EXTERIORRING:
      case MySqlParser::EXTRACTVALUE:
      case MySqlParser::FIELD:
      case MySqlParser::FIND_IN_SET:
      case MySqlParser::FLOOR:
      case MySqlParser::FORMAT:
      case MySqlParser::FOUND_ROWS:
      case MySqlParser::FROM_BASE64:
      case MySqlParser::FROM_DAYS:
      case MySqlParser::FROM_UNIXTIME:
      case MySqlParser::GEOMCOLLFROMTEXT:
      case MySqlParser::GEOMCOLLFROMWKB:
      case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::GEOMETRYFROMTEXT:
      case MySqlParser::GEOMETRYFROMWKB:
      case MySqlParser::GEOMETRYN:
      case MySqlParser::GEOMETRYTYPE:
      case MySqlParser::GEOMFROMTEXT:
      case MySqlParser::GEOMFROMWKB:
      case MySqlParser::GET_FORMAT:
      case MySqlParser::GET_LOCK:
      case MySqlParser::GLENGTH:
      case MySqlParser::GREATEST:
      case MySqlParser::GTID_SUBSET:
      case MySqlParser::GTID_SUBTRACT:
      case MySqlParser::HEX:
      case MySqlParser::IFNULL:
      case MySqlParser::INET6_ATON:
      case MySqlParser::INET6_NTOA:
      case MySqlParser::INET_ATON:
      case MySqlParser::INET_NTOA:
      case MySqlParser::INSTR:
      case MySqlParser::INTERIORRINGN:
      case MySqlParser::INTERSECTS:
      case MySqlParser::ISCLOSED:
      case MySqlParser::ISEMPTY:
      case MySqlParser::ISNULL:
      case MySqlParser::ISSIMPLE:
      case MySqlParser::IS_FREE_LOCK:
      case MySqlParser::IS_IPV4:
      case MySqlParser::IS_IPV4_COMPAT:
      case MySqlParser::IS_IPV4_MAPPED:
      case MySqlParser::IS_IPV6:
      case MySqlParser::IS_USED_LOCK:
      case MySqlParser::LAST_INSERT_ID:
      case MySqlParser::LCASE:
      case MySqlParser::LEAST:
      case MySqlParser::LENGTH:
      case MySqlParser::LINEFROMTEXT:
      case MySqlParser::LINEFROMWKB:
      case MySqlParser::LINESTRINGFROMTEXT:
      case MySqlParser::LINESTRINGFROMWKB:
      case MySqlParser::LN:
      case MySqlParser::LOAD_FILE:
      case MySqlParser::LOCATE:
      case MySqlParser::LOG:
      case MySqlParser::LOG10:
      case MySqlParser::LOG2:
      case MySqlParser::LOWER:
      case MySqlParser::LPAD:
      case MySqlParser::LTRIM:
      case MySqlParser::MAKEDATE:
      case MySqlParser::MAKETIME:
      case MySqlParser::MAKE_SET:
      case MySqlParser::MASTER_POS_WAIT:
      case MySqlParser::MBRCONTAINS:
      case MySqlParser::MBRDISJOINT:
      case MySqlParser::MBREQUAL:
      case MySqlParser::MBRINTERSECTS:
      case MySqlParser::MBROVERLAPS:
      case MySqlParser::MBRTOUCHES:
      case MySqlParser::MBRWITHIN:
      case MySqlParser::MD5:
      case MySqlParser::MLINEFROMTEXT:
      case MySqlParser::MLINEFROMWKB:
      case MySqlParser::MONTHNAME:
      case MySqlParser::MPOINTFROMTEXT:
      case MySqlParser::MPOINTFROMWKB:
      case MySqlParser::MPOLYFROMTEXT:
      case MySqlParser::MPOLYFROMWKB:
      case MySqlParser::MULTILINESTRINGFROMTEXT:
      case MySqlParser::MULTILINESTRINGFROMWKB:
      case MySqlParser::MULTIPOINTFROMTEXT:
      case MySqlParser::MULTIPOINTFROMWKB:
      case MySqlParser::MULTIPOLYGONFROMTEXT:
      case MySqlParser::MULTIPOLYGONFROMWKB:
      case MySqlParser::NAME_CONST:
      case MySqlParser::NULLIF:
      case MySqlParser::NUMGEOMETRIES:
      case MySqlParser::NUMINTERIORRINGS:
      case MySqlParser::NUMPOINTS:
      case MySqlParser::OCT:
      case MySqlParser::OCTET_LENGTH:
      case MySqlParser::ORD:
      case MySqlParser::OVERLAPS:
      case MySqlParser::PERIOD_ADD:
      case MySqlParser::PERIOD_DIFF:
      case MySqlParser::PI:
      case MySqlParser::POINTFROMTEXT:
      case MySqlParser::POINTFROMWKB:
      case MySqlParser::POINTN:
      case MySqlParser::POLYFROMTEXT:
      case MySqlParser::POLYFROMWKB:
      case MySqlParser::POLYGONFROMTEXT:
      case MySqlParser::POLYGONFROMWKB:
      case MySqlParser::POW:
      case MySqlParser::POWER:
      case MySqlParser::QUOTE:
      case MySqlParser::RADIANS:
      case MySqlParser::RAND:
      case MySqlParser::RANDOM_BYTES:
      case MySqlParser::RELEASE_LOCK:
      case MySqlParser::REVERSE:
      case MySqlParser::ROUND:
      case MySqlParser::ROW_COUNT:
      case MySqlParser::RPAD:
      case MySqlParser::RTRIM:
      case MySqlParser::SEC_TO_TIME:
      case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySqlParser::SESSION_USER:
      case MySqlParser::SHA:
      case MySqlParser::SHA1:
      case MySqlParser::SHA2:
      case MySqlParser::SCHEMA_NAME:
      case MySqlParser::SIGN:
      case MySqlParser::SIN:
      case MySqlParser::SLEEP:
      case MySqlParser::SOUNDEX:
      case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
      case MySqlParser::SQRT:
      case MySqlParser::SRID:
      case MySqlParser::STARTPOINT:
      case MySqlParser::STRCMP:
      case MySqlParser::STR_TO_DATE:
      case MySqlParser::ST_AREA:
      case MySqlParser::ST_ASBINARY:
      case MySqlParser::ST_ASTEXT:
      case MySqlParser::ST_ASWKB:
      case MySqlParser::ST_ASWKT:
      case MySqlParser::ST_BUFFER:
      case MySqlParser::ST_CENTROID:
      case MySqlParser::ST_CONTAINS:
      case MySqlParser::ST_CROSSES:
      case MySqlParser::ST_DIFFERENCE:
      case MySqlParser::ST_DIMENSION:
      case MySqlParser::ST_DISJOINT:
      case MySqlParser::ST_DISTANCE:
      case MySqlParser::ST_ENDPOINT:
      case MySqlParser::ST_ENVELOPE:
      case MySqlParser::ST_EQUALS:
      case MySqlParser::ST_EXTERIORRING:
      case MySqlParser::ST_GEOMCOLLFROMTEXT:
      case MySqlParser::ST_GEOMCOLLFROMTXT:
      case MySqlParser::ST_GEOMCOLLFROMWKB:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::ST_GEOMETRYFROMTEXT:
      case MySqlParser::ST_GEOMETRYFROMWKB:
      case MySqlParser::ST_GEOMETRYN:
      case MySqlParser::ST_GEOMETRYTYPE:
      case MySqlParser::ST_GEOMFROMTEXT:
      case MySqlParser::ST_GEOMFROMWKB:
      case MySqlParser::ST_INTERIORRINGN:
      case MySqlParser::ST_INTERSECTION:
      case MySqlParser::ST_INTERSECTS:
      case MySqlParser::ST_ISCLOSED:
      case MySqlParser::ST_ISEMPTY:
      case MySqlParser::ST_ISSIMPLE:
      case MySqlParser::ST_LINEFROMTEXT:
      case MySqlParser::ST_LINEFROMWKB:
      case MySqlParser::ST_LINESTRINGFROMTEXT:
      case MySqlParser::ST_LINESTRINGFROMWKB:
      case MySqlParser::ST_NUMGEOMETRIES:
      case MySqlParser::ST_NUMINTERIORRING:
      case MySqlParser::ST_NUMINTERIORRINGS:
      case MySqlParser::ST_NUMPOINTS:
      case MySqlParser::ST_OVERLAPS:
      case MySqlParser::ST_POINTFROMTEXT:
      case MySqlParser::ST_POINTFROMWKB:
      case MySqlParser::ST_POINTN:
      case MySqlParser::ST_POLYFROMTEXT:
      case MySqlParser::ST_POLYFROMWKB:
      case MySqlParser::ST_POLYGONFROMTEXT:
      case MySqlParser::ST_POLYGONFROMWKB:
      case MySqlParser::ST_SRID:
      case MySqlParser::ST_STARTPOINT:
      case MySqlParser::ST_SYMDIFFERENCE:
      case MySqlParser::ST_TOUCHES:
      case MySqlParser::ST_UNION:
      case MySqlParser::ST_WITHIN:
      case MySqlParser::ST_X:
      case MySqlParser::ST_Y:
      case MySqlParser::SUBDATE:
      case MySqlParser::SUBSTRING_INDEX:
      case MySqlParser::SUBTIME:
      case MySqlParser::SYSTEM_USER:
      case MySqlParser::TAN:
      case MySqlParser::TIMEDIFF:
      case MySqlParser::TIMESTAMPADD:
      case MySqlParser::TIMESTAMPDIFF:
      case MySqlParser::TIME_FORMAT:
      case MySqlParser::TIME_TO_SEC:
      case MySqlParser::TOUCHES:
      case MySqlParser::TO_BASE64:
      case MySqlParser::TO_DAYS:
      case MySqlParser::TO_SECONDS:
      case MySqlParser::TP_CONNECTION_ADMIN:
      case MySqlParser::UCASE:
      case MySqlParser::UNCOMPRESS:
      case MySqlParser::UNCOMPRESSED_LENGTH:
      case MySqlParser::UNHEX:
      case MySqlParser::UNIX_TIMESTAMP:
      case MySqlParser::UPDATEXML:
      case MySqlParser::UPPER:
      case MySqlParser::UUID:
      case MySqlParser::UUID_SHORT:
      case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
      case MySqlParser::VERSION:
      case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
      case MySqlParser::WEEKDAY:
      case MySqlParser::WEEKOFYEAR:
      case MySqlParser::WEIGHT_STRING:
      case MySqlParser::WITHIN:
      case MySqlParser::YEARWEEK:
      case MySqlParser::Y_FUNCTION:
      case MySqlParser::X_FUNCTION:
      case MySqlParser::MOD:
      case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
      case MySqlParser::STRING_LITERAL:
      case MySqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(3502);
        uid();
        break;
      }

      case MySqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(3503);
        match(MySqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockClauseContext ------------------------------------------------------------------

MySqlParser::LockClauseContext::LockClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::LockClauseContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

tree::TerminalNode* MySqlParser::LockClauseContext::UPDATE() {
  return getToken(MySqlParser::UPDATE, 0);
}

tree::TerminalNode* MySqlParser::LockClauseContext::LOCK() {
  return getToken(MySqlParser::LOCK, 0);
}

tree::TerminalNode* MySqlParser::LockClauseContext::IN() {
  return getToken(MySqlParser::IN, 0);
}

tree::TerminalNode* MySqlParser::LockClauseContext::SHARE() {
  return getToken(MySqlParser::SHARE, 0);
}

tree::TerminalNode* MySqlParser::LockClauseContext::MODE() {
  return getToken(MySqlParser::MODE, 0);
}


size_t MySqlParser::LockClauseContext::getRuleIndex() const {
  return MySqlParser::RuleLockClause;
}

void MySqlParser::LockClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockClause(this);
}

void MySqlParser::LockClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockClause(this);
}


std::any MySqlParser::LockClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLockClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LockClauseContext* MySqlParser::lockClause() {
  LockClauseContext *_localctx = _tracker.createInstance<LockClauseContext>(_ctx, getState());
  enterRule(_localctx, 210, MySqlParser::RuleLockClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3512);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::FOR: {
        enterOuterAlt(_localctx, 1);
        setState(3506);
        match(MySqlParser::FOR);
        setState(3507);
        match(MySqlParser::UPDATE);
        break;
      }

      case MySqlParser::LOCK: {
        enterOuterAlt(_localctx, 2);
        setState(3508);
        match(MySqlParser::LOCK);
        setState(3509);
        match(MySqlParser::IN);
        setState(3510);
        match(MySqlParser::SHARE);
        setState(3511);
        match(MySqlParser::MODE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleDeleteStatementContext ------------------------------------------------------------------

MySqlParser::SingleDeleteStatementContext::SingleDeleteStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SingleDeleteStatementContext::DELETE() {
  return getToken(MySqlParser::DELETE, 0);
}

tree::TerminalNode* MySqlParser::SingleDeleteStatementContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

MySqlParser::TableNameContext* MySqlParser::SingleDeleteStatementContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::SingleDeleteStatementContext::QUICK() {
  return getToken(MySqlParser::QUICK, 0);
}

tree::TerminalNode* MySqlParser::SingleDeleteStatementContext::IGNORE() {
  return getToken(MySqlParser::IGNORE, 0);
}

MySqlParser::UidContext* MySqlParser::SingleDeleteStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::SingleDeleteStatementContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

tree::TerminalNode* MySqlParser::SingleDeleteStatementContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::UidListContext* MySqlParser::SingleDeleteStatementContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::SingleDeleteStatementContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::SingleDeleteStatementContext::WHERE() {
  return getToken(MySqlParser::WHERE, 0);
}

MySqlParser::ExpressionContext* MySqlParser::SingleDeleteStatementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

MySqlParser::OrderByClauseContext* MySqlParser::SingleDeleteStatementContext::orderByClause() {
  return getRuleContext<MySqlParser::OrderByClauseContext>(0);
}

tree::TerminalNode* MySqlParser::SingleDeleteStatementContext::LIMIT() {
  return getToken(MySqlParser::LIMIT, 0);
}

MySqlParser::LimitClauseAtomContext* MySqlParser::SingleDeleteStatementContext::limitClauseAtom() {
  return getRuleContext<MySqlParser::LimitClauseAtomContext>(0);
}

tree::TerminalNode* MySqlParser::SingleDeleteStatementContext::LOW_PRIORITY() {
  return getToken(MySqlParser::LOW_PRIORITY, 0);
}

tree::TerminalNode* MySqlParser::SingleDeleteStatementContext::AS() {
  return getToken(MySqlParser::AS, 0);
}


size_t MySqlParser::SingleDeleteStatementContext::getRuleIndex() const {
  return MySqlParser::RuleSingleDeleteStatement;
}

void MySqlParser::SingleDeleteStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleDeleteStatement(this);
}

void MySqlParser::SingleDeleteStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleDeleteStatement(this);
}


std::any MySqlParser::SingleDeleteStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSingleDeleteStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SingleDeleteStatementContext* MySqlParser::singleDeleteStatement() {
  SingleDeleteStatementContext *_localctx = _tracker.createInstance<SingleDeleteStatementContext>(_ctx, getState());
  enterRule(_localctx, 212, MySqlParser::RuleSingleDeleteStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3514);
    match(MySqlParser::DELETE);
    setState(3516);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LOW_PRIORITY) {
      setState(3515);
      antlrcpp::downCast<SingleDeleteStatementContext *>(_localctx)->priority = match(MySqlParser::LOW_PRIORITY);
    }
    setState(3519);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::QUICK) {
      setState(3518);
      match(MySqlParser::QUICK);
    }
    setState(3522);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IGNORE) {
      setState(3521);
      match(MySqlParser::IGNORE);
    }
    setState(3524);
    match(MySqlParser::FROM);
    setState(3525);
    tableName();
    setState(3530);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 489, _ctx)) {
    case 1: {
      setState(3527);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::AS) {
        setState(3526);
        match(MySqlParser::AS);
      }
      setState(3529);
      uid();
      break;
    }

    default:
      break;
    }
    setState(3537);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::PARTITION) {
      setState(3532);
      match(MySqlParser::PARTITION);
      setState(3533);
      match(MySqlParser::LR_BRACKET);
      setState(3534);
      uidList();
      setState(3535);
      match(MySqlParser::RR_BRACKET);
    }
    setState(3541);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WHERE) {
      setState(3539);
      match(MySqlParser::WHERE);
      setState(3540);
      expression(0);
    }
    setState(3544);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ORDER) {
      setState(3543);
      orderByClause();
    }
    setState(3548);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LIMIT) {
      setState(3546);
      match(MySqlParser::LIMIT);
      setState(3547);
      limitClauseAtom();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipleDeleteStatementContext ------------------------------------------------------------------

MySqlParser::MultipleDeleteStatementContext::MultipleDeleteStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::MultipleDeleteStatementContext::DELETE() {
  return getToken(MySqlParser::DELETE, 0);
}

std::vector<MySqlParser::TableNameContext *> MySqlParser::MultipleDeleteStatementContext::tableName() {
  return getRuleContexts<MySqlParser::TableNameContext>();
}

MySqlParser::TableNameContext* MySqlParser::MultipleDeleteStatementContext::tableName(size_t i) {
  return getRuleContext<MySqlParser::TableNameContext>(i);
}

tree::TerminalNode* MySqlParser::MultipleDeleteStatementContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

MySqlParser::TableSourcesContext* MySqlParser::MultipleDeleteStatementContext::tableSources() {
  return getRuleContext<MySqlParser::TableSourcesContext>(0);
}

tree::TerminalNode* MySqlParser::MultipleDeleteStatementContext::USING() {
  return getToken(MySqlParser::USING, 0);
}

tree::TerminalNode* MySqlParser::MultipleDeleteStatementContext::QUICK() {
  return getToken(MySqlParser::QUICK, 0);
}

tree::TerminalNode* MySqlParser::MultipleDeleteStatementContext::IGNORE() {
  return getToken(MySqlParser::IGNORE, 0);
}

tree::TerminalNode* MySqlParser::MultipleDeleteStatementContext::WHERE() {
  return getToken(MySqlParser::WHERE, 0);
}

MySqlParser::ExpressionContext* MySqlParser::MultipleDeleteStatementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::MultipleDeleteStatementContext::LOW_PRIORITY() {
  return getToken(MySqlParser::LOW_PRIORITY, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::MultipleDeleteStatementContext::DOT() {
  return getTokens(MySqlParser::DOT);
}

tree::TerminalNode* MySqlParser::MultipleDeleteStatementContext::DOT(size_t i) {
  return getToken(MySqlParser::DOT, i);
}

std::vector<tree::TerminalNode *> MySqlParser::MultipleDeleteStatementContext::STAR() {
  return getTokens(MySqlParser::STAR);
}

tree::TerminalNode* MySqlParser::MultipleDeleteStatementContext::STAR(size_t i) {
  return getToken(MySqlParser::STAR, i);
}

std::vector<tree::TerminalNode *> MySqlParser::MultipleDeleteStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::MultipleDeleteStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::MultipleDeleteStatementContext::getRuleIndex() const {
  return MySqlParser::RuleMultipleDeleteStatement;
}

void MySqlParser::MultipleDeleteStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipleDeleteStatement(this);
}

void MySqlParser::MultipleDeleteStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipleDeleteStatement(this);
}


std::any MySqlParser::MultipleDeleteStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitMultipleDeleteStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::MultipleDeleteStatementContext* MySqlParser::multipleDeleteStatement() {
  MultipleDeleteStatementContext *_localctx = _tracker.createInstance<MultipleDeleteStatementContext>(_ctx, getState());
  enterRule(_localctx, 214, MySqlParser::RuleMultipleDeleteStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3550);
    match(MySqlParser::DELETE);
    setState(3552);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LOW_PRIORITY) {
      setState(3551);
      antlrcpp::downCast<MultipleDeleteStatementContext *>(_localctx)->priority = match(MySqlParser::LOW_PRIORITY);
    }
    setState(3555);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 495, _ctx)) {
    case 1: {
      setState(3554);
      match(MySqlParser::QUICK);
      break;
    }

    default:
      break;
    }
    setState(3558);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IGNORE) {
      setState(3557);
      match(MySqlParser::IGNORE);
    }
    setState(3599);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::ATTRIBUTE:
      case MySqlParser::BUCKETS:
      case MySqlParser::CONDITION:
      case MySqlParser::CURRENT:
      case MySqlParser::CURRENT_USER:
      case MySqlParser::DATABASE:
      case MySqlParser::DEFAULT:
      case MySqlParser::DIAGNOSTICS:
      case MySqlParser::EMPTY:
      case MySqlParser::ENFORCED:
      case MySqlParser::EXCEPT:
      case MySqlParser::GROUP:
      case MySqlParser::IF:
      case MySqlParser::IGNORED:
      case MySqlParser::INSERT:
      case MySqlParser::LATERAL:
      case MySqlParser::LEFT:
      case MySqlParser::NUMBER:
      case MySqlParser::OPTIONAL:
      case MySqlParser::ORDER:
      case MySqlParser::PRIMARY:
      case MySqlParser::REPLACE:
      case MySqlParser::RIGHT:
      case MySqlParser::SCHEMA:
      case MySqlParser::SKIP_QUERY_REWRITE:
      case MySqlParser::STACKED:
      case MySqlParser::DATE:
      case MySqlParser::TIME:
      case MySqlParser::TIMESTAMP:
      case MySqlParser::DATETIME:
      case MySqlParser::YEAR:
      case MySqlParser::BINARY:
      case MySqlParser::TEXT:
      case MySqlParser::ENUM:
      case MySqlParser::SERIAL:
      case MySqlParser::JSON_ARRAY:
      case MySqlParser::JSON_ARRAYAGG:
      case MySqlParser::JSON_ARRAY_APPEND:
      case MySqlParser::JSON_ARRAY_INSERT:
      case MySqlParser::JSON_CONTAINS:
      case MySqlParser::JSON_CONTAINS_PATH:
      case MySqlParser::JSON_DEPTH:
      case MySqlParser::JSON_EXTRACT:
      case MySqlParser::JSON_INSERT:
      case MySqlParser::JSON_KEYS:
      case MySqlParser::JSON_LENGTH:
      case MySqlParser::JSON_MERGE:
      case MySqlParser::JSON_MERGE_PATCH:
      case MySqlParser::JSON_MERGE_PRESERVE:
      case MySqlParser::JSON_OBJECT:
      case MySqlParser::JSON_OBJECTAGG:
      case MySqlParser::JSON_OVERLAPS:
      case MySqlParser::JSON_PRETTY:
      case MySqlParser::JSON_QUOTE:
      case MySqlParser::JSON_REMOVE:
      case MySqlParser::JSON_REPLACE:
      case MySqlParser::JSON_SCHEMA_VALID:
      case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
      case MySqlParser::JSON_SEARCH:
      case MySqlParser::JSON_SET:
      case MySqlParser::JSON_STORAGE_FREE:
      case MySqlParser::JSON_STORAGE_SIZE:
      case MySqlParser::JSON_TABLE:
      case MySqlParser::JSON_TYPE:
      case MySqlParser::JSON_UNQUOTE:
      case MySqlParser::JSON_VALID:
      case MySqlParser::JSON_VALUE:
      case MySqlParser::NESTED:
      case MySqlParser::ORDINALITY:
      case MySqlParser::PATH:
      case MySqlParser::AVG:
      case MySqlParser::BIT_AND:
      case MySqlParser::BIT_OR:
      case MySqlParser::BIT_XOR:
      case MySqlParser::COUNT:
      case MySqlParser::CUME_DIST:
      case MySqlParser::DENSE_RANK:
      case MySqlParser::FIRST_VALUE:
      case MySqlParser::GROUP_CONCAT:
      case MySqlParser::LAG:
      case MySqlParser::LAST_VALUE:
      case MySqlParser::LEAD:
      case MySqlParser::MAX:
      case MySqlParser::MIN:
      case MySqlParser::NTILE:
      case MySqlParser::NTH_VALUE:
      case MySqlParser::PERCENT_RANK:
      case MySqlParser::RANK:
      case MySqlParser::ROW_NUMBER:
      case MySqlParser::STD:
      case MySqlParser::STDDEV:
      case MySqlParser::STDDEV_POP:
      case MySqlParser::STDDEV_SAMP:
      case MySqlParser::SUM:
      case MySqlParser::VAR_POP:
      case MySqlParser::VAR_SAMP:
      case MySqlParser::VARIANCE:
      case MySqlParser::CURRENT_DATE:
      case MySqlParser::CURRENT_TIME:
      case MySqlParser::CURRENT_TIMESTAMP:
      case MySqlParser::LOCALTIME:
      case MySqlParser::CURDATE:
      case MySqlParser::CURTIME:
      case MySqlParser::DATE_ADD:
      case MySqlParser::DATE_SUB:
      case MySqlParser::LOCALTIMESTAMP:
      case MySqlParser::NOW:
      case MySqlParser::POSITION:
      case MySqlParser::SUBSTR:
      case MySqlParser::SUBSTRING:
      case MySqlParser::SYSDATE:
      case MySqlParser::TRIM:
      case MySqlParser::UTC_DATE:
      case MySqlParser::UTC_TIME:
      case MySqlParser::UTC_TIMESTAMP:
      case MySqlParser::ACCOUNT:
      case MySqlParser::ACTION:
      case MySqlParser::AFTER:
      case MySqlParser::AGGREGATE:
      case MySqlParser::ALGORITHM:
      case MySqlParser::ANY:
      case MySqlParser::AT:
      case MySqlParser::AUTHORS:
      case MySqlParser::AUTOCOMMIT:
      case MySqlParser::AUTOEXTEND_SIZE:
      case MySqlParser::AUTO_INCREMENT:
      case MySqlParser::AVG_ROW_LENGTH:
      case MySqlParser::BEGIN:
      case MySqlParser::BINLOG:
      case MySqlParser::BIT:
      case MySqlParser::BLOCK:
      case MySqlParser::BOOL:
      case MySqlParser::BOOLEAN:
      case MySqlParser::BTREE:
      case MySqlParser::CACHE:
      case MySqlParser::CASCADED:
      case MySqlParser::CHAIN:
      case MySqlParser::CHANGED:
      case MySqlParser::CHANNEL:
      case MySqlParser::CHECKSUM:
      case MySqlParser::PAGE_CHECKSUM:
      case MySqlParser::CIPHER:
      case MySqlParser::CLASS_ORIGIN:
      case MySqlParser::CLIENT:
      case MySqlParser::CLOSE:
      case MySqlParser::CLUSTERING:
      case MySqlParser::COALESCE:
      case MySqlParser::CODE:
      case MySqlParser::COLUMNS:
      case MySqlParser::COLUMN_FORMAT:
      case MySqlParser::COLUMN_NAME:
      case MySqlParser::COMMENT:
      case MySqlParser::COMMIT:
      case MySqlParser::COMPACT:
      case MySqlParser::COMPLETION:
      case MySqlParser::COMPRESSED:
      case MySqlParser::COMPRESSION:
      case MySqlParser::CONCURRENT:
      case MySqlParser::CONNECT:
      case MySqlParser::CONNECTION:
      case MySqlParser::CONSISTENT:
      case MySqlParser::CONSTRAINT_CATALOG:
      case MySqlParser::CONSTRAINT_SCHEMA:
      case MySqlParser::CONSTRAINT_NAME:
      case MySqlParser::CONTAINS:
      case MySqlParser::CONTEXT:
      case MySqlParser::CONTRIBUTORS:
      case MySqlParser::COPY:
      case MySqlParser::CPU:
      case MySqlParser::CURSOR_NAME:
      case MySqlParser::DATA:
      case MySqlParser::DATAFILE:
      case MySqlParser::DEALLOCATE:
      case MySqlParser::DEFAULT_AUTH:
      case MySqlParser::DEFINER:
      case MySqlParser::DELAY_KEY_WRITE:
      case MySqlParser::DES_KEY_FILE:
      case MySqlParser::DIRECTORY:
      case MySqlParser::DISABLE:
      case MySqlParser::DISCARD:
      case MySqlParser::DISK:
      case MySqlParser::DO:
      case MySqlParser::DUMPFILE:
      case MySqlParser::DUPLICATE:
      case MySqlParser::DYNAMIC:
      case MySqlParser::ENABLE:
      case MySqlParser::ENCRYPTION:
      case MySqlParser::END:
      case MySqlParser::ENDS:
      case MySqlParser::ENGINE:
      case MySqlParser::ENGINES:
      case MySqlParser::ERROR:
      case MySqlParser::ERRORS:
      case MySqlParser::ESCAPE:
      case MySqlParser::EVEN:
      case MySqlParser::EVENT:
      case MySqlParser::EVENTS:
      case MySqlParser::EVERY:
      case MySqlParser::EXCHANGE:
      case MySqlParser::EXCLUSIVE:
      case MySqlParser::EXPIRE:
      case MySqlParser::EXPORT:
      case MySqlParser::EXTENDED:
      case MySqlParser::EXTENT_SIZE:
      case MySqlParser::FAILED_LOGIN_ATTEMPTS:
      case MySqlParser::FAST:
      case MySqlParser::FAULTS:
      case MySqlParser::FIELDS:
      case MySqlParser::FILE_BLOCK_SIZE:
      case MySqlParser::FILTER:
      case MySqlParser::FIRST:
      case MySqlParser::FIXED:
      case MySqlParser::FLUSH:
      case MySqlParser::FOLLOWS:
      case MySqlParser::FOUND:
      case MySqlParser::FULL:
      case MySqlParser::FUNCTION:
      case MySqlParser::GENERAL:
      case MySqlParser::GLOBAL:
      case MySqlParser::GRANTS:
      case MySqlParser::GROUP_REPLICATION:
      case MySqlParser::HANDLER:
      case MySqlParser::HASH:
      case MySqlParser::HELP:
      case MySqlParser::HISTORY:
      case MySqlParser::HOST:
      case MySqlParser::HOSTS:
      case MySqlParser::IDENTIFIED:
      case MySqlParser::IGNORE_SERVER_IDS:
      case MySqlParser::IMPORT:
      case MySqlParser::INDEXES:
      case MySqlParser::INITIAL_SIZE:
      case MySqlParser::INPLACE:
      case MySqlParser::INSERT_METHOD:
      case MySqlParser::INSTALL:
      case MySqlParser::INSTANCE:
      case MySqlParser::INSTANT:
      case MySqlParser::INVISIBLE:
      case MySqlParser::INVOKER:
      case MySqlParser::IO:
      case MySqlParser::IO_THREAD:
      case MySqlParser::IPC:
      case MySqlParser::ISOLATION:
      case MySqlParser::ISSUER:
      case MySqlParser::JSON:
      case MySqlParser::KEY_BLOCK_SIZE:
      case MySqlParser::LANGUAGE:
      case MySqlParser::LAST:
      case MySqlParser::LEAVES:
      case MySqlParser::LESS:
      case MySqlParser::LEVEL:
      case MySqlParser::LIST:
      case MySqlParser::LOCAL:
      case MySqlParser::LOGFILE:
      case MySqlParser::LOGS:
      case MySqlParser::MASTER:
      case MySqlParser::MASTER_AUTO_POSITION:
      case MySqlParser::MASTER_CONNECT_RETRY:
      case MySqlParser::MASTER_DELAY:
      case MySqlParser::MASTER_HEARTBEAT_PERIOD:
      case MySqlParser::MASTER_HOST:
      case MySqlParser::MASTER_LOG_FILE:
      case MySqlParser::MASTER_LOG_POS:
      case MySqlParser::MASTER_PASSWORD:
      case MySqlParser::MASTER_PORT:
      case MySqlParser::MASTER_RETRY_COUNT:
      case MySqlParser::MASTER_SSL:
      case MySqlParser::MASTER_SSL_CA:
      case MySqlParser::MASTER_SSL_CAPATH:
      case MySqlParser::MASTER_SSL_CERT:
      case MySqlParser::MASTER_SSL_CIPHER:
      case MySqlParser::MASTER_SSL_CRL:
      case MySqlParser::MASTER_SSL_CRLPATH:
      case MySqlParser::MASTER_SSL_KEY:
      case MySqlParser::MASTER_TLS_VERSION:
      case MySqlParser::MASTER_USER:
      case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
      case MySqlParser::MAX_QUERIES_PER_HOUR:
      case MySqlParser::MAX_ROWS:
      case MySqlParser::MAX_SIZE:
      case MySqlParser::MAX_UPDATES_PER_HOUR:
      case MySqlParser::MAX_USER_CONNECTIONS:
      case MySqlParser::MEDIUM:
      case MySqlParser::MEMBER:
      case MySqlParser::MERGE:
      case MySqlParser::MESSAGE_TEXT:
      case MySqlParser::MID:
      case MySqlParser::MIGRATE:
      case MySqlParser::MIN_ROWS:
      case MySqlParser::MODE:
      case MySqlParser::MODIFY:
      case MySqlParser::MUTEX:
      case MySqlParser::MYSQL:
      case MySqlParser::MYSQL_ERRNO:
      case MySqlParser::NAME:
      case MySqlParser::NAMES:
      case MySqlParser::NCHAR:
      case MySqlParser::NEVER:
      case MySqlParser::NEXT:
      case MySqlParser::NO:
      case MySqlParser::NOCOPY:
      case MySqlParser::NOWAIT:
      case MySqlParser::NODEGROUP:
      case MySqlParser::NONE:
      case MySqlParser::ODBC:
      case MySqlParser::OFFLINE:
      case MySqlParser::OFFSET:
      case MySqlParser::OF:
      case MySqlParser::OJ:
      case MySqlParser::OLD_PASSWORD:
      case MySqlParser::ONE:
      case MySqlParser::ONLINE:
      case MySqlParser::ONLY:
      case MySqlParser::OPEN:
      case MySqlParser::OPTIMIZER_COSTS:
      case MySqlParser::OPTIONS:
      case MySqlParser::OWNER:
      case MySqlParser::PACK_KEYS:
      case MySqlParser::PAGE:
      case MySqlParser::PARSER:
      case MySqlParser::PARTIAL:
      case MySqlParser::PARTITIONING:
      case MySqlParser::PARTITIONS:
      case MySqlParser::PASSWORD:
      case MySqlParser::PASSWORD_LOCK_TIME:
      case MySqlParser::PHASE:
      case MySqlParser::PLUGIN:
      case MySqlParser::PLUGIN_DIR:
      case MySqlParser::PLUGINS:
      case MySqlParser::PORT:
      case MySqlParser::PRECEDES:
      case MySqlParser::PREPARE:
      case MySqlParser::PRESERVE:
      case MySqlParser::PREV:
      case MySqlParser::PROCESSLIST:
      case MySqlParser::PROFILE:
      case MySqlParser::PROFILES:
      case MySqlParser::PROXY:
      case MySqlParser::QUERY:
      case MySqlParser::QUICK:
      case MySqlParser::REBUILD:
      case MySqlParser::RECOVER:
      case MySqlParser::RECURSIVE:
      case MySqlParser::REDO_BUFFER_SIZE:
      case MySqlParser::REDUNDANT:
      case MySqlParser::RELAY:
      case MySqlParser::RELAY_LOG_FILE:
      case MySqlParser::RELAY_LOG_POS:
      case MySqlParser::RELAYLOG:
      case MySqlParser::REMOVE:
      case MySqlParser::REORGANIZE:
      case MySqlParser::REPAIR:
      case MySqlParser::REPLICATE_DO_DB:
      case MySqlParser::REPLICATE_DO_TABLE:
      case MySqlParser::REPLICATE_IGNORE_DB:
      case MySqlParser::REPLICATE_IGNORE_TABLE:
      case MySqlParser::REPLICATE_REWRITE_DB:
      case MySqlParser::REPLICATE_WILD_DO_TABLE:
      case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySqlParser::REPLICATION:
      case MySqlParser::RESET:
      case MySqlParser::RESUME:
      case MySqlParser::RETURNED_SQLSTATE:
      case MySqlParser::RETURNS:
      case MySqlParser::REUSE:
      case MySqlParser::ROLE:
      case MySqlParser::ROLLBACK:
      case MySqlParser::ROLLUP:
      case MySqlParser::ROTATE:
      case MySqlParser::ROW:
      case MySqlParser::ROWS:
      case MySqlParser::ROW_FORMAT:
      case MySqlParser::RTREE:
      case MySqlParser::SAVEPOINT:
      case MySqlParser::SCHEDULE:
      case MySqlParser::SECURITY:
      case MySqlParser::SERVER:
      case MySqlParser::SESSION:
      case MySqlParser::SHARE:
      case MySqlParser::SHARED:
      case MySqlParser::SIGNED:
      case MySqlParser::SIMPLE:
      case MySqlParser::SLAVE:
      case MySqlParser::SLOW:
      case MySqlParser::SNAPSHOT:
      case MySqlParser::SOCKET:
      case MySqlParser::SOME:
      case MySqlParser::SONAME:
      case MySqlParser::SOUNDS:
      case MySqlParser::SOURCE:
      case MySqlParser::SQL_AFTER_GTIDS:
      case MySqlParser::SQL_AFTER_MTS_GAPS:
      case MySqlParser::SQL_BEFORE_GTIDS:
      case MySqlParser::SQL_BUFFER_RESULT:
      case MySqlParser::SQL_CACHE:
      case MySqlParser::SQL_NO_CACHE:
      case MySqlParser::SQL_THREAD:
      case MySqlParser::START:
      case MySqlParser::STARTS:
      case MySqlParser::STATS_AUTO_RECALC:
      case MySqlParser::STATS_PERSISTENT:
      case MySqlParser::STATS_SAMPLE_PAGES:
      case MySqlParser::STATUS:
      case MySqlParser::STOP:
      case MySqlParser::STORAGE:
      case MySqlParser::STRING:
      case MySqlParser::SUBCLASS_ORIGIN:
      case MySqlParser::SUBJECT:
      case MySqlParser::SUBPARTITION:
      case MySqlParser::SUBPARTITIONS:
      case MySqlParser::SUSPEND:
      case MySqlParser::SWAPS:
      case MySqlParser::SWITCHES:
      case MySqlParser::TABLE_NAME:
      case MySqlParser::TABLESPACE:
      case MySqlParser::TABLE_TYPE:
      case MySqlParser::TEMPORARY:
      case MySqlParser::TEMPTABLE:
      case MySqlParser::THAN:
      case MySqlParser::TRADITIONAL:
      case MySqlParser::TRANSACTION:
      case MySqlParser::TRANSACTIONAL:
      case MySqlParser::TRIGGERS:
      case MySqlParser::TRUNCATE:
      case MySqlParser::UNBOUNDED:
      case MySqlParser::UNDEFINED:
      case MySqlParser::UNDOFILE:
      case MySqlParser::UNDO_BUFFER_SIZE:
      case MySqlParser::UNINSTALL:
      case MySqlParser::UNKNOWN:
      case MySqlParser::UNTIL:
      case MySqlParser::UPGRADE:
      case MySqlParser::USER:
      case MySqlParser::USE_FRM:
      case MySqlParser::USER_RESOURCES:
      case MySqlParser::VALIDATION:
      case MySqlParser::VALUE:
      case MySqlParser::VARIABLES:
      case MySqlParser::VIEW:
      case MySqlParser::VIRTUAL:
      case MySqlParser::VISIBLE:
      case MySqlParser::WAIT:
      case MySqlParser::WARNINGS:
      case MySqlParser::WITHOUT:
      case MySqlParser::WORK:
      case MySqlParser::WRAPPER:
      case MySqlParser::X509:
      case MySqlParser::XA:
      case MySqlParser::XML:
      case MySqlParser::EUR:
      case MySqlParser::USA:
      case MySqlParser::JIS:
      case MySqlParser::ISO:
      case MySqlParser::INTERNAL:
      case MySqlParser::QUARTER:
      case MySqlParser::MONTH:
      case MySqlParser::DAY:
      case MySqlParser::HOUR:
      case MySqlParser::MINUTE:
      case MySqlParser::WEEK:
      case MySqlParser::SECOND:
      case MySqlParser::MICROSECOND:
      case MySqlParser::ADMIN:
      case MySqlParser::AUDIT_ABORT_EXEMPT:
      case MySqlParser::AUDIT_ADMIN:
      case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
      case MySqlParser::BACKUP_ADMIN:
      case MySqlParser::BINLOG_ADMIN:
      case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
      case MySqlParser::CLONE_ADMIN:
      case MySqlParser::CONNECTION_ADMIN:
      case MySqlParser::ENCRYPTION_KEY_ADMIN:
      case MySqlParser::EXECUTE:
      case MySqlParser::FILE:
      case MySqlParser::FIREWALL_ADMIN:
      case MySqlParser::FIREWALL_EXEMPT:
      case MySqlParser::FIREWALL_USER:
      case MySqlParser::GROUP_REPLICATION_ADMIN:
      case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
      case MySqlParser::INVOKE:
      case MySqlParser::LAMBDA:
      case MySqlParser::NDB_STORED_USER:
      case MySqlParser::PASSWORDLESS_USER_ADMIN:
      case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
      case MySqlParser::PRIVILEGES:
      case MySqlParser::PROCESS:
      case MySqlParser::RELOAD:
      case MySqlParser::REPLICATION_APPLIER:
      case MySqlParser::REPLICATION_SLAVE_ADMIN:
      case MySqlParser::RESOURCE_GROUP_ADMIN:
      case MySqlParser::RESOURCE_GROUP_USER:
      case MySqlParser::ROLE_ADMIN:
      case MySqlParser::ROUTINE:
      case MySqlParser::S3:
      case MySqlParser::SESSION_VARIABLES_ADMIN:
      case MySqlParser::SET_USER_ID:
      case MySqlParser::SHOW_ROUTINE:
      case MySqlParser::SHUTDOWN:
      case MySqlParser::SUPER:
      case MySqlParser::SYSTEM_VARIABLES_ADMIN:
      case MySqlParser::TABLES:
      case MySqlParser::TABLE_ENCRYPTION_ADMIN:
      case MySqlParser::VERSION_TOKEN_ADMIN:
      case MySqlParser::XA_RECOVER_ADMIN:
      case MySqlParser::ARMSCII8:
      case MySqlParser::ASCII:
      case MySqlParser::BIG5:
      case MySqlParser::CP1250:
      case MySqlParser::CP1251:
      case MySqlParser::CP1256:
      case MySqlParser::CP1257:
      case MySqlParser::CP850:
      case MySqlParser::CP852:
      case MySqlParser::CP866:
      case MySqlParser::CP932:
      case MySqlParser::DEC8:
      case MySqlParser::EUCJPMS:
      case MySqlParser::EUCKR:
      case MySqlParser::GB18030:
      case MySqlParser::GB2312:
      case MySqlParser::GBK:
      case MySqlParser::GEOSTD8:
      case MySqlParser::GREEK:
      case MySqlParser::HEBREW:
      case MySqlParser::HP8:
      case MySqlParser::KEYBCS2:
      case MySqlParser::KOI8R:
      case MySqlParser::KOI8U:
      case MySqlParser::LATIN1:
      case MySqlParser::LATIN2:
      case MySqlParser::LATIN5:
      case MySqlParser::LATIN7:
      case MySqlParser::MACCE:
      case MySqlParser::MACROMAN:
      case MySqlParser::SJIS:
      case MySqlParser::SWE7:
      case MySqlParser::TIS620:
      case MySqlParser::UCS2:
      case MySqlParser::UJIS:
      case MySqlParser::UTF16:
      case MySqlParser::UTF16LE:
      case MySqlParser::UTF32:
      case MySqlParser::UTF8:
      case MySqlParser::UTF8MB3:
      case MySqlParser::UTF8MB4:
      case MySqlParser::ARCHIVE:
      case MySqlParser::BLACKHOLE:
      case MySqlParser::CSV:
      case MySqlParser::FEDERATED:
      case MySqlParser::INNODB:
      case MySqlParser::MEMORY:
      case MySqlParser::MRG_MYISAM:
      case MySqlParser::MYISAM:
      case MySqlParser::NDB:
      case MySqlParser::NDBCLUSTER:
      case MySqlParser::PERFORMANCE_SCHEMA:
      case MySqlParser::TOKUDB:
      case MySqlParser::REPEATABLE:
      case MySqlParser::COMMITTED:
      case MySqlParser::UNCOMMITTED:
      case MySqlParser::SERIALIZABLE:
      case MySqlParser::GEOMETRYCOLLECTION:
      case MySqlParser::LINESTRING:
      case MySqlParser::MULTILINESTRING:
      case MySqlParser::MULTIPOINT:
      case MySqlParser::MULTIPOLYGON:
      case MySqlParser::POINT:
      case MySqlParser::POLYGON:
      case MySqlParser::ABS:
      case MySqlParser::ACOS:
      case MySqlParser::ADDDATE:
      case MySqlParser::ADDTIME:
      case MySqlParser::AES_DECRYPT:
      case MySqlParser::AES_ENCRYPT:
      case MySqlParser::AREA:
      case MySqlParser::ASBINARY:
      case MySqlParser::ASIN:
      case MySqlParser::ASTEXT:
      case MySqlParser::ASWKB:
      case MySqlParser::ASWKT:
      case MySqlParser::ASYMMETRIC_DECRYPT:
      case MySqlParser::ASYMMETRIC_DERIVE:
      case MySqlParser::ASYMMETRIC_ENCRYPT:
      case MySqlParser::ASYMMETRIC_SIGN:
      case MySqlParser::ASYMMETRIC_VERIFY:
      case MySqlParser::ATAN:
      case MySqlParser::ATAN2:
      case MySqlParser::BENCHMARK:
      case MySqlParser::BIN:
      case MySqlParser::BIT_COUNT:
      case MySqlParser::BIT_LENGTH:
      case MySqlParser::BUFFER:
      case MySqlParser::CATALOG_NAME:
      case MySqlParser::CEIL:
      case MySqlParser::CEILING:
      case MySqlParser::CENTROID:
      case MySqlParser::CHARACTER_LENGTH:
      case MySqlParser::CHARSET:
      case MySqlParser::CHAR_LENGTH:
      case MySqlParser::COERCIBILITY:
      case MySqlParser::COLLATION:
      case MySqlParser::COMPRESS:
      case MySqlParser::CONCAT:
      case MySqlParser::CONCAT_WS:
      case MySqlParser::CONNECTION_ID:
      case MySqlParser::CONV:
      case MySqlParser::CONVERT_TZ:
      case MySqlParser::COS:
      case MySqlParser::COT:
      case MySqlParser::CRC32:
      case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
      case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
      case MySqlParser::CREATE_DH_PARAMETERS:
      case MySqlParser::CREATE_DIGEST:
      case MySqlParser::CROSSES:
      case MySqlParser::DATEDIFF:
      case MySqlParser::DATE_FORMAT:
      case MySqlParser::DAYNAME:
      case MySqlParser::DAYOFMONTH:
      case MySqlParser::DAYOFWEEK:
      case MySqlParser::DAYOFYEAR:
      case MySqlParser::DECODE:
      case MySqlParser::DEGREES:
      case MySqlParser::DES_DECRYPT:
      case MySqlParser::DES_ENCRYPT:
      case MySqlParser::DIMENSION:
      case MySqlParser::DISJOINT:
      case MySqlParser::ELT:
      case MySqlParser::ENCODE:
      case MySqlParser::ENCRYPT:
      case MySqlParser::ENDPOINT:
      case MySqlParser::ENGINE_ATTRIBUTE:
      case MySqlParser::ENVELOPE:
      case MySqlParser::EQUALS:
      case MySqlParser::EXP:
      case MySqlParser::EXPORT_SET:
      case MySqlParser::EXTERIORRING:
      case MySqlParser::EXTRACTVALUE:
      case MySqlParser::FIELD:
      case MySqlParser::FIND_IN_SET:
      case MySqlParser::FLOOR:
      case MySqlParser::FORMAT:
      case MySqlParser::FOUND_ROWS:
      case MySqlParser::FROM_BASE64:
      case MySqlParser::FROM_DAYS:
      case MySqlParser::FROM_UNIXTIME:
      case MySqlParser::GEOMCOLLFROMTEXT:
      case MySqlParser::GEOMCOLLFROMWKB:
      case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::GEOMETRYFROMTEXT:
      case MySqlParser::GEOMETRYFROMWKB:
      case MySqlParser::GEOMETRYN:
      case MySqlParser::GEOMETRYTYPE:
      case MySqlParser::GEOMFROMTEXT:
      case MySqlParser::GEOMFROMWKB:
      case MySqlParser::GET_FORMAT:
      case MySqlParser::GET_LOCK:
      case MySqlParser::GLENGTH:
      case MySqlParser::GREATEST:
      case MySqlParser::GTID_SUBSET:
      case MySqlParser::GTID_SUBTRACT:
      case MySqlParser::HEX:
      case MySqlParser::IFNULL:
      case MySqlParser::INET6_ATON:
      case MySqlParser::INET6_NTOA:
      case MySqlParser::INET_ATON:
      case MySqlParser::INET_NTOA:
      case MySqlParser::INSTR:
      case MySqlParser::INTERIORRINGN:
      case MySqlParser::INTERSECTS:
      case MySqlParser::ISCLOSED:
      case MySqlParser::ISEMPTY:
      case MySqlParser::ISNULL:
      case MySqlParser::ISSIMPLE:
      case MySqlParser::IS_FREE_LOCK:
      case MySqlParser::IS_IPV4:
      case MySqlParser::IS_IPV4_COMPAT:
      case MySqlParser::IS_IPV4_MAPPED:
      case MySqlParser::IS_IPV6:
      case MySqlParser::IS_USED_LOCK:
      case MySqlParser::LAST_INSERT_ID:
      case MySqlParser::LCASE:
      case MySqlParser::LEAST:
      case MySqlParser::LENGTH:
      case MySqlParser::LINEFROMTEXT:
      case MySqlParser::LINEFROMWKB:
      case MySqlParser::LINESTRINGFROMTEXT:
      case MySqlParser::LINESTRINGFROMWKB:
      case MySqlParser::LN:
      case MySqlParser::LOAD_FILE:
      case MySqlParser::LOCATE:
      case MySqlParser::LOG:
      case MySqlParser::LOG10:
      case MySqlParser::LOG2:
      case MySqlParser::LOWER:
      case MySqlParser::LPAD:
      case MySqlParser::LTRIM:
      case MySqlParser::MAKEDATE:
      case MySqlParser::MAKETIME:
      case MySqlParser::MAKE_SET:
      case MySqlParser::MASTER_POS_WAIT:
      case MySqlParser::MBRCONTAINS:
      case MySqlParser::MBRDISJOINT:
      case MySqlParser::MBREQUAL:
      case MySqlParser::MBRINTERSECTS:
      case MySqlParser::MBROVERLAPS:
      case MySqlParser::MBRTOUCHES:
      case MySqlParser::MBRWITHIN:
      case MySqlParser::MD5:
      case MySqlParser::MLINEFROMTEXT:
      case MySqlParser::MLINEFROMWKB:
      case MySqlParser::MONTHNAME:
      case MySqlParser::MPOINTFROMTEXT:
      case MySqlParser::MPOINTFROMWKB:
      case MySqlParser::MPOLYFROMTEXT:
      case MySqlParser::MPOLYFROMWKB:
      case MySqlParser::MULTILINESTRINGFROMTEXT:
      case MySqlParser::MULTILINESTRINGFROMWKB:
      case MySqlParser::MULTIPOINTFROMTEXT:
      case MySqlParser::MULTIPOINTFROMWKB:
      case MySqlParser::MULTIPOLYGONFROMTEXT:
      case MySqlParser::MULTIPOLYGONFROMWKB:
      case MySqlParser::NAME_CONST:
      case MySqlParser::NULLIF:
      case MySqlParser::NUMGEOMETRIES:
      case MySqlParser::NUMINTERIORRINGS:
      case MySqlParser::NUMPOINTS:
      case MySqlParser::OCT:
      case MySqlParser::OCTET_LENGTH:
      case MySqlParser::ORD:
      case MySqlParser::OVERLAPS:
      case MySqlParser::PERIOD_ADD:
      case MySqlParser::PERIOD_DIFF:
      case MySqlParser::PI:
      case MySqlParser::POINTFROMTEXT:
      case MySqlParser::POINTFROMWKB:
      case MySqlParser::POINTN:
      case MySqlParser::POLYFROMTEXT:
      case MySqlParser::POLYFROMWKB:
      case MySqlParser::POLYGONFROMTEXT:
      case MySqlParser::POLYGONFROMWKB:
      case MySqlParser::POW:
      case MySqlParser::POWER:
      case MySqlParser::QUOTE:
      case MySqlParser::RADIANS:
      case MySqlParser::RAND:
      case MySqlParser::RANDOM_BYTES:
      case MySqlParser::RELEASE_LOCK:
      case MySqlParser::REVERSE:
      case MySqlParser::ROUND:
      case MySqlParser::ROW_COUNT:
      case MySqlParser::RPAD:
      case MySqlParser::RTRIM:
      case MySqlParser::SEC_TO_TIME:
      case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySqlParser::SESSION_USER:
      case MySqlParser::SHA:
      case MySqlParser::SHA1:
      case MySqlParser::SHA2:
      case MySqlParser::SCHEMA_NAME:
      case MySqlParser::SIGN:
      case MySqlParser::SIN:
      case MySqlParser::SLEEP:
      case MySqlParser::SOUNDEX:
      case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
      case MySqlParser::SQRT:
      case MySqlParser::SRID:
      case MySqlParser::STARTPOINT:
      case MySqlParser::STRCMP:
      case MySqlParser::STR_TO_DATE:
      case MySqlParser::ST_AREA:
      case MySqlParser::ST_ASBINARY:
      case MySqlParser::ST_ASTEXT:
      case MySqlParser::ST_ASWKB:
      case MySqlParser::ST_ASWKT:
      case MySqlParser::ST_BUFFER:
      case MySqlParser::ST_CENTROID:
      case MySqlParser::ST_CONTAINS:
      case MySqlParser::ST_CROSSES:
      case MySqlParser::ST_DIFFERENCE:
      case MySqlParser::ST_DIMENSION:
      case MySqlParser::ST_DISJOINT:
      case MySqlParser::ST_DISTANCE:
      case MySqlParser::ST_ENDPOINT:
      case MySqlParser::ST_ENVELOPE:
      case MySqlParser::ST_EQUALS:
      case MySqlParser::ST_EXTERIORRING:
      case MySqlParser::ST_GEOMCOLLFROMTEXT:
      case MySqlParser::ST_GEOMCOLLFROMTXT:
      case MySqlParser::ST_GEOMCOLLFROMWKB:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::ST_GEOMETRYFROMTEXT:
      case MySqlParser::ST_GEOMETRYFROMWKB:
      case MySqlParser::ST_GEOMETRYN:
      case MySqlParser::ST_GEOMETRYTYPE:
      case MySqlParser::ST_GEOMFROMTEXT:
      case MySqlParser::ST_GEOMFROMWKB:
      case MySqlParser::ST_INTERIORRINGN:
      case MySqlParser::ST_INTERSECTION:
      case MySqlParser::ST_INTERSECTS:
      case MySqlParser::ST_ISCLOSED:
      case MySqlParser::ST_ISEMPTY:
      case MySqlParser::ST_ISSIMPLE:
      case MySqlParser::ST_LINEFROMTEXT:
      case MySqlParser::ST_LINEFROMWKB:
      case MySqlParser::ST_LINESTRINGFROMTEXT:
      case MySqlParser::ST_LINESTRINGFROMWKB:
      case MySqlParser::ST_NUMGEOMETRIES:
      case MySqlParser::ST_NUMINTERIORRING:
      case MySqlParser::ST_NUMINTERIORRINGS:
      case MySqlParser::ST_NUMPOINTS:
      case MySqlParser::ST_OVERLAPS:
      case MySqlParser::ST_POINTFROMTEXT:
      case MySqlParser::ST_POINTFROMWKB:
      case MySqlParser::ST_POINTN:
      case MySqlParser::ST_POLYFROMTEXT:
      case MySqlParser::ST_POLYFROMWKB:
      case MySqlParser::ST_POLYGONFROMTEXT:
      case MySqlParser::ST_POLYGONFROMWKB:
      case MySqlParser::ST_SRID:
      case MySqlParser::ST_STARTPOINT:
      case MySqlParser::ST_SYMDIFFERENCE:
      case MySqlParser::ST_TOUCHES:
      case MySqlParser::ST_UNION:
      case MySqlParser::ST_WITHIN:
      case MySqlParser::ST_X:
      case MySqlParser::ST_Y:
      case MySqlParser::SUBDATE:
      case MySqlParser::SUBSTRING_INDEX:
      case MySqlParser::SUBTIME:
      case MySqlParser::SYSTEM_USER:
      case MySqlParser::TAN:
      case MySqlParser::TIMEDIFF:
      case MySqlParser::TIMESTAMPADD:
      case MySqlParser::TIMESTAMPDIFF:
      case MySqlParser::TIME_FORMAT:
      case MySqlParser::TIME_TO_SEC:
      case MySqlParser::TOUCHES:
      case MySqlParser::TO_BASE64:
      case MySqlParser::TO_DAYS:
      case MySqlParser::TO_SECONDS:
      case MySqlParser::TP_CONNECTION_ADMIN:
      case MySqlParser::UCASE:
      case MySqlParser::UNCOMPRESS:
      case MySqlParser::UNCOMPRESSED_LENGTH:
      case MySqlParser::UNHEX:
      case MySqlParser::UNIX_TIMESTAMP:
      case MySqlParser::UPDATEXML:
      case MySqlParser::UPPER:
      case MySqlParser::UUID:
      case MySqlParser::UUID_SHORT:
      case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
      case MySqlParser::VERSION:
      case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
      case MySqlParser::WEEKDAY:
      case MySqlParser::WEEKOFYEAR:
      case MySqlParser::WEIGHT_STRING:
      case MySqlParser::WITHIN:
      case MySqlParser::YEARWEEK:
      case MySqlParser::Y_FUNCTION:
      case MySqlParser::X_FUNCTION:
      case MySqlParser::MOD:
      case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
      case MySqlParser::STRING_LITERAL:
      case MySqlParser::ID: {
        setState(3560);
        tableName();
        setState(3563);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::DOT) {
          setState(3561);
          match(MySqlParser::DOT);
          setState(3562);
          match(MySqlParser::STAR);
        }
        setState(3573);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(3565);
          match(MySqlParser::COMMA);
          setState(3566);
          tableName();
          setState(3569);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::DOT) {
            setState(3567);
            match(MySqlParser::DOT);
            setState(3568);
            match(MySqlParser::STAR);
          }
          setState(3575);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(3576);
        match(MySqlParser::FROM);
        setState(3577);
        tableSources();
        break;
      }

      case MySqlParser::FROM: {
        setState(3579);
        match(MySqlParser::FROM);
        setState(3580);
        tableName();
        setState(3583);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::DOT) {
          setState(3581);
          match(MySqlParser::DOT);
          setState(3582);
          match(MySqlParser::STAR);
        }
        setState(3593);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(3585);
          match(MySqlParser::COMMA);
          setState(3586);
          tableName();
          setState(3589);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::DOT) {
            setState(3587);
            match(MySqlParser::DOT);
            setState(3588);
            match(MySqlParser::STAR);
          }
          setState(3595);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(3596);
        match(MySqlParser::USING);
        setState(3597);
        tableSources();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3603);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WHERE) {
      setState(3601);
      match(MySqlParser::WHERE);
      setState(3602);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerOpenStatementContext ------------------------------------------------------------------

MySqlParser::HandlerOpenStatementContext::HandlerOpenStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::HandlerOpenStatementContext::HANDLER() {
  return getToken(MySqlParser::HANDLER, 0);
}

MySqlParser::TableNameContext* MySqlParser::HandlerOpenStatementContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::HandlerOpenStatementContext::OPEN() {
  return getToken(MySqlParser::OPEN, 0);
}

MySqlParser::UidContext* MySqlParser::HandlerOpenStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::HandlerOpenStatementContext::AS() {
  return getToken(MySqlParser::AS, 0);
}


size_t MySqlParser::HandlerOpenStatementContext::getRuleIndex() const {
  return MySqlParser::RuleHandlerOpenStatement;
}

void MySqlParser::HandlerOpenStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerOpenStatement(this);
}

void MySqlParser::HandlerOpenStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerOpenStatement(this);
}


std::any MySqlParser::HandlerOpenStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHandlerOpenStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::HandlerOpenStatementContext* MySqlParser::handlerOpenStatement() {
  HandlerOpenStatementContext *_localctx = _tracker.createInstance<HandlerOpenStatementContext>(_ctx, getState());
  enterRule(_localctx, 216, MySqlParser::RuleHandlerOpenStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3605);
    match(MySqlParser::HANDLER);
    setState(3606);
    tableName();
    setState(3607);
    match(MySqlParser::OPEN);
    setState(3612);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 506, _ctx)) {
    case 1: {
      setState(3609);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::AS) {
        setState(3608);
        match(MySqlParser::AS);
      }
      setState(3611);
      uid();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerReadIndexStatementContext ------------------------------------------------------------------

MySqlParser::HandlerReadIndexStatementContext::HandlerReadIndexStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::HandlerReadIndexStatementContext::HANDLER() {
  return getToken(MySqlParser::HANDLER, 0);
}

MySqlParser::TableNameContext* MySqlParser::HandlerReadIndexStatementContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::HandlerReadIndexStatementContext::READ() {
  return getToken(MySqlParser::READ, 0);
}

MySqlParser::UidContext* MySqlParser::HandlerReadIndexStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::ComparisonOperatorContext* MySqlParser::HandlerReadIndexStatementContext::comparisonOperator() {
  return getRuleContext<MySqlParser::ComparisonOperatorContext>(0);
}

tree::TerminalNode* MySqlParser::HandlerReadIndexStatementContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ConstantsContext* MySqlParser::HandlerReadIndexStatementContext::constants() {
  return getRuleContext<MySqlParser::ConstantsContext>(0);
}

tree::TerminalNode* MySqlParser::HandlerReadIndexStatementContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::HandlerReadIndexStatementContext::WHERE() {
  return getToken(MySqlParser::WHERE, 0);
}

MySqlParser::ExpressionContext* MySqlParser::HandlerReadIndexStatementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::HandlerReadIndexStatementContext::LIMIT() {
  return getToken(MySqlParser::LIMIT, 0);
}

MySqlParser::LimitClauseAtomContext* MySqlParser::HandlerReadIndexStatementContext::limitClauseAtom() {
  return getRuleContext<MySqlParser::LimitClauseAtomContext>(0);
}

tree::TerminalNode* MySqlParser::HandlerReadIndexStatementContext::FIRST() {
  return getToken(MySqlParser::FIRST, 0);
}

tree::TerminalNode* MySqlParser::HandlerReadIndexStatementContext::NEXT() {
  return getToken(MySqlParser::NEXT, 0);
}

tree::TerminalNode* MySqlParser::HandlerReadIndexStatementContext::PREV() {
  return getToken(MySqlParser::PREV, 0);
}

tree::TerminalNode* MySqlParser::HandlerReadIndexStatementContext::LAST() {
  return getToken(MySqlParser::LAST, 0);
}


size_t MySqlParser::HandlerReadIndexStatementContext::getRuleIndex() const {
  return MySqlParser::RuleHandlerReadIndexStatement;
}

void MySqlParser::HandlerReadIndexStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerReadIndexStatement(this);
}

void MySqlParser::HandlerReadIndexStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerReadIndexStatement(this);
}


std::any MySqlParser::HandlerReadIndexStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHandlerReadIndexStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::HandlerReadIndexStatementContext* MySqlParser::handlerReadIndexStatement() {
  HandlerReadIndexStatementContext *_localctx = _tracker.createInstance<HandlerReadIndexStatementContext>(_ctx, getState());
  enterRule(_localctx, 218, MySqlParser::RuleHandlerReadIndexStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3614);
    match(MySqlParser::HANDLER);
    setState(3615);
    tableName();
    setState(3616);
    match(MySqlParser::READ);
    setState(3617);
    antlrcpp::downCast<HandlerReadIndexStatementContext *>(_localctx)->index = uid();
    setState(3624);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::EQUAL_SYMBOL:
      case MySqlParser::GREATER_SYMBOL:
      case MySqlParser::LESS_SYMBOL:
      case MySqlParser::EXCLAMATION_SYMBOL: {
        setState(3618);
        comparisonOperator();
        setState(3619);
        match(MySqlParser::LR_BRACKET);
        setState(3620);
        constants();
        setState(3621);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      case MySqlParser::FIRST:
      case MySqlParser::LAST:
      case MySqlParser::NEXT:
      case MySqlParser::PREV: {
        setState(3623);
        antlrcpp::downCast<HandlerReadIndexStatementContext *>(_localctx)->moveOrder = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::FIRST

        || _la == MySqlParser::LAST || _la == MySqlParser::NEXT

        || _la == MySqlParser::PREV)) {
          antlrcpp::downCast<HandlerReadIndexStatementContext *>(_localctx)->moveOrder = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3628);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WHERE) {
      setState(3626);
      match(MySqlParser::WHERE);
      setState(3627);
      expression(0);
    }
    setState(3632);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LIMIT) {
      setState(3630);
      match(MySqlParser::LIMIT);
      setState(3631);
      limitClauseAtom();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerReadStatementContext ------------------------------------------------------------------

MySqlParser::HandlerReadStatementContext::HandlerReadStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::HandlerReadStatementContext::HANDLER() {
  return getToken(MySqlParser::HANDLER, 0);
}

MySqlParser::TableNameContext* MySqlParser::HandlerReadStatementContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::HandlerReadStatementContext::READ() {
  return getToken(MySqlParser::READ, 0);
}

tree::TerminalNode* MySqlParser::HandlerReadStatementContext::FIRST() {
  return getToken(MySqlParser::FIRST, 0);
}

tree::TerminalNode* MySqlParser::HandlerReadStatementContext::NEXT() {
  return getToken(MySqlParser::NEXT, 0);
}

tree::TerminalNode* MySqlParser::HandlerReadStatementContext::WHERE() {
  return getToken(MySqlParser::WHERE, 0);
}

MySqlParser::ExpressionContext* MySqlParser::HandlerReadStatementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::HandlerReadStatementContext::LIMIT() {
  return getToken(MySqlParser::LIMIT, 0);
}

MySqlParser::LimitClauseAtomContext* MySqlParser::HandlerReadStatementContext::limitClauseAtom() {
  return getRuleContext<MySqlParser::LimitClauseAtomContext>(0);
}


size_t MySqlParser::HandlerReadStatementContext::getRuleIndex() const {
  return MySqlParser::RuleHandlerReadStatement;
}

void MySqlParser::HandlerReadStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerReadStatement(this);
}

void MySqlParser::HandlerReadStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerReadStatement(this);
}


std::any MySqlParser::HandlerReadStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHandlerReadStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::HandlerReadStatementContext* MySqlParser::handlerReadStatement() {
  HandlerReadStatementContext *_localctx = _tracker.createInstance<HandlerReadStatementContext>(_ctx, getState());
  enterRule(_localctx, 220, MySqlParser::RuleHandlerReadStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3634);
    match(MySqlParser::HANDLER);
    setState(3635);
    tableName();
    setState(3636);
    match(MySqlParser::READ);
    setState(3637);
    antlrcpp::downCast<HandlerReadStatementContext *>(_localctx)->moveOrder = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::FIRST || _la == MySqlParser::NEXT)) {
      antlrcpp::downCast<HandlerReadStatementContext *>(_localctx)->moveOrder = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3640);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WHERE) {
      setState(3638);
      match(MySqlParser::WHERE);
      setState(3639);
      expression(0);
    }
    setState(3644);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LIMIT) {
      setState(3642);
      match(MySqlParser::LIMIT);
      setState(3643);
      limitClauseAtom();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerCloseStatementContext ------------------------------------------------------------------

MySqlParser::HandlerCloseStatementContext::HandlerCloseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::HandlerCloseStatementContext::HANDLER() {
  return getToken(MySqlParser::HANDLER, 0);
}

MySqlParser::TableNameContext* MySqlParser::HandlerCloseStatementContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::HandlerCloseStatementContext::CLOSE() {
  return getToken(MySqlParser::CLOSE, 0);
}


size_t MySqlParser::HandlerCloseStatementContext::getRuleIndex() const {
  return MySqlParser::RuleHandlerCloseStatement;
}

void MySqlParser::HandlerCloseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerCloseStatement(this);
}

void MySqlParser::HandlerCloseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerCloseStatement(this);
}


std::any MySqlParser::HandlerCloseStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHandlerCloseStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::HandlerCloseStatementContext* MySqlParser::handlerCloseStatement() {
  HandlerCloseStatementContext *_localctx = _tracker.createInstance<HandlerCloseStatementContext>(_ctx, getState());
  enterRule(_localctx, 222, MySqlParser::RuleHandlerCloseStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3646);
    match(MySqlParser::HANDLER);
    setState(3647);
    tableName();
    setState(3648);
    match(MySqlParser::CLOSE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleUpdateStatementContext ------------------------------------------------------------------

MySqlParser::SingleUpdateStatementContext::SingleUpdateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SingleUpdateStatementContext::UPDATE() {
  return getToken(MySqlParser::UPDATE, 0);
}

MySqlParser::TableNameContext* MySqlParser::SingleUpdateStatementContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::SingleUpdateStatementContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

std::vector<MySqlParser::UpdatedElementContext *> MySqlParser::SingleUpdateStatementContext::updatedElement() {
  return getRuleContexts<MySqlParser::UpdatedElementContext>();
}

MySqlParser::UpdatedElementContext* MySqlParser::SingleUpdateStatementContext::updatedElement(size_t i) {
  return getRuleContext<MySqlParser::UpdatedElementContext>(i);
}

tree::TerminalNode* MySqlParser::SingleUpdateStatementContext::IGNORE() {
  return getToken(MySqlParser::IGNORE, 0);
}

MySqlParser::UidContext* MySqlParser::SingleUpdateStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::SingleUpdateStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::SingleUpdateStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::SingleUpdateStatementContext::WHERE() {
  return getToken(MySqlParser::WHERE, 0);
}

MySqlParser::ExpressionContext* MySqlParser::SingleUpdateStatementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

MySqlParser::OrderByClauseContext* MySqlParser::SingleUpdateStatementContext::orderByClause() {
  return getRuleContext<MySqlParser::OrderByClauseContext>(0);
}

MySqlParser::LimitClauseContext* MySqlParser::SingleUpdateStatementContext::limitClause() {
  return getRuleContext<MySqlParser::LimitClauseContext>(0);
}

tree::TerminalNode* MySqlParser::SingleUpdateStatementContext::LOW_PRIORITY() {
  return getToken(MySqlParser::LOW_PRIORITY, 0);
}

tree::TerminalNode* MySqlParser::SingleUpdateStatementContext::AS() {
  return getToken(MySqlParser::AS, 0);
}


size_t MySqlParser::SingleUpdateStatementContext::getRuleIndex() const {
  return MySqlParser::RuleSingleUpdateStatement;
}

void MySqlParser::SingleUpdateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleUpdateStatement(this);
}

void MySqlParser::SingleUpdateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleUpdateStatement(this);
}


std::any MySqlParser::SingleUpdateStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSingleUpdateStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SingleUpdateStatementContext* MySqlParser::singleUpdateStatement() {
  SingleUpdateStatementContext *_localctx = _tracker.createInstance<SingleUpdateStatementContext>(_ctx, getState());
  enterRule(_localctx, 224, MySqlParser::RuleSingleUpdateStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3650);
    match(MySqlParser::UPDATE);
    setState(3652);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LOW_PRIORITY) {
      setState(3651);
      antlrcpp::downCast<SingleUpdateStatementContext *>(_localctx)->priority = match(MySqlParser::LOW_PRIORITY);
    }
    setState(3655);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IGNORE) {
      setState(3654);
      match(MySqlParser::IGNORE);
    }
    setState(3657);
    tableName();
    setState(3662);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 756891332513124352) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
      setState(3659);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::AS) {
        setState(3658);
        match(MySqlParser::AS);
      }
      setState(3661);
      uid();
    }
    setState(3664);
    match(MySqlParser::SET);
    setState(3665);
    updatedElement();
    setState(3670);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(3666);
      match(MySqlParser::COMMA);
      setState(3667);
      updatedElement();
      setState(3672);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3675);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WHERE) {
      setState(3673);
      match(MySqlParser::WHERE);
      setState(3674);
      expression(0);
    }
    setState(3678);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ORDER) {
      setState(3677);
      orderByClause();
    }
    setState(3681);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LIMIT) {
      setState(3680);
      limitClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipleUpdateStatementContext ------------------------------------------------------------------

MySqlParser::MultipleUpdateStatementContext::MultipleUpdateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::MultipleUpdateStatementContext::UPDATE() {
  return getToken(MySqlParser::UPDATE, 0);
}

MySqlParser::TableSourcesContext* MySqlParser::MultipleUpdateStatementContext::tableSources() {
  return getRuleContext<MySqlParser::TableSourcesContext>(0);
}

tree::TerminalNode* MySqlParser::MultipleUpdateStatementContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

std::vector<MySqlParser::UpdatedElementContext *> MySqlParser::MultipleUpdateStatementContext::updatedElement() {
  return getRuleContexts<MySqlParser::UpdatedElementContext>();
}

MySqlParser::UpdatedElementContext* MySqlParser::MultipleUpdateStatementContext::updatedElement(size_t i) {
  return getRuleContext<MySqlParser::UpdatedElementContext>(i);
}

tree::TerminalNode* MySqlParser::MultipleUpdateStatementContext::IGNORE() {
  return getToken(MySqlParser::IGNORE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::MultipleUpdateStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::MultipleUpdateStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::MultipleUpdateStatementContext::WHERE() {
  return getToken(MySqlParser::WHERE, 0);
}

MySqlParser::ExpressionContext* MySqlParser::MultipleUpdateStatementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::MultipleUpdateStatementContext::LOW_PRIORITY() {
  return getToken(MySqlParser::LOW_PRIORITY, 0);
}


size_t MySqlParser::MultipleUpdateStatementContext::getRuleIndex() const {
  return MySqlParser::RuleMultipleUpdateStatement;
}

void MySqlParser::MultipleUpdateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipleUpdateStatement(this);
}

void MySqlParser::MultipleUpdateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipleUpdateStatement(this);
}


std::any MySqlParser::MultipleUpdateStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitMultipleUpdateStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::MultipleUpdateStatementContext* MySqlParser::multipleUpdateStatement() {
  MultipleUpdateStatementContext *_localctx = _tracker.createInstance<MultipleUpdateStatementContext>(_ctx, getState());
  enterRule(_localctx, 226, MySqlParser::RuleMultipleUpdateStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3683);
    match(MySqlParser::UPDATE);
    setState(3685);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LOW_PRIORITY) {
      setState(3684);
      antlrcpp::downCast<MultipleUpdateStatementContext *>(_localctx)->priority = match(MySqlParser::LOW_PRIORITY);
    }
    setState(3688);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IGNORE) {
      setState(3687);
      match(MySqlParser::IGNORE);
    }
    setState(3690);
    tableSources();
    setState(3691);
    match(MySqlParser::SET);
    setState(3692);
    updatedElement();
    setState(3697);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(3693);
      match(MySqlParser::COMMA);
      setState(3694);
      updatedElement();
      setState(3699);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3702);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WHERE) {
      setState(3700);
      match(MySqlParser::WHERE);
      setState(3701);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderByClauseContext ------------------------------------------------------------------

MySqlParser::OrderByClauseContext::OrderByClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::OrderByClauseContext::ORDER() {
  return getToken(MySqlParser::ORDER, 0);
}

tree::TerminalNode* MySqlParser::OrderByClauseContext::BY() {
  return getToken(MySqlParser::BY, 0);
}

std::vector<MySqlParser::OrderByExpressionContext *> MySqlParser::OrderByClauseContext::orderByExpression() {
  return getRuleContexts<MySqlParser::OrderByExpressionContext>();
}

MySqlParser::OrderByExpressionContext* MySqlParser::OrderByClauseContext::orderByExpression(size_t i) {
  return getRuleContext<MySqlParser::OrderByExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::OrderByClauseContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::OrderByClauseContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::OrderByClauseContext::getRuleIndex() const {
  return MySqlParser::RuleOrderByClause;
}

void MySqlParser::OrderByClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrderByClause(this);
}

void MySqlParser::OrderByClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrderByClause(this);
}


std::any MySqlParser::OrderByClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitOrderByClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::OrderByClauseContext* MySqlParser::orderByClause() {
  OrderByClauseContext *_localctx = _tracker.createInstance<OrderByClauseContext>(_ctx, getState());
  enterRule(_localctx, 228, MySqlParser::RuleOrderByClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3704);
    match(MySqlParser::ORDER);
    setState(3705);
    match(MySqlParser::BY);
    setState(3706);
    orderByExpression();
    setState(3711);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 524, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3707);
        match(MySqlParser::COMMA);
        setState(3708);
        orderByExpression(); 
      }
      setState(3713);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 524, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderByExpressionContext ------------------------------------------------------------------

MySqlParser::OrderByExpressionContext::OrderByExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::ExpressionContext* MySqlParser::OrderByExpressionContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::OrderByExpressionContext::ASC() {
  return getToken(MySqlParser::ASC, 0);
}

tree::TerminalNode* MySqlParser::OrderByExpressionContext::DESC() {
  return getToken(MySqlParser::DESC, 0);
}


size_t MySqlParser::OrderByExpressionContext::getRuleIndex() const {
  return MySqlParser::RuleOrderByExpression;
}

void MySqlParser::OrderByExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrderByExpression(this);
}

void MySqlParser::OrderByExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrderByExpression(this);
}


std::any MySqlParser::OrderByExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitOrderByExpression(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::OrderByExpressionContext* MySqlParser::orderByExpression() {
  OrderByExpressionContext *_localctx = _tracker.createInstance<OrderByExpressionContext>(_ctx, getState());
  enterRule(_localctx, 230, MySqlParser::RuleOrderByExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3714);
    expression(0);
    setState(3716);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 525, _ctx)) {
    case 1: {
      setState(3715);
      antlrcpp::downCast<OrderByExpressionContext *>(_localctx)->order = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::ASC

      || _la == MySqlParser::DESC)) {
        antlrcpp::downCast<OrderByExpressionContext *>(_localctx)->order = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableSourcesContext ------------------------------------------------------------------

MySqlParser::TableSourcesContext::TableSourcesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::TableSourceContext *> MySqlParser::TableSourcesContext::tableSource() {
  return getRuleContexts<MySqlParser::TableSourceContext>();
}

MySqlParser::TableSourceContext* MySqlParser::TableSourcesContext::tableSource(size_t i) {
  return getRuleContext<MySqlParser::TableSourceContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::TableSourcesContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::TableSourcesContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::TableSourcesContext::getRuleIndex() const {
  return MySqlParser::RuleTableSources;
}

void MySqlParser::TableSourcesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableSources(this);
}

void MySqlParser::TableSourcesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableSources(this);
}


std::any MySqlParser::TableSourcesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableSources(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TableSourcesContext* MySqlParser::tableSources() {
  TableSourcesContext *_localctx = _tracker.createInstance<TableSourcesContext>(_ctx, getState());
  enterRule(_localctx, 232, MySqlParser::RuleTableSources);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3718);
    tableSource();
    setState(3723);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 526, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3719);
        match(MySqlParser::COMMA);
        setState(3720);
        tableSource(); 
      }
      setState(3725);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 526, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableSourceContext ------------------------------------------------------------------

MySqlParser::TableSourceContext::TableSourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::TableSourceContext::getRuleIndex() const {
  return MySqlParser::RuleTableSource;
}

void MySqlParser::TableSourceContext::copyFrom(TableSourceContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TableJsonContext ------------------------------------------------------------------

MySqlParser::JsonTableContext* MySqlParser::TableJsonContext::jsonTable() {
  return getRuleContext<MySqlParser::JsonTableContext>(0);
}

MySqlParser::TableJsonContext::TableJsonContext(TableSourceContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableJsonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableJson(this);
}
void MySqlParser::TableJsonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableJson(this);
}

std::any MySqlParser::TableJsonContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableJson(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableSourceNestedContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableSourceNestedContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::TableSourceItemContext* MySqlParser::TableSourceNestedContext::tableSourceItem() {
  return getRuleContext<MySqlParser::TableSourceItemContext>(0);
}

tree::TerminalNode* MySqlParser::TableSourceNestedContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<MySqlParser::JoinPartContext *> MySqlParser::TableSourceNestedContext::joinPart() {
  return getRuleContexts<MySqlParser::JoinPartContext>();
}

MySqlParser::JoinPartContext* MySqlParser::TableSourceNestedContext::joinPart(size_t i) {
  return getRuleContext<MySqlParser::JoinPartContext>(i);
}

MySqlParser::TableSourceNestedContext::TableSourceNestedContext(TableSourceContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableSourceNestedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableSourceNested(this);
}
void MySqlParser::TableSourceNestedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableSourceNested(this);
}

std::any MySqlParser::TableSourceNestedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableSourceNested(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableSourceBaseContext ------------------------------------------------------------------

MySqlParser::TableSourceItemContext* MySqlParser::TableSourceBaseContext::tableSourceItem() {
  return getRuleContext<MySqlParser::TableSourceItemContext>(0);
}

std::vector<MySqlParser::JoinPartContext *> MySqlParser::TableSourceBaseContext::joinPart() {
  return getRuleContexts<MySqlParser::JoinPartContext>();
}

MySqlParser::JoinPartContext* MySqlParser::TableSourceBaseContext::joinPart(size_t i) {
  return getRuleContext<MySqlParser::JoinPartContext>(i);
}

MySqlParser::TableSourceBaseContext::TableSourceBaseContext(TableSourceContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableSourceBaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableSourceBase(this);
}
void MySqlParser::TableSourceBaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableSourceBase(this);
}

std::any MySqlParser::TableSourceBaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableSourceBase(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::TableSourceContext* MySqlParser::tableSource() {
  TableSourceContext *_localctx = _tracker.createInstance<TableSourceContext>(_ctx, getState());
  enterRule(_localctx, 234, MySqlParser::RuleTableSource);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(3744);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 529, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::TableSourceBaseContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(3726);
      tableSourceItem();
      setState(3730);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 527, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3727);
          joinPart(); 
        }
        setState(3732);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 527, _ctx);
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::TableSourceNestedContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(3733);
      match(MySqlParser::LR_BRACKET);
      setState(3734);
      tableSourceItem();
      setState(3738);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 34) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 34)) & -9150751492863426559) != 0) || ((((_la - 113) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 113)) & 288230410511450113) != 0)) {
        setState(3735);
        joinPart();
        setState(3740);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3741);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::TableJsonContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(3743);
      jsonTable();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableSourceItemContext ------------------------------------------------------------------

MySqlParser::TableSourceItemContext::TableSourceItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::TableSourceItemContext::getRuleIndex() const {
  return MySqlParser::RuleTableSourceItem;
}

void MySqlParser::TableSourceItemContext::copyFrom(TableSourceItemContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SubqueryTableItemContext ------------------------------------------------------------------

MySqlParser::UidContext* MySqlParser::SubqueryTableItemContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::SelectStatementContext* MySqlParser::SubqueryTableItemContext::selectStatement() {
  return getRuleContext<MySqlParser::SelectStatementContext>(0);
}

tree::TerminalNode* MySqlParser::SubqueryTableItemContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::SubqueryTableItemContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::SubqueryTableItemContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

MySqlParser::SubqueryTableItemContext::SubqueryTableItemContext(TableSourceItemContext *ctx) { copyFrom(ctx); }

void MySqlParser::SubqueryTableItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubqueryTableItem(this);
}
void MySqlParser::SubqueryTableItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubqueryTableItem(this);
}

std::any MySqlParser::SubqueryTableItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSubqueryTableItem(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AtomTableItemContext ------------------------------------------------------------------

MySqlParser::TableNameContext* MySqlParser::AtomTableItemContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::AtomTableItemContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

tree::TerminalNode* MySqlParser::AtomTableItemContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::UidListContext* MySqlParser::AtomTableItemContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::AtomTableItemContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<MySqlParser::IndexHintContext *> MySqlParser::AtomTableItemContext::indexHint() {
  return getRuleContexts<MySqlParser::IndexHintContext>();
}

MySqlParser::IndexHintContext* MySqlParser::AtomTableItemContext::indexHint(size_t i) {
  return getRuleContext<MySqlParser::IndexHintContext>(i);
}

MySqlParser::UidContext* MySqlParser::AtomTableItemContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::AtomTableItemContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::AtomTableItemContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::AtomTableItemContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::AtomTableItemContext::AtomTableItemContext(TableSourceItemContext *ctx) { copyFrom(ctx); }

void MySqlParser::AtomTableItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtomTableItem(this);
}
void MySqlParser::AtomTableItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtomTableItem(this);
}

std::any MySqlParser::AtomTableItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAtomTableItem(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableSourcesItemContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableSourcesItemContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::TableSourcesContext* MySqlParser::TableSourcesItemContext::tableSources() {
  return getRuleContext<MySqlParser::TableSourcesContext>(0);
}

tree::TerminalNode* MySqlParser::TableSourcesItemContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::TableSourcesItemContext::TableSourcesItemContext(TableSourceItemContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableSourcesItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableSourcesItem(this);
}
void MySqlParser::TableSourcesItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableSourcesItem(this);
}

std::any MySqlParser::TableSourcesItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableSourcesItem(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::TableSourceItemContext* MySqlParser::tableSourceItem() {
  TableSourceItemContext *_localctx = _tracker.createInstance<TableSourceItemContext>(_ctx, getState());
  enterRule(_localctx, 236, MySqlParser::RuleTableSourceItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(3786);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 537, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::AtomTableItemContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(3746);
      tableName();
      setState(3752);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::PARTITION) {
        setState(3747);
        match(MySqlParser::PARTITION);
        setState(3748);
        match(MySqlParser::LR_BRACKET);
        setState(3749);
        uidList();
        setState(3750);
        match(MySqlParser::RR_BRACKET);
      }
      setState(3758);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 532, _ctx)) {
      case 1: {
        setState(3755);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::AS) {
          setState(3754);
          match(MySqlParser::AS);
        }
        setState(3757);
        antlrcpp::downCast<AtomTableItemContext *>(_localctx)->alias = uid();
        break;
      }

      default:
        break;
      }
      setState(3768);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 534, _ctx)) {
      case 1: {
        setState(3760);
        indexHint();
        setState(3765);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 533, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(3761);
            match(MySqlParser::COMMA);
            setState(3762);
            indexHint(); 
          }
          setState(3767);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 533, _ctx);
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::SubqueryTableItemContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(3775);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 535, _ctx)) {
      case 1: {
        setState(3770);
        selectStatement();
        break;
      }

      case 2: {
        setState(3771);
        match(MySqlParser::LR_BRACKET);
        setState(3772);
        antlrcpp::downCast<SubqueryTableItemContext *>(_localctx)->parenthesisSubquery = selectStatement();
        setState(3773);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
      setState(3778);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::AS) {
        setState(3777);
        match(MySqlParser::AS);
      }
      setState(3780);
      antlrcpp::downCast<SubqueryTableItemContext *>(_localctx)->alias = uid();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::TableSourcesItemContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(3782);
      match(MySqlParser::LR_BRACKET);
      setState(3783);
      tableSources();
      setState(3784);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintContext ------------------------------------------------------------------

MySqlParser::IndexHintContext::IndexHintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::IndexHintContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::UidListContext* MySqlParser::IndexHintContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::IndexHintContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::IndexHintContext::USE() {
  return getToken(MySqlParser::USE, 0);
}

tree::TerminalNode* MySqlParser::IndexHintContext::IGNORE() {
  return getToken(MySqlParser::IGNORE, 0);
}

tree::TerminalNode* MySqlParser::IndexHintContext::FORCE() {
  return getToken(MySqlParser::FORCE, 0);
}

tree::TerminalNode* MySqlParser::IndexHintContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::IndexHintContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}

tree::TerminalNode* MySqlParser::IndexHintContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

MySqlParser::IndexHintTypeContext* MySqlParser::IndexHintContext::indexHintType() {
  return getRuleContext<MySqlParser::IndexHintTypeContext>(0);
}


size_t MySqlParser::IndexHintContext::getRuleIndex() const {
  return MySqlParser::RuleIndexHint;
}

void MySqlParser::IndexHintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHint(this);
}

void MySqlParser::IndexHintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHint(this);
}


std::any MySqlParser::IndexHintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIndexHint(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::IndexHintContext* MySqlParser::indexHint() {
  IndexHintContext *_localctx = _tracker.createInstance<IndexHintContext>(_ctx, getState());
  enterRule(_localctx, 238, MySqlParser::RuleIndexHint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3788);
    antlrcpp::downCast<IndexHintContext *>(_localctx)->indexHintAction = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::FORCE

    || _la == MySqlParser::IGNORE || _la == MySqlParser::USE)) {
      antlrcpp::downCast<IndexHintContext *>(_localctx)->indexHintAction = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3789);
    antlrcpp::downCast<IndexHintContext *>(_localctx)->keyFormat = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::INDEX

    || _la == MySqlParser::KEY)) {
      antlrcpp::downCast<IndexHintContext *>(_localctx)->keyFormat = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3792);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::FOR) {
      setState(3790);
      match(MySqlParser::FOR);
      setState(3791);
      indexHintType();
    }
    setState(3794);
    match(MySqlParser::LR_BRACKET);
    setState(3795);
    uidList();
    setState(3796);
    match(MySqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintTypeContext ------------------------------------------------------------------

MySqlParser::IndexHintTypeContext::IndexHintTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::IndexHintTypeContext::JOIN() {
  return getToken(MySqlParser::JOIN, 0);
}

tree::TerminalNode* MySqlParser::IndexHintTypeContext::ORDER() {
  return getToken(MySqlParser::ORDER, 0);
}

tree::TerminalNode* MySqlParser::IndexHintTypeContext::BY() {
  return getToken(MySqlParser::BY, 0);
}

tree::TerminalNode* MySqlParser::IndexHintTypeContext::GROUP() {
  return getToken(MySqlParser::GROUP, 0);
}


size_t MySqlParser::IndexHintTypeContext::getRuleIndex() const {
  return MySqlParser::RuleIndexHintType;
}

void MySqlParser::IndexHintTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHintType(this);
}

void MySqlParser::IndexHintTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHintType(this);
}


std::any MySqlParser::IndexHintTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIndexHintType(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::IndexHintTypeContext* MySqlParser::indexHintType() {
  IndexHintTypeContext *_localctx = _tracker.createInstance<IndexHintTypeContext>(_ctx, getState());
  enterRule(_localctx, 240, MySqlParser::RuleIndexHintType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3803);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::JOIN: {
        enterOuterAlt(_localctx, 1);
        setState(3798);
        match(MySqlParser::JOIN);
        break;
      }

      case MySqlParser::ORDER: {
        enterOuterAlt(_localctx, 2);
        setState(3799);
        match(MySqlParser::ORDER);
        setState(3800);
        match(MySqlParser::BY);
        break;
      }

      case MySqlParser::GROUP: {
        enterOuterAlt(_localctx, 3);
        setState(3801);
        match(MySqlParser::GROUP);
        setState(3802);
        match(MySqlParser::BY);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinPartContext ------------------------------------------------------------------

MySqlParser::JoinPartContext::JoinPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::JoinPartContext::getRuleIndex() const {
  return MySqlParser::RuleJoinPart;
}

void MySqlParser::JoinPartContext::copyFrom(JoinPartContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- InnerJoinContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::InnerJoinContext::JOIN() {
  return getToken(MySqlParser::JOIN, 0);
}

MySqlParser::TableSourceItemContext* MySqlParser::InnerJoinContext::tableSourceItem() {
  return getRuleContext<MySqlParser::TableSourceItemContext>(0);
}

tree::TerminalNode* MySqlParser::InnerJoinContext::LATERAL() {
  return getToken(MySqlParser::LATERAL, 0);
}

tree::TerminalNode* MySqlParser::InnerJoinContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

MySqlParser::ExpressionContext* MySqlParser::InnerJoinContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::InnerJoinContext::USING() {
  return getToken(MySqlParser::USING, 0);
}

tree::TerminalNode* MySqlParser::InnerJoinContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::UidListContext* MySqlParser::InnerJoinContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::InnerJoinContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::InnerJoinContext::INNER() {
  return getToken(MySqlParser::INNER, 0);
}

tree::TerminalNode* MySqlParser::InnerJoinContext::CROSS() {
  return getToken(MySqlParser::CROSS, 0);
}

MySqlParser::InnerJoinContext::InnerJoinContext(JoinPartContext *ctx) { copyFrom(ctx); }

void MySqlParser::InnerJoinContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInnerJoin(this);
}
void MySqlParser::InnerJoinContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInnerJoin(this);
}

std::any MySqlParser::InnerJoinContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitInnerJoin(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NaturalJoinContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::NaturalJoinContext::NATURAL() {
  return getToken(MySqlParser::NATURAL, 0);
}

tree::TerminalNode* MySqlParser::NaturalJoinContext::JOIN() {
  return getToken(MySqlParser::JOIN, 0);
}

MySqlParser::TableSourceItemContext* MySqlParser::NaturalJoinContext::tableSourceItem() {
  return getRuleContext<MySqlParser::TableSourceItemContext>(0);
}

tree::TerminalNode* MySqlParser::NaturalJoinContext::LEFT() {
  return getToken(MySqlParser::LEFT, 0);
}

tree::TerminalNode* MySqlParser::NaturalJoinContext::RIGHT() {
  return getToken(MySqlParser::RIGHT, 0);
}

tree::TerminalNode* MySqlParser::NaturalJoinContext::OUTER() {
  return getToken(MySqlParser::OUTER, 0);
}

MySqlParser::NaturalJoinContext::NaturalJoinContext(JoinPartContext *ctx) { copyFrom(ctx); }

void MySqlParser::NaturalJoinContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNaturalJoin(this);
}
void MySqlParser::NaturalJoinContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNaturalJoin(this);
}

std::any MySqlParser::NaturalJoinContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitNaturalJoin(this);
  else
    return visitor->visitChildren(this);
}
//----------------- OuterJoinContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::OuterJoinContext::JOIN() {
  return getToken(MySqlParser::JOIN, 0);
}

MySqlParser::TableSourceItemContext* MySqlParser::OuterJoinContext::tableSourceItem() {
  return getRuleContext<MySqlParser::TableSourceItemContext>(0);
}

tree::TerminalNode* MySqlParser::OuterJoinContext::LEFT() {
  return getToken(MySqlParser::LEFT, 0);
}

tree::TerminalNode* MySqlParser::OuterJoinContext::RIGHT() {
  return getToken(MySqlParser::RIGHT, 0);
}

tree::TerminalNode* MySqlParser::OuterJoinContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

MySqlParser::ExpressionContext* MySqlParser::OuterJoinContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::OuterJoinContext::USING() {
  return getToken(MySqlParser::USING, 0);
}

tree::TerminalNode* MySqlParser::OuterJoinContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::UidListContext* MySqlParser::OuterJoinContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::OuterJoinContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::OuterJoinContext::OUTER() {
  return getToken(MySqlParser::OUTER, 0);
}

tree::TerminalNode* MySqlParser::OuterJoinContext::LATERAL() {
  return getToken(MySqlParser::LATERAL, 0);
}

MySqlParser::OuterJoinContext::OuterJoinContext(JoinPartContext *ctx) { copyFrom(ctx); }

void MySqlParser::OuterJoinContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOuterJoin(this);
}
void MySqlParser::OuterJoinContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOuterJoin(this);
}

std::any MySqlParser::OuterJoinContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitOuterJoin(this);
  else
    return visitor->visitChildren(this);
}
//----------------- StraightJoinContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::StraightJoinContext::STRAIGHT_JOIN() {
  return getToken(MySqlParser::STRAIGHT_JOIN, 0);
}

MySqlParser::TableSourceItemContext* MySqlParser::StraightJoinContext::tableSourceItem() {
  return getRuleContext<MySqlParser::TableSourceItemContext>(0);
}

tree::TerminalNode* MySqlParser::StraightJoinContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

MySqlParser::ExpressionContext* MySqlParser::StraightJoinContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

MySqlParser::StraightJoinContext::StraightJoinContext(JoinPartContext *ctx) { copyFrom(ctx); }

void MySqlParser::StraightJoinContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStraightJoin(this);
}
void MySqlParser::StraightJoinContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStraightJoin(this);
}

std::any MySqlParser::StraightJoinContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitStraightJoin(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::JoinPartContext* MySqlParser::joinPart() {
  JoinPartContext *_localctx = _tracker.createInstance<JoinPartContext>(_ctx, getState());
  enterRule(_localctx, 242, MySqlParser::RuleJoinPart);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3855);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::CROSS:
      case MySqlParser::INNER:
      case MySqlParser::JOIN: {
        _localctx = _tracker.createInstance<MySqlParser::InnerJoinContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(3806);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::CROSS

        || _la == MySqlParser::INNER) {
          setState(3805);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::CROSS

          || _la == MySqlParser::INNER)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(3808);
        match(MySqlParser::JOIN);
        setState(3810);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 541, _ctx)) {
        case 1: {
          setState(3809);
          match(MySqlParser::LATERAL);
          break;
        }

        default:
          break;
        }
        setState(3812);
        tableSourceItem();
        setState(3820);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 542, _ctx)) {
        case 1: {
          setState(3813);
          match(MySqlParser::ON);
          setState(3814);
          expression(0);
          break;
        }

        case 2: {
          setState(3815);
          match(MySqlParser::USING);
          setState(3816);
          match(MySqlParser::LR_BRACKET);
          setState(3817);
          uidList();
          setState(3818);
          match(MySqlParser::RR_BRACKET);
          break;
        }

        default:
          break;
        }
        break;
      }

      case MySqlParser::STRAIGHT_JOIN: {
        _localctx = _tracker.createInstance<MySqlParser::StraightJoinContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(3822);
        match(MySqlParser::STRAIGHT_JOIN);
        setState(3823);
        tableSourceItem();
        setState(3826);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 543, _ctx)) {
        case 1: {
          setState(3824);
          match(MySqlParser::ON);
          setState(3825);
          expression(0);
          break;
        }

        default:
          break;
        }
        break;
      }

      case MySqlParser::LEFT:
      case MySqlParser::RIGHT: {
        _localctx = _tracker.createInstance<MySqlParser::OuterJoinContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(3828);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::LEFT

        || _la == MySqlParser::RIGHT)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3830);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::OUTER) {
          setState(3829);
          match(MySqlParser::OUTER);
        }
        setState(3832);
        match(MySqlParser::JOIN);
        setState(3834);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 545, _ctx)) {
        case 1: {
          setState(3833);
          match(MySqlParser::LATERAL);
          break;
        }

        default:
          break;
        }
        setState(3836);
        tableSourceItem();
        setState(3844);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::ON: {
            setState(3837);
            match(MySqlParser::ON);
            setState(3838);
            expression(0);
            break;
          }

          case MySqlParser::USING: {
            setState(3839);
            match(MySqlParser::USING);
            setState(3840);
            match(MySqlParser::LR_BRACKET);
            setState(3841);
            uidList();
            setState(3842);
            match(MySqlParser::RR_BRACKET);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySqlParser::NATURAL: {
        _localctx = _tracker.createInstance<MySqlParser::NaturalJoinContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(3846);
        match(MySqlParser::NATURAL);
        setState(3851);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::LEFT

        || _la == MySqlParser::RIGHT) {
          setState(3847);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::LEFT

          || _la == MySqlParser::RIGHT)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3849);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::OUTER) {
            setState(3848);
            match(MySqlParser::OUTER);
          }
        }
        setState(3853);
        match(MySqlParser::JOIN);
        setState(3854);
        tableSourceItem();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionContext ------------------------------------------------------------------

MySqlParser::QueryExpressionContext::QueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::QueryExpressionContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::QuerySpecificationContext* MySqlParser::QueryExpressionContext::querySpecification() {
  return getRuleContext<MySqlParser::QuerySpecificationContext>(0);
}

tree::TerminalNode* MySqlParser::QueryExpressionContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::QueryExpressionContext* MySqlParser::QueryExpressionContext::queryExpression() {
  return getRuleContext<MySqlParser::QueryExpressionContext>(0);
}


size_t MySqlParser::QueryExpressionContext::getRuleIndex() const {
  return MySqlParser::RuleQueryExpression;
}

void MySqlParser::QueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpression(this);
}

void MySqlParser::QueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpression(this);
}


std::any MySqlParser::QueryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitQueryExpression(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::QueryExpressionContext* MySqlParser::queryExpression() {
  QueryExpressionContext *_localctx = _tracker.createInstance<QueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 244, MySqlParser::RuleQueryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3865);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 550, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3857);
      match(MySqlParser::LR_BRACKET);
      setState(3858);
      querySpecification();
      setState(3859);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3861);
      match(MySqlParser::LR_BRACKET);
      setState(3862);
      queryExpression();
      setState(3863);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionNointoContext ------------------------------------------------------------------

MySqlParser::QueryExpressionNointoContext::QueryExpressionNointoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::QueryExpressionNointoContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::QuerySpecificationNointoContext* MySqlParser::QueryExpressionNointoContext::querySpecificationNointo() {
  return getRuleContext<MySqlParser::QuerySpecificationNointoContext>(0);
}

tree::TerminalNode* MySqlParser::QueryExpressionNointoContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::QueryExpressionNointoContext* MySqlParser::QueryExpressionNointoContext::queryExpressionNointo() {
  return getRuleContext<MySqlParser::QueryExpressionNointoContext>(0);
}


size_t MySqlParser::QueryExpressionNointoContext::getRuleIndex() const {
  return MySqlParser::RuleQueryExpressionNointo;
}

void MySqlParser::QueryExpressionNointoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpressionNointo(this);
}

void MySqlParser::QueryExpressionNointoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpressionNointo(this);
}


std::any MySqlParser::QueryExpressionNointoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitQueryExpressionNointo(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::QueryExpressionNointoContext* MySqlParser::queryExpressionNointo() {
  QueryExpressionNointoContext *_localctx = _tracker.createInstance<QueryExpressionNointoContext>(_ctx, getState());
  enterRule(_localctx, 246, MySqlParser::RuleQueryExpressionNointo);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3875);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 551, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3867);
      match(MySqlParser::LR_BRACKET);
      setState(3868);
      querySpecificationNointo();
      setState(3869);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3871);
      match(MySqlParser::LR_BRACKET);
      setState(3872);
      queryExpressionNointo();
      setState(3873);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuerySpecificationContext ------------------------------------------------------------------

MySqlParser::QuerySpecificationContext::QuerySpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::QuerySpecificationContext::SELECT() {
  return getToken(MySqlParser::SELECT, 0);
}

MySqlParser::SelectElementsContext* MySqlParser::QuerySpecificationContext::selectElements() {
  return getRuleContext<MySqlParser::SelectElementsContext>(0);
}

MySqlParser::FromClauseContext* MySqlParser::QuerySpecificationContext::fromClause() {
  return getRuleContext<MySqlParser::FromClauseContext>(0);
}

std::vector<MySqlParser::SelectSpecContext *> MySqlParser::QuerySpecificationContext::selectSpec() {
  return getRuleContexts<MySqlParser::SelectSpecContext>();
}

MySqlParser::SelectSpecContext* MySqlParser::QuerySpecificationContext::selectSpec(size_t i) {
  return getRuleContext<MySqlParser::SelectSpecContext>(i);
}

MySqlParser::SelectIntoExpressionContext* MySqlParser::QuerySpecificationContext::selectIntoExpression() {
  return getRuleContext<MySqlParser::SelectIntoExpressionContext>(0);
}

MySqlParser::GroupByClauseContext* MySqlParser::QuerySpecificationContext::groupByClause() {
  return getRuleContext<MySqlParser::GroupByClauseContext>(0);
}

MySqlParser::HavingClauseContext* MySqlParser::QuerySpecificationContext::havingClause() {
  return getRuleContext<MySqlParser::HavingClauseContext>(0);
}

MySqlParser::WindowClauseContext* MySqlParser::QuerySpecificationContext::windowClause() {
  return getRuleContext<MySqlParser::WindowClauseContext>(0);
}

MySqlParser::OrderByClauseContext* MySqlParser::QuerySpecificationContext::orderByClause() {
  return getRuleContext<MySqlParser::OrderByClauseContext>(0);
}

MySqlParser::LimitClauseContext* MySqlParser::QuerySpecificationContext::limitClause() {
  return getRuleContext<MySqlParser::LimitClauseContext>(0);
}


size_t MySqlParser::QuerySpecificationContext::getRuleIndex() const {
  return MySqlParser::RuleQuerySpecification;
}

void MySqlParser::QuerySpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuerySpecification(this);
}

void MySqlParser::QuerySpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuerySpecification(this);
}


std::any MySqlParser::QuerySpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitQuerySpecification(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::QuerySpecificationContext* MySqlParser::querySpecification() {
  QuerySpecificationContext *_localctx = _tracker.createInstance<QuerySpecificationContext>(_ctx, getState());
  enterRule(_localctx, 248, MySqlParser::RuleQuerySpecification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(3931);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 566, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3877);
      match(MySqlParser::SELECT);
      setState(3881);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 552, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3878);
          selectSpec(); 
        }
        setState(3883);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 552, _ctx);
      }
      setState(3884);
      selectElements();
      setState(3886);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::INTO) {
        setState(3885);
        selectIntoExpression();
      }
      setState(3888);
      fromClause();
      setState(3890);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 554, _ctx)) {
      case 1: {
        setState(3889);
        groupByClause();
        break;
      }

      default:
        break;
      }
      setState(3893);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::HAVING) {
        setState(3892);
        havingClause();
      }
      setState(3896);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::WINDOW) {
        setState(3895);
        windowClause();
      }
      setState(3899);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 557, _ctx)) {
      case 1: {
        setState(3898);
        orderByClause();
        break;
      }

      default:
        break;
      }
      setState(3902);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 558, _ctx)) {
      case 1: {
        setState(3901);
        limitClause();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3904);
      match(MySqlParser::SELECT);
      setState(3908);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 559, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3905);
          selectSpec(); 
        }
        setState(3910);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 559, _ctx);
      }
      setState(3911);
      selectElements();
      setState(3912);
      fromClause();
      setState(3914);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 560, _ctx)) {
      case 1: {
        setState(3913);
        groupByClause();
        break;
      }

      default:
        break;
      }
      setState(3917);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::HAVING) {
        setState(3916);
        havingClause();
      }
      setState(3920);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::WINDOW) {
        setState(3919);
        windowClause();
      }
      setState(3923);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 563, _ctx)) {
      case 1: {
        setState(3922);
        orderByClause();
        break;
      }

      default:
        break;
      }
      setState(3926);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 564, _ctx)) {
      case 1: {
        setState(3925);
        limitClause();
        break;
      }

      default:
        break;
      }
      setState(3929);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::INTO) {
        setState(3928);
        selectIntoExpression();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuerySpecificationNointoContext ------------------------------------------------------------------

MySqlParser::QuerySpecificationNointoContext::QuerySpecificationNointoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::QuerySpecificationNointoContext::SELECT() {
  return getToken(MySqlParser::SELECT, 0);
}

MySqlParser::SelectElementsContext* MySqlParser::QuerySpecificationNointoContext::selectElements() {
  return getRuleContext<MySqlParser::SelectElementsContext>(0);
}

MySqlParser::FromClauseContext* MySqlParser::QuerySpecificationNointoContext::fromClause() {
  return getRuleContext<MySqlParser::FromClauseContext>(0);
}

std::vector<MySqlParser::SelectSpecContext *> MySqlParser::QuerySpecificationNointoContext::selectSpec() {
  return getRuleContexts<MySqlParser::SelectSpecContext>();
}

MySqlParser::SelectSpecContext* MySqlParser::QuerySpecificationNointoContext::selectSpec(size_t i) {
  return getRuleContext<MySqlParser::SelectSpecContext>(i);
}

MySqlParser::GroupByClauseContext* MySqlParser::QuerySpecificationNointoContext::groupByClause() {
  return getRuleContext<MySqlParser::GroupByClauseContext>(0);
}

MySqlParser::HavingClauseContext* MySqlParser::QuerySpecificationNointoContext::havingClause() {
  return getRuleContext<MySqlParser::HavingClauseContext>(0);
}

MySqlParser::WindowClauseContext* MySqlParser::QuerySpecificationNointoContext::windowClause() {
  return getRuleContext<MySqlParser::WindowClauseContext>(0);
}

MySqlParser::OrderByClauseContext* MySqlParser::QuerySpecificationNointoContext::orderByClause() {
  return getRuleContext<MySqlParser::OrderByClauseContext>(0);
}

MySqlParser::LimitClauseContext* MySqlParser::QuerySpecificationNointoContext::limitClause() {
  return getRuleContext<MySqlParser::LimitClauseContext>(0);
}


size_t MySqlParser::QuerySpecificationNointoContext::getRuleIndex() const {
  return MySqlParser::RuleQuerySpecificationNointo;
}

void MySqlParser::QuerySpecificationNointoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuerySpecificationNointo(this);
}

void MySqlParser::QuerySpecificationNointoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuerySpecificationNointo(this);
}


std::any MySqlParser::QuerySpecificationNointoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitQuerySpecificationNointo(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::QuerySpecificationNointoContext* MySqlParser::querySpecificationNointo() {
  QuerySpecificationNointoContext *_localctx = _tracker.createInstance<QuerySpecificationNointoContext>(_ctx, getState());
  enterRule(_localctx, 250, MySqlParser::RuleQuerySpecificationNointo);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3933);
    match(MySqlParser::SELECT);
    setState(3937);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 567, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3934);
        selectSpec(); 
      }
      setState(3939);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 567, _ctx);
    }
    setState(3940);
    selectElements();
    setState(3941);
    fromClause();
    setState(3943);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 568, _ctx)) {
    case 1: {
      setState(3942);
      groupByClause();
      break;
    }

    default:
      break;
    }
    setState(3946);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::HAVING) {
      setState(3945);
      havingClause();
    }
    setState(3949);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WINDOW) {
      setState(3948);
      windowClause();
    }
    setState(3952);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 571, _ctx)) {
    case 1: {
      setState(3951);
      orderByClause();
      break;
    }

    default:
      break;
    }
    setState(3955);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 572, _ctx)) {
    case 1: {
      setState(3954);
      limitClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnionParenthesisContext ------------------------------------------------------------------

MySqlParser::UnionParenthesisContext::UnionParenthesisContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::UnionParenthesisContext::UNION() {
  return getToken(MySqlParser::UNION, 0);
}

MySqlParser::QueryExpressionNointoContext* MySqlParser::UnionParenthesisContext::queryExpressionNointo() {
  return getRuleContext<MySqlParser::QueryExpressionNointoContext>(0);
}

tree::TerminalNode* MySqlParser::UnionParenthesisContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

tree::TerminalNode* MySqlParser::UnionParenthesisContext::DISTINCT() {
  return getToken(MySqlParser::DISTINCT, 0);
}


size_t MySqlParser::UnionParenthesisContext::getRuleIndex() const {
  return MySqlParser::RuleUnionParenthesis;
}

void MySqlParser::UnionParenthesisContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnionParenthesis(this);
}

void MySqlParser::UnionParenthesisContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnionParenthesis(this);
}


std::any MySqlParser::UnionParenthesisContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUnionParenthesis(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UnionParenthesisContext* MySqlParser::unionParenthesis() {
  UnionParenthesisContext *_localctx = _tracker.createInstance<UnionParenthesisContext>(_ctx, getState());
  enterRule(_localctx, 252, MySqlParser::RuleUnionParenthesis);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3957);
    match(MySqlParser::UNION);
    setState(3959);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ALL

    || _la == MySqlParser::DISTINCT) {
      setState(3958);
      antlrcpp::downCast<UnionParenthesisContext *>(_localctx)->unionType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::ALL

      || _la == MySqlParser::DISTINCT)) {
        antlrcpp::downCast<UnionParenthesisContext *>(_localctx)->unionType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3961);
    queryExpressionNointo();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnionStatementContext ------------------------------------------------------------------

MySqlParser::UnionStatementContext::UnionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::UnionStatementContext::UNION() {
  return getToken(MySqlParser::UNION, 0);
}

MySqlParser::QuerySpecificationNointoContext* MySqlParser::UnionStatementContext::querySpecificationNointo() {
  return getRuleContext<MySqlParser::QuerySpecificationNointoContext>(0);
}

MySqlParser::QueryExpressionNointoContext* MySqlParser::UnionStatementContext::queryExpressionNointo() {
  return getRuleContext<MySqlParser::QueryExpressionNointoContext>(0);
}

tree::TerminalNode* MySqlParser::UnionStatementContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

tree::TerminalNode* MySqlParser::UnionStatementContext::DISTINCT() {
  return getToken(MySqlParser::DISTINCT, 0);
}


size_t MySqlParser::UnionStatementContext::getRuleIndex() const {
  return MySqlParser::RuleUnionStatement;
}

void MySqlParser::UnionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnionStatement(this);
}

void MySqlParser::UnionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnionStatement(this);
}


std::any MySqlParser::UnionStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUnionStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UnionStatementContext* MySqlParser::unionStatement() {
  UnionStatementContext *_localctx = _tracker.createInstance<UnionStatementContext>(_ctx, getState());
  enterRule(_localctx, 254, MySqlParser::RuleUnionStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3963);
    match(MySqlParser::UNION);
    setState(3965);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ALL

    || _la == MySqlParser::DISTINCT) {
      setState(3964);
      antlrcpp::downCast<UnionStatementContext *>(_localctx)->unionType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::ALL

      || _la == MySqlParser::DISTINCT)) {
        antlrcpp::downCast<UnionStatementContext *>(_localctx)->unionType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3969);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::SELECT: {
        setState(3967);
        querySpecificationNointo();
        break;
      }

      case MySqlParser::LR_BRACKET: {
        setState(3968);
        queryExpressionNointo();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LateralStatementContext ------------------------------------------------------------------

MySqlParser::LateralStatementContext::LateralStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::LateralStatementContext::LATERAL() {
  return getToken(MySqlParser::LATERAL, 0);
}

MySqlParser::QuerySpecificationNointoContext* MySqlParser::LateralStatementContext::querySpecificationNointo() {
  return getRuleContext<MySqlParser::QuerySpecificationNointoContext>(0);
}

MySqlParser::QueryExpressionNointoContext* MySqlParser::LateralStatementContext::queryExpressionNointo() {
  return getRuleContext<MySqlParser::QueryExpressionNointoContext>(0);
}

tree::TerminalNode* MySqlParser::LateralStatementContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::LateralStatementContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::UidContext* MySqlParser::LateralStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::LateralStatementContext::AS() {
  return getToken(MySqlParser::AS, 0);
}


size_t MySqlParser::LateralStatementContext::getRuleIndex() const {
  return MySqlParser::RuleLateralStatement;
}

void MySqlParser::LateralStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLateralStatement(this);
}

void MySqlParser::LateralStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLateralStatement(this);
}


std::any MySqlParser::LateralStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLateralStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LateralStatementContext* MySqlParser::lateralStatement() {
  LateralStatementContext *_localctx = _tracker.createInstance<LateralStatementContext>(_ctx, getState());
  enterRule(_localctx, 256, MySqlParser::RuleLateralStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3971);
    match(MySqlParser::LATERAL);
    setState(3986);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 579, _ctx)) {
    case 1: {
      setState(3972);
      querySpecificationNointo();
      break;
    }

    case 2: {
      setState(3973);
      queryExpressionNointo();
      break;
    }

    case 3: {
      setState(3974);
      match(MySqlParser::LR_BRACKET);
      setState(3977);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::SELECT: {
          setState(3975);
          querySpecificationNointo();
          break;
        }

        case MySqlParser::LR_BRACKET: {
          setState(3976);
          queryExpressionNointo();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(3979);
      match(MySqlParser::RR_BRACKET);
      setState(3984);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 578, _ctx)) {
      case 1: {
        setState(3981);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::AS) {
          setState(3980);
          match(MySqlParser::AS);
        }
        setState(3983);
        uid();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonTableContext ------------------------------------------------------------------

MySqlParser::JsonTableContext::JsonTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::JsonTableContext::JSON_TABLE() {
  return getToken(MySqlParser::JSON_TABLE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::JsonTableContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::JsonTableContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> MySqlParser::JsonTableContext::STRING_LITERAL() {
  return getTokens(MySqlParser::STRING_LITERAL);
}

tree::TerminalNode* MySqlParser::JsonTableContext::STRING_LITERAL(size_t i) {
  return getToken(MySqlParser::STRING_LITERAL, i);
}

tree::TerminalNode* MySqlParser::JsonTableContext::COMMA() {
  return getToken(MySqlParser::COMMA, 0);
}

tree::TerminalNode* MySqlParser::JsonTableContext::COLUMNS() {
  return getToken(MySqlParser::COLUMNS, 0);
}

MySqlParser::JsonColumnListContext* MySqlParser::JsonTableContext::jsonColumnList() {
  return getRuleContext<MySqlParser::JsonColumnListContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::JsonTableContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::JsonTableContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

MySqlParser::UidContext* MySqlParser::JsonTableContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::JsonTableContext::AS() {
  return getToken(MySqlParser::AS, 0);
}


size_t MySqlParser::JsonTableContext::getRuleIndex() const {
  return MySqlParser::RuleJsonTable;
}

void MySqlParser::JsonTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonTable(this);
}

void MySqlParser::JsonTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonTable(this);
}


std::any MySqlParser::JsonTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitJsonTable(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::JsonTableContext* MySqlParser::jsonTable() {
  JsonTableContext *_localctx = _tracker.createInstance<JsonTableContext>(_ctx, getState());
  enterRule(_localctx, 258, MySqlParser::RuleJsonTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3988);
    match(MySqlParser::JSON_TABLE);
    setState(3989);
    match(MySqlParser::LR_BRACKET);
    setState(3990);
    match(MySqlParser::STRING_LITERAL);
    setState(3991);
    match(MySqlParser::COMMA);
    setState(3992);
    match(MySqlParser::STRING_LITERAL);
    setState(3993);
    match(MySqlParser::COLUMNS);
    setState(3994);
    match(MySqlParser::LR_BRACKET);
    setState(3995);
    jsonColumnList();
    setState(3996);
    match(MySqlParser::RR_BRACKET);
    setState(3997);
    match(MySqlParser::RR_BRACKET);
    setState(4002);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 581, _ctx)) {
    case 1: {
      setState(3999);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::AS) {
        setState(3998);
        match(MySqlParser::AS);
      }
      setState(4001);
      uid();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonColumnListContext ------------------------------------------------------------------

MySqlParser::JsonColumnListContext::JsonColumnListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::JsonColumnContext *> MySqlParser::JsonColumnListContext::jsonColumn() {
  return getRuleContexts<MySqlParser::JsonColumnContext>();
}

MySqlParser::JsonColumnContext* MySqlParser::JsonColumnListContext::jsonColumn(size_t i) {
  return getRuleContext<MySqlParser::JsonColumnContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::JsonColumnListContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::JsonColumnListContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::JsonColumnListContext::getRuleIndex() const {
  return MySqlParser::RuleJsonColumnList;
}

void MySqlParser::JsonColumnListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonColumnList(this);
}

void MySqlParser::JsonColumnListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonColumnList(this);
}


std::any MySqlParser::JsonColumnListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitJsonColumnList(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::JsonColumnListContext* MySqlParser::jsonColumnList() {
  JsonColumnListContext *_localctx = _tracker.createInstance<JsonColumnListContext>(_ctx, getState());
  enterRule(_localctx, 260, MySqlParser::RuleJsonColumnList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4004);
    jsonColumn();
    setState(4009);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(4005);
      match(MySqlParser::COMMA);
      setState(4006);
      jsonColumn();
      setState(4011);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonColumnContext ------------------------------------------------------------------

MySqlParser::JsonColumnContext::JsonColumnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::FullColumnNameContext* MySqlParser::JsonColumnContext::fullColumnName() {
  return getRuleContext<MySqlParser::FullColumnNameContext>(0);
}

tree::TerminalNode* MySqlParser::JsonColumnContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

tree::TerminalNode* MySqlParser::JsonColumnContext::ORDINALITY() {
  return getToken(MySqlParser::ORDINALITY, 0);
}

MySqlParser::DataTypeContext* MySqlParser::JsonColumnContext::dataType() {
  return getRuleContext<MySqlParser::DataTypeContext>(0);
}

tree::TerminalNode* MySqlParser::JsonColumnContext::PATH() {
  return getToken(MySqlParser::PATH, 0);
}

tree::TerminalNode* MySqlParser::JsonColumnContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::JsonColumnContext::EXISTS() {
  return getToken(MySqlParser::EXISTS, 0);
}

MySqlParser::JsonOnEmptyContext* MySqlParser::JsonColumnContext::jsonOnEmpty() {
  return getRuleContext<MySqlParser::JsonOnEmptyContext>(0);
}

MySqlParser::JsonOnErrorContext* MySqlParser::JsonColumnContext::jsonOnError() {
  return getRuleContext<MySqlParser::JsonOnErrorContext>(0);
}

tree::TerminalNode* MySqlParser::JsonColumnContext::NESTED() {
  return getToken(MySqlParser::NESTED, 0);
}

tree::TerminalNode* MySqlParser::JsonColumnContext::COLUMNS() {
  return getToken(MySqlParser::COLUMNS, 0);
}

tree::TerminalNode* MySqlParser::JsonColumnContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::JsonColumnListContext* MySqlParser::JsonColumnContext::jsonColumnList() {
  return getRuleContext<MySqlParser::JsonColumnListContext>(0);
}

tree::TerminalNode* MySqlParser::JsonColumnContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}


size_t MySqlParser::JsonColumnContext::getRuleIndex() const {
  return MySqlParser::RuleJsonColumn;
}

void MySqlParser::JsonColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonColumn(this);
}

void MySqlParser::JsonColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonColumn(this);
}


std::any MySqlParser::JsonColumnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitJsonColumn(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::JsonColumnContext* MySqlParser::jsonColumn() {
  JsonColumnContext *_localctx = _tracker.createInstance<JsonColumnContext>(_ctx, getState());
  enterRule(_localctx, 262, MySqlParser::RuleJsonColumn);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4041);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 588, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4012);
      fullColumnName();
      setState(4029);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::FOR: {
          setState(4013);
          match(MySqlParser::FOR);
          setState(4014);
          match(MySqlParser::ORDINALITY);
          break;
        }

        case MySqlParser::CHARACTER:
        case MySqlParser::SET:
        case MySqlParser::TINYINT:
        case MySqlParser::SMALLINT:
        case MySqlParser::MEDIUMINT:
        case MySqlParser::MIDDLEINT:
        case MySqlParser::INT:
        case MySqlParser::INT1:
        case MySqlParser::INT2:
        case MySqlParser::INT3:
        case MySqlParser::INT4:
        case MySqlParser::INT8:
        case MySqlParser::INTEGER:
        case MySqlParser::BIGINT:
        case MySqlParser::REAL:
        case MySqlParser::DOUBLE:
        case MySqlParser::FLOAT:
        case MySqlParser::FLOAT4:
        case MySqlParser::FLOAT8:
        case MySqlParser::DECIMAL:
        case MySqlParser::DEC:
        case MySqlParser::NUMERIC:
        case MySqlParser::DATE:
        case MySqlParser::TIME:
        case MySqlParser::TIMESTAMP:
        case MySqlParser::DATETIME:
        case MySqlParser::YEAR:
        case MySqlParser::CHAR:
        case MySqlParser::VARCHAR:
        case MySqlParser::NVARCHAR:
        case MySqlParser::NATIONAL:
        case MySqlParser::BINARY:
        case MySqlParser::VARBINARY:
        case MySqlParser::TINYBLOB:
        case MySqlParser::BLOB:
        case MySqlParser::MEDIUMBLOB:
        case MySqlParser::LONG:
        case MySqlParser::LONGBLOB:
        case MySqlParser::TINYTEXT:
        case MySqlParser::TEXT:
        case MySqlParser::MEDIUMTEXT:
        case MySqlParser::LONGTEXT:
        case MySqlParser::ENUM:
        case MySqlParser::SERIAL:
        case MySqlParser::BIT:
        case MySqlParser::BOOL:
        case MySqlParser::BOOLEAN:
        case MySqlParser::FIXED:
        case MySqlParser::JSON:
        case MySqlParser::NCHAR:
        case MySqlParser::GEOMETRYCOLLECTION:
        case MySqlParser::GEOMCOLLECTION:
        case MySqlParser::GEOMETRY:
        case MySqlParser::LINESTRING:
        case MySqlParser::MULTILINESTRING:
        case MySqlParser::MULTIPOINT:
        case MySqlParser::MULTIPOLYGON:
        case MySqlParser::POINT:
        case MySqlParser::POLYGON: {
          setState(4015);
          dataType();
          setState(4027);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case MySqlParser::PATH: {
              setState(4016);
              match(MySqlParser::PATH);
              setState(4017);
              match(MySqlParser::STRING_LITERAL);
              setState(4019);
              _errHandler->sync(this);

              switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 583, _ctx)) {
              case 1: {
                setState(4018);
                jsonOnEmpty();
                break;
              }

              default:
                break;
              }
              setState(4022);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == MySqlParser::DEFAULT || _la == MySqlParser::NULL_LITERAL || _la == MySqlParser::ERROR) {
                setState(4021);
                jsonOnError();
              }
              break;
            }

            case MySqlParser::EXISTS: {
              setState(4024);
              match(MySqlParser::EXISTS);
              setState(4025);
              match(MySqlParser::PATH);
              setState(4026);
              match(MySqlParser::STRING_LITERAL);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4031);
      match(MySqlParser::NESTED);
      setState(4033);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::PATH) {
        setState(4032);
        match(MySqlParser::PATH);
      }
      setState(4035);
      match(MySqlParser::STRING_LITERAL);
      setState(4036);
      match(MySqlParser::COLUMNS);
      setState(4037);
      match(MySqlParser::LR_BRACKET);
      setState(4038);
      jsonColumnList();
      setState(4039);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonOnEmptyContext ------------------------------------------------------------------

MySqlParser::JsonOnEmptyContext::JsonOnEmptyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::JsonOnEmptyContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

tree::TerminalNode* MySqlParser::JsonOnEmptyContext::EMPTY() {
  return getToken(MySqlParser::EMPTY, 0);
}

tree::TerminalNode* MySqlParser::JsonOnEmptyContext::NULL_LITERAL() {
  return getToken(MySqlParser::NULL_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::JsonOnEmptyContext::ERROR() {
  return getToken(MySqlParser::ERROR, 0);
}

tree::TerminalNode* MySqlParser::JsonOnEmptyContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

MySqlParser::DefaultValueContext* MySqlParser::JsonOnEmptyContext::defaultValue() {
  return getRuleContext<MySqlParser::DefaultValueContext>(0);
}


size_t MySqlParser::JsonOnEmptyContext::getRuleIndex() const {
  return MySqlParser::RuleJsonOnEmpty;
}

void MySqlParser::JsonOnEmptyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonOnEmpty(this);
}

void MySqlParser::JsonOnEmptyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonOnEmpty(this);
}


std::any MySqlParser::JsonOnEmptyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitJsonOnEmpty(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::JsonOnEmptyContext* MySqlParser::jsonOnEmpty() {
  JsonOnEmptyContext *_localctx = _tracker.createInstance<JsonOnEmptyContext>(_ctx, getState());
  enterRule(_localctx, 264, MySqlParser::RuleJsonOnEmpty);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4047);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::NULL_LITERAL: {
        setState(4043);
        match(MySqlParser::NULL_LITERAL);
        break;
      }

      case MySqlParser::ERROR: {
        setState(4044);
        match(MySqlParser::ERROR);
        break;
      }

      case MySqlParser::DEFAULT: {
        setState(4045);
        match(MySqlParser::DEFAULT);
        setState(4046);
        defaultValue();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(4049);
    match(MySqlParser::ON);
    setState(4050);
    match(MySqlParser::EMPTY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonOnErrorContext ------------------------------------------------------------------

MySqlParser::JsonOnErrorContext::JsonOnErrorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::JsonOnErrorContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::JsonOnErrorContext::ERROR() {
  return getTokens(MySqlParser::ERROR);
}

tree::TerminalNode* MySqlParser::JsonOnErrorContext::ERROR(size_t i) {
  return getToken(MySqlParser::ERROR, i);
}

tree::TerminalNode* MySqlParser::JsonOnErrorContext::NULL_LITERAL() {
  return getToken(MySqlParser::NULL_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::JsonOnErrorContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

MySqlParser::DefaultValueContext* MySqlParser::JsonOnErrorContext::defaultValue() {
  return getRuleContext<MySqlParser::DefaultValueContext>(0);
}


size_t MySqlParser::JsonOnErrorContext::getRuleIndex() const {
  return MySqlParser::RuleJsonOnError;
}

void MySqlParser::JsonOnErrorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonOnError(this);
}

void MySqlParser::JsonOnErrorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonOnError(this);
}


std::any MySqlParser::JsonOnErrorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitJsonOnError(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::JsonOnErrorContext* MySqlParser::jsonOnError() {
  JsonOnErrorContext *_localctx = _tracker.createInstance<JsonOnErrorContext>(_ctx, getState());
  enterRule(_localctx, 266, MySqlParser::RuleJsonOnError);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4056);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::NULL_LITERAL: {
        setState(4052);
        match(MySqlParser::NULL_LITERAL);
        break;
      }

      case MySqlParser::ERROR: {
        setState(4053);
        match(MySqlParser::ERROR);
        break;
      }

      case MySqlParser::DEFAULT: {
        setState(4054);
        match(MySqlParser::DEFAULT);
        setState(4055);
        defaultValue();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(4058);
    match(MySqlParser::ON);
    setState(4059);
    match(MySqlParser::ERROR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectSpecContext ------------------------------------------------------------------

MySqlParser::SelectSpecContext::SelectSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SelectSpecContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

tree::TerminalNode* MySqlParser::SelectSpecContext::DISTINCT() {
  return getToken(MySqlParser::DISTINCT, 0);
}

tree::TerminalNode* MySqlParser::SelectSpecContext::DISTINCTROW() {
  return getToken(MySqlParser::DISTINCTROW, 0);
}

tree::TerminalNode* MySqlParser::SelectSpecContext::HIGH_PRIORITY() {
  return getToken(MySqlParser::HIGH_PRIORITY, 0);
}

tree::TerminalNode* MySqlParser::SelectSpecContext::STRAIGHT_JOIN() {
  return getToken(MySqlParser::STRAIGHT_JOIN, 0);
}

tree::TerminalNode* MySqlParser::SelectSpecContext::SQL_SMALL_RESULT() {
  return getToken(MySqlParser::SQL_SMALL_RESULT, 0);
}

tree::TerminalNode* MySqlParser::SelectSpecContext::SQL_BIG_RESULT() {
  return getToken(MySqlParser::SQL_BIG_RESULT, 0);
}

tree::TerminalNode* MySqlParser::SelectSpecContext::SQL_BUFFER_RESULT() {
  return getToken(MySqlParser::SQL_BUFFER_RESULT, 0);
}

tree::TerminalNode* MySqlParser::SelectSpecContext::SQL_CACHE() {
  return getToken(MySqlParser::SQL_CACHE, 0);
}

tree::TerminalNode* MySqlParser::SelectSpecContext::SQL_NO_CACHE() {
  return getToken(MySqlParser::SQL_NO_CACHE, 0);
}

tree::TerminalNode* MySqlParser::SelectSpecContext::SQL_CALC_FOUND_ROWS() {
  return getToken(MySqlParser::SQL_CALC_FOUND_ROWS, 0);
}


size_t MySqlParser::SelectSpecContext::getRuleIndex() const {
  return MySqlParser::RuleSelectSpec;
}

void MySqlParser::SelectSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectSpec(this);
}

void MySqlParser::SelectSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectSpec(this);
}


std::any MySqlParser::SelectSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSelectSpec(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SelectSpecContext* MySqlParser::selectSpec() {
  SelectSpecContext *_localctx = _tracker.createInstance<SelectSpecContext>(_ctx, getState());
  enterRule(_localctx, 268, MySqlParser::RuleSelectSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4069);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::ALL:
      case MySqlParser::DISTINCT:
      case MySqlParser::DISTINCTROW: {
        enterOuterAlt(_localctx, 1);
        setState(4061);
        _la = _input->LA(1);
        if (!((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 1688849860264000) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySqlParser::HIGH_PRIORITY: {
        enterOuterAlt(_localctx, 2);
        setState(4062);
        match(MySqlParser::HIGH_PRIORITY);
        break;
      }

      case MySqlParser::STRAIGHT_JOIN: {
        enterOuterAlt(_localctx, 3);
        setState(4063);
        match(MySqlParser::STRAIGHT_JOIN);
        break;
      }

      case MySqlParser::SQL_SMALL_RESULT: {
        enterOuterAlt(_localctx, 4);
        setState(4064);
        match(MySqlParser::SQL_SMALL_RESULT);
        break;
      }

      case MySqlParser::SQL_BIG_RESULT: {
        enterOuterAlt(_localctx, 5);
        setState(4065);
        match(MySqlParser::SQL_BIG_RESULT);
        break;
      }

      case MySqlParser::SQL_BUFFER_RESULT: {
        enterOuterAlt(_localctx, 6);
        setState(4066);
        match(MySqlParser::SQL_BUFFER_RESULT);
        break;
      }

      case MySqlParser::SQL_CACHE:
      case MySqlParser::SQL_NO_CACHE: {
        enterOuterAlt(_localctx, 7);
        setState(4067);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::SQL_CACHE

        || _la == MySqlParser::SQL_NO_CACHE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySqlParser::SQL_CALC_FOUND_ROWS: {
        enterOuterAlt(_localctx, 8);
        setState(4068);
        match(MySqlParser::SQL_CALC_FOUND_ROWS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectElementsContext ------------------------------------------------------------------

MySqlParser::SelectElementsContext::SelectElementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::SelectElementContext *> MySqlParser::SelectElementsContext::selectElement() {
  return getRuleContexts<MySqlParser::SelectElementContext>();
}

MySqlParser::SelectElementContext* MySqlParser::SelectElementsContext::selectElement(size_t i) {
  return getRuleContext<MySqlParser::SelectElementContext>(i);
}

tree::TerminalNode* MySqlParser::SelectElementsContext::STAR() {
  return getToken(MySqlParser::STAR, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::SelectElementsContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::SelectElementsContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::SelectElementsContext::getRuleIndex() const {
  return MySqlParser::RuleSelectElements;
}

void MySqlParser::SelectElementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectElements(this);
}

void MySqlParser::SelectElementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectElements(this);
}


std::any MySqlParser::SelectElementsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSelectElements(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SelectElementsContext* MySqlParser::selectElements() {
  SelectElementsContext *_localctx = _tracker.createInstance<SelectElementsContext>(_ctx, getState());
  enterRule(_localctx, 270, MySqlParser::RuleSelectElements);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4073);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 592, _ctx)) {
    case 1: {
      setState(4071);
      antlrcpp::downCast<SelectElementsContext *>(_localctx)->star = match(MySqlParser::STAR);
      break;
    }

    case 2: {
      setState(4072);
      selectElement();
      break;
    }

    default:
      break;
    }
    setState(4079);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 593, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4075);
        match(MySqlParser::COMMA);
        setState(4076);
        selectElement(); 
      }
      setState(4081);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 593, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectElementContext ------------------------------------------------------------------

MySqlParser::SelectElementContext::SelectElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::SelectElementContext::getRuleIndex() const {
  return MySqlParser::RuleSelectElement;
}

void MySqlParser::SelectElementContext::copyFrom(SelectElementContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SelectExpressionElementContext ------------------------------------------------------------------

MySqlParser::ExpressionContext* MySqlParser::SelectExpressionElementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::SelectExpressionElementContext::LOCAL_ID() {
  return getToken(MySqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* MySqlParser::SelectExpressionElementContext::VAR_ASSIGN() {
  return getToken(MySqlParser::VAR_ASSIGN, 0);
}

MySqlParser::UidContext* MySqlParser::SelectExpressionElementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::SelectExpressionElementContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

MySqlParser::SelectExpressionElementContext::SelectExpressionElementContext(SelectElementContext *ctx) { copyFrom(ctx); }

void MySqlParser::SelectExpressionElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectExpressionElement(this);
}
void MySqlParser::SelectExpressionElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectExpressionElement(this);
}

std::any MySqlParser::SelectExpressionElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSelectExpressionElement(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SelectFunctionElementContext ------------------------------------------------------------------

MySqlParser::FunctionCallContext* MySqlParser::SelectFunctionElementContext::functionCall() {
  return getRuleContext<MySqlParser::FunctionCallContext>(0);
}

MySqlParser::UidContext* MySqlParser::SelectFunctionElementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::SelectFunctionElementContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

MySqlParser::SelectFunctionElementContext::SelectFunctionElementContext(SelectElementContext *ctx) { copyFrom(ctx); }

void MySqlParser::SelectFunctionElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectFunctionElement(this);
}
void MySqlParser::SelectFunctionElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectFunctionElement(this);
}

std::any MySqlParser::SelectFunctionElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSelectFunctionElement(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SelectStarElementContext ------------------------------------------------------------------

MySqlParser::FullIdContext* MySqlParser::SelectStarElementContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

tree::TerminalNode* MySqlParser::SelectStarElementContext::DOT() {
  return getToken(MySqlParser::DOT, 0);
}

tree::TerminalNode* MySqlParser::SelectStarElementContext::STAR() {
  return getToken(MySqlParser::STAR, 0);
}

MySqlParser::SelectStarElementContext::SelectStarElementContext(SelectElementContext *ctx) { copyFrom(ctx); }

void MySqlParser::SelectStarElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectStarElement(this);
}
void MySqlParser::SelectStarElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectStarElement(this);
}

std::any MySqlParser::SelectStarElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSelectStarElement(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SelectColumnElementContext ------------------------------------------------------------------

MySqlParser::FullColumnNameContext* MySqlParser::SelectColumnElementContext::fullColumnName() {
  return getRuleContext<MySqlParser::FullColumnNameContext>(0);
}

MySqlParser::UidContext* MySqlParser::SelectColumnElementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::SelectColumnElementContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

MySqlParser::SelectColumnElementContext::SelectColumnElementContext(SelectElementContext *ctx) { copyFrom(ctx); }

void MySqlParser::SelectColumnElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectColumnElement(this);
}
void MySqlParser::SelectColumnElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectColumnElement(this);
}

std::any MySqlParser::SelectColumnElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSelectColumnElement(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::SelectElementContext* MySqlParser::selectElement() {
  SelectElementContext *_localctx = _tracker.createInstance<SelectElementContext>(_ctx, getState());
  enterRule(_localctx, 272, MySqlParser::RuleSelectElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4111);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 601, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::SelectStarElementContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(4082);
      fullId();
      setState(4083);
      match(MySqlParser::DOT);
      setState(4084);
      match(MySqlParser::STAR);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::SelectColumnElementContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(4086);
      fullColumnName();
      setState(4091);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 595, _ctx)) {
      case 1: {
        setState(4088);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::AS) {
          setState(4087);
          match(MySqlParser::AS);
        }
        setState(4090);
        uid();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::SelectFunctionElementContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(4093);
      functionCall();
      setState(4098);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 597, _ctx)) {
      case 1: {
        setState(4095);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::AS) {
          setState(4094);
          match(MySqlParser::AS);
        }
        setState(4097);
        uid();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::SelectExpressionElementContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(4102);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 598, _ctx)) {
      case 1: {
        setState(4100);
        match(MySqlParser::LOCAL_ID);
        setState(4101);
        match(MySqlParser::VAR_ASSIGN);
        break;
      }

      default:
        break;
      }
      setState(4104);
      expression(0);
      setState(4109);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 600, _ctx)) {
      case 1: {
        setState(4106);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::AS) {
          setState(4105);
          match(MySqlParser::AS);
        }
        setState(4108);
        uid();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectIntoExpressionContext ------------------------------------------------------------------

MySqlParser::SelectIntoExpressionContext::SelectIntoExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::SelectIntoExpressionContext::getRuleIndex() const {
  return MySqlParser::RuleSelectIntoExpression;
}

void MySqlParser::SelectIntoExpressionContext::copyFrom(SelectIntoExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SelectIntoVariablesContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SelectIntoVariablesContext::INTO() {
  return getToken(MySqlParser::INTO, 0);
}

std::vector<MySqlParser::AssignmentFieldContext *> MySqlParser::SelectIntoVariablesContext::assignmentField() {
  return getRuleContexts<MySqlParser::AssignmentFieldContext>();
}

MySqlParser::AssignmentFieldContext* MySqlParser::SelectIntoVariablesContext::assignmentField(size_t i) {
  return getRuleContext<MySqlParser::AssignmentFieldContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::SelectIntoVariablesContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::SelectIntoVariablesContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::SelectIntoVariablesContext::SelectIntoVariablesContext(SelectIntoExpressionContext *ctx) { copyFrom(ctx); }

void MySqlParser::SelectIntoVariablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectIntoVariables(this);
}
void MySqlParser::SelectIntoVariablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectIntoVariables(this);
}

std::any MySqlParser::SelectIntoVariablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSelectIntoVariables(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SelectIntoTextFileContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SelectIntoTextFileContext::INTO() {
  return getToken(MySqlParser::INTO, 0);
}

tree::TerminalNode* MySqlParser::SelectIntoTextFileContext::OUTFILE() {
  return getToken(MySqlParser::OUTFILE, 0);
}

tree::TerminalNode* MySqlParser::SelectIntoTextFileContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::SelectIntoTextFileContext::CHARACTER() {
  return getToken(MySqlParser::CHARACTER, 0);
}

tree::TerminalNode* MySqlParser::SelectIntoTextFileContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::SelectIntoTextFileContext::LINES() {
  return getToken(MySqlParser::LINES, 0);
}

MySqlParser::CharsetNameContext* MySqlParser::SelectIntoTextFileContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySqlParser::SelectIntoTextFileContext::FIELDS() {
  return getToken(MySqlParser::FIELDS, 0);
}

tree::TerminalNode* MySqlParser::SelectIntoTextFileContext::COLUMNS() {
  return getToken(MySqlParser::COLUMNS, 0);
}

std::vector<MySqlParser::SelectFieldsIntoContext *> MySqlParser::SelectIntoTextFileContext::selectFieldsInto() {
  return getRuleContexts<MySqlParser::SelectFieldsIntoContext>();
}

MySqlParser::SelectFieldsIntoContext* MySqlParser::SelectIntoTextFileContext::selectFieldsInto(size_t i) {
  return getRuleContext<MySqlParser::SelectFieldsIntoContext>(i);
}

std::vector<MySqlParser::SelectLinesIntoContext *> MySqlParser::SelectIntoTextFileContext::selectLinesInto() {
  return getRuleContexts<MySqlParser::SelectLinesIntoContext>();
}

MySqlParser::SelectLinesIntoContext* MySqlParser::SelectIntoTextFileContext::selectLinesInto(size_t i) {
  return getRuleContext<MySqlParser::SelectLinesIntoContext>(i);
}

MySqlParser::SelectIntoTextFileContext::SelectIntoTextFileContext(SelectIntoExpressionContext *ctx) { copyFrom(ctx); }

void MySqlParser::SelectIntoTextFileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectIntoTextFile(this);
}
void MySqlParser::SelectIntoTextFileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectIntoTextFile(this);
}

std::any MySqlParser::SelectIntoTextFileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSelectIntoTextFile(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SelectIntoDumpFileContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SelectIntoDumpFileContext::INTO() {
  return getToken(MySqlParser::INTO, 0);
}

tree::TerminalNode* MySqlParser::SelectIntoDumpFileContext::DUMPFILE() {
  return getToken(MySqlParser::DUMPFILE, 0);
}

tree::TerminalNode* MySqlParser::SelectIntoDumpFileContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

MySqlParser::SelectIntoDumpFileContext::SelectIntoDumpFileContext(SelectIntoExpressionContext *ctx) { copyFrom(ctx); }

void MySqlParser::SelectIntoDumpFileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectIntoDumpFile(this);
}
void MySqlParser::SelectIntoDumpFileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectIntoDumpFile(this);
}

std::any MySqlParser::SelectIntoDumpFileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSelectIntoDumpFile(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::SelectIntoExpressionContext* MySqlParser::selectIntoExpression() {
  SelectIntoExpressionContext *_localctx = _tracker.createInstance<SelectIntoExpressionContext>(_ctx, getState());
  enterRule(_localctx, 274, MySqlParser::RuleSelectIntoExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4149);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 608, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::SelectIntoVariablesContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(4113);
      match(MySqlParser::INTO);
      setState(4114);
      assignmentField();
      setState(4119);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(4115);
        match(MySqlParser::COMMA);
        setState(4116);
        assignmentField();
        setState(4121);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::SelectIntoDumpFileContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(4122);
      match(MySqlParser::INTO);
      setState(4123);
      match(MySqlParser::DUMPFILE);
      setState(4124);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::SelectIntoTextFileContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(4125);
      match(MySqlParser::INTO);
      setState(4126);
      match(MySqlParser::OUTFILE);
      setState(4127);
      antlrcpp::downCast<SelectIntoTextFileContext *>(_localctx)->filename = match(MySqlParser::STRING_LITERAL);
      setState(4131);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::CHARACTER) {
        setState(4128);
        match(MySqlParser::CHARACTER);
        setState(4129);
        match(MySqlParser::SET);
        setState(4130);
        antlrcpp::downCast<SelectIntoTextFileContext *>(_localctx)->charset = charsetName();
      }
      setState(4139);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 605, _ctx)) {
      case 1: {
        setState(4133);
        antlrcpp::downCast<SelectIntoTextFileContext *>(_localctx)->fieldsFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::COLUMNS

        || _la == MySqlParser::FIELDS)) {
          antlrcpp::downCast<SelectIntoTextFileContext *>(_localctx)->fieldsFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4135); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(4134);
          selectFieldsInto();
          setState(4137); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == MySqlParser::ENCLOSED

        || _la == MySqlParser::ESCAPED || _la == MySqlParser::OPTIONALLY

        || _la == MySqlParser::TERMINATED);
        break;
      }

      default:
        break;
      }
      setState(4147);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LINES) {
        setState(4141);
        match(MySqlParser::LINES);
        setState(4143); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(4142);
          selectLinesInto();
          setState(4145); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == MySqlParser::STARTING

        || _la == MySqlParser::TERMINATED);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectFieldsIntoContext ------------------------------------------------------------------

MySqlParser::SelectFieldsIntoContext::SelectFieldsIntoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SelectFieldsIntoContext::TERMINATED() {
  return getToken(MySqlParser::TERMINATED, 0);
}

tree::TerminalNode* MySqlParser::SelectFieldsIntoContext::BY() {
  return getToken(MySqlParser::BY, 0);
}

tree::TerminalNode* MySqlParser::SelectFieldsIntoContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::SelectFieldsIntoContext::ENCLOSED() {
  return getToken(MySqlParser::ENCLOSED, 0);
}

tree::TerminalNode* MySqlParser::SelectFieldsIntoContext::OPTIONALLY() {
  return getToken(MySqlParser::OPTIONALLY, 0);
}

tree::TerminalNode* MySqlParser::SelectFieldsIntoContext::ESCAPED() {
  return getToken(MySqlParser::ESCAPED, 0);
}


size_t MySqlParser::SelectFieldsIntoContext::getRuleIndex() const {
  return MySqlParser::RuleSelectFieldsInto;
}

void MySqlParser::SelectFieldsIntoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectFieldsInto(this);
}

void MySqlParser::SelectFieldsIntoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectFieldsInto(this);
}


std::any MySqlParser::SelectFieldsIntoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSelectFieldsInto(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SelectFieldsIntoContext* MySqlParser::selectFieldsInto() {
  SelectFieldsIntoContext *_localctx = _tracker.createInstance<SelectFieldsIntoContext>(_ctx, getState());
  enterRule(_localctx, 276, MySqlParser::RuleSelectFieldsInto);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4163);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::TERMINATED: {
        enterOuterAlt(_localctx, 1);
        setState(4151);
        match(MySqlParser::TERMINATED);
        setState(4152);
        match(MySqlParser::BY);
        setState(4153);
        antlrcpp::downCast<SelectFieldsIntoContext *>(_localctx)->terminationField = match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::ENCLOSED:
      case MySqlParser::OPTIONALLY: {
        enterOuterAlt(_localctx, 2);
        setState(4155);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::OPTIONALLY) {
          setState(4154);
          match(MySqlParser::OPTIONALLY);
        }
        setState(4157);
        match(MySqlParser::ENCLOSED);
        setState(4158);
        match(MySqlParser::BY);
        setState(4159);
        antlrcpp::downCast<SelectFieldsIntoContext *>(_localctx)->enclosion = match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::ESCAPED: {
        enterOuterAlt(_localctx, 3);
        setState(4160);
        match(MySqlParser::ESCAPED);
        setState(4161);
        match(MySqlParser::BY);
        setState(4162);
        antlrcpp::downCast<SelectFieldsIntoContext *>(_localctx)->escaping = match(MySqlParser::STRING_LITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectLinesIntoContext ------------------------------------------------------------------

MySqlParser::SelectLinesIntoContext::SelectLinesIntoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SelectLinesIntoContext::STARTING() {
  return getToken(MySqlParser::STARTING, 0);
}

tree::TerminalNode* MySqlParser::SelectLinesIntoContext::BY() {
  return getToken(MySqlParser::BY, 0);
}

tree::TerminalNode* MySqlParser::SelectLinesIntoContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::SelectLinesIntoContext::TERMINATED() {
  return getToken(MySqlParser::TERMINATED, 0);
}


size_t MySqlParser::SelectLinesIntoContext::getRuleIndex() const {
  return MySqlParser::RuleSelectLinesInto;
}

void MySqlParser::SelectLinesIntoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectLinesInto(this);
}

void MySqlParser::SelectLinesIntoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectLinesInto(this);
}


std::any MySqlParser::SelectLinesIntoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSelectLinesInto(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SelectLinesIntoContext* MySqlParser::selectLinesInto() {
  SelectLinesIntoContext *_localctx = _tracker.createInstance<SelectLinesIntoContext>(_ctx, getState());
  enterRule(_localctx, 278, MySqlParser::RuleSelectLinesInto);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4171);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::STARTING: {
        enterOuterAlt(_localctx, 1);
        setState(4165);
        match(MySqlParser::STARTING);
        setState(4166);
        match(MySqlParser::BY);
        setState(4167);
        antlrcpp::downCast<SelectLinesIntoContext *>(_localctx)->starting = match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::TERMINATED: {
        enterOuterAlt(_localctx, 2);
        setState(4168);
        match(MySqlParser::TERMINATED);
        setState(4169);
        match(MySqlParser::BY);
        setState(4170);
        antlrcpp::downCast<SelectLinesIntoContext *>(_localctx)->terminationLine = match(MySqlParser::STRING_LITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromClauseContext ------------------------------------------------------------------

MySqlParser::FromClauseContext::FromClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::FromClauseContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

MySqlParser::TableSourcesContext* MySqlParser::FromClauseContext::tableSources() {
  return getRuleContext<MySqlParser::TableSourcesContext>(0);
}

tree::TerminalNode* MySqlParser::FromClauseContext::WHERE() {
  return getToken(MySqlParser::WHERE, 0);
}

MySqlParser::ExpressionContext* MySqlParser::FromClauseContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}


size_t MySqlParser::FromClauseContext::getRuleIndex() const {
  return MySqlParser::RuleFromClause;
}

void MySqlParser::FromClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromClause(this);
}

void MySqlParser::FromClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromClause(this);
}


std::any MySqlParser::FromClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFromClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FromClauseContext* MySqlParser::fromClause() {
  FromClauseContext *_localctx = _tracker.createInstance<FromClauseContext>(_ctx, getState());
  enterRule(_localctx, 280, MySqlParser::RuleFromClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4175);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::FROM) {
      setState(4173);
      match(MySqlParser::FROM);
      setState(4174);
      tableSources();
    }
    setState(4179);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WHERE) {
      setState(4177);
      match(MySqlParser::WHERE);
      setState(4178);
      antlrcpp::downCast<FromClauseContext *>(_localctx)->whereExpr = expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupByClauseContext ------------------------------------------------------------------

MySqlParser::GroupByClauseContext::GroupByClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::GroupByClauseContext::GROUP() {
  return getToken(MySqlParser::GROUP, 0);
}

tree::TerminalNode* MySqlParser::GroupByClauseContext::BY() {
  return getToken(MySqlParser::BY, 0);
}

std::vector<MySqlParser::GroupByItemContext *> MySqlParser::GroupByClauseContext::groupByItem() {
  return getRuleContexts<MySqlParser::GroupByItemContext>();
}

MySqlParser::GroupByItemContext* MySqlParser::GroupByClauseContext::groupByItem(size_t i) {
  return getRuleContext<MySqlParser::GroupByItemContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::GroupByClauseContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::GroupByClauseContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::GroupByClauseContext::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

tree::TerminalNode* MySqlParser::GroupByClauseContext::ROLLUP() {
  return getToken(MySqlParser::ROLLUP, 0);
}


size_t MySqlParser::GroupByClauseContext::getRuleIndex() const {
  return MySqlParser::RuleGroupByClause;
}

void MySqlParser::GroupByClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupByClause(this);
}

void MySqlParser::GroupByClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupByClause(this);
}


std::any MySqlParser::GroupByClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitGroupByClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::GroupByClauseContext* MySqlParser::groupByClause() {
  GroupByClauseContext *_localctx = _tracker.createInstance<GroupByClauseContext>(_ctx, getState());
  enterRule(_localctx, 282, MySqlParser::RuleGroupByClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4181);
    match(MySqlParser::GROUP);
    setState(4182);
    match(MySqlParser::BY);
    setState(4183);
    groupByItem();
    setState(4188);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 614, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4184);
        match(MySqlParser::COMMA);
        setState(4185);
        groupByItem(); 
      }
      setState(4190);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 614, _ctx);
    }
    setState(4193);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 615, _ctx)) {
    case 1: {
      setState(4191);
      match(MySqlParser::WITH);
      setState(4192);
      match(MySqlParser::ROLLUP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HavingClauseContext ------------------------------------------------------------------

MySqlParser::HavingClauseContext::HavingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::HavingClauseContext::HAVING() {
  return getToken(MySqlParser::HAVING, 0);
}

MySqlParser::ExpressionContext* MySqlParser::HavingClauseContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}


size_t MySqlParser::HavingClauseContext::getRuleIndex() const {
  return MySqlParser::RuleHavingClause;
}

void MySqlParser::HavingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHavingClause(this);
}

void MySqlParser::HavingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHavingClause(this);
}


std::any MySqlParser::HavingClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHavingClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::HavingClauseContext* MySqlParser::havingClause() {
  HavingClauseContext *_localctx = _tracker.createInstance<HavingClauseContext>(_ctx, getState());
  enterRule(_localctx, 284, MySqlParser::RuleHavingClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4195);
    match(MySqlParser::HAVING);
    setState(4196);
    antlrcpp::downCast<HavingClauseContext *>(_localctx)->havingExpr = expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowClauseContext ------------------------------------------------------------------

MySqlParser::WindowClauseContext::WindowClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::WindowClauseContext::WINDOW() {
  return getToken(MySqlParser::WINDOW, 0);
}

std::vector<MySqlParser::WindowNameContext *> MySqlParser::WindowClauseContext::windowName() {
  return getRuleContexts<MySqlParser::WindowNameContext>();
}

MySqlParser::WindowNameContext* MySqlParser::WindowClauseContext::windowName(size_t i) {
  return getRuleContext<MySqlParser::WindowNameContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::WindowClauseContext::AS() {
  return getTokens(MySqlParser::AS);
}

tree::TerminalNode* MySqlParser::WindowClauseContext::AS(size_t i) {
  return getToken(MySqlParser::AS, i);
}

std::vector<tree::TerminalNode *> MySqlParser::WindowClauseContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::WindowClauseContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

std::vector<MySqlParser::WindowSpecContext *> MySqlParser::WindowClauseContext::windowSpec() {
  return getRuleContexts<MySqlParser::WindowSpecContext>();
}

MySqlParser::WindowSpecContext* MySqlParser::WindowClauseContext::windowSpec(size_t i) {
  return getRuleContext<MySqlParser::WindowSpecContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::WindowClauseContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::WindowClauseContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

std::vector<tree::TerminalNode *> MySqlParser::WindowClauseContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::WindowClauseContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::WindowClauseContext::getRuleIndex() const {
  return MySqlParser::RuleWindowClause;
}

void MySqlParser::WindowClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowClause(this);
}

void MySqlParser::WindowClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowClause(this);
}


std::any MySqlParser::WindowClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitWindowClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::WindowClauseContext* MySqlParser::windowClause() {
  WindowClauseContext *_localctx = _tracker.createInstance<WindowClauseContext>(_ctx, getState());
  enterRule(_localctx, 286, MySqlParser::RuleWindowClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4198);
    match(MySqlParser::WINDOW);
    setState(4199);
    windowName();
    setState(4200);
    match(MySqlParser::AS);
    setState(4201);
    match(MySqlParser::LR_BRACKET);
    setState(4202);
    windowSpec();
    setState(4203);
    match(MySqlParser::RR_BRACKET);
    setState(4213);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 616, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4204);
        match(MySqlParser::COMMA);
        setState(4205);
        windowName();
        setState(4206);
        match(MySqlParser::AS);
        setState(4207);
        match(MySqlParser::LR_BRACKET);
        setState(4208);
        windowSpec();
        setState(4209);
        match(MySqlParser::RR_BRACKET); 
      }
      setState(4215);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 616, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupByItemContext ------------------------------------------------------------------

MySqlParser::GroupByItemContext::GroupByItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::ExpressionContext* MySqlParser::GroupByItemContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::GroupByItemContext::ASC() {
  return getToken(MySqlParser::ASC, 0);
}

tree::TerminalNode* MySqlParser::GroupByItemContext::DESC() {
  return getToken(MySqlParser::DESC, 0);
}


size_t MySqlParser::GroupByItemContext::getRuleIndex() const {
  return MySqlParser::RuleGroupByItem;
}

void MySqlParser::GroupByItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupByItem(this);
}

void MySqlParser::GroupByItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupByItem(this);
}


std::any MySqlParser::GroupByItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitGroupByItem(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::GroupByItemContext* MySqlParser::groupByItem() {
  GroupByItemContext *_localctx = _tracker.createInstance<GroupByItemContext>(_ctx, getState());
  enterRule(_localctx, 288, MySqlParser::RuleGroupByItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4216);
    expression(0);
    setState(4218);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 617, _ctx)) {
    case 1: {
      setState(4217);
      antlrcpp::downCast<GroupByItemContext *>(_localctx)->order = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::ASC

      || _la == MySqlParser::DESC)) {
        antlrcpp::downCast<GroupByItemContext *>(_localctx)->order = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitClauseContext ------------------------------------------------------------------

MySqlParser::LimitClauseContext::LimitClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::LimitClauseContext::LIMIT() {
  return getToken(MySqlParser::LIMIT, 0);
}

tree::TerminalNode* MySqlParser::LimitClauseContext::OFFSET() {
  return getToken(MySqlParser::OFFSET, 0);
}

std::vector<MySqlParser::LimitClauseAtomContext *> MySqlParser::LimitClauseContext::limitClauseAtom() {
  return getRuleContexts<MySqlParser::LimitClauseAtomContext>();
}

MySqlParser::LimitClauseAtomContext* MySqlParser::LimitClauseContext::limitClauseAtom(size_t i) {
  return getRuleContext<MySqlParser::LimitClauseAtomContext>(i);
}

tree::TerminalNode* MySqlParser::LimitClauseContext::COMMA() {
  return getToken(MySqlParser::COMMA, 0);
}


size_t MySqlParser::LimitClauseContext::getRuleIndex() const {
  return MySqlParser::RuleLimitClause;
}

void MySqlParser::LimitClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitClause(this);
}

void MySqlParser::LimitClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitClause(this);
}


std::any MySqlParser::LimitClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLimitClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LimitClauseContext* MySqlParser::limitClause() {
  LimitClauseContext *_localctx = _tracker.createInstance<LimitClauseContext>(_ctx, getState());
  enterRule(_localctx, 290, MySqlParser::RuleLimitClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4220);
    match(MySqlParser::LIMIT);
    setState(4231);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 619, _ctx)) {
    case 1: {
      setState(4224);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 618, _ctx)) {
      case 1: {
        setState(4221);
        antlrcpp::downCast<LimitClauseContext *>(_localctx)->offset = limitClauseAtom();
        setState(4222);
        match(MySqlParser::COMMA);
        break;
      }

      default:
        break;
      }
      setState(4226);
      antlrcpp::downCast<LimitClauseContext *>(_localctx)->limit = limitClauseAtom();
      break;
    }

    case 2: {
      setState(4227);
      antlrcpp::downCast<LimitClauseContext *>(_localctx)->limit = limitClauseAtom();
      setState(4228);
      match(MySqlParser::OFFSET);
      setState(4229);
      antlrcpp::downCast<LimitClauseContext *>(_localctx)->offset = limitClauseAtom();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitClauseAtomContext ------------------------------------------------------------------

MySqlParser::LimitClauseAtomContext::LimitClauseAtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::DecimalLiteralContext* MySqlParser::LimitClauseAtomContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

MySqlParser::MysqlVariableContext* MySqlParser::LimitClauseAtomContext::mysqlVariable() {
  return getRuleContext<MySqlParser::MysqlVariableContext>(0);
}

MySqlParser::SimpleIdContext* MySqlParser::LimitClauseAtomContext::simpleId() {
  return getRuleContext<MySqlParser::SimpleIdContext>(0);
}


size_t MySqlParser::LimitClauseAtomContext::getRuleIndex() const {
  return MySqlParser::RuleLimitClauseAtom;
}

void MySqlParser::LimitClauseAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitClauseAtom(this);
}

void MySqlParser::LimitClauseAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitClauseAtom(this);
}


std::any MySqlParser::LimitClauseAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLimitClauseAtom(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LimitClauseAtomContext* MySqlParser::limitClauseAtom() {
  LimitClauseAtomContext *_localctx = _tracker.createInstance<LimitClauseAtomContext>(_ctx, getState());
  enterRule(_localctx, 292, MySqlParser::RuleLimitClauseAtom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4236);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::ZERO_DECIMAL:
      case MySqlParser::ONE_DECIMAL:
      case MySqlParser::TWO_DECIMAL:
      case MySqlParser::DECIMAL_LITERAL:
      case MySqlParser::REAL_LITERAL: {
        enterOuterAlt(_localctx, 1);
        setState(4233);
        decimalLiteral();
        break;
      }

      case MySqlParser::LOCAL_ID:
      case MySqlParser::GLOBAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(4234);
        mysqlVariable();
        break;
      }

      case MySqlParser::ATTRIBUTE:
      case MySqlParser::BUCKETS:
      case MySqlParser::CONDITION:
      case MySqlParser::CURRENT:
      case MySqlParser::CURRENT_USER:
      case MySqlParser::DATABASE:
      case MySqlParser::DEFAULT:
      case MySqlParser::DIAGNOSTICS:
      case MySqlParser::EMPTY:
      case MySqlParser::ENFORCED:
      case MySqlParser::EXCEPT:
      case MySqlParser::GROUP:
      case MySqlParser::IF:
      case MySqlParser::IGNORED:
      case MySqlParser::INSERT:
      case MySqlParser::LATERAL:
      case MySqlParser::LEFT:
      case MySqlParser::NUMBER:
      case MySqlParser::OPTIONAL:
      case MySqlParser::ORDER:
      case MySqlParser::PRIMARY:
      case MySqlParser::REPLACE:
      case MySqlParser::RIGHT:
      case MySqlParser::SCHEMA:
      case MySqlParser::SKIP_QUERY_REWRITE:
      case MySqlParser::STACKED:
      case MySqlParser::DATE:
      case MySqlParser::TIME:
      case MySqlParser::TIMESTAMP:
      case MySqlParser::DATETIME:
      case MySqlParser::YEAR:
      case MySqlParser::BINARY:
      case MySqlParser::TEXT:
      case MySqlParser::ENUM:
      case MySqlParser::SERIAL:
      case MySqlParser::JSON_ARRAY:
      case MySqlParser::JSON_ARRAYAGG:
      case MySqlParser::JSON_ARRAY_APPEND:
      case MySqlParser::JSON_ARRAY_INSERT:
      case MySqlParser::JSON_CONTAINS:
      case MySqlParser::JSON_CONTAINS_PATH:
      case MySqlParser::JSON_DEPTH:
      case MySqlParser::JSON_EXTRACT:
      case MySqlParser::JSON_INSERT:
      case MySqlParser::JSON_KEYS:
      case MySqlParser::JSON_LENGTH:
      case MySqlParser::JSON_MERGE:
      case MySqlParser::JSON_MERGE_PATCH:
      case MySqlParser::JSON_MERGE_PRESERVE:
      case MySqlParser::JSON_OBJECT:
      case MySqlParser::JSON_OBJECTAGG:
      case MySqlParser::JSON_OVERLAPS:
      case MySqlParser::JSON_PRETTY:
      case MySqlParser::JSON_QUOTE:
      case MySqlParser::JSON_REMOVE:
      case MySqlParser::JSON_REPLACE:
      case MySqlParser::JSON_SCHEMA_VALID:
      case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
      case MySqlParser::JSON_SEARCH:
      case MySqlParser::JSON_SET:
      case MySqlParser::JSON_STORAGE_FREE:
      case MySqlParser::JSON_STORAGE_SIZE:
      case MySqlParser::JSON_TABLE:
      case MySqlParser::JSON_TYPE:
      case MySqlParser::JSON_UNQUOTE:
      case MySqlParser::JSON_VALID:
      case MySqlParser::JSON_VALUE:
      case MySqlParser::NESTED:
      case MySqlParser::ORDINALITY:
      case MySqlParser::PATH:
      case MySqlParser::AVG:
      case MySqlParser::BIT_AND:
      case MySqlParser::BIT_OR:
      case MySqlParser::BIT_XOR:
      case MySqlParser::COUNT:
      case MySqlParser::CUME_DIST:
      case MySqlParser::DENSE_RANK:
      case MySqlParser::FIRST_VALUE:
      case MySqlParser::GROUP_CONCAT:
      case MySqlParser::LAG:
      case MySqlParser::LAST_VALUE:
      case MySqlParser::LEAD:
      case MySqlParser::MAX:
      case MySqlParser::MIN:
      case MySqlParser::NTILE:
      case MySqlParser::NTH_VALUE:
      case MySqlParser::PERCENT_RANK:
      case MySqlParser::RANK:
      case MySqlParser::ROW_NUMBER:
      case MySqlParser::STD:
      case MySqlParser::STDDEV:
      case MySqlParser::STDDEV_POP:
      case MySqlParser::STDDEV_SAMP:
      case MySqlParser::SUM:
      case MySqlParser::VAR_POP:
      case MySqlParser::VAR_SAMP:
      case MySqlParser::VARIANCE:
      case MySqlParser::CURRENT_DATE:
      case MySqlParser::CURRENT_TIME:
      case MySqlParser::CURRENT_TIMESTAMP:
      case MySqlParser::LOCALTIME:
      case MySqlParser::CURDATE:
      case MySqlParser::CURTIME:
      case MySqlParser::DATE_ADD:
      case MySqlParser::DATE_SUB:
      case MySqlParser::LOCALTIMESTAMP:
      case MySqlParser::NOW:
      case MySqlParser::POSITION:
      case MySqlParser::SUBSTR:
      case MySqlParser::SUBSTRING:
      case MySqlParser::SYSDATE:
      case MySqlParser::TRIM:
      case MySqlParser::UTC_DATE:
      case MySqlParser::UTC_TIME:
      case MySqlParser::UTC_TIMESTAMP:
      case MySqlParser::ACCOUNT:
      case MySqlParser::ACTION:
      case MySqlParser::AFTER:
      case MySqlParser::AGGREGATE:
      case MySqlParser::ALGORITHM:
      case MySqlParser::ANY:
      case MySqlParser::AT:
      case MySqlParser::AUTHORS:
      case MySqlParser::AUTOCOMMIT:
      case MySqlParser::AUTOEXTEND_SIZE:
      case MySqlParser::AUTO_INCREMENT:
      case MySqlParser::AVG_ROW_LENGTH:
      case MySqlParser::BEGIN:
      case MySqlParser::BINLOG:
      case MySqlParser::BIT:
      case MySqlParser::BLOCK:
      case MySqlParser::BOOL:
      case MySqlParser::BOOLEAN:
      case MySqlParser::BTREE:
      case MySqlParser::CACHE:
      case MySqlParser::CASCADED:
      case MySqlParser::CHAIN:
      case MySqlParser::CHANGED:
      case MySqlParser::CHANNEL:
      case MySqlParser::CHECKSUM:
      case MySqlParser::PAGE_CHECKSUM:
      case MySqlParser::CIPHER:
      case MySqlParser::CLASS_ORIGIN:
      case MySqlParser::CLIENT:
      case MySqlParser::CLOSE:
      case MySqlParser::CLUSTERING:
      case MySqlParser::COALESCE:
      case MySqlParser::CODE:
      case MySqlParser::COLUMNS:
      case MySqlParser::COLUMN_FORMAT:
      case MySqlParser::COLUMN_NAME:
      case MySqlParser::COMMENT:
      case MySqlParser::COMMIT:
      case MySqlParser::COMPACT:
      case MySqlParser::COMPLETION:
      case MySqlParser::COMPRESSED:
      case MySqlParser::COMPRESSION:
      case MySqlParser::CONCURRENT:
      case MySqlParser::CONNECT:
      case MySqlParser::CONNECTION:
      case MySqlParser::CONSISTENT:
      case MySqlParser::CONSTRAINT_CATALOG:
      case MySqlParser::CONSTRAINT_SCHEMA:
      case MySqlParser::CONSTRAINT_NAME:
      case MySqlParser::CONTAINS:
      case MySqlParser::CONTEXT:
      case MySqlParser::CONTRIBUTORS:
      case MySqlParser::COPY:
      case MySqlParser::CPU:
      case MySqlParser::CURSOR_NAME:
      case MySqlParser::DATA:
      case MySqlParser::DATAFILE:
      case MySqlParser::DEALLOCATE:
      case MySqlParser::DEFAULT_AUTH:
      case MySqlParser::DEFINER:
      case MySqlParser::DELAY_KEY_WRITE:
      case MySqlParser::DES_KEY_FILE:
      case MySqlParser::DIRECTORY:
      case MySqlParser::DISABLE:
      case MySqlParser::DISCARD:
      case MySqlParser::DISK:
      case MySqlParser::DO:
      case MySqlParser::DUMPFILE:
      case MySqlParser::DUPLICATE:
      case MySqlParser::DYNAMIC:
      case MySqlParser::ENABLE:
      case MySqlParser::ENCRYPTION:
      case MySqlParser::END:
      case MySqlParser::ENDS:
      case MySqlParser::ENGINE:
      case MySqlParser::ENGINES:
      case MySqlParser::ERROR:
      case MySqlParser::ERRORS:
      case MySqlParser::ESCAPE:
      case MySqlParser::EVEN:
      case MySqlParser::EVENT:
      case MySqlParser::EVENTS:
      case MySqlParser::EVERY:
      case MySqlParser::EXCHANGE:
      case MySqlParser::EXCLUSIVE:
      case MySqlParser::EXPIRE:
      case MySqlParser::EXPORT:
      case MySqlParser::EXTENDED:
      case MySqlParser::EXTENT_SIZE:
      case MySqlParser::FAILED_LOGIN_ATTEMPTS:
      case MySqlParser::FAST:
      case MySqlParser::FAULTS:
      case MySqlParser::FIELDS:
      case MySqlParser::FILE_BLOCK_SIZE:
      case MySqlParser::FILTER:
      case MySqlParser::FIRST:
      case MySqlParser::FIXED:
      case MySqlParser::FLUSH:
      case MySqlParser::FOLLOWS:
      case MySqlParser::FOUND:
      case MySqlParser::FULL:
      case MySqlParser::FUNCTION:
      case MySqlParser::GENERAL:
      case MySqlParser::GLOBAL:
      case MySqlParser::GRANTS:
      case MySqlParser::GROUP_REPLICATION:
      case MySqlParser::HANDLER:
      case MySqlParser::HASH:
      case MySqlParser::HELP:
      case MySqlParser::HISTORY:
      case MySqlParser::HOST:
      case MySqlParser::HOSTS:
      case MySqlParser::IDENTIFIED:
      case MySqlParser::IGNORE_SERVER_IDS:
      case MySqlParser::IMPORT:
      case MySqlParser::INDEXES:
      case MySqlParser::INITIAL_SIZE:
      case MySqlParser::INPLACE:
      case MySqlParser::INSERT_METHOD:
      case MySqlParser::INSTALL:
      case MySqlParser::INSTANCE:
      case MySqlParser::INSTANT:
      case MySqlParser::INVISIBLE:
      case MySqlParser::INVOKER:
      case MySqlParser::IO:
      case MySqlParser::IO_THREAD:
      case MySqlParser::IPC:
      case MySqlParser::ISOLATION:
      case MySqlParser::ISSUER:
      case MySqlParser::JSON:
      case MySqlParser::KEY_BLOCK_SIZE:
      case MySqlParser::LANGUAGE:
      case MySqlParser::LAST:
      case MySqlParser::LEAVES:
      case MySqlParser::LESS:
      case MySqlParser::LEVEL:
      case MySqlParser::LIST:
      case MySqlParser::LOCAL:
      case MySqlParser::LOGFILE:
      case MySqlParser::LOGS:
      case MySqlParser::MASTER:
      case MySqlParser::MASTER_AUTO_POSITION:
      case MySqlParser::MASTER_CONNECT_RETRY:
      case MySqlParser::MASTER_DELAY:
      case MySqlParser::MASTER_HEARTBEAT_PERIOD:
      case MySqlParser::MASTER_HOST:
      case MySqlParser::MASTER_LOG_FILE:
      case MySqlParser::MASTER_LOG_POS:
      case MySqlParser::MASTER_PASSWORD:
      case MySqlParser::MASTER_PORT:
      case MySqlParser::MASTER_RETRY_COUNT:
      case MySqlParser::MASTER_SSL:
      case MySqlParser::MASTER_SSL_CA:
      case MySqlParser::MASTER_SSL_CAPATH:
      case MySqlParser::MASTER_SSL_CERT:
      case MySqlParser::MASTER_SSL_CIPHER:
      case MySqlParser::MASTER_SSL_CRL:
      case MySqlParser::MASTER_SSL_CRLPATH:
      case MySqlParser::MASTER_SSL_KEY:
      case MySqlParser::MASTER_TLS_VERSION:
      case MySqlParser::MASTER_USER:
      case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
      case MySqlParser::MAX_QUERIES_PER_HOUR:
      case MySqlParser::MAX_ROWS:
      case MySqlParser::MAX_SIZE:
      case MySqlParser::MAX_UPDATES_PER_HOUR:
      case MySqlParser::MAX_USER_CONNECTIONS:
      case MySqlParser::MEDIUM:
      case MySqlParser::MEMBER:
      case MySqlParser::MERGE:
      case MySqlParser::MESSAGE_TEXT:
      case MySqlParser::MID:
      case MySqlParser::MIGRATE:
      case MySqlParser::MIN_ROWS:
      case MySqlParser::MODE:
      case MySqlParser::MODIFY:
      case MySqlParser::MUTEX:
      case MySqlParser::MYSQL:
      case MySqlParser::MYSQL_ERRNO:
      case MySqlParser::NAME:
      case MySqlParser::NAMES:
      case MySqlParser::NCHAR:
      case MySqlParser::NEVER:
      case MySqlParser::NEXT:
      case MySqlParser::NO:
      case MySqlParser::NOCOPY:
      case MySqlParser::NOWAIT:
      case MySqlParser::NODEGROUP:
      case MySqlParser::NONE:
      case MySqlParser::ODBC:
      case MySqlParser::OFFLINE:
      case MySqlParser::OFFSET:
      case MySqlParser::OF:
      case MySqlParser::OJ:
      case MySqlParser::OLD_PASSWORD:
      case MySqlParser::ONE:
      case MySqlParser::ONLINE:
      case MySqlParser::ONLY:
      case MySqlParser::OPEN:
      case MySqlParser::OPTIMIZER_COSTS:
      case MySqlParser::OPTIONS:
      case MySqlParser::OWNER:
      case MySqlParser::PACK_KEYS:
      case MySqlParser::PAGE:
      case MySqlParser::PARSER:
      case MySqlParser::PARTIAL:
      case MySqlParser::PARTITIONING:
      case MySqlParser::PARTITIONS:
      case MySqlParser::PASSWORD:
      case MySqlParser::PASSWORD_LOCK_TIME:
      case MySqlParser::PHASE:
      case MySqlParser::PLUGIN:
      case MySqlParser::PLUGIN_DIR:
      case MySqlParser::PLUGINS:
      case MySqlParser::PORT:
      case MySqlParser::PRECEDES:
      case MySqlParser::PREPARE:
      case MySqlParser::PRESERVE:
      case MySqlParser::PREV:
      case MySqlParser::PROCESSLIST:
      case MySqlParser::PROFILE:
      case MySqlParser::PROFILES:
      case MySqlParser::PROXY:
      case MySqlParser::QUERY:
      case MySqlParser::QUICK:
      case MySqlParser::REBUILD:
      case MySqlParser::RECOVER:
      case MySqlParser::RECURSIVE:
      case MySqlParser::REDO_BUFFER_SIZE:
      case MySqlParser::REDUNDANT:
      case MySqlParser::RELAY:
      case MySqlParser::RELAY_LOG_FILE:
      case MySqlParser::RELAY_LOG_POS:
      case MySqlParser::RELAYLOG:
      case MySqlParser::REMOVE:
      case MySqlParser::REORGANIZE:
      case MySqlParser::REPAIR:
      case MySqlParser::REPLICATE_DO_DB:
      case MySqlParser::REPLICATE_DO_TABLE:
      case MySqlParser::REPLICATE_IGNORE_DB:
      case MySqlParser::REPLICATE_IGNORE_TABLE:
      case MySqlParser::REPLICATE_REWRITE_DB:
      case MySqlParser::REPLICATE_WILD_DO_TABLE:
      case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySqlParser::REPLICATION:
      case MySqlParser::RESET:
      case MySqlParser::RESUME:
      case MySqlParser::RETURNED_SQLSTATE:
      case MySqlParser::RETURNS:
      case MySqlParser::REUSE:
      case MySqlParser::ROLE:
      case MySqlParser::ROLLBACK:
      case MySqlParser::ROLLUP:
      case MySqlParser::ROTATE:
      case MySqlParser::ROW:
      case MySqlParser::ROWS:
      case MySqlParser::ROW_FORMAT:
      case MySqlParser::RTREE:
      case MySqlParser::SAVEPOINT:
      case MySqlParser::SCHEDULE:
      case MySqlParser::SECURITY:
      case MySqlParser::SERVER:
      case MySqlParser::SESSION:
      case MySqlParser::SHARE:
      case MySqlParser::SHARED:
      case MySqlParser::SIGNED:
      case MySqlParser::SIMPLE:
      case MySqlParser::SLAVE:
      case MySqlParser::SLOW:
      case MySqlParser::SNAPSHOT:
      case MySqlParser::SOCKET:
      case MySqlParser::SOME:
      case MySqlParser::SONAME:
      case MySqlParser::SOUNDS:
      case MySqlParser::SOURCE:
      case MySqlParser::SQL_AFTER_GTIDS:
      case MySqlParser::SQL_AFTER_MTS_GAPS:
      case MySqlParser::SQL_BEFORE_GTIDS:
      case MySqlParser::SQL_BUFFER_RESULT:
      case MySqlParser::SQL_CACHE:
      case MySqlParser::SQL_NO_CACHE:
      case MySqlParser::SQL_THREAD:
      case MySqlParser::START:
      case MySqlParser::STARTS:
      case MySqlParser::STATS_AUTO_RECALC:
      case MySqlParser::STATS_PERSISTENT:
      case MySqlParser::STATS_SAMPLE_PAGES:
      case MySqlParser::STATUS:
      case MySqlParser::STOP:
      case MySqlParser::STORAGE:
      case MySqlParser::STRING:
      case MySqlParser::SUBCLASS_ORIGIN:
      case MySqlParser::SUBJECT:
      case MySqlParser::SUBPARTITION:
      case MySqlParser::SUBPARTITIONS:
      case MySqlParser::SUSPEND:
      case MySqlParser::SWAPS:
      case MySqlParser::SWITCHES:
      case MySqlParser::TABLE_NAME:
      case MySqlParser::TABLESPACE:
      case MySqlParser::TABLE_TYPE:
      case MySqlParser::TEMPORARY:
      case MySqlParser::TEMPTABLE:
      case MySqlParser::THAN:
      case MySqlParser::TRADITIONAL:
      case MySqlParser::TRANSACTION:
      case MySqlParser::TRANSACTIONAL:
      case MySqlParser::TRIGGERS:
      case MySqlParser::TRUNCATE:
      case MySqlParser::UNBOUNDED:
      case MySqlParser::UNDEFINED:
      case MySqlParser::UNDOFILE:
      case MySqlParser::UNDO_BUFFER_SIZE:
      case MySqlParser::UNINSTALL:
      case MySqlParser::UNKNOWN:
      case MySqlParser::UNTIL:
      case MySqlParser::UPGRADE:
      case MySqlParser::USER:
      case MySqlParser::USE_FRM:
      case MySqlParser::USER_RESOURCES:
      case MySqlParser::VALIDATION:
      case MySqlParser::VALUE:
      case MySqlParser::VARIABLES:
      case MySqlParser::VIEW:
      case MySqlParser::VIRTUAL:
      case MySqlParser::VISIBLE:
      case MySqlParser::WAIT:
      case MySqlParser::WARNINGS:
      case MySqlParser::WITHOUT:
      case MySqlParser::WORK:
      case MySqlParser::WRAPPER:
      case MySqlParser::X509:
      case MySqlParser::XA:
      case MySqlParser::XML:
      case MySqlParser::EUR:
      case MySqlParser::USA:
      case MySqlParser::JIS:
      case MySqlParser::ISO:
      case MySqlParser::INTERNAL:
      case MySqlParser::QUARTER:
      case MySqlParser::MONTH:
      case MySqlParser::DAY:
      case MySqlParser::HOUR:
      case MySqlParser::MINUTE:
      case MySqlParser::WEEK:
      case MySqlParser::SECOND:
      case MySqlParser::MICROSECOND:
      case MySqlParser::ADMIN:
      case MySqlParser::AUDIT_ABORT_EXEMPT:
      case MySqlParser::AUDIT_ADMIN:
      case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
      case MySqlParser::BACKUP_ADMIN:
      case MySqlParser::BINLOG_ADMIN:
      case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
      case MySqlParser::CLONE_ADMIN:
      case MySqlParser::CONNECTION_ADMIN:
      case MySqlParser::ENCRYPTION_KEY_ADMIN:
      case MySqlParser::EXECUTE:
      case MySqlParser::FILE:
      case MySqlParser::FIREWALL_ADMIN:
      case MySqlParser::FIREWALL_EXEMPT:
      case MySqlParser::FIREWALL_USER:
      case MySqlParser::GROUP_REPLICATION_ADMIN:
      case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
      case MySqlParser::INVOKE:
      case MySqlParser::LAMBDA:
      case MySqlParser::NDB_STORED_USER:
      case MySqlParser::PASSWORDLESS_USER_ADMIN:
      case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
      case MySqlParser::PRIVILEGES:
      case MySqlParser::PROCESS:
      case MySqlParser::RELOAD:
      case MySqlParser::REPLICATION_APPLIER:
      case MySqlParser::REPLICATION_SLAVE_ADMIN:
      case MySqlParser::RESOURCE_GROUP_ADMIN:
      case MySqlParser::RESOURCE_GROUP_USER:
      case MySqlParser::ROLE_ADMIN:
      case MySqlParser::ROUTINE:
      case MySqlParser::S3:
      case MySqlParser::SESSION_VARIABLES_ADMIN:
      case MySqlParser::SET_USER_ID:
      case MySqlParser::SHOW_ROUTINE:
      case MySqlParser::SHUTDOWN:
      case MySqlParser::SUPER:
      case MySqlParser::SYSTEM_VARIABLES_ADMIN:
      case MySqlParser::TABLES:
      case MySqlParser::TABLE_ENCRYPTION_ADMIN:
      case MySqlParser::VERSION_TOKEN_ADMIN:
      case MySqlParser::XA_RECOVER_ADMIN:
      case MySqlParser::ARMSCII8:
      case MySqlParser::ASCII:
      case MySqlParser::BIG5:
      case MySqlParser::CP1250:
      case MySqlParser::CP1251:
      case MySqlParser::CP1256:
      case MySqlParser::CP1257:
      case MySqlParser::CP850:
      case MySqlParser::CP852:
      case MySqlParser::CP866:
      case MySqlParser::CP932:
      case MySqlParser::DEC8:
      case MySqlParser::EUCJPMS:
      case MySqlParser::EUCKR:
      case MySqlParser::GB18030:
      case MySqlParser::GB2312:
      case MySqlParser::GBK:
      case MySqlParser::GEOSTD8:
      case MySqlParser::GREEK:
      case MySqlParser::HEBREW:
      case MySqlParser::HP8:
      case MySqlParser::KEYBCS2:
      case MySqlParser::KOI8R:
      case MySqlParser::KOI8U:
      case MySqlParser::LATIN1:
      case MySqlParser::LATIN2:
      case MySqlParser::LATIN5:
      case MySqlParser::LATIN7:
      case MySqlParser::MACCE:
      case MySqlParser::MACROMAN:
      case MySqlParser::SJIS:
      case MySqlParser::SWE7:
      case MySqlParser::TIS620:
      case MySqlParser::UCS2:
      case MySqlParser::UJIS:
      case MySqlParser::UTF16:
      case MySqlParser::UTF16LE:
      case MySqlParser::UTF32:
      case MySqlParser::UTF8:
      case MySqlParser::UTF8MB3:
      case MySqlParser::UTF8MB4:
      case MySqlParser::ARCHIVE:
      case MySqlParser::BLACKHOLE:
      case MySqlParser::CSV:
      case MySqlParser::FEDERATED:
      case MySqlParser::INNODB:
      case MySqlParser::MEMORY:
      case MySqlParser::MRG_MYISAM:
      case MySqlParser::MYISAM:
      case MySqlParser::NDB:
      case MySqlParser::NDBCLUSTER:
      case MySqlParser::PERFORMANCE_SCHEMA:
      case MySqlParser::TOKUDB:
      case MySqlParser::REPEATABLE:
      case MySqlParser::COMMITTED:
      case MySqlParser::UNCOMMITTED:
      case MySqlParser::SERIALIZABLE:
      case MySqlParser::GEOMETRYCOLLECTION:
      case MySqlParser::LINESTRING:
      case MySqlParser::MULTILINESTRING:
      case MySqlParser::MULTIPOINT:
      case MySqlParser::MULTIPOLYGON:
      case MySqlParser::POINT:
      case MySqlParser::POLYGON:
      case MySqlParser::ABS:
      case MySqlParser::ACOS:
      case MySqlParser::ADDDATE:
      case MySqlParser::ADDTIME:
      case MySqlParser::AES_DECRYPT:
      case MySqlParser::AES_ENCRYPT:
      case MySqlParser::AREA:
      case MySqlParser::ASBINARY:
      case MySqlParser::ASIN:
      case MySqlParser::ASTEXT:
      case MySqlParser::ASWKB:
      case MySqlParser::ASWKT:
      case MySqlParser::ASYMMETRIC_DECRYPT:
      case MySqlParser::ASYMMETRIC_DERIVE:
      case MySqlParser::ASYMMETRIC_ENCRYPT:
      case MySqlParser::ASYMMETRIC_SIGN:
      case MySqlParser::ASYMMETRIC_VERIFY:
      case MySqlParser::ATAN:
      case MySqlParser::ATAN2:
      case MySqlParser::BENCHMARK:
      case MySqlParser::BIN:
      case MySqlParser::BIT_COUNT:
      case MySqlParser::BIT_LENGTH:
      case MySqlParser::BUFFER:
      case MySqlParser::CATALOG_NAME:
      case MySqlParser::CEIL:
      case MySqlParser::CEILING:
      case MySqlParser::CENTROID:
      case MySqlParser::CHARACTER_LENGTH:
      case MySqlParser::CHARSET:
      case MySqlParser::CHAR_LENGTH:
      case MySqlParser::COERCIBILITY:
      case MySqlParser::COLLATION:
      case MySqlParser::COMPRESS:
      case MySqlParser::CONCAT:
      case MySqlParser::CONCAT_WS:
      case MySqlParser::CONNECTION_ID:
      case MySqlParser::CONV:
      case MySqlParser::CONVERT_TZ:
      case MySqlParser::COS:
      case MySqlParser::COT:
      case MySqlParser::CRC32:
      case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
      case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
      case MySqlParser::CREATE_DH_PARAMETERS:
      case MySqlParser::CREATE_DIGEST:
      case MySqlParser::CROSSES:
      case MySqlParser::DATEDIFF:
      case MySqlParser::DATE_FORMAT:
      case MySqlParser::DAYNAME:
      case MySqlParser::DAYOFMONTH:
      case MySqlParser::DAYOFWEEK:
      case MySqlParser::DAYOFYEAR:
      case MySqlParser::DECODE:
      case MySqlParser::DEGREES:
      case MySqlParser::DES_DECRYPT:
      case MySqlParser::DES_ENCRYPT:
      case MySqlParser::DIMENSION:
      case MySqlParser::DISJOINT:
      case MySqlParser::ELT:
      case MySqlParser::ENCODE:
      case MySqlParser::ENCRYPT:
      case MySqlParser::ENDPOINT:
      case MySqlParser::ENGINE_ATTRIBUTE:
      case MySqlParser::ENVELOPE:
      case MySqlParser::EQUALS:
      case MySqlParser::EXP:
      case MySqlParser::EXPORT_SET:
      case MySqlParser::EXTERIORRING:
      case MySqlParser::EXTRACTVALUE:
      case MySqlParser::FIELD:
      case MySqlParser::FIND_IN_SET:
      case MySqlParser::FLOOR:
      case MySqlParser::FORMAT:
      case MySqlParser::FOUND_ROWS:
      case MySqlParser::FROM_BASE64:
      case MySqlParser::FROM_DAYS:
      case MySqlParser::FROM_UNIXTIME:
      case MySqlParser::GEOMCOLLFROMTEXT:
      case MySqlParser::GEOMCOLLFROMWKB:
      case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::GEOMETRYFROMTEXT:
      case MySqlParser::GEOMETRYFROMWKB:
      case MySqlParser::GEOMETRYN:
      case MySqlParser::GEOMETRYTYPE:
      case MySqlParser::GEOMFROMTEXT:
      case MySqlParser::GEOMFROMWKB:
      case MySqlParser::GET_FORMAT:
      case MySqlParser::GET_LOCK:
      case MySqlParser::GLENGTH:
      case MySqlParser::GREATEST:
      case MySqlParser::GTID_SUBSET:
      case MySqlParser::GTID_SUBTRACT:
      case MySqlParser::HEX:
      case MySqlParser::IFNULL:
      case MySqlParser::INET6_ATON:
      case MySqlParser::INET6_NTOA:
      case MySqlParser::INET_ATON:
      case MySqlParser::INET_NTOA:
      case MySqlParser::INSTR:
      case MySqlParser::INTERIORRINGN:
      case MySqlParser::INTERSECTS:
      case MySqlParser::ISCLOSED:
      case MySqlParser::ISEMPTY:
      case MySqlParser::ISNULL:
      case MySqlParser::ISSIMPLE:
      case MySqlParser::IS_FREE_LOCK:
      case MySqlParser::IS_IPV4:
      case MySqlParser::IS_IPV4_COMPAT:
      case MySqlParser::IS_IPV4_MAPPED:
      case MySqlParser::IS_IPV6:
      case MySqlParser::IS_USED_LOCK:
      case MySqlParser::LAST_INSERT_ID:
      case MySqlParser::LCASE:
      case MySqlParser::LEAST:
      case MySqlParser::LENGTH:
      case MySqlParser::LINEFROMTEXT:
      case MySqlParser::LINEFROMWKB:
      case MySqlParser::LINESTRINGFROMTEXT:
      case MySqlParser::LINESTRINGFROMWKB:
      case MySqlParser::LN:
      case MySqlParser::LOAD_FILE:
      case MySqlParser::LOCATE:
      case MySqlParser::LOG:
      case MySqlParser::LOG10:
      case MySqlParser::LOG2:
      case MySqlParser::LOWER:
      case MySqlParser::LPAD:
      case MySqlParser::LTRIM:
      case MySqlParser::MAKEDATE:
      case MySqlParser::MAKETIME:
      case MySqlParser::MAKE_SET:
      case MySqlParser::MASTER_POS_WAIT:
      case MySqlParser::MBRCONTAINS:
      case MySqlParser::MBRDISJOINT:
      case MySqlParser::MBREQUAL:
      case MySqlParser::MBRINTERSECTS:
      case MySqlParser::MBROVERLAPS:
      case MySqlParser::MBRTOUCHES:
      case MySqlParser::MBRWITHIN:
      case MySqlParser::MD5:
      case MySqlParser::MLINEFROMTEXT:
      case MySqlParser::MLINEFROMWKB:
      case MySqlParser::MONTHNAME:
      case MySqlParser::MPOINTFROMTEXT:
      case MySqlParser::MPOINTFROMWKB:
      case MySqlParser::MPOLYFROMTEXT:
      case MySqlParser::MPOLYFROMWKB:
      case MySqlParser::MULTILINESTRINGFROMTEXT:
      case MySqlParser::MULTILINESTRINGFROMWKB:
      case MySqlParser::MULTIPOINTFROMTEXT:
      case MySqlParser::MULTIPOINTFROMWKB:
      case MySqlParser::MULTIPOLYGONFROMTEXT:
      case MySqlParser::MULTIPOLYGONFROMWKB:
      case MySqlParser::NAME_CONST:
      case MySqlParser::NULLIF:
      case MySqlParser::NUMGEOMETRIES:
      case MySqlParser::NUMINTERIORRINGS:
      case MySqlParser::NUMPOINTS:
      case MySqlParser::OCT:
      case MySqlParser::OCTET_LENGTH:
      case MySqlParser::ORD:
      case MySqlParser::OVERLAPS:
      case MySqlParser::PERIOD_ADD:
      case MySqlParser::PERIOD_DIFF:
      case MySqlParser::PI:
      case MySqlParser::POINTFROMTEXT:
      case MySqlParser::POINTFROMWKB:
      case MySqlParser::POINTN:
      case MySqlParser::POLYFROMTEXT:
      case MySqlParser::POLYFROMWKB:
      case MySqlParser::POLYGONFROMTEXT:
      case MySqlParser::POLYGONFROMWKB:
      case MySqlParser::POW:
      case MySqlParser::POWER:
      case MySqlParser::QUOTE:
      case MySqlParser::RADIANS:
      case MySqlParser::RAND:
      case MySqlParser::RANDOM_BYTES:
      case MySqlParser::RELEASE_LOCK:
      case MySqlParser::REVERSE:
      case MySqlParser::ROUND:
      case MySqlParser::ROW_COUNT:
      case MySqlParser::RPAD:
      case MySqlParser::RTRIM:
      case MySqlParser::SEC_TO_TIME:
      case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySqlParser::SESSION_USER:
      case MySqlParser::SHA:
      case MySqlParser::SHA1:
      case MySqlParser::SHA2:
      case MySqlParser::SCHEMA_NAME:
      case MySqlParser::SIGN:
      case MySqlParser::SIN:
      case MySqlParser::SLEEP:
      case MySqlParser::SOUNDEX:
      case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
      case MySqlParser::SQRT:
      case MySqlParser::SRID:
      case MySqlParser::STARTPOINT:
      case MySqlParser::STRCMP:
      case MySqlParser::STR_TO_DATE:
      case MySqlParser::ST_AREA:
      case MySqlParser::ST_ASBINARY:
      case MySqlParser::ST_ASTEXT:
      case MySqlParser::ST_ASWKB:
      case MySqlParser::ST_ASWKT:
      case MySqlParser::ST_BUFFER:
      case MySqlParser::ST_CENTROID:
      case MySqlParser::ST_CONTAINS:
      case MySqlParser::ST_CROSSES:
      case MySqlParser::ST_DIFFERENCE:
      case MySqlParser::ST_DIMENSION:
      case MySqlParser::ST_DISJOINT:
      case MySqlParser::ST_DISTANCE:
      case MySqlParser::ST_ENDPOINT:
      case MySqlParser::ST_ENVELOPE:
      case MySqlParser::ST_EQUALS:
      case MySqlParser::ST_EXTERIORRING:
      case MySqlParser::ST_GEOMCOLLFROMTEXT:
      case MySqlParser::ST_GEOMCOLLFROMTXT:
      case MySqlParser::ST_GEOMCOLLFROMWKB:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::ST_GEOMETRYFROMTEXT:
      case MySqlParser::ST_GEOMETRYFROMWKB:
      case MySqlParser::ST_GEOMETRYN:
      case MySqlParser::ST_GEOMETRYTYPE:
      case MySqlParser::ST_GEOMFROMTEXT:
      case MySqlParser::ST_GEOMFROMWKB:
      case MySqlParser::ST_INTERIORRINGN:
      case MySqlParser::ST_INTERSECTION:
      case MySqlParser::ST_INTERSECTS:
      case MySqlParser::ST_ISCLOSED:
      case MySqlParser::ST_ISEMPTY:
      case MySqlParser::ST_ISSIMPLE:
      case MySqlParser::ST_LINEFROMTEXT:
      case MySqlParser::ST_LINEFROMWKB:
      case MySqlParser::ST_LINESTRINGFROMTEXT:
      case MySqlParser::ST_LINESTRINGFROMWKB:
      case MySqlParser::ST_NUMGEOMETRIES:
      case MySqlParser::ST_NUMINTERIORRING:
      case MySqlParser::ST_NUMINTERIORRINGS:
      case MySqlParser::ST_NUMPOINTS:
      case MySqlParser::ST_OVERLAPS:
      case MySqlParser::ST_POINTFROMTEXT:
      case MySqlParser::ST_POINTFROMWKB:
      case MySqlParser::ST_POINTN:
      case MySqlParser::ST_POLYFROMTEXT:
      case MySqlParser::ST_POLYFROMWKB:
      case MySqlParser::ST_POLYGONFROMTEXT:
      case MySqlParser::ST_POLYGONFROMWKB:
      case MySqlParser::ST_SRID:
      case MySqlParser::ST_STARTPOINT:
      case MySqlParser::ST_SYMDIFFERENCE:
      case MySqlParser::ST_TOUCHES:
      case MySqlParser::ST_UNION:
      case MySqlParser::ST_WITHIN:
      case MySqlParser::ST_X:
      case MySqlParser::ST_Y:
      case MySqlParser::SUBDATE:
      case MySqlParser::SUBSTRING_INDEX:
      case MySqlParser::SUBTIME:
      case MySqlParser::SYSTEM_USER:
      case MySqlParser::TAN:
      case MySqlParser::TIMEDIFF:
      case MySqlParser::TIMESTAMPADD:
      case MySqlParser::TIMESTAMPDIFF:
      case MySqlParser::TIME_FORMAT:
      case MySqlParser::TIME_TO_SEC:
      case MySqlParser::TOUCHES:
      case MySqlParser::TO_BASE64:
      case MySqlParser::TO_DAYS:
      case MySqlParser::TO_SECONDS:
      case MySqlParser::TP_CONNECTION_ADMIN:
      case MySqlParser::UCASE:
      case MySqlParser::UNCOMPRESS:
      case MySqlParser::UNCOMPRESSED_LENGTH:
      case MySqlParser::UNHEX:
      case MySqlParser::UNIX_TIMESTAMP:
      case MySqlParser::UPDATEXML:
      case MySqlParser::UPPER:
      case MySqlParser::UUID:
      case MySqlParser::UUID_SHORT:
      case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
      case MySqlParser::VERSION:
      case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
      case MySqlParser::WEEKDAY:
      case MySqlParser::WEEKOFYEAR:
      case MySqlParser::WEIGHT_STRING:
      case MySqlParser::WITHIN:
      case MySqlParser::YEARWEEK:
      case MySqlParser::Y_FUNCTION:
      case MySqlParser::X_FUNCTION:
      case MySqlParser::MOD:
      case MySqlParser::ID: {
        enterOuterAlt(_localctx, 3);
        setState(4235);
        simpleId();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StartTransactionContext ------------------------------------------------------------------

MySqlParser::StartTransactionContext::StartTransactionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::StartTransactionContext::START() {
  return getToken(MySqlParser::START, 0);
}

tree::TerminalNode* MySqlParser::StartTransactionContext::TRANSACTION() {
  return getToken(MySqlParser::TRANSACTION, 0);
}

std::vector<MySqlParser::TransactionModeContext *> MySqlParser::StartTransactionContext::transactionMode() {
  return getRuleContexts<MySqlParser::TransactionModeContext>();
}

MySqlParser::TransactionModeContext* MySqlParser::StartTransactionContext::transactionMode(size_t i) {
  return getRuleContext<MySqlParser::TransactionModeContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::StartTransactionContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::StartTransactionContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::StartTransactionContext::getRuleIndex() const {
  return MySqlParser::RuleStartTransaction;
}

void MySqlParser::StartTransactionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStartTransaction(this);
}

void MySqlParser::StartTransactionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStartTransaction(this);
}


std::any MySqlParser::StartTransactionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitStartTransaction(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::StartTransactionContext* MySqlParser::startTransaction() {
  StartTransactionContext *_localctx = _tracker.createInstance<StartTransactionContext>(_ctx, getState());
  enterRule(_localctx, 294, MySqlParser::RuleStartTransaction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4238);
    match(MySqlParser::START);
    setState(4239);
    match(MySqlParser::TRANSACTION);
    setState(4248);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 622, _ctx)) {
    case 1: {
      setState(4240);
      transactionMode();
      setState(4245);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(4241);
        match(MySqlParser::COMMA);
        setState(4242);
        transactionMode();
        setState(4247);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginWorkContext ------------------------------------------------------------------

MySqlParser::BeginWorkContext::BeginWorkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::BeginWorkContext::BEGIN() {
  return getToken(MySqlParser::BEGIN, 0);
}

tree::TerminalNode* MySqlParser::BeginWorkContext::WORK() {
  return getToken(MySqlParser::WORK, 0);
}


size_t MySqlParser::BeginWorkContext::getRuleIndex() const {
  return MySqlParser::RuleBeginWork;
}

void MySqlParser::BeginWorkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginWork(this);
}

void MySqlParser::BeginWorkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginWork(this);
}


std::any MySqlParser::BeginWorkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitBeginWork(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::BeginWorkContext* MySqlParser::beginWork() {
  BeginWorkContext *_localctx = _tracker.createInstance<BeginWorkContext>(_ctx, getState());
  enterRule(_localctx, 296, MySqlParser::RuleBeginWork);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4250);
    match(MySqlParser::BEGIN);
    setState(4252);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WORK) {
      setState(4251);
      match(MySqlParser::WORK);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommitWorkContext ------------------------------------------------------------------

MySqlParser::CommitWorkContext::CommitWorkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CommitWorkContext::COMMIT() {
  return getToken(MySqlParser::COMMIT, 0);
}

tree::TerminalNode* MySqlParser::CommitWorkContext::WORK() {
  return getToken(MySqlParser::WORK, 0);
}

tree::TerminalNode* MySqlParser::CommitWorkContext::AND() {
  return getToken(MySqlParser::AND, 0);
}

tree::TerminalNode* MySqlParser::CommitWorkContext::CHAIN() {
  return getToken(MySqlParser::CHAIN, 0);
}

tree::TerminalNode* MySqlParser::CommitWorkContext::RELEASE() {
  return getToken(MySqlParser::RELEASE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::CommitWorkContext::NO() {
  return getTokens(MySqlParser::NO);
}

tree::TerminalNode* MySqlParser::CommitWorkContext::NO(size_t i) {
  return getToken(MySqlParser::NO, i);
}


size_t MySqlParser::CommitWorkContext::getRuleIndex() const {
  return MySqlParser::RuleCommitWork;
}

void MySqlParser::CommitWorkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommitWork(this);
}

void MySqlParser::CommitWorkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommitWork(this);
}


std::any MySqlParser::CommitWorkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCommitWork(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CommitWorkContext* MySqlParser::commitWork() {
  CommitWorkContext *_localctx = _tracker.createInstance<CommitWorkContext>(_ctx, getState());
  enterRule(_localctx, 298, MySqlParser::RuleCommitWork);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4254);
    match(MySqlParser::COMMIT);
    setState(4256);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WORK) {
      setState(4255);
      match(MySqlParser::WORK);
    }
    setState(4263);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::AND) {
      setState(4258);
      match(MySqlParser::AND);
      setState(4260);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::NO) {
        setState(4259);
        antlrcpp::downCast<CommitWorkContext *>(_localctx)->nochain = match(MySqlParser::NO);
      }
      setState(4262);
      match(MySqlParser::CHAIN);
    }
    setState(4269);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 628, _ctx)) {
    case 1: {
      setState(4266);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::NO) {
        setState(4265);
        antlrcpp::downCast<CommitWorkContext *>(_localctx)->norelease = match(MySqlParser::NO);
      }
      setState(4268);
      match(MySqlParser::RELEASE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RollbackWorkContext ------------------------------------------------------------------

MySqlParser::RollbackWorkContext::RollbackWorkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::RollbackWorkContext::ROLLBACK() {
  return getToken(MySqlParser::ROLLBACK, 0);
}

tree::TerminalNode* MySqlParser::RollbackWorkContext::WORK() {
  return getToken(MySqlParser::WORK, 0);
}

tree::TerminalNode* MySqlParser::RollbackWorkContext::AND() {
  return getToken(MySqlParser::AND, 0);
}

tree::TerminalNode* MySqlParser::RollbackWorkContext::CHAIN() {
  return getToken(MySqlParser::CHAIN, 0);
}

tree::TerminalNode* MySqlParser::RollbackWorkContext::RELEASE() {
  return getToken(MySqlParser::RELEASE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::RollbackWorkContext::NO() {
  return getTokens(MySqlParser::NO);
}

tree::TerminalNode* MySqlParser::RollbackWorkContext::NO(size_t i) {
  return getToken(MySqlParser::NO, i);
}


size_t MySqlParser::RollbackWorkContext::getRuleIndex() const {
  return MySqlParser::RuleRollbackWork;
}

void MySqlParser::RollbackWorkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRollbackWork(this);
}

void MySqlParser::RollbackWorkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRollbackWork(this);
}


std::any MySqlParser::RollbackWorkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRollbackWork(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::RollbackWorkContext* MySqlParser::rollbackWork() {
  RollbackWorkContext *_localctx = _tracker.createInstance<RollbackWorkContext>(_ctx, getState());
  enterRule(_localctx, 300, MySqlParser::RuleRollbackWork);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4271);
    match(MySqlParser::ROLLBACK);
    setState(4273);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WORK) {
      setState(4272);
      match(MySqlParser::WORK);
    }
    setState(4280);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::AND) {
      setState(4275);
      match(MySqlParser::AND);
      setState(4277);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::NO) {
        setState(4276);
        antlrcpp::downCast<RollbackWorkContext *>(_localctx)->nochain = match(MySqlParser::NO);
      }
      setState(4279);
      match(MySqlParser::CHAIN);
    }
    setState(4286);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 633, _ctx)) {
    case 1: {
      setState(4283);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::NO) {
        setState(4282);
        antlrcpp::downCast<RollbackWorkContext *>(_localctx)->norelease = match(MySqlParser::NO);
      }
      setState(4285);
      match(MySqlParser::RELEASE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SavepointStatementContext ------------------------------------------------------------------

MySqlParser::SavepointStatementContext::SavepointStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SavepointStatementContext::SAVEPOINT() {
  return getToken(MySqlParser::SAVEPOINT, 0);
}

MySqlParser::UidContext* MySqlParser::SavepointStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}


size_t MySqlParser::SavepointStatementContext::getRuleIndex() const {
  return MySqlParser::RuleSavepointStatement;
}

void MySqlParser::SavepointStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSavepointStatement(this);
}

void MySqlParser::SavepointStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSavepointStatement(this);
}


std::any MySqlParser::SavepointStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSavepointStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SavepointStatementContext* MySqlParser::savepointStatement() {
  SavepointStatementContext *_localctx = _tracker.createInstance<SavepointStatementContext>(_ctx, getState());
  enterRule(_localctx, 302, MySqlParser::RuleSavepointStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4288);
    match(MySqlParser::SAVEPOINT);
    setState(4289);
    uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RollbackStatementContext ------------------------------------------------------------------

MySqlParser::RollbackStatementContext::RollbackStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::RollbackStatementContext::ROLLBACK() {
  return getToken(MySqlParser::ROLLBACK, 0);
}

tree::TerminalNode* MySqlParser::RollbackStatementContext::TO() {
  return getToken(MySqlParser::TO, 0);
}

MySqlParser::UidContext* MySqlParser::RollbackStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::RollbackStatementContext::WORK() {
  return getToken(MySqlParser::WORK, 0);
}

tree::TerminalNode* MySqlParser::RollbackStatementContext::SAVEPOINT() {
  return getToken(MySqlParser::SAVEPOINT, 0);
}


size_t MySqlParser::RollbackStatementContext::getRuleIndex() const {
  return MySqlParser::RuleRollbackStatement;
}

void MySqlParser::RollbackStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRollbackStatement(this);
}

void MySqlParser::RollbackStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRollbackStatement(this);
}


std::any MySqlParser::RollbackStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRollbackStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::RollbackStatementContext* MySqlParser::rollbackStatement() {
  RollbackStatementContext *_localctx = _tracker.createInstance<RollbackStatementContext>(_ctx, getState());
  enterRule(_localctx, 304, MySqlParser::RuleRollbackStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4291);
    match(MySqlParser::ROLLBACK);
    setState(4293);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::WORK) {
      setState(4292);
      match(MySqlParser::WORK);
    }
    setState(4295);
    match(MySqlParser::TO);
    setState(4297);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 635, _ctx)) {
    case 1: {
      setState(4296);
      match(MySqlParser::SAVEPOINT);
      break;
    }

    default:
      break;
    }
    setState(4299);
    uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReleaseStatementContext ------------------------------------------------------------------

MySqlParser::ReleaseStatementContext::ReleaseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ReleaseStatementContext::RELEASE() {
  return getToken(MySqlParser::RELEASE, 0);
}

tree::TerminalNode* MySqlParser::ReleaseStatementContext::SAVEPOINT() {
  return getToken(MySqlParser::SAVEPOINT, 0);
}

MySqlParser::UidContext* MySqlParser::ReleaseStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}


size_t MySqlParser::ReleaseStatementContext::getRuleIndex() const {
  return MySqlParser::RuleReleaseStatement;
}

void MySqlParser::ReleaseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReleaseStatement(this);
}

void MySqlParser::ReleaseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReleaseStatement(this);
}


std::any MySqlParser::ReleaseStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitReleaseStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ReleaseStatementContext* MySqlParser::releaseStatement() {
  ReleaseStatementContext *_localctx = _tracker.createInstance<ReleaseStatementContext>(_ctx, getState());
  enterRule(_localctx, 306, MySqlParser::RuleReleaseStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4301);
    match(MySqlParser::RELEASE);
    setState(4302);
    match(MySqlParser::SAVEPOINT);
    setState(4303);
    uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockTablesContext ------------------------------------------------------------------

MySqlParser::LockTablesContext::LockTablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::LockTablesContext::LOCK() {
  return getToken(MySqlParser::LOCK, 0);
}

std::vector<MySqlParser::LockTableElementContext *> MySqlParser::LockTablesContext::lockTableElement() {
  return getRuleContexts<MySqlParser::LockTableElementContext>();
}

MySqlParser::LockTableElementContext* MySqlParser::LockTablesContext::lockTableElement(size_t i) {
  return getRuleContext<MySqlParser::LockTableElementContext>(i);
}

tree::TerminalNode* MySqlParser::LockTablesContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

tree::TerminalNode* MySqlParser::LockTablesContext::TABLES() {
  return getToken(MySqlParser::TABLES, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::LockTablesContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::LockTablesContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::WaitNowaitClauseContext* MySqlParser::LockTablesContext::waitNowaitClause() {
  return getRuleContext<MySqlParser::WaitNowaitClauseContext>(0);
}


size_t MySqlParser::LockTablesContext::getRuleIndex() const {
  return MySqlParser::RuleLockTables;
}

void MySqlParser::LockTablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockTables(this);
}

void MySqlParser::LockTablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockTables(this);
}


std::any MySqlParser::LockTablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLockTables(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LockTablesContext* MySqlParser::lockTables() {
  LockTablesContext *_localctx = _tracker.createInstance<LockTablesContext>(_ctx, getState());
  enterRule(_localctx, 308, MySqlParser::RuleLockTables);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4305);
    match(MySqlParser::LOCK);
    setState(4306);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::TABLE || _la == MySqlParser::TABLES)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4307);
    lockTableElement();
    setState(4312);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(4308);
      match(MySqlParser::COMMA);
      setState(4309);
      lockTableElement();
      setState(4314);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4316);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::NOWAIT || _la == MySqlParser::WAIT) {
      setState(4315);
      waitNowaitClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlockTablesContext ------------------------------------------------------------------

MySqlParser::UnlockTablesContext::UnlockTablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::UnlockTablesContext::UNLOCK() {
  return getToken(MySqlParser::UNLOCK, 0);
}

tree::TerminalNode* MySqlParser::UnlockTablesContext::TABLES() {
  return getToken(MySqlParser::TABLES, 0);
}


size_t MySqlParser::UnlockTablesContext::getRuleIndex() const {
  return MySqlParser::RuleUnlockTables;
}

void MySqlParser::UnlockTablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlockTables(this);
}

void MySqlParser::UnlockTablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlockTables(this);
}


std::any MySqlParser::UnlockTablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUnlockTables(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UnlockTablesContext* MySqlParser::unlockTables() {
  UnlockTablesContext *_localctx = _tracker.createInstance<UnlockTablesContext>(_ctx, getState());
  enterRule(_localctx, 310, MySqlParser::RuleUnlockTables);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4318);
    match(MySqlParser::UNLOCK);
    setState(4319);
    match(MySqlParser::TABLES);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetAutocommitStatementContext ------------------------------------------------------------------

MySqlParser::SetAutocommitStatementContext::SetAutocommitStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SetAutocommitStatementContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::SetAutocommitStatementContext::AUTOCOMMIT() {
  return getToken(MySqlParser::AUTOCOMMIT, 0);
}

tree::TerminalNode* MySqlParser::SetAutocommitStatementContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::SetAutocommitStatementContext::ZERO_DECIMAL() {
  return getToken(MySqlParser::ZERO_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::SetAutocommitStatementContext::ONE_DECIMAL() {
  return getToken(MySqlParser::ONE_DECIMAL, 0);
}


size_t MySqlParser::SetAutocommitStatementContext::getRuleIndex() const {
  return MySqlParser::RuleSetAutocommitStatement;
}

void MySqlParser::SetAutocommitStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetAutocommitStatement(this);
}

void MySqlParser::SetAutocommitStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetAutocommitStatement(this);
}


std::any MySqlParser::SetAutocommitStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSetAutocommitStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SetAutocommitStatementContext* MySqlParser::setAutocommitStatement() {
  SetAutocommitStatementContext *_localctx = _tracker.createInstance<SetAutocommitStatementContext>(_ctx, getState());
  enterRule(_localctx, 312, MySqlParser::RuleSetAutocommitStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4321);
    match(MySqlParser::SET);
    setState(4322);
    match(MySqlParser::AUTOCOMMIT);
    setState(4323);
    match(MySqlParser::EQUAL_SYMBOL);
    setState(4324);
    antlrcpp::downCast<SetAutocommitStatementContext *>(_localctx)->autocommitValue = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::ZERO_DECIMAL

    || _la == MySqlParser::ONE_DECIMAL)) {
      antlrcpp::downCast<SetAutocommitStatementContext *>(_localctx)->autocommitValue = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetTransactionStatementContext ------------------------------------------------------------------

MySqlParser::SetTransactionStatementContext::SetTransactionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SetTransactionStatementContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::SetTransactionStatementContext::TRANSACTION() {
  return getToken(MySqlParser::TRANSACTION, 0);
}

std::vector<MySqlParser::TransactionOptionContext *> MySqlParser::SetTransactionStatementContext::transactionOption() {
  return getRuleContexts<MySqlParser::TransactionOptionContext>();
}

MySqlParser::TransactionOptionContext* MySqlParser::SetTransactionStatementContext::transactionOption(size_t i) {
  return getRuleContext<MySqlParser::TransactionOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::SetTransactionStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::SetTransactionStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::SetTransactionStatementContext::GLOBAL() {
  return getToken(MySqlParser::GLOBAL, 0);
}

tree::TerminalNode* MySqlParser::SetTransactionStatementContext::SESSION() {
  return getToken(MySqlParser::SESSION, 0);
}


size_t MySqlParser::SetTransactionStatementContext::getRuleIndex() const {
  return MySqlParser::RuleSetTransactionStatement;
}

void MySqlParser::SetTransactionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetTransactionStatement(this);
}

void MySqlParser::SetTransactionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetTransactionStatement(this);
}


std::any MySqlParser::SetTransactionStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSetTransactionStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SetTransactionStatementContext* MySqlParser::setTransactionStatement() {
  SetTransactionStatementContext *_localctx = _tracker.createInstance<SetTransactionStatementContext>(_ctx, getState());
  enterRule(_localctx, 314, MySqlParser::RuleSetTransactionStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4326);
    match(MySqlParser::SET);
    setState(4328);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::GLOBAL || _la == MySqlParser::SESSION) {
      setState(4327);
      antlrcpp::downCast<SetTransactionStatementContext *>(_localctx)->transactionContext = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::GLOBAL || _la == MySqlParser::SESSION)) {
        antlrcpp::downCast<SetTransactionStatementContext *>(_localctx)->transactionContext = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(4330);
    match(MySqlParser::TRANSACTION);
    setState(4331);
    transactionOption();
    setState(4336);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(4332);
      match(MySqlParser::COMMA);
      setState(4333);
      transactionOption();
      setState(4338);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionModeContext ------------------------------------------------------------------

MySqlParser::TransactionModeContext::TransactionModeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::TransactionModeContext::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

tree::TerminalNode* MySqlParser::TransactionModeContext::CONSISTENT() {
  return getToken(MySqlParser::CONSISTENT, 0);
}

tree::TerminalNode* MySqlParser::TransactionModeContext::SNAPSHOT() {
  return getToken(MySqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* MySqlParser::TransactionModeContext::READ() {
  return getToken(MySqlParser::READ, 0);
}

tree::TerminalNode* MySqlParser::TransactionModeContext::WRITE() {
  return getToken(MySqlParser::WRITE, 0);
}

tree::TerminalNode* MySqlParser::TransactionModeContext::ONLY() {
  return getToken(MySqlParser::ONLY, 0);
}


size_t MySqlParser::TransactionModeContext::getRuleIndex() const {
  return MySqlParser::RuleTransactionMode;
}

void MySqlParser::TransactionModeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionMode(this);
}

void MySqlParser::TransactionModeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionMode(this);
}


std::any MySqlParser::TransactionModeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTransactionMode(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TransactionModeContext* MySqlParser::transactionMode() {
  TransactionModeContext *_localctx = _tracker.createInstance<TransactionModeContext>(_ctx, getState());
  enterRule(_localctx, 316, MySqlParser::RuleTransactionMode);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4346);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 640, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4339);
      match(MySqlParser::WITH);
      setState(4340);
      match(MySqlParser::CONSISTENT);
      setState(4341);
      match(MySqlParser::SNAPSHOT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4342);
      match(MySqlParser::READ);
      setState(4343);
      match(MySqlParser::WRITE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4344);
      match(MySqlParser::READ);
      setState(4345);
      match(MySqlParser::ONLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockTableElementContext ------------------------------------------------------------------

MySqlParser::LockTableElementContext::LockTableElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::TableNameContext* MySqlParser::LockTableElementContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

MySqlParser::LockActionContext* MySqlParser::LockTableElementContext::lockAction() {
  return getRuleContext<MySqlParser::LockActionContext>(0);
}

MySqlParser::UidContext* MySqlParser::LockTableElementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::LockTableElementContext::AS() {
  return getToken(MySqlParser::AS, 0);
}


size_t MySqlParser::LockTableElementContext::getRuleIndex() const {
  return MySqlParser::RuleLockTableElement;
}

void MySqlParser::LockTableElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockTableElement(this);
}

void MySqlParser::LockTableElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockTableElement(this);
}


std::any MySqlParser::LockTableElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLockTableElement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LockTableElementContext* MySqlParser::lockTableElement() {
  LockTableElementContext *_localctx = _tracker.createInstance<LockTableElementContext>(_ctx, getState());
  enterRule(_localctx, 318, MySqlParser::RuleLockTableElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4348);
    tableName();
    setState(4353);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 756891332513124352) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
      setState(4350);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::AS) {
        setState(4349);
        match(MySqlParser::AS);
      }
      setState(4352);
      uid();
    }
    setState(4355);
    lockAction();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockActionContext ------------------------------------------------------------------

MySqlParser::LockActionContext::LockActionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::LockActionContext::READ() {
  return getToken(MySqlParser::READ, 0);
}

tree::TerminalNode* MySqlParser::LockActionContext::LOCAL() {
  return getToken(MySqlParser::LOCAL, 0);
}

tree::TerminalNode* MySqlParser::LockActionContext::WRITE() {
  return getToken(MySqlParser::WRITE, 0);
}

tree::TerminalNode* MySqlParser::LockActionContext::LOW_PRIORITY() {
  return getToken(MySqlParser::LOW_PRIORITY, 0);
}


size_t MySqlParser::LockActionContext::getRuleIndex() const {
  return MySqlParser::RuleLockAction;
}

void MySqlParser::LockActionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockAction(this);
}

void MySqlParser::LockActionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockAction(this);
}


std::any MySqlParser::LockActionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLockAction(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LockActionContext* MySqlParser::lockAction() {
  LockActionContext *_localctx = _tracker.createInstance<LockActionContext>(_ctx, getState());
  enterRule(_localctx, 320, MySqlParser::RuleLockAction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4365);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::READ: {
        enterOuterAlt(_localctx, 1);
        setState(4357);
        match(MySqlParser::READ);
        setState(4359);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::LOCAL) {
          setState(4358);
          match(MySqlParser::LOCAL);
        }
        break;
      }

      case MySqlParser::LOW_PRIORITY:
      case MySqlParser::WRITE: {
        enterOuterAlt(_localctx, 2);
        setState(4362);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::LOW_PRIORITY) {
          setState(4361);
          match(MySqlParser::LOW_PRIORITY);
        }
        setState(4364);
        match(MySqlParser::WRITE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionOptionContext ------------------------------------------------------------------

MySqlParser::TransactionOptionContext::TransactionOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::TransactionOptionContext::ISOLATION() {
  return getToken(MySqlParser::ISOLATION, 0);
}

tree::TerminalNode* MySqlParser::TransactionOptionContext::LEVEL() {
  return getToken(MySqlParser::LEVEL, 0);
}

MySqlParser::TransactionLevelContext* MySqlParser::TransactionOptionContext::transactionLevel() {
  return getRuleContext<MySqlParser::TransactionLevelContext>(0);
}

tree::TerminalNode* MySqlParser::TransactionOptionContext::READ() {
  return getToken(MySqlParser::READ, 0);
}

tree::TerminalNode* MySqlParser::TransactionOptionContext::WRITE() {
  return getToken(MySqlParser::WRITE, 0);
}

tree::TerminalNode* MySqlParser::TransactionOptionContext::ONLY() {
  return getToken(MySqlParser::ONLY, 0);
}


size_t MySqlParser::TransactionOptionContext::getRuleIndex() const {
  return MySqlParser::RuleTransactionOption;
}

void MySqlParser::TransactionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionOption(this);
}

void MySqlParser::TransactionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionOption(this);
}


std::any MySqlParser::TransactionOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTransactionOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TransactionOptionContext* MySqlParser::transactionOption() {
  TransactionOptionContext *_localctx = _tracker.createInstance<TransactionOptionContext>(_ctx, getState());
  enterRule(_localctx, 322, MySqlParser::RuleTransactionOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4374);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 646, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4367);
      match(MySqlParser::ISOLATION);
      setState(4368);
      match(MySqlParser::LEVEL);
      setState(4369);
      transactionLevel();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4370);
      match(MySqlParser::READ);
      setState(4371);
      match(MySqlParser::WRITE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4372);
      match(MySqlParser::READ);
      setState(4373);
      match(MySqlParser::ONLY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionLevelContext ------------------------------------------------------------------

MySqlParser::TransactionLevelContext::TransactionLevelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::TransactionLevelContext::REPEATABLE() {
  return getToken(MySqlParser::REPEATABLE, 0);
}

tree::TerminalNode* MySqlParser::TransactionLevelContext::READ() {
  return getToken(MySqlParser::READ, 0);
}

tree::TerminalNode* MySqlParser::TransactionLevelContext::COMMITTED() {
  return getToken(MySqlParser::COMMITTED, 0);
}

tree::TerminalNode* MySqlParser::TransactionLevelContext::UNCOMMITTED() {
  return getToken(MySqlParser::UNCOMMITTED, 0);
}

tree::TerminalNode* MySqlParser::TransactionLevelContext::SERIALIZABLE() {
  return getToken(MySqlParser::SERIALIZABLE, 0);
}


size_t MySqlParser::TransactionLevelContext::getRuleIndex() const {
  return MySqlParser::RuleTransactionLevel;
}

void MySqlParser::TransactionLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionLevel(this);
}

void MySqlParser::TransactionLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionLevel(this);
}


std::any MySqlParser::TransactionLevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTransactionLevel(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TransactionLevelContext* MySqlParser::transactionLevel() {
  TransactionLevelContext *_localctx = _tracker.createInstance<TransactionLevelContext>(_ctx, getState());
  enterRule(_localctx, 324, MySqlParser::RuleTransactionLevel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4383);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 647, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4376);
      match(MySqlParser::REPEATABLE);
      setState(4377);
      match(MySqlParser::READ);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4378);
      match(MySqlParser::READ);
      setState(4379);
      match(MySqlParser::COMMITTED);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4380);
      match(MySqlParser::READ);
      setState(4381);
      match(MySqlParser::UNCOMMITTED);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4382);
      match(MySqlParser::SERIALIZABLE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeMasterContext ------------------------------------------------------------------

MySqlParser::ChangeMasterContext::ChangeMasterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ChangeMasterContext::CHANGE() {
  return getToken(MySqlParser::CHANGE, 0);
}

tree::TerminalNode* MySqlParser::ChangeMasterContext::MASTER() {
  return getToken(MySqlParser::MASTER, 0);
}

tree::TerminalNode* MySqlParser::ChangeMasterContext::TO() {
  return getToken(MySqlParser::TO, 0);
}

std::vector<MySqlParser::MasterOptionContext *> MySqlParser::ChangeMasterContext::masterOption() {
  return getRuleContexts<MySqlParser::MasterOptionContext>();
}

MySqlParser::MasterOptionContext* MySqlParser::ChangeMasterContext::masterOption(size_t i) {
  return getRuleContext<MySqlParser::MasterOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::ChangeMasterContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::ChangeMasterContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::ChannelOptionContext* MySqlParser::ChangeMasterContext::channelOption() {
  return getRuleContext<MySqlParser::ChannelOptionContext>(0);
}


size_t MySqlParser::ChangeMasterContext::getRuleIndex() const {
  return MySqlParser::RuleChangeMaster;
}

void MySqlParser::ChangeMasterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeMaster(this);
}

void MySqlParser::ChangeMasterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeMaster(this);
}


std::any MySqlParser::ChangeMasterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitChangeMaster(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ChangeMasterContext* MySqlParser::changeMaster() {
  ChangeMasterContext *_localctx = _tracker.createInstance<ChangeMasterContext>(_ctx, getState());
  enterRule(_localctx, 326, MySqlParser::RuleChangeMaster);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4385);
    match(MySqlParser::CHANGE);
    setState(4386);
    match(MySqlParser::MASTER);
    setState(4387);
    match(MySqlParser::TO);
    setState(4388);
    masterOption();
    setState(4393);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(4389);
      match(MySqlParser::COMMA);
      setState(4390);
      masterOption();
      setState(4395);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4397);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::FOR) {
      setState(4396);
      channelOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationFilterContext ------------------------------------------------------------------

MySqlParser::ChangeReplicationFilterContext::ChangeReplicationFilterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ChangeReplicationFilterContext::CHANGE() {
  return getToken(MySqlParser::CHANGE, 0);
}

tree::TerminalNode* MySqlParser::ChangeReplicationFilterContext::REPLICATION() {
  return getToken(MySqlParser::REPLICATION, 0);
}

tree::TerminalNode* MySqlParser::ChangeReplicationFilterContext::FILTER() {
  return getToken(MySqlParser::FILTER, 0);
}

std::vector<MySqlParser::ReplicationFilterContext *> MySqlParser::ChangeReplicationFilterContext::replicationFilter() {
  return getRuleContexts<MySqlParser::ReplicationFilterContext>();
}

MySqlParser::ReplicationFilterContext* MySqlParser::ChangeReplicationFilterContext::replicationFilter(size_t i) {
  return getRuleContext<MySqlParser::ReplicationFilterContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::ChangeReplicationFilterContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::ChangeReplicationFilterContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::ChangeReplicationFilterContext::getRuleIndex() const {
  return MySqlParser::RuleChangeReplicationFilter;
}

void MySqlParser::ChangeReplicationFilterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationFilter(this);
}

void MySqlParser::ChangeReplicationFilterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationFilter(this);
}


std::any MySqlParser::ChangeReplicationFilterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitChangeReplicationFilter(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ChangeReplicationFilterContext* MySqlParser::changeReplicationFilter() {
  ChangeReplicationFilterContext *_localctx = _tracker.createInstance<ChangeReplicationFilterContext>(_ctx, getState());
  enterRule(_localctx, 328, MySqlParser::RuleChangeReplicationFilter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4399);
    match(MySqlParser::CHANGE);
    setState(4400);
    match(MySqlParser::REPLICATION);
    setState(4401);
    match(MySqlParser::FILTER);
    setState(4402);
    replicationFilter();
    setState(4407);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(4403);
      match(MySqlParser::COMMA);
      setState(4404);
      replicationFilter();
      setState(4409);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PurgeBinaryLogsContext ------------------------------------------------------------------

MySqlParser::PurgeBinaryLogsContext::PurgeBinaryLogsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::PurgeBinaryLogsContext::PURGE() {
  return getToken(MySqlParser::PURGE, 0);
}

tree::TerminalNode* MySqlParser::PurgeBinaryLogsContext::LOGS() {
  return getToken(MySqlParser::LOGS, 0);
}

tree::TerminalNode* MySqlParser::PurgeBinaryLogsContext::BINARY() {
  return getToken(MySqlParser::BINARY, 0);
}

tree::TerminalNode* MySqlParser::PurgeBinaryLogsContext::MASTER() {
  return getToken(MySqlParser::MASTER, 0);
}

tree::TerminalNode* MySqlParser::PurgeBinaryLogsContext::TO() {
  return getToken(MySqlParser::TO, 0);
}

tree::TerminalNode* MySqlParser::PurgeBinaryLogsContext::BEFORE() {
  return getToken(MySqlParser::BEFORE, 0);
}

tree::TerminalNode* MySqlParser::PurgeBinaryLogsContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}


size_t MySqlParser::PurgeBinaryLogsContext::getRuleIndex() const {
  return MySqlParser::RulePurgeBinaryLogs;
}

void MySqlParser::PurgeBinaryLogsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPurgeBinaryLogs(this);
}

void MySqlParser::PurgeBinaryLogsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPurgeBinaryLogs(this);
}


std::any MySqlParser::PurgeBinaryLogsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPurgeBinaryLogs(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::PurgeBinaryLogsContext* MySqlParser::purgeBinaryLogs() {
  PurgeBinaryLogsContext *_localctx = _tracker.createInstance<PurgeBinaryLogsContext>(_ctx, getState());
  enterRule(_localctx, 330, MySqlParser::RulePurgeBinaryLogs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4410);
    match(MySqlParser::PURGE);
    setState(4411);
    antlrcpp::downCast<PurgeBinaryLogsContext *>(_localctx)->purgeFormat = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::BINARY || _la == MySqlParser::MASTER)) {
      antlrcpp::downCast<PurgeBinaryLogsContext *>(_localctx)->purgeFormat = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4412);
    match(MySqlParser::LOGS);
    setState(4417);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::TO: {
        setState(4413);
        match(MySqlParser::TO);
        setState(4414);
        antlrcpp::downCast<PurgeBinaryLogsContext *>(_localctx)->fileName = match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::BEFORE: {
        setState(4415);
        match(MySqlParser::BEFORE);
        setState(4416);
        antlrcpp::downCast<PurgeBinaryLogsContext *>(_localctx)->timeValue = match(MySqlParser::STRING_LITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResetMasterContext ------------------------------------------------------------------

MySqlParser::ResetMasterContext::ResetMasterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ResetMasterContext::RESET() {
  return getToken(MySqlParser::RESET, 0);
}

tree::TerminalNode* MySqlParser::ResetMasterContext::MASTER() {
  return getToken(MySqlParser::MASTER, 0);
}


size_t MySqlParser::ResetMasterContext::getRuleIndex() const {
  return MySqlParser::RuleResetMaster;
}

void MySqlParser::ResetMasterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResetMaster(this);
}

void MySqlParser::ResetMasterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResetMaster(this);
}


std::any MySqlParser::ResetMasterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitResetMaster(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ResetMasterContext* MySqlParser::resetMaster() {
  ResetMasterContext *_localctx = _tracker.createInstance<ResetMasterContext>(_ctx, getState());
  enterRule(_localctx, 332, MySqlParser::RuleResetMaster);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4419);
    match(MySqlParser::RESET);
    setState(4420);
    match(MySqlParser::MASTER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResetSlaveContext ------------------------------------------------------------------

MySqlParser::ResetSlaveContext::ResetSlaveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ResetSlaveContext::RESET() {
  return getToken(MySqlParser::RESET, 0);
}

tree::TerminalNode* MySqlParser::ResetSlaveContext::SLAVE() {
  return getToken(MySqlParser::SLAVE, 0);
}

tree::TerminalNode* MySqlParser::ResetSlaveContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

MySqlParser::ChannelOptionContext* MySqlParser::ResetSlaveContext::channelOption() {
  return getRuleContext<MySqlParser::ChannelOptionContext>(0);
}


size_t MySqlParser::ResetSlaveContext::getRuleIndex() const {
  return MySqlParser::RuleResetSlave;
}

void MySqlParser::ResetSlaveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResetSlave(this);
}

void MySqlParser::ResetSlaveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResetSlave(this);
}


std::any MySqlParser::ResetSlaveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitResetSlave(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ResetSlaveContext* MySqlParser::resetSlave() {
  ResetSlaveContext *_localctx = _tracker.createInstance<ResetSlaveContext>(_ctx, getState());
  enterRule(_localctx, 334, MySqlParser::RuleResetSlave);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4422);
    match(MySqlParser::RESET);
    setState(4423);
    match(MySqlParser::SLAVE);
    setState(4425);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ALL) {
      setState(4424);
      match(MySqlParser::ALL);
    }
    setState(4428);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::FOR) {
      setState(4427);
      channelOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StartSlaveContext ------------------------------------------------------------------

MySqlParser::StartSlaveContext::StartSlaveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::StartSlaveContext::START() {
  return getToken(MySqlParser::START, 0);
}

tree::TerminalNode* MySqlParser::StartSlaveContext::SLAVE() {
  return getToken(MySqlParser::SLAVE, 0);
}

std::vector<MySqlParser::ThreadTypeContext *> MySqlParser::StartSlaveContext::threadType() {
  return getRuleContexts<MySqlParser::ThreadTypeContext>();
}

MySqlParser::ThreadTypeContext* MySqlParser::StartSlaveContext::threadType(size_t i) {
  return getRuleContext<MySqlParser::ThreadTypeContext>(i);
}

tree::TerminalNode* MySqlParser::StartSlaveContext::UNTIL() {
  return getToken(MySqlParser::UNTIL, 0);
}

MySqlParser::UntilOptionContext* MySqlParser::StartSlaveContext::untilOption() {
  return getRuleContext<MySqlParser::UntilOptionContext>(0);
}

std::vector<MySqlParser::ConnectionOptionContext *> MySqlParser::StartSlaveContext::connectionOption() {
  return getRuleContexts<MySqlParser::ConnectionOptionContext>();
}

MySqlParser::ConnectionOptionContext* MySqlParser::StartSlaveContext::connectionOption(size_t i) {
  return getRuleContext<MySqlParser::ConnectionOptionContext>(i);
}

MySqlParser::ChannelOptionContext* MySqlParser::StartSlaveContext::channelOption() {
  return getRuleContext<MySqlParser::ChannelOptionContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::StartSlaveContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::StartSlaveContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::StartSlaveContext::getRuleIndex() const {
  return MySqlParser::RuleStartSlave;
}

void MySqlParser::StartSlaveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStartSlave(this);
}

void MySqlParser::StartSlaveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStartSlave(this);
}


std::any MySqlParser::StartSlaveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitStartSlave(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::StartSlaveContext* MySqlParser::startSlave() {
  StartSlaveContext *_localctx = _tracker.createInstance<StartSlaveContext>(_ctx, getState());
  enterRule(_localctx, 336, MySqlParser::RuleStartSlave);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4430);
    match(MySqlParser::START);
    setState(4431);
    match(MySqlParser::SLAVE);
    setState(4440);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IO_THREAD || _la == MySqlParser::SQL_THREAD) {
      setState(4432);
      threadType();
      setState(4437);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(4433);
        match(MySqlParser::COMMA);
        setState(4434);
        threadType();
        setState(4439);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(4444);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::UNTIL) {
      setState(4442);
      match(MySqlParser::UNTIL);
      setState(4443);
      untilOption();
    }
    setState(4449);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::DEFAULT_AUTH || _la == MySqlParser::PASSWORD

    || _la == MySqlParser::PLUGIN_DIR || _la == MySqlParser::USER) {
      setState(4446);
      connectionOption();
      setState(4451);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4453);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::FOR) {
      setState(4452);
      channelOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StopSlaveContext ------------------------------------------------------------------

MySqlParser::StopSlaveContext::StopSlaveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::StopSlaveContext::STOP() {
  return getToken(MySqlParser::STOP, 0);
}

tree::TerminalNode* MySqlParser::StopSlaveContext::SLAVE() {
  return getToken(MySqlParser::SLAVE, 0);
}

std::vector<MySqlParser::ThreadTypeContext *> MySqlParser::StopSlaveContext::threadType() {
  return getRuleContexts<MySqlParser::ThreadTypeContext>();
}

MySqlParser::ThreadTypeContext* MySqlParser::StopSlaveContext::threadType(size_t i) {
  return getRuleContext<MySqlParser::ThreadTypeContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::StopSlaveContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::StopSlaveContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::StopSlaveContext::getRuleIndex() const {
  return MySqlParser::RuleStopSlave;
}

void MySqlParser::StopSlaveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStopSlave(this);
}

void MySqlParser::StopSlaveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStopSlave(this);
}


std::any MySqlParser::StopSlaveContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitStopSlave(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::StopSlaveContext* MySqlParser::stopSlave() {
  StopSlaveContext *_localctx = _tracker.createInstance<StopSlaveContext>(_ctx, getState());
  enterRule(_localctx, 338, MySqlParser::RuleStopSlave);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4455);
    match(MySqlParser::STOP);
    setState(4456);
    match(MySqlParser::SLAVE);
    setState(4465);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IO_THREAD || _la == MySqlParser::SQL_THREAD) {
      setState(4457);
      threadType();
      setState(4462);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(4458);
        match(MySqlParser::COMMA);
        setState(4459);
        threadType();
        setState(4464);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StartGroupReplicationContext ------------------------------------------------------------------

MySqlParser::StartGroupReplicationContext::StartGroupReplicationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::StartGroupReplicationContext::START() {
  return getToken(MySqlParser::START, 0);
}

tree::TerminalNode* MySqlParser::StartGroupReplicationContext::GROUP_REPLICATION() {
  return getToken(MySqlParser::GROUP_REPLICATION, 0);
}


size_t MySqlParser::StartGroupReplicationContext::getRuleIndex() const {
  return MySqlParser::RuleStartGroupReplication;
}

void MySqlParser::StartGroupReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStartGroupReplication(this);
}

void MySqlParser::StartGroupReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStartGroupReplication(this);
}


std::any MySqlParser::StartGroupReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitStartGroupReplication(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::StartGroupReplicationContext* MySqlParser::startGroupReplication() {
  StartGroupReplicationContext *_localctx = _tracker.createInstance<StartGroupReplicationContext>(_ctx, getState());
  enterRule(_localctx, 340, MySqlParser::RuleStartGroupReplication);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4467);
    match(MySqlParser::START);
    setState(4468);
    match(MySqlParser::GROUP_REPLICATION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StopGroupReplicationContext ------------------------------------------------------------------

MySqlParser::StopGroupReplicationContext::StopGroupReplicationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::StopGroupReplicationContext::STOP() {
  return getToken(MySqlParser::STOP, 0);
}

tree::TerminalNode* MySqlParser::StopGroupReplicationContext::GROUP_REPLICATION() {
  return getToken(MySqlParser::GROUP_REPLICATION, 0);
}


size_t MySqlParser::StopGroupReplicationContext::getRuleIndex() const {
  return MySqlParser::RuleStopGroupReplication;
}

void MySqlParser::StopGroupReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStopGroupReplication(this);
}

void MySqlParser::StopGroupReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStopGroupReplication(this);
}


std::any MySqlParser::StopGroupReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitStopGroupReplication(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::StopGroupReplicationContext* MySqlParser::stopGroupReplication() {
  StopGroupReplicationContext *_localctx = _tracker.createInstance<StopGroupReplicationContext>(_ctx, getState());
  enterRule(_localctx, 342, MySqlParser::RuleStopGroupReplication);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4470);
    match(MySqlParser::STOP);
    setState(4471);
    match(MySqlParser::GROUP_REPLICATION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MasterOptionContext ------------------------------------------------------------------

MySqlParser::MasterOptionContext::MasterOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::MasterOptionContext::getRuleIndex() const {
  return MySqlParser::RuleMasterOption;
}

void MySqlParser::MasterOptionContext::copyFrom(MasterOptionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- MasterStringOptionContext ------------------------------------------------------------------

MySqlParser::StringMasterOptionContext* MySqlParser::MasterStringOptionContext::stringMasterOption() {
  return getRuleContext<MySqlParser::StringMasterOptionContext>(0);
}

tree::TerminalNode* MySqlParser::MasterStringOptionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::MasterStringOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

MySqlParser::MasterStringOptionContext::MasterStringOptionContext(MasterOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::MasterStringOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterStringOption(this);
}
void MySqlParser::MasterStringOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterStringOption(this);
}

std::any MySqlParser::MasterStringOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitMasterStringOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- MasterRealOptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::MasterRealOptionContext::MASTER_HEARTBEAT_PERIOD() {
  return getToken(MySqlParser::MASTER_HEARTBEAT_PERIOD, 0);
}

tree::TerminalNode* MySqlParser::MasterRealOptionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::MasterRealOptionContext::REAL_LITERAL() {
  return getToken(MySqlParser::REAL_LITERAL, 0);
}

MySqlParser::MasterRealOptionContext::MasterRealOptionContext(MasterOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::MasterRealOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterRealOption(this);
}
void MySqlParser::MasterRealOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterRealOption(this);
}

std::any MySqlParser::MasterRealOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitMasterRealOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- MasterBoolOptionContext ------------------------------------------------------------------

MySqlParser::BoolMasterOptionContext* MySqlParser::MasterBoolOptionContext::boolMasterOption() {
  return getRuleContext<MySqlParser::BoolMasterOptionContext>(0);
}

tree::TerminalNode* MySqlParser::MasterBoolOptionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::MasterBoolOptionContext::ZERO_DECIMAL() {
  return getToken(MySqlParser::ZERO_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::MasterBoolOptionContext::ONE_DECIMAL() {
  return getToken(MySqlParser::ONE_DECIMAL, 0);
}

MySqlParser::MasterBoolOptionContext::MasterBoolOptionContext(MasterOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::MasterBoolOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterBoolOption(this);
}
void MySqlParser::MasterBoolOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterBoolOption(this);
}

std::any MySqlParser::MasterBoolOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitMasterBoolOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- MasterUidListOptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::MasterUidListOptionContext::IGNORE_SERVER_IDS() {
  return getToken(MySqlParser::IGNORE_SERVER_IDS, 0);
}

tree::TerminalNode* MySqlParser::MasterUidListOptionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::MasterUidListOptionContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::MasterUidListOptionContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::MasterUidListOptionContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::MasterUidListOptionContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::MasterUidListOptionContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::MasterUidListOptionContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::MasterUidListOptionContext::MasterUidListOptionContext(MasterOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::MasterUidListOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterUidListOption(this);
}
void MySqlParser::MasterUidListOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterUidListOption(this);
}

std::any MySqlParser::MasterUidListOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitMasterUidListOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- MasterDecimalOptionContext ------------------------------------------------------------------

MySqlParser::DecimalMasterOptionContext* MySqlParser::MasterDecimalOptionContext::decimalMasterOption() {
  return getRuleContext<MySqlParser::DecimalMasterOptionContext>(0);
}

tree::TerminalNode* MySqlParser::MasterDecimalOptionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::MasterDecimalOptionContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

MySqlParser::MasterDecimalOptionContext::MasterDecimalOptionContext(MasterOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::MasterDecimalOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterDecimalOption(this);
}
void MySqlParser::MasterDecimalOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterDecimalOption(this);
}

std::any MySqlParser::MasterDecimalOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitMasterDecimalOption(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::MasterOptionContext* MySqlParser::masterOption() {
  MasterOptionContext *_localctx = _tracker.createInstance<MasterOptionContext>(_ctx, getState());
  enterRule(_localctx, 344, MySqlParser::RuleMasterOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4502);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::MASTER_BIND:
      case MySqlParser::MASTER_HOST:
      case MySqlParser::MASTER_LOG_FILE:
      case MySqlParser::MASTER_PASSWORD:
      case MySqlParser::MASTER_SSL_CA:
      case MySqlParser::MASTER_SSL_CAPATH:
      case MySqlParser::MASTER_SSL_CERT:
      case MySqlParser::MASTER_SSL_CIPHER:
      case MySqlParser::MASTER_SSL_CRL:
      case MySqlParser::MASTER_SSL_CRLPATH:
      case MySqlParser::MASTER_SSL_KEY:
      case MySqlParser::MASTER_TLS_VERSION:
      case MySqlParser::MASTER_USER:
      case MySqlParser::RELAY_LOG_FILE: {
        _localctx = _tracker.createInstance<MySqlParser::MasterStringOptionContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(4473);
        stringMasterOption();
        setState(4474);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4475);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::MASTER_CONNECT_RETRY:
      case MySqlParser::MASTER_DELAY:
      case MySqlParser::MASTER_LOG_POS:
      case MySqlParser::MASTER_PORT:
      case MySqlParser::MASTER_RETRY_COUNT:
      case MySqlParser::RELAY_LOG_POS: {
        _localctx = _tracker.createInstance<MySqlParser::MasterDecimalOptionContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(4477);
        decimalMasterOption();
        setState(4478);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4479);
        decimalLiteral();
        break;
      }

      case MySqlParser::MASTER_SSL_VERIFY_SERVER_CERT:
      case MySqlParser::MASTER_AUTO_POSITION:
      case MySqlParser::MASTER_SSL: {
        _localctx = _tracker.createInstance<MySqlParser::MasterBoolOptionContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(4481);
        boolMasterOption();
        setState(4482);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4483);
        antlrcpp::downCast<MasterBoolOptionContext *>(_localctx)->boolVal = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::ZERO_DECIMAL

        || _la == MySqlParser::ONE_DECIMAL)) {
          antlrcpp::downCast<MasterBoolOptionContext *>(_localctx)->boolVal = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySqlParser::MASTER_HEARTBEAT_PERIOD: {
        _localctx = _tracker.createInstance<MySqlParser::MasterRealOptionContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(4485);
        match(MySqlParser::MASTER_HEARTBEAT_PERIOD);
        setState(4486);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4487);
        match(MySqlParser::REAL_LITERAL);
        break;
      }

      case MySqlParser::IGNORE_SERVER_IDS: {
        _localctx = _tracker.createInstance<MySqlParser::MasterUidListOptionContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(4488);
        match(MySqlParser::IGNORE_SERVER_IDS);
        setState(4489);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4490);
        match(MySqlParser::LR_BRACKET);
        setState(4499);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
          setState(4491);
          uid();
          setState(4496);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == MySqlParser::COMMA) {
            setState(4492);
            match(MySqlParser::COMMA);
            setState(4493);
            uid();
            setState(4498);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        setState(4501);
        match(MySqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringMasterOptionContext ------------------------------------------------------------------

MySqlParser::StringMasterOptionContext::StringMasterOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::MASTER_BIND() {
  return getToken(MySqlParser::MASTER_BIND, 0);
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::MASTER_HOST() {
  return getToken(MySqlParser::MASTER_HOST, 0);
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::MASTER_USER() {
  return getToken(MySqlParser::MASTER_USER, 0);
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::MASTER_PASSWORD() {
  return getToken(MySqlParser::MASTER_PASSWORD, 0);
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::MASTER_LOG_FILE() {
  return getToken(MySqlParser::MASTER_LOG_FILE, 0);
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::RELAY_LOG_FILE() {
  return getToken(MySqlParser::RELAY_LOG_FILE, 0);
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::MASTER_SSL_CA() {
  return getToken(MySqlParser::MASTER_SSL_CA, 0);
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::MASTER_SSL_CAPATH() {
  return getToken(MySqlParser::MASTER_SSL_CAPATH, 0);
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::MASTER_SSL_CERT() {
  return getToken(MySqlParser::MASTER_SSL_CERT, 0);
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::MASTER_SSL_CRL() {
  return getToken(MySqlParser::MASTER_SSL_CRL, 0);
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::MASTER_SSL_CRLPATH() {
  return getToken(MySqlParser::MASTER_SSL_CRLPATH, 0);
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::MASTER_SSL_KEY() {
  return getToken(MySqlParser::MASTER_SSL_KEY, 0);
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::MASTER_SSL_CIPHER() {
  return getToken(MySqlParser::MASTER_SSL_CIPHER, 0);
}

tree::TerminalNode* MySqlParser::StringMasterOptionContext::MASTER_TLS_VERSION() {
  return getToken(MySqlParser::MASTER_TLS_VERSION, 0);
}


size_t MySqlParser::StringMasterOptionContext::getRuleIndex() const {
  return MySqlParser::RuleStringMasterOption;
}

void MySqlParser::StringMasterOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringMasterOption(this);
}

void MySqlParser::StringMasterOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringMasterOption(this);
}


std::any MySqlParser::StringMasterOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitStringMasterOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::StringMasterOptionContext* MySqlParser::stringMasterOption() {
  StringMasterOptionContext *_localctx = _tracker.createInstance<StringMasterOptionContext>(_ctx, getState());
  enterRule(_localctx, 346, MySqlParser::RuleStringMasterOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4504);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::MASTER_BIND || ((((_la - 482) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 482)) & 65419) != 0) || _la == MySqlParser::RELAY_LOG_FILE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecimalMasterOptionContext ------------------------------------------------------------------

MySqlParser::DecimalMasterOptionContext::DecimalMasterOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DecimalMasterOptionContext::MASTER_PORT() {
  return getToken(MySqlParser::MASTER_PORT, 0);
}

tree::TerminalNode* MySqlParser::DecimalMasterOptionContext::MASTER_CONNECT_RETRY() {
  return getToken(MySqlParser::MASTER_CONNECT_RETRY, 0);
}

tree::TerminalNode* MySqlParser::DecimalMasterOptionContext::MASTER_RETRY_COUNT() {
  return getToken(MySqlParser::MASTER_RETRY_COUNT, 0);
}

tree::TerminalNode* MySqlParser::DecimalMasterOptionContext::MASTER_DELAY() {
  return getToken(MySqlParser::MASTER_DELAY, 0);
}

tree::TerminalNode* MySqlParser::DecimalMasterOptionContext::MASTER_LOG_POS() {
  return getToken(MySqlParser::MASTER_LOG_POS, 0);
}

tree::TerminalNode* MySqlParser::DecimalMasterOptionContext::RELAY_LOG_POS() {
  return getToken(MySqlParser::RELAY_LOG_POS, 0);
}


size_t MySqlParser::DecimalMasterOptionContext::getRuleIndex() const {
  return MySqlParser::RuleDecimalMasterOption;
}

void MySqlParser::DecimalMasterOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecimalMasterOption(this);
}

void MySqlParser::DecimalMasterOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecimalMasterOption(this);
}


std::any MySqlParser::DecimalMasterOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDecimalMasterOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DecimalMasterOptionContext* MySqlParser::decimalMasterOption() {
  DecimalMasterOptionContext *_localctx = _tracker.createInstance<DecimalMasterOptionContext>(_ctx, getState());
  enterRule(_localctx, 348, MySqlParser::RuleDecimalMasterOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4506);
    _la = _input->LA(1);
    if (!(((((_la - 479) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 479)) & 419) != 0) || _la == MySqlParser::RELAY_LOG_POS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BoolMasterOptionContext ------------------------------------------------------------------

MySqlParser::BoolMasterOptionContext::BoolMasterOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::BoolMasterOptionContext::MASTER_AUTO_POSITION() {
  return getToken(MySqlParser::MASTER_AUTO_POSITION, 0);
}

tree::TerminalNode* MySqlParser::BoolMasterOptionContext::MASTER_SSL() {
  return getToken(MySqlParser::MASTER_SSL, 0);
}

tree::TerminalNode* MySqlParser::BoolMasterOptionContext::MASTER_SSL_VERIFY_SERVER_CERT() {
  return getToken(MySqlParser::MASTER_SSL_VERIFY_SERVER_CERT, 0);
}


size_t MySqlParser::BoolMasterOptionContext::getRuleIndex() const {
  return MySqlParser::RuleBoolMasterOption;
}

void MySqlParser::BoolMasterOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBoolMasterOption(this);
}

void MySqlParser::BoolMasterOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBoolMasterOption(this);
}


std::any MySqlParser::BoolMasterOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitBoolMasterOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::BoolMasterOptionContext* MySqlParser::boolMasterOption() {
  BoolMasterOptionContext *_localctx = _tracker.createInstance<BoolMasterOptionContext>(_ctx, getState());
  enterRule(_localctx, 350, MySqlParser::RuleBoolMasterOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4508);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::MASTER_SSL_VERIFY_SERVER_CERT || _la == MySqlParser::MASTER_AUTO_POSITION

    || _la == MySqlParser::MASTER_SSL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChannelOptionContext ------------------------------------------------------------------

MySqlParser::ChannelOptionContext::ChannelOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ChannelOptionContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

tree::TerminalNode* MySqlParser::ChannelOptionContext::CHANNEL() {
  return getToken(MySqlParser::CHANNEL, 0);
}

tree::TerminalNode* MySqlParser::ChannelOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}


size_t MySqlParser::ChannelOptionContext::getRuleIndex() const {
  return MySqlParser::RuleChannelOption;
}

void MySqlParser::ChannelOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChannelOption(this);
}

void MySqlParser::ChannelOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChannelOption(this);
}


std::any MySqlParser::ChannelOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitChannelOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ChannelOptionContext* MySqlParser::channelOption() {
  ChannelOptionContext *_localctx = _tracker.createInstance<ChannelOptionContext>(_ctx, getState());
  enterRule(_localctx, 352, MySqlParser::RuleChannelOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4510);
    match(MySqlParser::FOR);
    setState(4511);
    match(MySqlParser::CHANNEL);
    setState(4512);
    match(MySqlParser::STRING_LITERAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicationFilterContext ------------------------------------------------------------------

MySqlParser::ReplicationFilterContext::ReplicationFilterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::ReplicationFilterContext::getRuleIndex() const {
  return MySqlParser::RuleReplicationFilter;
}

void MySqlParser::ReplicationFilterContext::copyFrom(ReplicationFilterContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- WildIgnoreTableReplicationContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::WildIgnoreTableReplicationContext::REPLICATE_WILD_IGNORE_TABLE() {
  return getToken(MySqlParser::REPLICATE_WILD_IGNORE_TABLE, 0);
}

tree::TerminalNode* MySqlParser::WildIgnoreTableReplicationContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::WildIgnoreTableReplicationContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::SimpleStringsContext* MySqlParser::WildIgnoreTableReplicationContext::simpleStrings() {
  return getRuleContext<MySqlParser::SimpleStringsContext>(0);
}

tree::TerminalNode* MySqlParser::WildIgnoreTableReplicationContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::WildIgnoreTableReplicationContext::WildIgnoreTableReplicationContext(ReplicationFilterContext *ctx) { copyFrom(ctx); }

void MySqlParser::WildIgnoreTableReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWildIgnoreTableReplication(this);
}
void MySqlParser::WildIgnoreTableReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWildIgnoreTableReplication(this);
}

std::any MySqlParser::WildIgnoreTableReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitWildIgnoreTableReplication(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DoTableReplicationContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::DoTableReplicationContext::REPLICATE_DO_TABLE() {
  return getToken(MySqlParser::REPLICATE_DO_TABLE, 0);
}

tree::TerminalNode* MySqlParser::DoTableReplicationContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::DoTableReplicationContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::TablesContext* MySqlParser::DoTableReplicationContext::tables() {
  return getRuleContext<MySqlParser::TablesContext>(0);
}

tree::TerminalNode* MySqlParser::DoTableReplicationContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::DoTableReplicationContext::DoTableReplicationContext(ReplicationFilterContext *ctx) { copyFrom(ctx); }

void MySqlParser::DoTableReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoTableReplication(this);
}
void MySqlParser::DoTableReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoTableReplication(this);
}

std::any MySqlParser::DoTableReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDoTableReplication(this);
  else
    return visitor->visitChildren(this);
}
//----------------- IgnoreTableReplicationContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::IgnoreTableReplicationContext::REPLICATE_IGNORE_TABLE() {
  return getToken(MySqlParser::REPLICATE_IGNORE_TABLE, 0);
}

tree::TerminalNode* MySqlParser::IgnoreTableReplicationContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::IgnoreTableReplicationContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::TablesContext* MySqlParser::IgnoreTableReplicationContext::tables() {
  return getRuleContext<MySqlParser::TablesContext>(0);
}

tree::TerminalNode* MySqlParser::IgnoreTableReplicationContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::IgnoreTableReplicationContext::IgnoreTableReplicationContext(ReplicationFilterContext *ctx) { copyFrom(ctx); }

void MySqlParser::IgnoreTableReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIgnoreTableReplication(this);
}
void MySqlParser::IgnoreTableReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIgnoreTableReplication(this);
}

std::any MySqlParser::IgnoreTableReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIgnoreTableReplication(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RewriteDbReplicationContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::RewriteDbReplicationContext::REPLICATE_REWRITE_DB() {
  return getToken(MySqlParser::REPLICATE_REWRITE_DB, 0);
}

tree::TerminalNode* MySqlParser::RewriteDbReplicationContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::RewriteDbReplicationContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::TablePairContext *> MySqlParser::RewriteDbReplicationContext::tablePair() {
  return getRuleContexts<MySqlParser::TablePairContext>();
}

MySqlParser::TablePairContext* MySqlParser::RewriteDbReplicationContext::tablePair(size_t i) {
  return getRuleContext<MySqlParser::TablePairContext>(i);
}

tree::TerminalNode* MySqlParser::RewriteDbReplicationContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::RewriteDbReplicationContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::RewriteDbReplicationContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::RewriteDbReplicationContext::RewriteDbReplicationContext(ReplicationFilterContext *ctx) { copyFrom(ctx); }

void MySqlParser::RewriteDbReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRewriteDbReplication(this);
}
void MySqlParser::RewriteDbReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRewriteDbReplication(this);
}

std::any MySqlParser::RewriteDbReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRewriteDbReplication(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DoDbReplicationContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::DoDbReplicationContext::REPLICATE_DO_DB() {
  return getToken(MySqlParser::REPLICATE_DO_DB, 0);
}

tree::TerminalNode* MySqlParser::DoDbReplicationContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::DoDbReplicationContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::UidListContext* MySqlParser::DoDbReplicationContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::DoDbReplicationContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::DoDbReplicationContext::DoDbReplicationContext(ReplicationFilterContext *ctx) { copyFrom(ctx); }

void MySqlParser::DoDbReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoDbReplication(this);
}
void MySqlParser::DoDbReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoDbReplication(this);
}

std::any MySqlParser::DoDbReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDoDbReplication(this);
  else
    return visitor->visitChildren(this);
}
//----------------- IgnoreDbReplicationContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::IgnoreDbReplicationContext::REPLICATE_IGNORE_DB() {
  return getToken(MySqlParser::REPLICATE_IGNORE_DB, 0);
}

tree::TerminalNode* MySqlParser::IgnoreDbReplicationContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::IgnoreDbReplicationContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::UidListContext* MySqlParser::IgnoreDbReplicationContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::IgnoreDbReplicationContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::IgnoreDbReplicationContext::IgnoreDbReplicationContext(ReplicationFilterContext *ctx) { copyFrom(ctx); }

void MySqlParser::IgnoreDbReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIgnoreDbReplication(this);
}
void MySqlParser::IgnoreDbReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIgnoreDbReplication(this);
}

std::any MySqlParser::IgnoreDbReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIgnoreDbReplication(this);
  else
    return visitor->visitChildren(this);
}
//----------------- WildDoTableReplicationContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::WildDoTableReplicationContext::REPLICATE_WILD_DO_TABLE() {
  return getToken(MySqlParser::REPLICATE_WILD_DO_TABLE, 0);
}

tree::TerminalNode* MySqlParser::WildDoTableReplicationContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::WildDoTableReplicationContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::SimpleStringsContext* MySqlParser::WildDoTableReplicationContext::simpleStrings() {
  return getRuleContext<MySqlParser::SimpleStringsContext>(0);
}

tree::TerminalNode* MySqlParser::WildDoTableReplicationContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::WildDoTableReplicationContext::WildDoTableReplicationContext(ReplicationFilterContext *ctx) { copyFrom(ctx); }

void MySqlParser::WildDoTableReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWildDoTableReplication(this);
}
void MySqlParser::WildDoTableReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWildDoTableReplication(this);
}

std::any MySqlParser::WildDoTableReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitWildDoTableReplication(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::ReplicationFilterContext* MySqlParser::replicationFilter() {
  ReplicationFilterContext *_localctx = _tracker.createInstance<ReplicationFilterContext>(_ctx, getState());
  enterRule(_localctx, 354, MySqlParser::RuleReplicationFilter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4563);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::REPLICATE_DO_DB: {
        _localctx = _tracker.createInstance<MySqlParser::DoDbReplicationContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(4514);
        match(MySqlParser::REPLICATE_DO_DB);
        setState(4515);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4516);
        match(MySqlParser::LR_BRACKET);
        setState(4517);
        uidList();
        setState(4518);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      case MySqlParser::REPLICATE_IGNORE_DB: {
        _localctx = _tracker.createInstance<MySqlParser::IgnoreDbReplicationContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(4520);
        match(MySqlParser::REPLICATE_IGNORE_DB);
        setState(4521);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4522);
        match(MySqlParser::LR_BRACKET);
        setState(4523);
        uidList();
        setState(4524);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      case MySqlParser::REPLICATE_DO_TABLE: {
        _localctx = _tracker.createInstance<MySqlParser::DoTableReplicationContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(4526);
        match(MySqlParser::REPLICATE_DO_TABLE);
        setState(4527);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4528);
        match(MySqlParser::LR_BRACKET);
        setState(4529);
        tables();
        setState(4530);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      case MySqlParser::REPLICATE_IGNORE_TABLE: {
        _localctx = _tracker.createInstance<MySqlParser::IgnoreTableReplicationContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(4532);
        match(MySqlParser::REPLICATE_IGNORE_TABLE);
        setState(4533);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4534);
        match(MySqlParser::LR_BRACKET);
        setState(4535);
        tables();
        setState(4536);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      case MySqlParser::REPLICATE_WILD_DO_TABLE: {
        _localctx = _tracker.createInstance<MySqlParser::WildDoTableReplicationContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(4538);
        match(MySqlParser::REPLICATE_WILD_DO_TABLE);
        setState(4539);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4540);
        match(MySqlParser::LR_BRACKET);
        setState(4541);
        simpleStrings();
        setState(4542);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      case MySqlParser::REPLICATE_WILD_IGNORE_TABLE: {
        _localctx = _tracker.createInstance<MySqlParser::WildIgnoreTableReplicationContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(4544);
        match(MySqlParser::REPLICATE_WILD_IGNORE_TABLE);
        setState(4545);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4546);
        match(MySqlParser::LR_BRACKET);
        setState(4547);
        simpleStrings();
        setState(4548);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      case MySqlParser::REPLICATE_REWRITE_DB: {
        _localctx = _tracker.createInstance<MySqlParser::RewriteDbReplicationContext>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(4550);
        match(MySqlParser::REPLICATE_REWRITE_DB);
        setState(4551);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4552);
        match(MySqlParser::LR_BRACKET);
        setState(4553);
        tablePair();
        setState(4558);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(4554);
          match(MySqlParser::COMMA);
          setState(4555);
          tablePair();
          setState(4560);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(4561);
        match(MySqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablePairContext ------------------------------------------------------------------

MySqlParser::TablePairContext::TablePairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::TablePairContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::TablePairContext::COMMA() {
  return getToken(MySqlParser::COMMA, 0);
}

tree::TerminalNode* MySqlParser::TablePairContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<MySqlParser::TableNameContext *> MySqlParser::TablePairContext::tableName() {
  return getRuleContexts<MySqlParser::TableNameContext>();
}

MySqlParser::TableNameContext* MySqlParser::TablePairContext::tableName(size_t i) {
  return getRuleContext<MySqlParser::TableNameContext>(i);
}


size_t MySqlParser::TablePairContext::getRuleIndex() const {
  return MySqlParser::RuleTablePair;
}

void MySqlParser::TablePairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablePair(this);
}

void MySqlParser::TablePairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablePair(this);
}


std::any MySqlParser::TablePairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTablePair(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TablePairContext* MySqlParser::tablePair() {
  TablePairContext *_localctx = _tracker.createInstance<TablePairContext>(_ctx, getState());
  enterRule(_localctx, 356, MySqlParser::RuleTablePair);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4565);
    match(MySqlParser::LR_BRACKET);
    setState(4566);
    antlrcpp::downCast<TablePairContext *>(_localctx)->firstTable = tableName();
    setState(4567);
    match(MySqlParser::COMMA);
    setState(4568);
    antlrcpp::downCast<TablePairContext *>(_localctx)->secondTable = tableName();
    setState(4569);
    match(MySqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThreadTypeContext ------------------------------------------------------------------

MySqlParser::ThreadTypeContext::ThreadTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ThreadTypeContext::IO_THREAD() {
  return getToken(MySqlParser::IO_THREAD, 0);
}

tree::TerminalNode* MySqlParser::ThreadTypeContext::SQL_THREAD() {
  return getToken(MySqlParser::SQL_THREAD, 0);
}


size_t MySqlParser::ThreadTypeContext::getRuleIndex() const {
  return MySqlParser::RuleThreadType;
}

void MySqlParser::ThreadTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThreadType(this);
}

void MySqlParser::ThreadTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThreadType(this);
}


std::any MySqlParser::ThreadTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitThreadType(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ThreadTypeContext* MySqlParser::threadType() {
  ThreadTypeContext *_localctx = _tracker.createInstance<ThreadTypeContext>(_ctx, getState());
  enterRule(_localctx, 358, MySqlParser::RuleThreadType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4571);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::IO_THREAD || _la == MySqlParser::SQL_THREAD)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UntilOptionContext ------------------------------------------------------------------

MySqlParser::UntilOptionContext::UntilOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::UntilOptionContext::getRuleIndex() const {
  return MySqlParser::RuleUntilOption;
}

void MySqlParser::UntilOptionContext::copyFrom(UntilOptionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- GtidsUntilOptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::GtidsUntilOptionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::GtuidSetContext* MySqlParser::GtidsUntilOptionContext::gtuidSet() {
  return getRuleContext<MySqlParser::GtuidSetContext>(0);
}

tree::TerminalNode* MySqlParser::GtidsUntilOptionContext::SQL_BEFORE_GTIDS() {
  return getToken(MySqlParser::SQL_BEFORE_GTIDS, 0);
}

tree::TerminalNode* MySqlParser::GtidsUntilOptionContext::SQL_AFTER_GTIDS() {
  return getToken(MySqlParser::SQL_AFTER_GTIDS, 0);
}

MySqlParser::GtidsUntilOptionContext::GtidsUntilOptionContext(UntilOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::GtidsUntilOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGtidsUntilOption(this);
}
void MySqlParser::GtidsUntilOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGtidsUntilOption(this);
}

std::any MySqlParser::GtidsUntilOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitGtidsUntilOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SqlGapsUntilOptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SqlGapsUntilOptionContext::SQL_AFTER_MTS_GAPS() {
  return getToken(MySqlParser::SQL_AFTER_MTS_GAPS, 0);
}

MySqlParser::SqlGapsUntilOptionContext::SqlGapsUntilOptionContext(UntilOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::SqlGapsUntilOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSqlGapsUntilOption(this);
}
void MySqlParser::SqlGapsUntilOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSqlGapsUntilOption(this);
}

std::any MySqlParser::SqlGapsUntilOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSqlGapsUntilOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- MasterLogUntilOptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::MasterLogUntilOptionContext::MASTER_LOG_FILE() {
  return getToken(MySqlParser::MASTER_LOG_FILE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::MasterLogUntilOptionContext::EQUAL_SYMBOL() {
  return getTokens(MySqlParser::EQUAL_SYMBOL);
}

tree::TerminalNode* MySqlParser::MasterLogUntilOptionContext::EQUAL_SYMBOL(size_t i) {
  return getToken(MySqlParser::EQUAL_SYMBOL, i);
}

tree::TerminalNode* MySqlParser::MasterLogUntilOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::MasterLogUntilOptionContext::COMMA() {
  return getToken(MySqlParser::COMMA, 0);
}

tree::TerminalNode* MySqlParser::MasterLogUntilOptionContext::MASTER_LOG_POS() {
  return getToken(MySqlParser::MASTER_LOG_POS, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::MasterLogUntilOptionContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

MySqlParser::MasterLogUntilOptionContext::MasterLogUntilOptionContext(UntilOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::MasterLogUntilOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterLogUntilOption(this);
}
void MySqlParser::MasterLogUntilOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterLogUntilOption(this);
}

std::any MySqlParser::MasterLogUntilOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitMasterLogUntilOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RelayLogUntilOptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::RelayLogUntilOptionContext::RELAY_LOG_FILE() {
  return getToken(MySqlParser::RELAY_LOG_FILE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::RelayLogUntilOptionContext::EQUAL_SYMBOL() {
  return getTokens(MySqlParser::EQUAL_SYMBOL);
}

tree::TerminalNode* MySqlParser::RelayLogUntilOptionContext::EQUAL_SYMBOL(size_t i) {
  return getToken(MySqlParser::EQUAL_SYMBOL, i);
}

tree::TerminalNode* MySqlParser::RelayLogUntilOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::RelayLogUntilOptionContext::COMMA() {
  return getToken(MySqlParser::COMMA, 0);
}

tree::TerminalNode* MySqlParser::RelayLogUntilOptionContext::RELAY_LOG_POS() {
  return getToken(MySqlParser::RELAY_LOG_POS, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::RelayLogUntilOptionContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

MySqlParser::RelayLogUntilOptionContext::RelayLogUntilOptionContext(UntilOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::RelayLogUntilOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelayLogUntilOption(this);
}
void MySqlParser::RelayLogUntilOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelayLogUntilOption(this);
}

std::any MySqlParser::RelayLogUntilOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRelayLogUntilOption(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::UntilOptionContext* MySqlParser::untilOption() {
  UntilOptionContext *_localctx = _tracker.createInstance<UntilOptionContext>(_ctx, getState());
  enterRule(_localctx, 360, MySqlParser::RuleUntilOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4591);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::SQL_AFTER_GTIDS:
      case MySqlParser::SQL_BEFORE_GTIDS: {
        _localctx = _tracker.createInstance<MySqlParser::GtidsUntilOptionContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(4573);
        antlrcpp::downCast<GtidsUntilOptionContext *>(_localctx)->gtids = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::SQL_AFTER_GTIDS

        || _la == MySqlParser::SQL_BEFORE_GTIDS)) {
          antlrcpp::downCast<GtidsUntilOptionContext *>(_localctx)->gtids = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4574);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4575);
        gtuidSet();
        break;
      }

      case MySqlParser::MASTER_LOG_FILE: {
        _localctx = _tracker.createInstance<MySqlParser::MasterLogUntilOptionContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(4576);
        match(MySqlParser::MASTER_LOG_FILE);
        setState(4577);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4578);
        match(MySqlParser::STRING_LITERAL);
        setState(4579);
        match(MySqlParser::COMMA);
        setState(4580);
        match(MySqlParser::MASTER_LOG_POS);
        setState(4581);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4582);
        decimalLiteral();
        break;
      }

      case MySqlParser::RELAY_LOG_FILE: {
        _localctx = _tracker.createInstance<MySqlParser::RelayLogUntilOptionContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(4583);
        match(MySqlParser::RELAY_LOG_FILE);
        setState(4584);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4585);
        match(MySqlParser::STRING_LITERAL);
        setState(4586);
        match(MySqlParser::COMMA);
        setState(4587);
        match(MySqlParser::RELAY_LOG_POS);
        setState(4588);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4589);
        decimalLiteral();
        break;
      }

      case MySqlParser::SQL_AFTER_MTS_GAPS: {
        _localctx = _tracker.createInstance<MySqlParser::SqlGapsUntilOptionContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(4590);
        match(MySqlParser::SQL_AFTER_MTS_GAPS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConnectionOptionContext ------------------------------------------------------------------

MySqlParser::ConnectionOptionContext::ConnectionOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::ConnectionOptionContext::getRuleIndex() const {
  return MySqlParser::RuleConnectionOption;
}

void MySqlParser::ConnectionOptionContext::copyFrom(ConnectionOptionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PluginDirConnectionOptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PluginDirConnectionOptionContext::PLUGIN_DIR() {
  return getToken(MySqlParser::PLUGIN_DIR, 0);
}

tree::TerminalNode* MySqlParser::PluginDirConnectionOptionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::PluginDirConnectionOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

MySqlParser::PluginDirConnectionOptionContext::PluginDirConnectionOptionContext(ConnectionOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PluginDirConnectionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPluginDirConnectionOption(this);
}
void MySqlParser::PluginDirConnectionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPluginDirConnectionOption(this);
}

std::any MySqlParser::PluginDirConnectionOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPluginDirConnectionOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- UserConnectionOptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::UserConnectionOptionContext::USER() {
  return getToken(MySqlParser::USER, 0);
}

tree::TerminalNode* MySqlParser::UserConnectionOptionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::UserConnectionOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

MySqlParser::UserConnectionOptionContext::UserConnectionOptionContext(ConnectionOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::UserConnectionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserConnectionOption(this);
}
void MySqlParser::UserConnectionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserConnectionOption(this);
}

std::any MySqlParser::UserConnectionOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUserConnectionOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DefaultAuthConnectionOptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::DefaultAuthConnectionOptionContext::DEFAULT_AUTH() {
  return getToken(MySqlParser::DEFAULT_AUTH, 0);
}

tree::TerminalNode* MySqlParser::DefaultAuthConnectionOptionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::DefaultAuthConnectionOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

MySqlParser::DefaultAuthConnectionOptionContext::DefaultAuthConnectionOptionContext(ConnectionOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::DefaultAuthConnectionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultAuthConnectionOption(this);
}
void MySqlParser::DefaultAuthConnectionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultAuthConnectionOption(this);
}

std::any MySqlParser::DefaultAuthConnectionOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDefaultAuthConnectionOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PasswordConnectionOptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PasswordConnectionOptionContext::PASSWORD() {
  return getToken(MySqlParser::PASSWORD, 0);
}

tree::TerminalNode* MySqlParser::PasswordConnectionOptionContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::PasswordConnectionOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

MySqlParser::PasswordConnectionOptionContext::PasswordConnectionOptionContext(ConnectionOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PasswordConnectionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPasswordConnectionOption(this);
}
void MySqlParser::PasswordConnectionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPasswordConnectionOption(this);
}

std::any MySqlParser::PasswordConnectionOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPasswordConnectionOption(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::ConnectionOptionContext* MySqlParser::connectionOption() {
  ConnectionOptionContext *_localctx = _tracker.createInstance<ConnectionOptionContext>(_ctx, getState());
  enterRule(_localctx, 362, MySqlParser::RuleConnectionOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4605);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::USER: {
        _localctx = _tracker.createInstance<MySqlParser::UserConnectionOptionContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(4593);
        match(MySqlParser::USER);
        setState(4594);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4595);
        antlrcpp::downCast<UserConnectionOptionContext *>(_localctx)->conOptUser = match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::PASSWORD: {
        _localctx = _tracker.createInstance<MySqlParser::PasswordConnectionOptionContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(4596);
        match(MySqlParser::PASSWORD);
        setState(4597);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4598);
        antlrcpp::downCast<PasswordConnectionOptionContext *>(_localctx)->conOptPassword = match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::DEFAULT_AUTH: {
        _localctx = _tracker.createInstance<MySqlParser::DefaultAuthConnectionOptionContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(4599);
        match(MySqlParser::DEFAULT_AUTH);
        setState(4600);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4601);
        antlrcpp::downCast<DefaultAuthConnectionOptionContext *>(_localctx)->conOptDefAuth = match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::PLUGIN_DIR: {
        _localctx = _tracker.createInstance<MySqlParser::PluginDirConnectionOptionContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(4602);
        match(MySqlParser::PLUGIN_DIR);
        setState(4603);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(4604);
        antlrcpp::downCast<PluginDirConnectionOptionContext *>(_localctx)->conOptPluginDir = match(MySqlParser::STRING_LITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GtuidSetContext ------------------------------------------------------------------

MySqlParser::GtuidSetContext::GtuidSetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::UuidSetContext *> MySqlParser::GtuidSetContext::uuidSet() {
  return getRuleContexts<MySqlParser::UuidSetContext>();
}

MySqlParser::UuidSetContext* MySqlParser::GtuidSetContext::uuidSet(size_t i) {
  return getRuleContext<MySqlParser::UuidSetContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::GtuidSetContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::GtuidSetContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::GtuidSetContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}


size_t MySqlParser::GtuidSetContext::getRuleIndex() const {
  return MySqlParser::RuleGtuidSet;
}

void MySqlParser::GtuidSetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGtuidSet(this);
}

void MySqlParser::GtuidSetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGtuidSet(this);
}


std::any MySqlParser::GtuidSetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitGtuidSet(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::GtuidSetContext* MySqlParser::gtuidSet() {
  GtuidSetContext *_localctx = _tracker.createInstance<GtuidSetContext>(_ctx, getState());
  enterRule(_localctx, 364, MySqlParser::RuleGtuidSet);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4616);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::ZERO_DECIMAL:
      case MySqlParser::ONE_DECIMAL:
      case MySqlParser::TWO_DECIMAL:
      case MySqlParser::DECIMAL_LITERAL:
      case MySqlParser::REAL_LITERAL: {
        enterOuterAlt(_localctx, 1);
        setState(4607);
        uuidSet();
        setState(4612);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(4608);
          match(MySqlParser::COMMA);
          setState(4609);
          uuidSet();
          setState(4614);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySqlParser::STRING_LITERAL: {
        enterOuterAlt(_localctx, 2);
        setState(4615);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XaStartTransactionContext ------------------------------------------------------------------

MySqlParser::XaStartTransactionContext::XaStartTransactionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::XaStartTransactionContext::XA() {
  return getToken(MySqlParser::XA, 0);
}

MySqlParser::XidContext* MySqlParser::XaStartTransactionContext::xid() {
  return getRuleContext<MySqlParser::XidContext>(0);
}

tree::TerminalNode* MySqlParser::XaStartTransactionContext::START() {
  return getToken(MySqlParser::START, 0);
}

tree::TerminalNode* MySqlParser::XaStartTransactionContext::BEGIN() {
  return getToken(MySqlParser::BEGIN, 0);
}

tree::TerminalNode* MySqlParser::XaStartTransactionContext::JOIN() {
  return getToken(MySqlParser::JOIN, 0);
}

tree::TerminalNode* MySqlParser::XaStartTransactionContext::RESUME() {
  return getToken(MySqlParser::RESUME, 0);
}


size_t MySqlParser::XaStartTransactionContext::getRuleIndex() const {
  return MySqlParser::RuleXaStartTransaction;
}

void MySqlParser::XaStartTransactionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXaStartTransaction(this);
}

void MySqlParser::XaStartTransactionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXaStartTransaction(this);
}


std::any MySqlParser::XaStartTransactionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitXaStartTransaction(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::XaStartTransactionContext* MySqlParser::xaStartTransaction() {
  XaStartTransactionContext *_localctx = _tracker.createInstance<XaStartTransactionContext>(_ctx, getState());
  enterRule(_localctx, 366, MySqlParser::RuleXaStartTransaction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4618);
    match(MySqlParser::XA);
    setState(4619);
    antlrcpp::downCast<XaStartTransactionContext *>(_localctx)->xaStart = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::BEGIN || _la == MySqlParser::START)) {
      antlrcpp::downCast<XaStartTransactionContext *>(_localctx)->xaStart = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4620);
    xid();
    setState(4622);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::JOIN || _la == MySqlParser::RESUME) {
      setState(4621);
      antlrcpp::downCast<XaStartTransactionContext *>(_localctx)->xaAction = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::JOIN || _la == MySqlParser::RESUME)) {
        antlrcpp::downCast<XaStartTransactionContext *>(_localctx)->xaAction = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XaEndTransactionContext ------------------------------------------------------------------

MySqlParser::XaEndTransactionContext::XaEndTransactionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::XaEndTransactionContext::XA() {
  return getToken(MySqlParser::XA, 0);
}

tree::TerminalNode* MySqlParser::XaEndTransactionContext::END() {
  return getToken(MySqlParser::END, 0);
}

MySqlParser::XidContext* MySqlParser::XaEndTransactionContext::xid() {
  return getRuleContext<MySqlParser::XidContext>(0);
}

tree::TerminalNode* MySqlParser::XaEndTransactionContext::SUSPEND() {
  return getToken(MySqlParser::SUSPEND, 0);
}

tree::TerminalNode* MySqlParser::XaEndTransactionContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

tree::TerminalNode* MySqlParser::XaEndTransactionContext::MIGRATE() {
  return getToken(MySqlParser::MIGRATE, 0);
}


size_t MySqlParser::XaEndTransactionContext::getRuleIndex() const {
  return MySqlParser::RuleXaEndTransaction;
}

void MySqlParser::XaEndTransactionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXaEndTransaction(this);
}

void MySqlParser::XaEndTransactionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXaEndTransaction(this);
}


std::any MySqlParser::XaEndTransactionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitXaEndTransaction(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::XaEndTransactionContext* MySqlParser::xaEndTransaction() {
  XaEndTransactionContext *_localctx = _tracker.createInstance<XaEndTransactionContext>(_ctx, getState());
  enterRule(_localctx, 368, MySqlParser::RuleXaEndTransaction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4624);
    match(MySqlParser::XA);
    setState(4625);
    match(MySqlParser::END);
    setState(4626);
    xid();
    setState(4632);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::SUSPEND) {
      setState(4627);
      match(MySqlParser::SUSPEND);
      setState(4630);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::FOR) {
        setState(4628);
        match(MySqlParser::FOR);
        setState(4629);
        match(MySqlParser::MIGRATE);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XaPrepareStatementContext ------------------------------------------------------------------

MySqlParser::XaPrepareStatementContext::XaPrepareStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::XaPrepareStatementContext::XA() {
  return getToken(MySqlParser::XA, 0);
}

tree::TerminalNode* MySqlParser::XaPrepareStatementContext::PREPARE() {
  return getToken(MySqlParser::PREPARE, 0);
}

MySqlParser::XidContext* MySqlParser::XaPrepareStatementContext::xid() {
  return getRuleContext<MySqlParser::XidContext>(0);
}


size_t MySqlParser::XaPrepareStatementContext::getRuleIndex() const {
  return MySqlParser::RuleXaPrepareStatement;
}

void MySqlParser::XaPrepareStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXaPrepareStatement(this);
}

void MySqlParser::XaPrepareStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXaPrepareStatement(this);
}


std::any MySqlParser::XaPrepareStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitXaPrepareStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::XaPrepareStatementContext* MySqlParser::xaPrepareStatement() {
  XaPrepareStatementContext *_localctx = _tracker.createInstance<XaPrepareStatementContext>(_ctx, getState());
  enterRule(_localctx, 370, MySqlParser::RuleXaPrepareStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4634);
    match(MySqlParser::XA);
    setState(4635);
    match(MySqlParser::PREPARE);
    setState(4636);
    xid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XaCommitWorkContext ------------------------------------------------------------------

MySqlParser::XaCommitWorkContext::XaCommitWorkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::XaCommitWorkContext::XA() {
  return getToken(MySqlParser::XA, 0);
}

tree::TerminalNode* MySqlParser::XaCommitWorkContext::COMMIT() {
  return getToken(MySqlParser::COMMIT, 0);
}

MySqlParser::XidContext* MySqlParser::XaCommitWorkContext::xid() {
  return getRuleContext<MySqlParser::XidContext>(0);
}

tree::TerminalNode* MySqlParser::XaCommitWorkContext::ONE() {
  return getToken(MySqlParser::ONE, 0);
}

tree::TerminalNode* MySqlParser::XaCommitWorkContext::PHASE() {
  return getToken(MySqlParser::PHASE, 0);
}


size_t MySqlParser::XaCommitWorkContext::getRuleIndex() const {
  return MySqlParser::RuleXaCommitWork;
}

void MySqlParser::XaCommitWorkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXaCommitWork(this);
}

void MySqlParser::XaCommitWorkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXaCommitWork(this);
}


std::any MySqlParser::XaCommitWorkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitXaCommitWork(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::XaCommitWorkContext* MySqlParser::xaCommitWork() {
  XaCommitWorkContext *_localctx = _tracker.createInstance<XaCommitWorkContext>(_ctx, getState());
  enterRule(_localctx, 372, MySqlParser::RuleXaCommitWork);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4638);
    match(MySqlParser::XA);
    setState(4639);
    match(MySqlParser::COMMIT);
    setState(4640);
    xid();
    setState(4643);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ONE) {
      setState(4641);
      match(MySqlParser::ONE);
      setState(4642);
      match(MySqlParser::PHASE);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XaRollbackWorkContext ------------------------------------------------------------------

MySqlParser::XaRollbackWorkContext::XaRollbackWorkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::XaRollbackWorkContext::XA() {
  return getToken(MySqlParser::XA, 0);
}

tree::TerminalNode* MySqlParser::XaRollbackWorkContext::ROLLBACK() {
  return getToken(MySqlParser::ROLLBACK, 0);
}

MySqlParser::XidContext* MySqlParser::XaRollbackWorkContext::xid() {
  return getRuleContext<MySqlParser::XidContext>(0);
}


size_t MySqlParser::XaRollbackWorkContext::getRuleIndex() const {
  return MySqlParser::RuleXaRollbackWork;
}

void MySqlParser::XaRollbackWorkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXaRollbackWork(this);
}

void MySqlParser::XaRollbackWorkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXaRollbackWork(this);
}


std::any MySqlParser::XaRollbackWorkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitXaRollbackWork(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::XaRollbackWorkContext* MySqlParser::xaRollbackWork() {
  XaRollbackWorkContext *_localctx = _tracker.createInstance<XaRollbackWorkContext>(_ctx, getState());
  enterRule(_localctx, 374, MySqlParser::RuleXaRollbackWork);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4645);
    match(MySqlParser::XA);
    setState(4646);
    match(MySqlParser::ROLLBACK);
    setState(4647);
    xid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XaRecoverWorkContext ------------------------------------------------------------------

MySqlParser::XaRecoverWorkContext::XaRecoverWorkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::XaRecoverWorkContext::XA() {
  return getToken(MySqlParser::XA, 0);
}

tree::TerminalNode* MySqlParser::XaRecoverWorkContext::RECOVER() {
  return getToken(MySqlParser::RECOVER, 0);
}

tree::TerminalNode* MySqlParser::XaRecoverWorkContext::CONVERT() {
  return getToken(MySqlParser::CONVERT, 0);
}

MySqlParser::XidContext* MySqlParser::XaRecoverWorkContext::xid() {
  return getRuleContext<MySqlParser::XidContext>(0);
}


size_t MySqlParser::XaRecoverWorkContext::getRuleIndex() const {
  return MySqlParser::RuleXaRecoverWork;
}

void MySqlParser::XaRecoverWorkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXaRecoverWork(this);
}

void MySqlParser::XaRecoverWorkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXaRecoverWork(this);
}


std::any MySqlParser::XaRecoverWorkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitXaRecoverWork(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::XaRecoverWorkContext* MySqlParser::xaRecoverWork() {
  XaRecoverWorkContext *_localctx = _tracker.createInstance<XaRecoverWorkContext>(_ctx, getState());
  enterRule(_localctx, 376, MySqlParser::RuleXaRecoverWork);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4649);
    match(MySqlParser::XA);
    setState(4650);
    match(MySqlParser::RECOVER);
    setState(4653);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::CONVERT) {
      setState(4651);
      match(MySqlParser::CONVERT);
      setState(4652);
      xid();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrepareStatementContext ------------------------------------------------------------------

MySqlParser::PrepareStatementContext::PrepareStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::PrepareStatementContext::PREPARE() {
  return getToken(MySqlParser::PREPARE, 0);
}

MySqlParser::UidContext* MySqlParser::PrepareStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::PrepareStatementContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

tree::TerminalNode* MySqlParser::PrepareStatementContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::PrepareStatementContext::LOCAL_ID() {
  return getToken(MySqlParser::LOCAL_ID, 0);
}


size_t MySqlParser::PrepareStatementContext::getRuleIndex() const {
  return MySqlParser::RulePrepareStatement;
}

void MySqlParser::PrepareStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrepareStatement(this);
}

void MySqlParser::PrepareStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrepareStatement(this);
}


std::any MySqlParser::PrepareStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPrepareStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::PrepareStatementContext* MySqlParser::prepareStatement() {
  PrepareStatementContext *_localctx = _tracker.createInstance<PrepareStatementContext>(_ctx, getState());
  enterRule(_localctx, 378, MySqlParser::RulePrepareStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4655);
    match(MySqlParser::PREPARE);
    setState(4656);
    uid();
    setState(4657);
    match(MySqlParser::FROM);
    setState(4660);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::STRING_LITERAL: {
        setState(4658);
        antlrcpp::downCast<PrepareStatementContext *>(_localctx)->query = match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::LOCAL_ID: {
        setState(4659);
        antlrcpp::downCast<PrepareStatementContext *>(_localctx)->variable = match(MySqlParser::LOCAL_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExecuteStatementContext ------------------------------------------------------------------

MySqlParser::ExecuteStatementContext::ExecuteStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ExecuteStatementContext::EXECUTE() {
  return getToken(MySqlParser::EXECUTE, 0);
}

MySqlParser::UidContext* MySqlParser::ExecuteStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::ExecuteStatementContext::USING() {
  return getToken(MySqlParser::USING, 0);
}

MySqlParser::UserVariablesContext* MySqlParser::ExecuteStatementContext::userVariables() {
  return getRuleContext<MySqlParser::UserVariablesContext>(0);
}


size_t MySqlParser::ExecuteStatementContext::getRuleIndex() const {
  return MySqlParser::RuleExecuteStatement;
}

void MySqlParser::ExecuteStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecuteStatement(this);
}

void MySqlParser::ExecuteStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecuteStatement(this);
}


std::any MySqlParser::ExecuteStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitExecuteStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ExecuteStatementContext* MySqlParser::executeStatement() {
  ExecuteStatementContext *_localctx = _tracker.createInstance<ExecuteStatementContext>(_ctx, getState());
  enterRule(_localctx, 380, MySqlParser::RuleExecuteStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4662);
    match(MySqlParser::EXECUTE);
    setState(4663);
    uid();
    setState(4666);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::USING) {
      setState(4664);
      match(MySqlParser::USING);
      setState(4665);
      userVariables();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeallocatePrepareContext ------------------------------------------------------------------

MySqlParser::DeallocatePrepareContext::DeallocatePrepareContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DeallocatePrepareContext::PREPARE() {
  return getToken(MySqlParser::PREPARE, 0);
}

MySqlParser::UidContext* MySqlParser::DeallocatePrepareContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::DeallocatePrepareContext::DEALLOCATE() {
  return getToken(MySqlParser::DEALLOCATE, 0);
}

tree::TerminalNode* MySqlParser::DeallocatePrepareContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}


size_t MySqlParser::DeallocatePrepareContext::getRuleIndex() const {
  return MySqlParser::RuleDeallocatePrepare;
}

void MySqlParser::DeallocatePrepareContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeallocatePrepare(this);
}

void MySqlParser::DeallocatePrepareContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeallocatePrepare(this);
}


std::any MySqlParser::DeallocatePrepareContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDeallocatePrepare(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DeallocatePrepareContext* MySqlParser::deallocatePrepare() {
  DeallocatePrepareContext *_localctx = _tracker.createInstance<DeallocatePrepareContext>(_ctx, getState());
  enterRule(_localctx, 382, MySqlParser::RuleDeallocatePrepare);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4668);
    antlrcpp::downCast<DeallocatePrepareContext *>(_localctx)->dropFormat = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::DROP || _la == MySqlParser::DEALLOCATE)) {
      antlrcpp::downCast<DeallocatePrepareContext *>(_localctx)->dropFormat = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4669);
    match(MySqlParser::PREPARE);
    setState(4670);
    uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineBodyContext ------------------------------------------------------------------

MySqlParser::RoutineBodyContext::RoutineBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::BlockStatementContext* MySqlParser::RoutineBodyContext::blockStatement() {
  return getRuleContext<MySqlParser::BlockStatementContext>(0);
}

MySqlParser::SqlStatementContext* MySqlParser::RoutineBodyContext::sqlStatement() {
  return getRuleContext<MySqlParser::SqlStatementContext>(0);
}


size_t MySqlParser::RoutineBodyContext::getRuleIndex() const {
  return MySqlParser::RuleRoutineBody;
}

void MySqlParser::RoutineBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineBody(this);
}

void MySqlParser::RoutineBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineBody(this);
}


std::any MySqlParser::RoutineBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRoutineBody(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::RoutineBodyContext* MySqlParser::routineBody() {
  RoutineBodyContext *_localctx = _tracker.createInstance<RoutineBodyContext>(_ctx, getState());
  enterRule(_localctx, 384, MySqlParser::RuleRoutineBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4674);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 677, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4672);
      blockStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4673);
      sqlStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockStatementContext ------------------------------------------------------------------

MySqlParser::BlockStatementContext::BlockStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::BlockStatementContext::BEGIN() {
  return getToken(MySqlParser::BEGIN, 0);
}

tree::TerminalNode* MySqlParser::BlockStatementContext::END() {
  return getToken(MySqlParser::END, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::BlockStatementContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::BlockStatementContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

tree::TerminalNode* MySqlParser::BlockStatementContext::COLON_SYMB() {
  return getToken(MySqlParser::COLON_SYMB, 0);
}

std::vector<MySqlParser::DeclareVariableContext *> MySqlParser::BlockStatementContext::declareVariable() {
  return getRuleContexts<MySqlParser::DeclareVariableContext>();
}

MySqlParser::DeclareVariableContext* MySqlParser::BlockStatementContext::declareVariable(size_t i) {
  return getRuleContext<MySqlParser::DeclareVariableContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::BlockStatementContext::SEMI() {
  return getTokens(MySqlParser::SEMI);
}

tree::TerminalNode* MySqlParser::BlockStatementContext::SEMI(size_t i) {
  return getToken(MySqlParser::SEMI, i);
}

std::vector<MySqlParser::DeclareConditionContext *> MySqlParser::BlockStatementContext::declareCondition() {
  return getRuleContexts<MySqlParser::DeclareConditionContext>();
}

MySqlParser::DeclareConditionContext* MySqlParser::BlockStatementContext::declareCondition(size_t i) {
  return getRuleContext<MySqlParser::DeclareConditionContext>(i);
}

std::vector<MySqlParser::DeclareCursorContext *> MySqlParser::BlockStatementContext::declareCursor() {
  return getRuleContexts<MySqlParser::DeclareCursorContext>();
}

MySqlParser::DeclareCursorContext* MySqlParser::BlockStatementContext::declareCursor(size_t i) {
  return getRuleContext<MySqlParser::DeclareCursorContext>(i);
}

std::vector<MySqlParser::DeclareHandlerContext *> MySqlParser::BlockStatementContext::declareHandler() {
  return getRuleContexts<MySqlParser::DeclareHandlerContext>();
}

MySqlParser::DeclareHandlerContext* MySqlParser::BlockStatementContext::declareHandler(size_t i) {
  return getRuleContext<MySqlParser::DeclareHandlerContext>(i);
}

std::vector<MySqlParser::ProcedureSqlStatementContext *> MySqlParser::BlockStatementContext::procedureSqlStatement() {
  return getRuleContexts<MySqlParser::ProcedureSqlStatementContext>();
}

MySqlParser::ProcedureSqlStatementContext* MySqlParser::BlockStatementContext::procedureSqlStatement(size_t i) {
  return getRuleContext<MySqlParser::ProcedureSqlStatementContext>(i);
}


size_t MySqlParser::BlockStatementContext::getRuleIndex() const {
  return MySqlParser::RuleBlockStatement;
}

void MySqlParser::BlockStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlockStatement(this);
}

void MySqlParser::BlockStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlockStatement(this);
}


std::any MySqlParser::BlockStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitBlockStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::BlockStatementContext* MySqlParser::blockStatement() {
  BlockStatementContext *_localctx = _tracker.createInstance<BlockStatementContext>(_ctx, getState());
  enterRule(_localctx, 386, MySqlParser::RuleBlockStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4679);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 678, _ctx)) {
    case 1: {
      setState(4676);
      uid();
      setState(4677);
      match(MySqlParser::COLON_SYMB);
      break;
    }

    default:
      break;
    }
    setState(4681);
    match(MySqlParser::BEGIN);
    setState(4687);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 679, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4682);
        declareVariable();
        setState(4683);
        match(MySqlParser::SEMI); 
      }
      setState(4689);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 679, _ctx);
    }
    setState(4695);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 680, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4690);
        declareCondition();
        setState(4691);
        match(MySqlParser::SEMI); 
      }
      setState(4697);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 680, _ctx);
    }
    setState(4703);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 681, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4698);
        declareCursor();
        setState(4699);
        match(MySqlParser::SEMI); 
      }
      setState(4705);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 681, _ctx);
    }
    setState(4711);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::DECLARE) {
      setState(4706);
      declareHandler();
      setState(4707);
      match(MySqlParser::SEMI);
      setState(4713);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4717);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 683, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4714);
        procedureSqlStatement(); 
      }
      setState(4719);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 683, _ctx);
    }
    setState(4720);
    match(MySqlParser::END);
    setState(4722);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 684, _ctx)) {
    case 1: {
      setState(4721);
      uid();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseStatementContext ------------------------------------------------------------------

MySqlParser::CaseStatementContext::CaseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySqlParser::CaseStatementContext::CASE() {
  return getTokens(MySqlParser::CASE);
}

tree::TerminalNode* MySqlParser::CaseStatementContext::CASE(size_t i) {
  return getToken(MySqlParser::CASE, i);
}

tree::TerminalNode* MySqlParser::CaseStatementContext::END() {
  return getToken(MySqlParser::END, 0);
}

MySqlParser::UidContext* MySqlParser::CaseStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::ExpressionContext* MySqlParser::CaseStatementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

std::vector<MySqlParser::CaseAlternativeContext *> MySqlParser::CaseStatementContext::caseAlternative() {
  return getRuleContexts<MySqlParser::CaseAlternativeContext>();
}

MySqlParser::CaseAlternativeContext* MySqlParser::CaseStatementContext::caseAlternative(size_t i) {
  return getRuleContext<MySqlParser::CaseAlternativeContext>(i);
}

tree::TerminalNode* MySqlParser::CaseStatementContext::ELSE() {
  return getToken(MySqlParser::ELSE, 0);
}

std::vector<MySqlParser::ProcedureSqlStatementContext *> MySqlParser::CaseStatementContext::procedureSqlStatement() {
  return getRuleContexts<MySqlParser::ProcedureSqlStatementContext>();
}

MySqlParser::ProcedureSqlStatementContext* MySqlParser::CaseStatementContext::procedureSqlStatement(size_t i) {
  return getRuleContext<MySqlParser::ProcedureSqlStatementContext>(i);
}


size_t MySqlParser::CaseStatementContext::getRuleIndex() const {
  return MySqlParser::RuleCaseStatement;
}

void MySqlParser::CaseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseStatement(this);
}

void MySqlParser::CaseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseStatement(this);
}


std::any MySqlParser::CaseStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCaseStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CaseStatementContext* MySqlParser::caseStatement() {
  CaseStatementContext *_localctx = _tracker.createInstance<CaseStatementContext>(_ctx, getState());
  enterRule(_localctx, 388, MySqlParser::RuleCaseStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4724);
    match(MySqlParser::CASE);
    setState(4727);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 685, _ctx)) {
    case 1: {
      setState(4725);
      uid();
      break;
    }

    case 2: {
      setState(4726);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(4730); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(4729);
      caseAlternative();
      setState(4732); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MySqlParser::WHEN);
    setState(4740);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ELSE) {
      setState(4734);
      match(MySqlParser::ELSE);
      setState(4736); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(4735);
                procedureSqlStatement();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(4738); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 687, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    }
    setState(4742);
    match(MySqlParser::END);
    setState(4743);
    match(MySqlParser::CASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

MySqlParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySqlParser::IfStatementContext::IF() {
  return getTokens(MySqlParser::IF);
}

tree::TerminalNode* MySqlParser::IfStatementContext::IF(size_t i) {
  return getToken(MySqlParser::IF, i);
}

MySqlParser::ExpressionContext* MySqlParser::IfStatementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::IfStatementContext::THEN() {
  return getToken(MySqlParser::THEN, 0);
}

tree::TerminalNode* MySqlParser::IfStatementContext::END() {
  return getToken(MySqlParser::END, 0);
}

std::vector<MySqlParser::ElifAlternativeContext *> MySqlParser::IfStatementContext::elifAlternative() {
  return getRuleContexts<MySqlParser::ElifAlternativeContext>();
}

MySqlParser::ElifAlternativeContext* MySqlParser::IfStatementContext::elifAlternative(size_t i) {
  return getRuleContext<MySqlParser::ElifAlternativeContext>(i);
}

tree::TerminalNode* MySqlParser::IfStatementContext::ELSE() {
  return getToken(MySqlParser::ELSE, 0);
}

std::vector<MySqlParser::ProcedureSqlStatementContext *> MySqlParser::IfStatementContext::procedureSqlStatement() {
  return getRuleContexts<MySqlParser::ProcedureSqlStatementContext>();
}

MySqlParser::ProcedureSqlStatementContext* MySqlParser::IfStatementContext::procedureSqlStatement(size_t i) {
  return getRuleContext<MySqlParser::ProcedureSqlStatementContext>(i);
}


size_t MySqlParser::IfStatementContext::getRuleIndex() const {
  return MySqlParser::RuleIfStatement;
}

void MySqlParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}

void MySqlParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}


std::any MySqlParser::IfStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIfStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::IfStatementContext* MySqlParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 390, MySqlParser::RuleIfStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4745);
    match(MySqlParser::IF);
    setState(4746);
    expression(0);
    setState(4747);
    match(MySqlParser::THEN);
    setState(4749); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4748);
              antlrcpp::downCast<IfStatementContext *>(_localctx)->procedureSqlStatementContext = procedureSqlStatement();
              antlrcpp::downCast<IfStatementContext *>(_localctx)->thenStatements.push_back(antlrcpp::downCast<IfStatementContext *>(_localctx)->procedureSqlStatementContext);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4751); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 689, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(4756);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::ELSEIF) {
      setState(4753);
      elifAlternative();
      setState(4758);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4765);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ELSE) {
      setState(4759);
      match(MySqlParser::ELSE);
      setState(4761); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(4760);
                antlrcpp::downCast<IfStatementContext *>(_localctx)->procedureSqlStatementContext = procedureSqlStatement();
                antlrcpp::downCast<IfStatementContext *>(_localctx)->elseStatements.push_back(antlrcpp::downCast<IfStatementContext *>(_localctx)->procedureSqlStatementContext);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(4763); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 691, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    }
    setState(4767);
    match(MySqlParser::END);
    setState(4768);
    match(MySqlParser::IF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IterateStatementContext ------------------------------------------------------------------

MySqlParser::IterateStatementContext::IterateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::IterateStatementContext::ITERATE() {
  return getToken(MySqlParser::ITERATE, 0);
}

MySqlParser::UidContext* MySqlParser::IterateStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}


size_t MySqlParser::IterateStatementContext::getRuleIndex() const {
  return MySqlParser::RuleIterateStatement;
}

void MySqlParser::IterateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterateStatement(this);
}

void MySqlParser::IterateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterateStatement(this);
}


std::any MySqlParser::IterateStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIterateStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::IterateStatementContext* MySqlParser::iterateStatement() {
  IterateStatementContext *_localctx = _tracker.createInstance<IterateStatementContext>(_ctx, getState());
  enterRule(_localctx, 392, MySqlParser::RuleIterateStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4770);
    match(MySqlParser::ITERATE);
    setState(4771);
    uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LeaveStatementContext ------------------------------------------------------------------

MySqlParser::LeaveStatementContext::LeaveStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::LeaveStatementContext::LEAVE() {
  return getToken(MySqlParser::LEAVE, 0);
}

MySqlParser::UidContext* MySqlParser::LeaveStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}


size_t MySqlParser::LeaveStatementContext::getRuleIndex() const {
  return MySqlParser::RuleLeaveStatement;
}

void MySqlParser::LeaveStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLeaveStatement(this);
}

void MySqlParser::LeaveStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLeaveStatement(this);
}


std::any MySqlParser::LeaveStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLeaveStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LeaveStatementContext* MySqlParser::leaveStatement() {
  LeaveStatementContext *_localctx = _tracker.createInstance<LeaveStatementContext>(_ctx, getState());
  enterRule(_localctx, 394, MySqlParser::RuleLeaveStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4773);
    match(MySqlParser::LEAVE);
    setState(4774);
    uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoopStatementContext ------------------------------------------------------------------

MySqlParser::LoopStatementContext::LoopStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySqlParser::LoopStatementContext::LOOP() {
  return getTokens(MySqlParser::LOOP);
}

tree::TerminalNode* MySqlParser::LoopStatementContext::LOOP(size_t i) {
  return getToken(MySqlParser::LOOP, i);
}

tree::TerminalNode* MySqlParser::LoopStatementContext::END() {
  return getToken(MySqlParser::END, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::LoopStatementContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::LoopStatementContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

tree::TerminalNode* MySqlParser::LoopStatementContext::COLON_SYMB() {
  return getToken(MySqlParser::COLON_SYMB, 0);
}

std::vector<MySqlParser::ProcedureSqlStatementContext *> MySqlParser::LoopStatementContext::procedureSqlStatement() {
  return getRuleContexts<MySqlParser::ProcedureSqlStatementContext>();
}

MySqlParser::ProcedureSqlStatementContext* MySqlParser::LoopStatementContext::procedureSqlStatement(size_t i) {
  return getRuleContext<MySqlParser::ProcedureSqlStatementContext>(i);
}


size_t MySqlParser::LoopStatementContext::getRuleIndex() const {
  return MySqlParser::RuleLoopStatement;
}

void MySqlParser::LoopStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoopStatement(this);
}

void MySqlParser::LoopStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoopStatement(this);
}


std::any MySqlParser::LoopStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLoopStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LoopStatementContext* MySqlParser::loopStatement() {
  LoopStatementContext *_localctx = _tracker.createInstance<LoopStatementContext>(_ctx, getState());
  enterRule(_localctx, 396, MySqlParser::RuleLoopStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4779);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
      setState(4776);
      uid();
      setState(4777);
      match(MySqlParser::COLON_SYMB);
    }
    setState(4781);
    match(MySqlParser::LOOP);
    setState(4783); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4782);
              procedureSqlStatement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4785); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 694, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(4787);
    match(MySqlParser::END);
    setState(4788);
    match(MySqlParser::LOOP);
    setState(4790);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
      setState(4789);
      uid();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepeatStatementContext ------------------------------------------------------------------

MySqlParser::RepeatStatementContext::RepeatStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySqlParser::RepeatStatementContext::REPEAT() {
  return getTokens(MySqlParser::REPEAT);
}

tree::TerminalNode* MySqlParser::RepeatStatementContext::REPEAT(size_t i) {
  return getToken(MySqlParser::REPEAT, i);
}

tree::TerminalNode* MySqlParser::RepeatStatementContext::UNTIL() {
  return getToken(MySqlParser::UNTIL, 0);
}

MySqlParser::ExpressionContext* MySqlParser::RepeatStatementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::RepeatStatementContext::END() {
  return getToken(MySqlParser::END, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::RepeatStatementContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::RepeatStatementContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

tree::TerminalNode* MySqlParser::RepeatStatementContext::COLON_SYMB() {
  return getToken(MySqlParser::COLON_SYMB, 0);
}

std::vector<MySqlParser::ProcedureSqlStatementContext *> MySqlParser::RepeatStatementContext::procedureSqlStatement() {
  return getRuleContexts<MySqlParser::ProcedureSqlStatementContext>();
}

MySqlParser::ProcedureSqlStatementContext* MySqlParser::RepeatStatementContext::procedureSqlStatement(size_t i) {
  return getRuleContext<MySqlParser::ProcedureSqlStatementContext>(i);
}


size_t MySqlParser::RepeatStatementContext::getRuleIndex() const {
  return MySqlParser::RuleRepeatStatement;
}

void MySqlParser::RepeatStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepeatStatement(this);
}

void MySqlParser::RepeatStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepeatStatement(this);
}


std::any MySqlParser::RepeatStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRepeatStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::RepeatStatementContext* MySqlParser::repeatStatement() {
  RepeatStatementContext *_localctx = _tracker.createInstance<RepeatStatementContext>(_ctx, getState());
  enterRule(_localctx, 398, MySqlParser::RuleRepeatStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4795);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
      setState(4792);
      uid();
      setState(4793);
      match(MySqlParser::COLON_SYMB);
    }
    setState(4797);
    match(MySqlParser::REPEAT);
    setState(4799); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4798);
              procedureSqlStatement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4801); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 697, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(4803);
    match(MySqlParser::UNTIL);
    setState(4804);
    expression(0);
    setState(4805);
    match(MySqlParser::END);
    setState(4806);
    match(MySqlParser::REPEAT);
    setState(4808);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
      setState(4807);
      uid();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

MySqlParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ReturnStatementContext::RETURN() {
  return getToken(MySqlParser::RETURN, 0);
}

MySqlParser::ExpressionContext* MySqlParser::ReturnStatementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}


size_t MySqlParser::ReturnStatementContext::getRuleIndex() const {
  return MySqlParser::RuleReturnStatement;
}

void MySqlParser::ReturnStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStatement(this);
}

void MySqlParser::ReturnStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStatement(this);
}


std::any MySqlParser::ReturnStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitReturnStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ReturnStatementContext* MySqlParser::returnStatement() {
  ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
  enterRule(_localctx, 400, MySqlParser::RuleReturnStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4810);
    match(MySqlParser::RETURN);
    setState(4811);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhileStatementContext ------------------------------------------------------------------

MySqlParser::WhileStatementContext::WhileStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySqlParser::WhileStatementContext::WHILE() {
  return getTokens(MySqlParser::WHILE);
}

tree::TerminalNode* MySqlParser::WhileStatementContext::WHILE(size_t i) {
  return getToken(MySqlParser::WHILE, i);
}

MySqlParser::ExpressionContext* MySqlParser::WhileStatementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::WhileStatementContext::DO() {
  return getToken(MySqlParser::DO, 0);
}

tree::TerminalNode* MySqlParser::WhileStatementContext::END() {
  return getToken(MySqlParser::END, 0);
}

std::vector<MySqlParser::UidContext *> MySqlParser::WhileStatementContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::WhileStatementContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

tree::TerminalNode* MySqlParser::WhileStatementContext::COLON_SYMB() {
  return getToken(MySqlParser::COLON_SYMB, 0);
}

std::vector<MySqlParser::ProcedureSqlStatementContext *> MySqlParser::WhileStatementContext::procedureSqlStatement() {
  return getRuleContexts<MySqlParser::ProcedureSqlStatementContext>();
}

MySqlParser::ProcedureSqlStatementContext* MySqlParser::WhileStatementContext::procedureSqlStatement(size_t i) {
  return getRuleContext<MySqlParser::ProcedureSqlStatementContext>(i);
}


size_t MySqlParser::WhileStatementContext::getRuleIndex() const {
  return MySqlParser::RuleWhileStatement;
}

void MySqlParser::WhileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileStatement(this);
}

void MySqlParser::WhileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileStatement(this);
}


std::any MySqlParser::WhileStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitWhileStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::WhileStatementContext* MySqlParser::whileStatement() {
  WhileStatementContext *_localctx = _tracker.createInstance<WhileStatementContext>(_ctx, getState());
  enterRule(_localctx, 402, MySqlParser::RuleWhileStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4816);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
      setState(4813);
      uid();
      setState(4814);
      match(MySqlParser::COLON_SYMB);
    }
    setState(4818);
    match(MySqlParser::WHILE);
    setState(4819);
    expression(0);
    setState(4820);
    match(MySqlParser::DO);
    setState(4822); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4821);
              procedureSqlStatement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4824); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 700, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(4826);
    match(MySqlParser::END);
    setState(4827);
    match(MySqlParser::WHILE);
    setState(4829);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 756891332513120256) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 146666055071174737) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 141)) & 134349441) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & -17174494689) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & -1099511627777) != 0) || ((((_la - 345) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 345)) & -2882305960540372993) != 0) || ((((_la - 409) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 409)) & -4398063288321) != 0) || ((((_la - 473) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 473)) & -16325548649218049) != 0) || ((((_la - 537) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 537)) & -81064793296864001) != 0) || ((((_la - 601) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 601)) & -68719476801) != 0) || ((((_la - 665) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 665)) & -22236531750340609) != 0) || ((((_la - 729) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 729)) & -65) != 0) || ((((_la - 793) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 793)) & -6145) != 0) || ((((_la - 857) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 857)) & -1) != 0) || ((((_la - 921) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 921)) & -1) != 0) || ((((_la - 985) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 985)) & -1) != 0) || ((((_la - 1049) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1049)) & 288230376151711743) != 0) || ((((_la - 1122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1122)) & 8627683329) != 0)) {
      setState(4828);
      uid();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorStatementContext ------------------------------------------------------------------

MySqlParser::CursorStatementContext::CursorStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::CursorStatementContext::getRuleIndex() const {
  return MySqlParser::RuleCursorStatement;
}

void MySqlParser::CursorStatementContext::copyFrom(CursorStatementContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- CloseCursorContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::CloseCursorContext::CLOSE() {
  return getToken(MySqlParser::CLOSE, 0);
}

MySqlParser::UidContext* MySqlParser::CloseCursorContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::CloseCursorContext::CloseCursorContext(CursorStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::CloseCursorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCloseCursor(this);
}
void MySqlParser::CloseCursorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCloseCursor(this);
}

std::any MySqlParser::CloseCursorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCloseCursor(this);
  else
    return visitor->visitChildren(this);
}
//----------------- OpenCursorContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::OpenCursorContext::OPEN() {
  return getToken(MySqlParser::OPEN, 0);
}

MySqlParser::UidContext* MySqlParser::OpenCursorContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::OpenCursorContext::OpenCursorContext(CursorStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::OpenCursorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpenCursor(this);
}
void MySqlParser::OpenCursorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpenCursor(this);
}

std::any MySqlParser::OpenCursorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitOpenCursor(this);
  else
    return visitor->visitChildren(this);
}
//----------------- FetchCursorContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::FetchCursorContext::FETCH() {
  return getToken(MySqlParser::FETCH, 0);
}

MySqlParser::UidContext* MySqlParser::FetchCursorContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::FetchCursorContext::INTO() {
  return getToken(MySqlParser::INTO, 0);
}

MySqlParser::UidListContext* MySqlParser::FetchCursorContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::FetchCursorContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

tree::TerminalNode* MySqlParser::FetchCursorContext::NEXT() {
  return getToken(MySqlParser::NEXT, 0);
}

MySqlParser::FetchCursorContext::FetchCursorContext(CursorStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::FetchCursorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFetchCursor(this);
}
void MySqlParser::FetchCursorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFetchCursor(this);
}

std::any MySqlParser::FetchCursorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFetchCursor(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::CursorStatementContext* MySqlParser::cursorStatement() {
  CursorStatementContext *_localctx = _tracker.createInstance<CursorStatementContext>(_ctx, getState());
  enterRule(_localctx, 404, MySqlParser::RuleCursorStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4846);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::CLOSE: {
        _localctx = _tracker.createInstance<MySqlParser::CloseCursorContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(4831);
        match(MySqlParser::CLOSE);
        setState(4832);
        uid();
        break;
      }

      case MySqlParser::FETCH: {
        _localctx = _tracker.createInstance<MySqlParser::FetchCursorContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(4833);
        match(MySqlParser::FETCH);
        setState(4838);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 703, _ctx)) {
        case 1: {
          setState(4835);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::NEXT) {
            setState(4834);
            match(MySqlParser::NEXT);
          }
          setState(4837);
          match(MySqlParser::FROM);
          break;
        }

        default:
          break;
        }
        setState(4840);
        uid();
        setState(4841);
        match(MySqlParser::INTO);
        setState(4842);
        uidList();
        break;
      }

      case MySqlParser::OPEN: {
        _localctx = _tracker.createInstance<MySqlParser::OpenCursorContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(4844);
        match(MySqlParser::OPEN);
        setState(4845);
        uid();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclareVariableContext ------------------------------------------------------------------

MySqlParser::DeclareVariableContext::DeclareVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DeclareVariableContext::DECLARE() {
  return getToken(MySqlParser::DECLARE, 0);
}

MySqlParser::UidListContext* MySqlParser::DeclareVariableContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

MySqlParser::DataTypeContext* MySqlParser::DeclareVariableContext::dataType() {
  return getRuleContext<MySqlParser::DataTypeContext>(0);
}

tree::TerminalNode* MySqlParser::DeclareVariableContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

MySqlParser::ExpressionContext* MySqlParser::DeclareVariableContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}


size_t MySqlParser::DeclareVariableContext::getRuleIndex() const {
  return MySqlParser::RuleDeclareVariable;
}

void MySqlParser::DeclareVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclareVariable(this);
}

void MySqlParser::DeclareVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclareVariable(this);
}


std::any MySqlParser::DeclareVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDeclareVariable(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DeclareVariableContext* MySqlParser::declareVariable() {
  DeclareVariableContext *_localctx = _tracker.createInstance<DeclareVariableContext>(_ctx, getState());
  enterRule(_localctx, 406, MySqlParser::RuleDeclareVariable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4848);
    match(MySqlParser::DECLARE);
    setState(4849);
    uidList();
    setState(4850);
    dataType();
    setState(4853);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::DEFAULT) {
      setState(4851);
      match(MySqlParser::DEFAULT);
      setState(4852);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclareConditionContext ------------------------------------------------------------------

MySqlParser::DeclareConditionContext::DeclareConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DeclareConditionContext::DECLARE() {
  return getToken(MySqlParser::DECLARE, 0);
}

MySqlParser::UidContext* MySqlParser::DeclareConditionContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::DeclareConditionContext::CONDITION() {
  return getToken(MySqlParser::CONDITION, 0);
}

tree::TerminalNode* MySqlParser::DeclareConditionContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::DeclareConditionContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::DeclareConditionContext::SQLSTATE() {
  return getToken(MySqlParser::SQLSTATE, 0);
}

tree::TerminalNode* MySqlParser::DeclareConditionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::DeclareConditionContext::VALUE() {
  return getToken(MySqlParser::VALUE, 0);
}


size_t MySqlParser::DeclareConditionContext::getRuleIndex() const {
  return MySqlParser::RuleDeclareCondition;
}

void MySqlParser::DeclareConditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclareCondition(this);
}

void MySqlParser::DeclareConditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclareCondition(this);
}


std::any MySqlParser::DeclareConditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDeclareCondition(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DeclareConditionContext* MySqlParser::declareCondition() {
  DeclareConditionContext *_localctx = _tracker.createInstance<DeclareConditionContext>(_ctx, getState());
  enterRule(_localctx, 408, MySqlParser::RuleDeclareCondition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4855);
    match(MySqlParser::DECLARE);
    setState(4856);
    uid();
    setState(4857);
    match(MySqlParser::CONDITION);
    setState(4858);
    match(MySqlParser::FOR);
    setState(4865);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::ZERO_DECIMAL:
      case MySqlParser::ONE_DECIMAL:
      case MySqlParser::TWO_DECIMAL:
      case MySqlParser::DECIMAL_LITERAL:
      case MySqlParser::REAL_LITERAL: {
        setState(4859);
        decimalLiteral();
        break;
      }

      case MySqlParser::SQLSTATE: {
        setState(4860);
        match(MySqlParser::SQLSTATE);
        setState(4862);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::VALUE) {
          setState(4861);
          match(MySqlParser::VALUE);
        }
        setState(4864);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclareCursorContext ------------------------------------------------------------------

MySqlParser::DeclareCursorContext::DeclareCursorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DeclareCursorContext::DECLARE() {
  return getToken(MySqlParser::DECLARE, 0);
}

MySqlParser::UidContext* MySqlParser::DeclareCursorContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::DeclareCursorContext::CURSOR() {
  return getToken(MySqlParser::CURSOR, 0);
}

tree::TerminalNode* MySqlParser::DeclareCursorContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

MySqlParser::SelectStatementContext* MySqlParser::DeclareCursorContext::selectStatement() {
  return getRuleContext<MySqlParser::SelectStatementContext>(0);
}


size_t MySqlParser::DeclareCursorContext::getRuleIndex() const {
  return MySqlParser::RuleDeclareCursor;
}

void MySqlParser::DeclareCursorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclareCursor(this);
}

void MySqlParser::DeclareCursorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclareCursor(this);
}


std::any MySqlParser::DeclareCursorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDeclareCursor(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DeclareCursorContext* MySqlParser::declareCursor() {
  DeclareCursorContext *_localctx = _tracker.createInstance<DeclareCursorContext>(_ctx, getState());
  enterRule(_localctx, 410, MySqlParser::RuleDeclareCursor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4867);
    match(MySqlParser::DECLARE);
    setState(4868);
    uid();
    setState(4869);
    match(MySqlParser::CURSOR);
    setState(4870);
    match(MySqlParser::FOR);
    setState(4871);
    selectStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclareHandlerContext ------------------------------------------------------------------

MySqlParser::DeclareHandlerContext::DeclareHandlerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DeclareHandlerContext::DECLARE() {
  return getToken(MySqlParser::DECLARE, 0);
}

tree::TerminalNode* MySqlParser::DeclareHandlerContext::HANDLER() {
  return getToken(MySqlParser::HANDLER, 0);
}

tree::TerminalNode* MySqlParser::DeclareHandlerContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

std::vector<MySqlParser::HandlerConditionValueContext *> MySqlParser::DeclareHandlerContext::handlerConditionValue() {
  return getRuleContexts<MySqlParser::HandlerConditionValueContext>();
}

MySqlParser::HandlerConditionValueContext* MySqlParser::DeclareHandlerContext::handlerConditionValue(size_t i) {
  return getRuleContext<MySqlParser::HandlerConditionValueContext>(i);
}

MySqlParser::RoutineBodyContext* MySqlParser::DeclareHandlerContext::routineBody() {
  return getRuleContext<MySqlParser::RoutineBodyContext>(0);
}

tree::TerminalNode* MySqlParser::DeclareHandlerContext::CONTINUE() {
  return getToken(MySqlParser::CONTINUE, 0);
}

tree::TerminalNode* MySqlParser::DeclareHandlerContext::EXIT() {
  return getToken(MySqlParser::EXIT, 0);
}

tree::TerminalNode* MySqlParser::DeclareHandlerContext::UNDO() {
  return getToken(MySqlParser::UNDO, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::DeclareHandlerContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::DeclareHandlerContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::DeclareHandlerContext::getRuleIndex() const {
  return MySqlParser::RuleDeclareHandler;
}

void MySqlParser::DeclareHandlerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclareHandler(this);
}

void MySqlParser::DeclareHandlerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclareHandler(this);
}


std::any MySqlParser::DeclareHandlerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDeclareHandler(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DeclareHandlerContext* MySqlParser::declareHandler() {
  DeclareHandlerContext *_localctx = _tracker.createInstance<DeclareHandlerContext>(_ctx, getState());
  enterRule(_localctx, 412, MySqlParser::RuleDeclareHandler);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4873);
    match(MySqlParser::DECLARE);
    setState(4874);
    antlrcpp::downCast<DeclareHandlerContext *>(_localctx)->handlerAction = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::CONTINUE

    || _la == MySqlParser::EXIT || _la == MySqlParser::UNDO)) {
      antlrcpp::downCast<DeclareHandlerContext *>(_localctx)->handlerAction = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4875);
    match(MySqlParser::HANDLER);
    setState(4876);
    match(MySqlParser::FOR);
    setState(4877);
    handlerConditionValue();
    setState(4882);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(4878);
      match(MySqlParser::COMMA);
      setState(4879);
      handlerConditionValue();
      setState(4884);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4885);
    routineBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerConditionValueContext ------------------------------------------------------------------

MySqlParser::HandlerConditionValueContext::HandlerConditionValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::HandlerConditionValueContext::getRuleIndex() const {
  return MySqlParser::RuleHandlerConditionValue;
}

void MySqlParser::HandlerConditionValueContext::copyFrom(HandlerConditionValueContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- HandlerConditionWarningContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::HandlerConditionWarningContext::SQLWARNING() {
  return getToken(MySqlParser::SQLWARNING, 0);
}

MySqlParser::HandlerConditionWarningContext::HandlerConditionWarningContext(HandlerConditionValueContext *ctx) { copyFrom(ctx); }

void MySqlParser::HandlerConditionWarningContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerConditionWarning(this);
}
void MySqlParser::HandlerConditionWarningContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerConditionWarning(this);
}

std::any MySqlParser::HandlerConditionWarningContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHandlerConditionWarning(this);
  else
    return visitor->visitChildren(this);
}
//----------------- HandlerConditionCodeContext ------------------------------------------------------------------

MySqlParser::DecimalLiteralContext* MySqlParser::HandlerConditionCodeContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

MySqlParser::HandlerConditionCodeContext::HandlerConditionCodeContext(HandlerConditionValueContext *ctx) { copyFrom(ctx); }

void MySqlParser::HandlerConditionCodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerConditionCode(this);
}
void MySqlParser::HandlerConditionCodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerConditionCode(this);
}

std::any MySqlParser::HandlerConditionCodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHandlerConditionCode(this);
  else
    return visitor->visitChildren(this);
}
//----------------- HandlerConditionNotfoundContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::HandlerConditionNotfoundContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}

tree::TerminalNode* MySqlParser::HandlerConditionNotfoundContext::FOUND() {
  return getToken(MySqlParser::FOUND, 0);
}

MySqlParser::HandlerConditionNotfoundContext::HandlerConditionNotfoundContext(HandlerConditionValueContext *ctx) { copyFrom(ctx); }

void MySqlParser::HandlerConditionNotfoundContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerConditionNotfound(this);
}
void MySqlParser::HandlerConditionNotfoundContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerConditionNotfound(this);
}

std::any MySqlParser::HandlerConditionNotfoundContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHandlerConditionNotfound(this);
  else
    return visitor->visitChildren(this);
}
//----------------- HandlerConditionStateContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::HandlerConditionStateContext::SQLSTATE() {
  return getToken(MySqlParser::SQLSTATE, 0);
}

tree::TerminalNode* MySqlParser::HandlerConditionStateContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::HandlerConditionStateContext::VALUE() {
  return getToken(MySqlParser::VALUE, 0);
}

MySqlParser::HandlerConditionStateContext::HandlerConditionStateContext(HandlerConditionValueContext *ctx) { copyFrom(ctx); }

void MySqlParser::HandlerConditionStateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerConditionState(this);
}
void MySqlParser::HandlerConditionStateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerConditionState(this);
}

std::any MySqlParser::HandlerConditionStateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHandlerConditionState(this);
  else
    return visitor->visitChildren(this);
}
//----------------- HandlerConditionExceptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::HandlerConditionExceptionContext::SQLEXCEPTION() {
  return getToken(MySqlParser::SQLEXCEPTION, 0);
}

MySqlParser::HandlerConditionExceptionContext::HandlerConditionExceptionContext(HandlerConditionValueContext *ctx) { copyFrom(ctx); }

void MySqlParser::HandlerConditionExceptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerConditionException(this);
}
void MySqlParser::HandlerConditionExceptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerConditionException(this);
}

std::any MySqlParser::HandlerConditionExceptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHandlerConditionException(this);
  else
    return visitor->visitChildren(this);
}
//----------------- HandlerConditionNameContext ------------------------------------------------------------------

MySqlParser::UidContext* MySqlParser::HandlerConditionNameContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::HandlerConditionNameContext::HandlerConditionNameContext(HandlerConditionValueContext *ctx) { copyFrom(ctx); }

void MySqlParser::HandlerConditionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerConditionName(this);
}
void MySqlParser::HandlerConditionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerConditionName(this);
}

std::any MySqlParser::HandlerConditionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHandlerConditionName(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::HandlerConditionValueContext* MySqlParser::handlerConditionValue() {
  HandlerConditionValueContext *_localctx = _tracker.createInstance<HandlerConditionValueContext>(_ctx, getState());
  enterRule(_localctx, 414, MySqlParser::RuleHandlerConditionValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4898);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::ZERO_DECIMAL:
      case MySqlParser::ONE_DECIMAL:
      case MySqlParser::TWO_DECIMAL:
      case MySqlParser::DECIMAL_LITERAL:
      case MySqlParser::REAL_LITERAL: {
        _localctx = _tracker.createInstance<MySqlParser::HandlerConditionCodeContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(4887);
        decimalLiteral();
        break;
      }

      case MySqlParser::SQLSTATE: {
        _localctx = _tracker.createInstance<MySqlParser::HandlerConditionStateContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(4888);
        match(MySqlParser::SQLSTATE);
        setState(4890);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::VALUE) {
          setState(4889);
          match(MySqlParser::VALUE);
        }
        setState(4892);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::ATTRIBUTE:
      case MySqlParser::BUCKETS:
      case MySqlParser::CONDITION:
      case MySqlParser::CURRENT:
      case MySqlParser::CURRENT_USER:
      case MySqlParser::DATABASE:
      case MySqlParser::DEFAULT:
      case MySqlParser::DIAGNOSTICS:
      case MySqlParser::EMPTY:
      case MySqlParser::ENFORCED:
      case MySqlParser::EXCEPT:
      case MySqlParser::GROUP:
      case MySqlParser::IF:
      case MySqlParser::IGNORED:
      case MySqlParser::INSERT:
      case MySqlParser::LATERAL:
      case MySqlParser::LEFT:
      case MySqlParser::NUMBER:
      case MySqlParser::OPTIONAL:
      case MySqlParser::ORDER:
      case MySqlParser::PRIMARY:
      case MySqlParser::REPLACE:
      case MySqlParser::RIGHT:
      case MySqlParser::SCHEMA:
      case MySqlParser::SKIP_QUERY_REWRITE:
      case MySqlParser::STACKED:
      case MySqlParser::DATE:
      case MySqlParser::TIME:
      case MySqlParser::TIMESTAMP:
      case MySqlParser::DATETIME:
      case MySqlParser::YEAR:
      case MySqlParser::BINARY:
      case MySqlParser::TEXT:
      case MySqlParser::ENUM:
      case MySqlParser::SERIAL:
      case MySqlParser::JSON_ARRAY:
      case MySqlParser::JSON_ARRAYAGG:
      case MySqlParser::JSON_ARRAY_APPEND:
      case MySqlParser::JSON_ARRAY_INSERT:
      case MySqlParser::JSON_CONTAINS:
      case MySqlParser::JSON_CONTAINS_PATH:
      case MySqlParser::JSON_DEPTH:
      case MySqlParser::JSON_EXTRACT:
      case MySqlParser::JSON_INSERT:
      case MySqlParser::JSON_KEYS:
      case MySqlParser::JSON_LENGTH:
      case MySqlParser::JSON_MERGE:
      case MySqlParser::JSON_MERGE_PATCH:
      case MySqlParser::JSON_MERGE_PRESERVE:
      case MySqlParser::JSON_OBJECT:
      case MySqlParser::JSON_OBJECTAGG:
      case MySqlParser::JSON_OVERLAPS:
      case MySqlParser::JSON_PRETTY:
      case MySqlParser::JSON_QUOTE:
      case MySqlParser::JSON_REMOVE:
      case MySqlParser::JSON_REPLACE:
      case MySqlParser::JSON_SCHEMA_VALID:
      case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
      case MySqlParser::JSON_SEARCH:
      case MySqlParser::JSON_SET:
      case MySqlParser::JSON_STORAGE_FREE:
      case MySqlParser::JSON_STORAGE_SIZE:
      case MySqlParser::JSON_TABLE:
      case MySqlParser::JSON_TYPE:
      case MySqlParser::JSON_UNQUOTE:
      case MySqlParser::JSON_VALID:
      case MySqlParser::JSON_VALUE:
      case MySqlParser::NESTED:
      case MySqlParser::ORDINALITY:
      case MySqlParser::PATH:
      case MySqlParser::AVG:
      case MySqlParser::BIT_AND:
      case MySqlParser::BIT_OR:
      case MySqlParser::BIT_XOR:
      case MySqlParser::COUNT:
      case MySqlParser::CUME_DIST:
      case MySqlParser::DENSE_RANK:
      case MySqlParser::FIRST_VALUE:
      case MySqlParser::GROUP_CONCAT:
      case MySqlParser::LAG:
      case MySqlParser::LAST_VALUE:
      case MySqlParser::LEAD:
      case MySqlParser::MAX:
      case MySqlParser::MIN:
      case MySqlParser::NTILE:
      case MySqlParser::NTH_VALUE:
      case MySqlParser::PERCENT_RANK:
      case MySqlParser::RANK:
      case MySqlParser::ROW_NUMBER:
      case MySqlParser::STD:
      case MySqlParser::STDDEV:
      case MySqlParser::STDDEV_POP:
      case MySqlParser::STDDEV_SAMP:
      case MySqlParser::SUM:
      case MySqlParser::VAR_POP:
      case MySqlParser::VAR_SAMP:
      case MySqlParser::VARIANCE:
      case MySqlParser::CURRENT_DATE:
      case MySqlParser::CURRENT_TIME:
      case MySqlParser::CURRENT_TIMESTAMP:
      case MySqlParser::LOCALTIME:
      case MySqlParser::CURDATE:
      case MySqlParser::CURTIME:
      case MySqlParser::DATE_ADD:
      case MySqlParser::DATE_SUB:
      case MySqlParser::LOCALTIMESTAMP:
      case MySqlParser::NOW:
      case MySqlParser::POSITION:
      case MySqlParser::SUBSTR:
      case MySqlParser::SUBSTRING:
      case MySqlParser::SYSDATE:
      case MySqlParser::TRIM:
      case MySqlParser::UTC_DATE:
      case MySqlParser::UTC_TIME:
      case MySqlParser::UTC_TIMESTAMP:
      case MySqlParser::ACCOUNT:
      case MySqlParser::ACTION:
      case MySqlParser::AFTER:
      case MySqlParser::AGGREGATE:
      case MySqlParser::ALGORITHM:
      case MySqlParser::ANY:
      case MySqlParser::AT:
      case MySqlParser::AUTHORS:
      case MySqlParser::AUTOCOMMIT:
      case MySqlParser::AUTOEXTEND_SIZE:
      case MySqlParser::AUTO_INCREMENT:
      case MySqlParser::AVG_ROW_LENGTH:
      case MySqlParser::BEGIN:
      case MySqlParser::BINLOG:
      case MySqlParser::BIT:
      case MySqlParser::BLOCK:
      case MySqlParser::BOOL:
      case MySqlParser::BOOLEAN:
      case MySqlParser::BTREE:
      case MySqlParser::CACHE:
      case MySqlParser::CASCADED:
      case MySqlParser::CHAIN:
      case MySqlParser::CHANGED:
      case MySqlParser::CHANNEL:
      case MySqlParser::CHECKSUM:
      case MySqlParser::PAGE_CHECKSUM:
      case MySqlParser::CIPHER:
      case MySqlParser::CLASS_ORIGIN:
      case MySqlParser::CLIENT:
      case MySqlParser::CLOSE:
      case MySqlParser::CLUSTERING:
      case MySqlParser::COALESCE:
      case MySqlParser::CODE:
      case MySqlParser::COLUMNS:
      case MySqlParser::COLUMN_FORMAT:
      case MySqlParser::COLUMN_NAME:
      case MySqlParser::COMMENT:
      case MySqlParser::COMMIT:
      case MySqlParser::COMPACT:
      case MySqlParser::COMPLETION:
      case MySqlParser::COMPRESSED:
      case MySqlParser::COMPRESSION:
      case MySqlParser::CONCURRENT:
      case MySqlParser::CONNECT:
      case MySqlParser::CONNECTION:
      case MySqlParser::CONSISTENT:
      case MySqlParser::CONSTRAINT_CATALOG:
      case MySqlParser::CONSTRAINT_SCHEMA:
      case MySqlParser::CONSTRAINT_NAME:
      case MySqlParser::CONTAINS:
      case MySqlParser::CONTEXT:
      case MySqlParser::CONTRIBUTORS:
      case MySqlParser::COPY:
      case MySqlParser::CPU:
      case MySqlParser::CURSOR_NAME:
      case MySqlParser::DATA:
      case MySqlParser::DATAFILE:
      case MySqlParser::DEALLOCATE:
      case MySqlParser::DEFAULT_AUTH:
      case MySqlParser::DEFINER:
      case MySqlParser::DELAY_KEY_WRITE:
      case MySqlParser::DES_KEY_FILE:
      case MySqlParser::DIRECTORY:
      case MySqlParser::DISABLE:
      case MySqlParser::DISCARD:
      case MySqlParser::DISK:
      case MySqlParser::DO:
      case MySqlParser::DUMPFILE:
      case MySqlParser::DUPLICATE:
      case MySqlParser::DYNAMIC:
      case MySqlParser::ENABLE:
      case MySqlParser::ENCRYPTION:
      case MySqlParser::END:
      case MySqlParser::ENDS:
      case MySqlParser::ENGINE:
      case MySqlParser::ENGINES:
      case MySqlParser::ERROR:
      case MySqlParser::ERRORS:
      case MySqlParser::ESCAPE:
      case MySqlParser::EVEN:
      case MySqlParser::EVENT:
      case MySqlParser::EVENTS:
      case MySqlParser::EVERY:
      case MySqlParser::EXCHANGE:
      case MySqlParser::EXCLUSIVE:
      case MySqlParser::EXPIRE:
      case MySqlParser::EXPORT:
      case MySqlParser::EXTENDED:
      case MySqlParser::EXTENT_SIZE:
      case MySqlParser::FAILED_LOGIN_ATTEMPTS:
      case MySqlParser::FAST:
      case MySqlParser::FAULTS:
      case MySqlParser::FIELDS:
      case MySqlParser::FILE_BLOCK_SIZE:
      case MySqlParser::FILTER:
      case MySqlParser::FIRST:
      case MySqlParser::FIXED:
      case MySqlParser::FLUSH:
      case MySqlParser::FOLLOWS:
      case MySqlParser::FOUND:
      case MySqlParser::FULL:
      case MySqlParser::FUNCTION:
      case MySqlParser::GENERAL:
      case MySqlParser::GLOBAL:
      case MySqlParser::GRANTS:
      case MySqlParser::GROUP_REPLICATION:
      case MySqlParser::HANDLER:
      case MySqlParser::HASH:
      case MySqlParser::HELP:
      case MySqlParser::HISTORY:
      case MySqlParser::HOST:
      case MySqlParser::HOSTS:
      case MySqlParser::IDENTIFIED:
      case MySqlParser::IGNORE_SERVER_IDS:
      case MySqlParser::IMPORT:
      case MySqlParser::INDEXES:
      case MySqlParser::INITIAL_SIZE:
      case MySqlParser::INPLACE:
      case MySqlParser::INSERT_METHOD:
      case MySqlParser::INSTALL:
      case MySqlParser::INSTANCE:
      case MySqlParser::INSTANT:
      case MySqlParser::INVISIBLE:
      case MySqlParser::INVOKER:
      case MySqlParser::IO:
      case MySqlParser::IO_THREAD:
      case MySqlParser::IPC:
      case MySqlParser::ISOLATION:
      case MySqlParser::ISSUER:
      case MySqlParser::JSON:
      case MySqlParser::KEY_BLOCK_SIZE:
      case MySqlParser::LANGUAGE:
      case MySqlParser::LAST:
      case MySqlParser::LEAVES:
      case MySqlParser::LESS:
      case MySqlParser::LEVEL:
      case MySqlParser::LIST:
      case MySqlParser::LOCAL:
      case MySqlParser::LOGFILE:
      case MySqlParser::LOGS:
      case MySqlParser::MASTER:
      case MySqlParser::MASTER_AUTO_POSITION:
      case MySqlParser::MASTER_CONNECT_RETRY:
      case MySqlParser::MASTER_DELAY:
      case MySqlParser::MASTER_HEARTBEAT_PERIOD:
      case MySqlParser::MASTER_HOST:
      case MySqlParser::MASTER_LOG_FILE:
      case MySqlParser::MASTER_LOG_POS:
      case MySqlParser::MASTER_PASSWORD:
      case MySqlParser::MASTER_PORT:
      case MySqlParser::MASTER_RETRY_COUNT:
      case MySqlParser::MASTER_SSL:
      case MySqlParser::MASTER_SSL_CA:
      case MySqlParser::MASTER_SSL_CAPATH:
      case MySqlParser::MASTER_SSL_CERT:
      case MySqlParser::MASTER_SSL_CIPHER:
      case MySqlParser::MASTER_SSL_CRL:
      case MySqlParser::MASTER_SSL_CRLPATH:
      case MySqlParser::MASTER_SSL_KEY:
      case MySqlParser::MASTER_TLS_VERSION:
      case MySqlParser::MASTER_USER:
      case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
      case MySqlParser::MAX_QUERIES_PER_HOUR:
      case MySqlParser::MAX_ROWS:
      case MySqlParser::MAX_SIZE:
      case MySqlParser::MAX_UPDATES_PER_HOUR:
      case MySqlParser::MAX_USER_CONNECTIONS:
      case MySqlParser::MEDIUM:
      case MySqlParser::MEMBER:
      case MySqlParser::MERGE:
      case MySqlParser::MESSAGE_TEXT:
      case MySqlParser::MID:
      case MySqlParser::MIGRATE:
      case MySqlParser::MIN_ROWS:
      case MySqlParser::MODE:
      case MySqlParser::MODIFY:
      case MySqlParser::MUTEX:
      case MySqlParser::MYSQL:
      case MySqlParser::MYSQL_ERRNO:
      case MySqlParser::NAME:
      case MySqlParser::NAMES:
      case MySqlParser::NCHAR:
      case MySqlParser::NEVER:
      case MySqlParser::NEXT:
      case MySqlParser::NO:
      case MySqlParser::NOCOPY:
      case MySqlParser::NOWAIT:
      case MySqlParser::NODEGROUP:
      case MySqlParser::NONE:
      case MySqlParser::ODBC:
      case MySqlParser::OFFLINE:
      case MySqlParser::OFFSET:
      case MySqlParser::OF:
      case MySqlParser::OJ:
      case MySqlParser::OLD_PASSWORD:
      case MySqlParser::ONE:
      case MySqlParser::ONLINE:
      case MySqlParser::ONLY:
      case MySqlParser::OPEN:
      case MySqlParser::OPTIMIZER_COSTS:
      case MySqlParser::OPTIONS:
      case MySqlParser::OWNER:
      case MySqlParser::PACK_KEYS:
      case MySqlParser::PAGE:
      case MySqlParser::PARSER:
      case MySqlParser::PARTIAL:
      case MySqlParser::PARTITIONING:
      case MySqlParser::PARTITIONS:
      case MySqlParser::PASSWORD:
      case MySqlParser::PASSWORD_LOCK_TIME:
      case MySqlParser::PHASE:
      case MySqlParser::PLUGIN:
      case MySqlParser::PLUGIN_DIR:
      case MySqlParser::PLUGINS:
      case MySqlParser::PORT:
      case MySqlParser::PRECEDES:
      case MySqlParser::PREPARE:
      case MySqlParser::PRESERVE:
      case MySqlParser::PREV:
      case MySqlParser::PROCESSLIST:
      case MySqlParser::PROFILE:
      case MySqlParser::PROFILES:
      case MySqlParser::PROXY:
      case MySqlParser::QUERY:
      case MySqlParser::QUICK:
      case MySqlParser::REBUILD:
      case MySqlParser::RECOVER:
      case MySqlParser::RECURSIVE:
      case MySqlParser::REDO_BUFFER_SIZE:
      case MySqlParser::REDUNDANT:
      case MySqlParser::RELAY:
      case MySqlParser::RELAY_LOG_FILE:
      case MySqlParser::RELAY_LOG_POS:
      case MySqlParser::RELAYLOG:
      case MySqlParser::REMOVE:
      case MySqlParser::REORGANIZE:
      case MySqlParser::REPAIR:
      case MySqlParser::REPLICATE_DO_DB:
      case MySqlParser::REPLICATE_DO_TABLE:
      case MySqlParser::REPLICATE_IGNORE_DB:
      case MySqlParser::REPLICATE_IGNORE_TABLE:
      case MySqlParser::REPLICATE_REWRITE_DB:
      case MySqlParser::REPLICATE_WILD_DO_TABLE:
      case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySqlParser::REPLICATION:
      case MySqlParser::RESET:
      case MySqlParser::RESUME:
      case MySqlParser::RETURNED_SQLSTATE:
      case MySqlParser::RETURNS:
      case MySqlParser::REUSE:
      case MySqlParser::ROLE:
      case MySqlParser::ROLLBACK:
      case MySqlParser::ROLLUP:
      case MySqlParser::ROTATE:
      case MySqlParser::ROW:
      case MySqlParser::ROWS:
      case MySqlParser::ROW_FORMAT:
      case MySqlParser::RTREE:
      case MySqlParser::SAVEPOINT:
      case MySqlParser::SCHEDULE:
      case MySqlParser::SECURITY:
      case MySqlParser::SERVER:
      case MySqlParser::SESSION:
      case MySqlParser::SHARE:
      case MySqlParser::SHARED:
      case MySqlParser::SIGNED:
      case MySqlParser::SIMPLE:
      case MySqlParser::SLAVE:
      case MySqlParser::SLOW:
      case MySqlParser::SNAPSHOT:
      case MySqlParser::SOCKET:
      case MySqlParser::SOME:
      case MySqlParser::SONAME:
      case MySqlParser::SOUNDS:
      case MySqlParser::SOURCE:
      case MySqlParser::SQL_AFTER_GTIDS:
      case MySqlParser::SQL_AFTER_MTS_GAPS:
      case MySqlParser::SQL_BEFORE_GTIDS:
      case MySqlParser::SQL_BUFFER_RESULT:
      case MySqlParser::SQL_CACHE:
      case MySqlParser::SQL_NO_CACHE:
      case MySqlParser::SQL_THREAD:
      case MySqlParser::START:
      case MySqlParser::STARTS:
      case MySqlParser::STATS_AUTO_RECALC:
      case MySqlParser::STATS_PERSISTENT:
      case MySqlParser::STATS_SAMPLE_PAGES:
      case MySqlParser::STATUS:
      case MySqlParser::STOP:
      case MySqlParser::STORAGE:
      case MySqlParser::STRING:
      case MySqlParser::SUBCLASS_ORIGIN:
      case MySqlParser::SUBJECT:
      case MySqlParser::SUBPARTITION:
      case MySqlParser::SUBPARTITIONS:
      case MySqlParser::SUSPEND:
      case MySqlParser::SWAPS:
      case MySqlParser::SWITCHES:
      case MySqlParser::TABLE_NAME:
      case MySqlParser::TABLESPACE:
      case MySqlParser::TABLE_TYPE:
      case MySqlParser::TEMPORARY:
      case MySqlParser::TEMPTABLE:
      case MySqlParser::THAN:
      case MySqlParser::TRADITIONAL:
      case MySqlParser::TRANSACTION:
      case MySqlParser::TRANSACTIONAL:
      case MySqlParser::TRIGGERS:
      case MySqlParser::TRUNCATE:
      case MySqlParser::UNBOUNDED:
      case MySqlParser::UNDEFINED:
      case MySqlParser::UNDOFILE:
      case MySqlParser::UNDO_BUFFER_SIZE:
      case MySqlParser::UNINSTALL:
      case MySqlParser::UNKNOWN:
      case MySqlParser::UNTIL:
      case MySqlParser::UPGRADE:
      case MySqlParser::USER:
      case MySqlParser::USE_FRM:
      case MySqlParser::USER_RESOURCES:
      case MySqlParser::VALIDATION:
      case MySqlParser::VALUE:
      case MySqlParser::VARIABLES:
      case MySqlParser::VIEW:
      case MySqlParser::VIRTUAL:
      case MySqlParser::VISIBLE:
      case MySqlParser::WAIT:
      case MySqlParser::WARNINGS:
      case MySqlParser::WITHOUT:
      case MySqlParser::WORK:
      case MySqlParser::WRAPPER:
      case MySqlParser::X509:
      case MySqlParser::XA:
      case MySqlParser::XML:
      case MySqlParser::EUR:
      case MySqlParser::USA:
      case MySqlParser::JIS:
      case MySqlParser::ISO:
      case MySqlParser::INTERNAL:
      case MySqlParser::QUARTER:
      case MySqlParser::MONTH:
      case MySqlParser::DAY:
      case MySqlParser::HOUR:
      case MySqlParser::MINUTE:
      case MySqlParser::WEEK:
      case MySqlParser::SECOND:
      case MySqlParser::MICROSECOND:
      case MySqlParser::ADMIN:
      case MySqlParser::AUDIT_ABORT_EXEMPT:
      case MySqlParser::AUDIT_ADMIN:
      case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
      case MySqlParser::BACKUP_ADMIN:
      case MySqlParser::BINLOG_ADMIN:
      case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
      case MySqlParser::CLONE_ADMIN:
      case MySqlParser::CONNECTION_ADMIN:
      case MySqlParser::ENCRYPTION_KEY_ADMIN:
      case MySqlParser::EXECUTE:
      case MySqlParser::FILE:
      case MySqlParser::FIREWALL_ADMIN:
      case MySqlParser::FIREWALL_EXEMPT:
      case MySqlParser::FIREWALL_USER:
      case MySqlParser::GROUP_REPLICATION_ADMIN:
      case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
      case MySqlParser::INVOKE:
      case MySqlParser::LAMBDA:
      case MySqlParser::NDB_STORED_USER:
      case MySqlParser::PASSWORDLESS_USER_ADMIN:
      case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
      case MySqlParser::PRIVILEGES:
      case MySqlParser::PROCESS:
      case MySqlParser::RELOAD:
      case MySqlParser::REPLICATION_APPLIER:
      case MySqlParser::REPLICATION_SLAVE_ADMIN:
      case MySqlParser::RESOURCE_GROUP_ADMIN:
      case MySqlParser::RESOURCE_GROUP_USER:
      case MySqlParser::ROLE_ADMIN:
      case MySqlParser::ROUTINE:
      case MySqlParser::S3:
      case MySqlParser::SESSION_VARIABLES_ADMIN:
      case MySqlParser::SET_USER_ID:
      case MySqlParser::SHOW_ROUTINE:
      case MySqlParser::SHUTDOWN:
      case MySqlParser::SUPER:
      case MySqlParser::SYSTEM_VARIABLES_ADMIN:
      case MySqlParser::TABLES:
      case MySqlParser::TABLE_ENCRYPTION_ADMIN:
      case MySqlParser::VERSION_TOKEN_ADMIN:
      case MySqlParser::XA_RECOVER_ADMIN:
      case MySqlParser::ARMSCII8:
      case MySqlParser::ASCII:
      case MySqlParser::BIG5:
      case MySqlParser::CP1250:
      case MySqlParser::CP1251:
      case MySqlParser::CP1256:
      case MySqlParser::CP1257:
      case MySqlParser::CP850:
      case MySqlParser::CP852:
      case MySqlParser::CP866:
      case MySqlParser::CP932:
      case MySqlParser::DEC8:
      case MySqlParser::EUCJPMS:
      case MySqlParser::EUCKR:
      case MySqlParser::GB18030:
      case MySqlParser::GB2312:
      case MySqlParser::GBK:
      case MySqlParser::GEOSTD8:
      case MySqlParser::GREEK:
      case MySqlParser::HEBREW:
      case MySqlParser::HP8:
      case MySqlParser::KEYBCS2:
      case MySqlParser::KOI8R:
      case MySqlParser::KOI8U:
      case MySqlParser::LATIN1:
      case MySqlParser::LATIN2:
      case MySqlParser::LATIN5:
      case MySqlParser::LATIN7:
      case MySqlParser::MACCE:
      case MySqlParser::MACROMAN:
      case MySqlParser::SJIS:
      case MySqlParser::SWE7:
      case MySqlParser::TIS620:
      case MySqlParser::UCS2:
      case MySqlParser::UJIS:
      case MySqlParser::UTF16:
      case MySqlParser::UTF16LE:
      case MySqlParser::UTF32:
      case MySqlParser::UTF8:
      case MySqlParser::UTF8MB3:
      case MySqlParser::UTF8MB4:
      case MySqlParser::ARCHIVE:
      case MySqlParser::BLACKHOLE:
      case MySqlParser::CSV:
      case MySqlParser::FEDERATED:
      case MySqlParser::INNODB:
      case MySqlParser::MEMORY:
      case MySqlParser::MRG_MYISAM:
      case MySqlParser::MYISAM:
      case MySqlParser::NDB:
      case MySqlParser::NDBCLUSTER:
      case MySqlParser::PERFORMANCE_SCHEMA:
      case MySqlParser::TOKUDB:
      case MySqlParser::REPEATABLE:
      case MySqlParser::COMMITTED:
      case MySqlParser::UNCOMMITTED:
      case MySqlParser::SERIALIZABLE:
      case MySqlParser::GEOMETRYCOLLECTION:
      case MySqlParser::LINESTRING:
      case MySqlParser::MULTILINESTRING:
      case MySqlParser::MULTIPOINT:
      case MySqlParser::MULTIPOLYGON:
      case MySqlParser::POINT:
      case MySqlParser::POLYGON:
      case MySqlParser::ABS:
      case MySqlParser::ACOS:
      case MySqlParser::ADDDATE:
      case MySqlParser::ADDTIME:
      case MySqlParser::AES_DECRYPT:
      case MySqlParser::AES_ENCRYPT:
      case MySqlParser::AREA:
      case MySqlParser::ASBINARY:
      case MySqlParser::ASIN:
      case MySqlParser::ASTEXT:
      case MySqlParser::ASWKB:
      case MySqlParser::ASWKT:
      case MySqlParser::ASYMMETRIC_DECRYPT:
      case MySqlParser::ASYMMETRIC_DERIVE:
      case MySqlParser::ASYMMETRIC_ENCRYPT:
      case MySqlParser::ASYMMETRIC_SIGN:
      case MySqlParser::ASYMMETRIC_VERIFY:
      case MySqlParser::ATAN:
      case MySqlParser::ATAN2:
      case MySqlParser::BENCHMARK:
      case MySqlParser::BIN:
      case MySqlParser::BIT_COUNT:
      case MySqlParser::BIT_LENGTH:
      case MySqlParser::BUFFER:
      case MySqlParser::CATALOG_NAME:
      case MySqlParser::CEIL:
      case MySqlParser::CEILING:
      case MySqlParser::CENTROID:
      case MySqlParser::CHARACTER_LENGTH:
      case MySqlParser::CHARSET:
      case MySqlParser::CHAR_LENGTH:
      case MySqlParser::COERCIBILITY:
      case MySqlParser::COLLATION:
      case MySqlParser::COMPRESS:
      case MySqlParser::CONCAT:
      case MySqlParser::CONCAT_WS:
      case MySqlParser::CONNECTION_ID:
      case MySqlParser::CONV:
      case MySqlParser::CONVERT_TZ:
      case MySqlParser::COS:
      case MySqlParser::COT:
      case MySqlParser::CRC32:
      case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
      case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
      case MySqlParser::CREATE_DH_PARAMETERS:
      case MySqlParser::CREATE_DIGEST:
      case MySqlParser::CROSSES:
      case MySqlParser::DATEDIFF:
      case MySqlParser::DATE_FORMAT:
      case MySqlParser::DAYNAME:
      case MySqlParser::DAYOFMONTH:
      case MySqlParser::DAYOFWEEK:
      case MySqlParser::DAYOFYEAR:
      case MySqlParser::DECODE:
      case MySqlParser::DEGREES:
      case MySqlParser::DES_DECRYPT:
      case MySqlParser::DES_ENCRYPT:
      case MySqlParser::DIMENSION:
      case MySqlParser::DISJOINT:
      case MySqlParser::ELT:
      case MySqlParser::ENCODE:
      case MySqlParser::ENCRYPT:
      case MySqlParser::ENDPOINT:
      case MySqlParser::ENGINE_ATTRIBUTE:
      case MySqlParser::ENVELOPE:
      case MySqlParser::EQUALS:
      case MySqlParser::EXP:
      case MySqlParser::EXPORT_SET:
      case MySqlParser::EXTERIORRING:
      case MySqlParser::EXTRACTVALUE:
      case MySqlParser::FIELD:
      case MySqlParser::FIND_IN_SET:
      case MySqlParser::FLOOR:
      case MySqlParser::FORMAT:
      case MySqlParser::FOUND_ROWS:
      case MySqlParser::FROM_BASE64:
      case MySqlParser::FROM_DAYS:
      case MySqlParser::FROM_UNIXTIME:
      case MySqlParser::GEOMCOLLFROMTEXT:
      case MySqlParser::GEOMCOLLFROMWKB:
      case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::GEOMETRYFROMTEXT:
      case MySqlParser::GEOMETRYFROMWKB:
      case MySqlParser::GEOMETRYN:
      case MySqlParser::GEOMETRYTYPE:
      case MySqlParser::GEOMFROMTEXT:
      case MySqlParser::GEOMFROMWKB:
      case MySqlParser::GET_FORMAT:
      case MySqlParser::GET_LOCK:
      case MySqlParser::GLENGTH:
      case MySqlParser::GREATEST:
      case MySqlParser::GTID_SUBSET:
      case MySqlParser::GTID_SUBTRACT:
      case MySqlParser::HEX:
      case MySqlParser::IFNULL:
      case MySqlParser::INET6_ATON:
      case MySqlParser::INET6_NTOA:
      case MySqlParser::INET_ATON:
      case MySqlParser::INET_NTOA:
      case MySqlParser::INSTR:
      case MySqlParser::INTERIORRINGN:
      case MySqlParser::INTERSECTS:
      case MySqlParser::ISCLOSED:
      case MySqlParser::ISEMPTY:
      case MySqlParser::ISNULL:
      case MySqlParser::ISSIMPLE:
      case MySqlParser::IS_FREE_LOCK:
      case MySqlParser::IS_IPV4:
      case MySqlParser::IS_IPV4_COMPAT:
      case MySqlParser::IS_IPV4_MAPPED:
      case MySqlParser::IS_IPV6:
      case MySqlParser::IS_USED_LOCK:
      case MySqlParser::LAST_INSERT_ID:
      case MySqlParser::LCASE:
      case MySqlParser::LEAST:
      case MySqlParser::LENGTH:
      case MySqlParser::LINEFROMTEXT:
      case MySqlParser::LINEFROMWKB:
      case MySqlParser::LINESTRINGFROMTEXT:
      case MySqlParser::LINESTRINGFROMWKB:
      case MySqlParser::LN:
      case MySqlParser::LOAD_FILE:
      case MySqlParser::LOCATE:
      case MySqlParser::LOG:
      case MySqlParser::LOG10:
      case MySqlParser::LOG2:
      case MySqlParser::LOWER:
      case MySqlParser::LPAD:
      case MySqlParser::LTRIM:
      case MySqlParser::MAKEDATE:
      case MySqlParser::MAKETIME:
      case MySqlParser::MAKE_SET:
      case MySqlParser::MASTER_POS_WAIT:
      case MySqlParser::MBRCONTAINS:
      case MySqlParser::MBRDISJOINT:
      case MySqlParser::MBREQUAL:
      case MySqlParser::MBRINTERSECTS:
      case MySqlParser::MBROVERLAPS:
      case MySqlParser::MBRTOUCHES:
      case MySqlParser::MBRWITHIN:
      case MySqlParser::MD5:
      case MySqlParser::MLINEFROMTEXT:
      case MySqlParser::MLINEFROMWKB:
      case MySqlParser::MONTHNAME:
      case MySqlParser::MPOINTFROMTEXT:
      case MySqlParser::MPOINTFROMWKB:
      case MySqlParser::MPOLYFROMTEXT:
      case MySqlParser::MPOLYFROMWKB:
      case MySqlParser::MULTILINESTRINGFROMTEXT:
      case MySqlParser::MULTILINESTRINGFROMWKB:
      case MySqlParser::MULTIPOINTFROMTEXT:
      case MySqlParser::MULTIPOINTFROMWKB:
      case MySqlParser::MULTIPOLYGONFROMTEXT:
      case MySqlParser::MULTIPOLYGONFROMWKB:
      case MySqlParser::NAME_CONST:
      case MySqlParser::NULLIF:
      case MySqlParser::NUMGEOMETRIES:
      case MySqlParser::NUMINTERIORRINGS:
      case MySqlParser::NUMPOINTS:
      case MySqlParser::OCT:
      case MySqlParser::OCTET_LENGTH:
      case MySqlParser::ORD:
      case MySqlParser::OVERLAPS:
      case MySqlParser::PERIOD_ADD:
      case MySqlParser::PERIOD_DIFF:
      case MySqlParser::PI:
      case MySqlParser::POINTFROMTEXT:
      case MySqlParser::POINTFROMWKB:
      case MySqlParser::POINTN:
      case MySqlParser::POLYFROMTEXT:
      case MySqlParser::POLYFROMWKB:
      case MySqlParser::POLYGONFROMTEXT:
      case MySqlParser::POLYGONFROMWKB:
      case MySqlParser::POW:
      case MySqlParser::POWER:
      case MySqlParser::QUOTE:
      case MySqlParser::RADIANS:
      case MySqlParser::RAND:
      case MySqlParser::RANDOM_BYTES:
      case MySqlParser::RELEASE_LOCK:
      case MySqlParser::REVERSE:
      case MySqlParser::ROUND:
      case MySqlParser::ROW_COUNT:
      case MySqlParser::RPAD:
      case MySqlParser::RTRIM:
      case MySqlParser::SEC_TO_TIME:
      case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySqlParser::SESSION_USER:
      case MySqlParser::SHA:
      case MySqlParser::SHA1:
      case MySqlParser::SHA2:
      case MySqlParser::SCHEMA_NAME:
      case MySqlParser::SIGN:
      case MySqlParser::SIN:
      case MySqlParser::SLEEP:
      case MySqlParser::SOUNDEX:
      case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
      case MySqlParser::SQRT:
      case MySqlParser::SRID:
      case MySqlParser::STARTPOINT:
      case MySqlParser::STRCMP:
      case MySqlParser::STR_TO_DATE:
      case MySqlParser::ST_AREA:
      case MySqlParser::ST_ASBINARY:
      case MySqlParser::ST_ASTEXT:
      case MySqlParser::ST_ASWKB:
      case MySqlParser::ST_ASWKT:
      case MySqlParser::ST_BUFFER:
      case MySqlParser::ST_CENTROID:
      case MySqlParser::ST_CONTAINS:
      case MySqlParser::ST_CROSSES:
      case MySqlParser::ST_DIFFERENCE:
      case MySqlParser::ST_DIMENSION:
      case MySqlParser::ST_DISJOINT:
      case MySqlParser::ST_DISTANCE:
      case MySqlParser::ST_ENDPOINT:
      case MySqlParser::ST_ENVELOPE:
      case MySqlParser::ST_EQUALS:
      case MySqlParser::ST_EXTERIORRING:
      case MySqlParser::ST_GEOMCOLLFROMTEXT:
      case MySqlParser::ST_GEOMCOLLFROMTXT:
      case MySqlParser::ST_GEOMCOLLFROMWKB:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::ST_GEOMETRYFROMTEXT:
      case MySqlParser::ST_GEOMETRYFROMWKB:
      case MySqlParser::ST_GEOMETRYN:
      case MySqlParser::ST_GEOMETRYTYPE:
      case MySqlParser::ST_GEOMFROMTEXT:
      case MySqlParser::ST_GEOMFROMWKB:
      case MySqlParser::ST_INTERIORRINGN:
      case MySqlParser::ST_INTERSECTION:
      case MySqlParser::ST_INTERSECTS:
      case MySqlParser::ST_ISCLOSED:
      case MySqlParser::ST_ISEMPTY:
      case MySqlParser::ST_ISSIMPLE:
      case MySqlParser::ST_LINEFROMTEXT:
      case MySqlParser::ST_LINEFROMWKB:
      case MySqlParser::ST_LINESTRINGFROMTEXT:
      case MySqlParser::ST_LINESTRINGFROMWKB:
      case MySqlParser::ST_NUMGEOMETRIES:
      case MySqlParser::ST_NUMINTERIORRING:
      case MySqlParser::ST_NUMINTERIORRINGS:
      case MySqlParser::ST_NUMPOINTS:
      case MySqlParser::ST_OVERLAPS:
      case MySqlParser::ST_POINTFROMTEXT:
      case MySqlParser::ST_POINTFROMWKB:
      case MySqlParser::ST_POINTN:
      case MySqlParser::ST_POLYFROMTEXT:
      case MySqlParser::ST_POLYFROMWKB:
      case MySqlParser::ST_POLYGONFROMTEXT:
      case MySqlParser::ST_POLYGONFROMWKB:
      case MySqlParser::ST_SRID:
      case MySqlParser::ST_STARTPOINT:
      case MySqlParser::ST_SYMDIFFERENCE:
      case MySqlParser::ST_TOUCHES:
      case MySqlParser::ST_UNION:
      case MySqlParser::ST_WITHIN:
      case MySqlParser::ST_X:
      case MySqlParser::ST_Y:
      case MySqlParser::SUBDATE:
      case MySqlParser::SUBSTRING_INDEX:
      case MySqlParser::SUBTIME:
      case MySqlParser::SYSTEM_USER:
      case MySqlParser::TAN:
      case MySqlParser::TIMEDIFF:
      case MySqlParser::TIMESTAMPADD:
      case MySqlParser::TIMESTAMPDIFF:
      case MySqlParser::TIME_FORMAT:
      case MySqlParser::TIME_TO_SEC:
      case MySqlParser::TOUCHES:
      case MySqlParser::TO_BASE64:
      case MySqlParser::TO_DAYS:
      case MySqlParser::TO_SECONDS:
      case MySqlParser::TP_CONNECTION_ADMIN:
      case MySqlParser::UCASE:
      case MySqlParser::UNCOMPRESS:
      case MySqlParser::UNCOMPRESSED_LENGTH:
      case MySqlParser::UNHEX:
      case MySqlParser::UNIX_TIMESTAMP:
      case MySqlParser::UPDATEXML:
      case MySqlParser::UPPER:
      case MySqlParser::UUID:
      case MySqlParser::UUID_SHORT:
      case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
      case MySqlParser::VERSION:
      case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
      case MySqlParser::WEEKDAY:
      case MySqlParser::WEEKOFYEAR:
      case MySqlParser::WEIGHT_STRING:
      case MySqlParser::WITHIN:
      case MySqlParser::YEARWEEK:
      case MySqlParser::Y_FUNCTION:
      case MySqlParser::X_FUNCTION:
      case MySqlParser::MOD:
      case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
      case MySqlParser::STRING_LITERAL:
      case MySqlParser::ID: {
        _localctx = _tracker.createInstance<MySqlParser::HandlerConditionNameContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(4893);
        uid();
        break;
      }

      case MySqlParser::SQLWARNING: {
        _localctx = _tracker.createInstance<MySqlParser::HandlerConditionWarningContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(4894);
        match(MySqlParser::SQLWARNING);
        break;
      }

      case MySqlParser::NOT: {
        _localctx = _tracker.createInstance<MySqlParser::HandlerConditionNotfoundContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(4895);
        match(MySqlParser::NOT);
        setState(4896);
        match(MySqlParser::FOUND);
        break;
      }

      case MySqlParser::SQLEXCEPTION: {
        _localctx = _tracker.createInstance<MySqlParser::HandlerConditionExceptionContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(4897);
        match(MySqlParser::SQLEXCEPTION);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureSqlStatementContext ------------------------------------------------------------------

MySqlParser::ProcedureSqlStatementContext::ProcedureSqlStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ProcedureSqlStatementContext::SEMI() {
  return getToken(MySqlParser::SEMI, 0);
}

MySqlParser::CompoundStatementContext* MySqlParser::ProcedureSqlStatementContext::compoundStatement() {
  return getRuleContext<MySqlParser::CompoundStatementContext>(0);
}

MySqlParser::SqlStatementContext* MySqlParser::ProcedureSqlStatementContext::sqlStatement() {
  return getRuleContext<MySqlParser::SqlStatementContext>(0);
}


size_t MySqlParser::ProcedureSqlStatementContext::getRuleIndex() const {
  return MySqlParser::RuleProcedureSqlStatement;
}

void MySqlParser::ProcedureSqlStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureSqlStatement(this);
}

void MySqlParser::ProcedureSqlStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureSqlStatement(this);
}


std::any MySqlParser::ProcedureSqlStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitProcedureSqlStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ProcedureSqlStatementContext* MySqlParser::procedureSqlStatement() {
  ProcedureSqlStatementContext *_localctx = _tracker.createInstance<ProcedureSqlStatementContext>(_ctx, getState());
  enterRule(_localctx, 416, MySqlParser::RuleProcedureSqlStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4902);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 711, _ctx)) {
    case 1: {
      setState(4900);
      compoundStatement();
      break;
    }

    case 2: {
      setState(4901);
      sqlStatement();
      break;
    }

    default:
      break;
    }
    setState(4904);
    match(MySqlParser::SEMI);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseAlternativeContext ------------------------------------------------------------------

MySqlParser::CaseAlternativeContext::CaseAlternativeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CaseAlternativeContext::WHEN() {
  return getToken(MySqlParser::WHEN, 0);
}

tree::TerminalNode* MySqlParser::CaseAlternativeContext::THEN() {
  return getToken(MySqlParser::THEN, 0);
}

MySqlParser::ConstantContext* MySqlParser::CaseAlternativeContext::constant() {
  return getRuleContext<MySqlParser::ConstantContext>(0);
}

MySqlParser::ExpressionContext* MySqlParser::CaseAlternativeContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

std::vector<MySqlParser::ProcedureSqlStatementContext *> MySqlParser::CaseAlternativeContext::procedureSqlStatement() {
  return getRuleContexts<MySqlParser::ProcedureSqlStatementContext>();
}

MySqlParser::ProcedureSqlStatementContext* MySqlParser::CaseAlternativeContext::procedureSqlStatement(size_t i) {
  return getRuleContext<MySqlParser::ProcedureSqlStatementContext>(i);
}


size_t MySqlParser::CaseAlternativeContext::getRuleIndex() const {
  return MySqlParser::RuleCaseAlternative;
}

void MySqlParser::CaseAlternativeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseAlternative(this);
}

void MySqlParser::CaseAlternativeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseAlternative(this);
}


std::any MySqlParser::CaseAlternativeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCaseAlternative(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CaseAlternativeContext* MySqlParser::caseAlternative() {
  CaseAlternativeContext *_localctx = _tracker.createInstance<CaseAlternativeContext>(_ctx, getState());
  enterRule(_localctx, 418, MySqlParser::RuleCaseAlternative);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4906);
    match(MySqlParser::WHEN);
    setState(4909);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 712, _ctx)) {
    case 1: {
      setState(4907);
      constant();
      break;
    }

    case 2: {
      setState(4908);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(4911);
    match(MySqlParser::THEN);
    setState(4913); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4912);
              procedureSqlStatement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4915); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 713, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElifAlternativeContext ------------------------------------------------------------------

MySqlParser::ElifAlternativeContext::ElifAlternativeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ElifAlternativeContext::ELSEIF() {
  return getToken(MySqlParser::ELSEIF, 0);
}

MySqlParser::ExpressionContext* MySqlParser::ElifAlternativeContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::ElifAlternativeContext::THEN() {
  return getToken(MySqlParser::THEN, 0);
}

std::vector<MySqlParser::ProcedureSqlStatementContext *> MySqlParser::ElifAlternativeContext::procedureSqlStatement() {
  return getRuleContexts<MySqlParser::ProcedureSqlStatementContext>();
}

MySqlParser::ProcedureSqlStatementContext* MySqlParser::ElifAlternativeContext::procedureSqlStatement(size_t i) {
  return getRuleContext<MySqlParser::ProcedureSqlStatementContext>(i);
}


size_t MySqlParser::ElifAlternativeContext::getRuleIndex() const {
  return MySqlParser::RuleElifAlternative;
}

void MySqlParser::ElifAlternativeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElifAlternative(this);
}

void MySqlParser::ElifAlternativeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElifAlternative(this);
}


std::any MySqlParser::ElifAlternativeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitElifAlternative(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ElifAlternativeContext* MySqlParser::elifAlternative() {
  ElifAlternativeContext *_localctx = _tracker.createInstance<ElifAlternativeContext>(_ctx, getState());
  enterRule(_localctx, 420, MySqlParser::RuleElifAlternative);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4917);
    match(MySqlParser::ELSEIF);
    setState(4918);
    expression(0);
    setState(4919);
    match(MySqlParser::THEN);
    setState(4921); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4920);
              procedureSqlStatement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4923); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 714, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserContext ------------------------------------------------------------------

MySqlParser::AlterUserContext::AlterUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::AlterUserContext::getRuleIndex() const {
  return MySqlParser::RuleAlterUser;
}

void MySqlParser::AlterUserContext::copyFrom(AlterUserContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- AlterUserMysqlV80Context ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterUserMysqlV80Context::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterUserMysqlV80Context::USER() {
  return getToken(MySqlParser::USER, 0);
}

std::vector<MySqlParser::UserAuthOptionContext *> MySqlParser::AlterUserMysqlV80Context::userAuthOption() {
  return getRuleContexts<MySqlParser::UserAuthOptionContext>();
}

MySqlParser::UserAuthOptionContext* MySqlParser::AlterUserMysqlV80Context::userAuthOption(size_t i) {
  return getRuleContext<MySqlParser::UserAuthOptionContext>(i);
}

MySqlParser::IfExistsContext* MySqlParser::AlterUserMysqlV80Context::ifExists() {
  return getRuleContext<MySqlParser::IfExistsContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterUserMysqlV80Context::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::AlterUserMysqlV80Context::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::AlterUserMysqlV80Context::REQUIRE() {
  return getToken(MySqlParser::REQUIRE, 0);
}

tree::TerminalNode* MySqlParser::AlterUserMysqlV80Context::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

std::vector<MySqlParser::UserPasswordOptionContext *> MySqlParser::AlterUserMysqlV80Context::userPasswordOption() {
  return getRuleContexts<MySqlParser::UserPasswordOptionContext>();
}

MySqlParser::UserPasswordOptionContext* MySqlParser::AlterUserMysqlV80Context::userPasswordOption(size_t i) {
  return getRuleContext<MySqlParser::UserPasswordOptionContext>(i);
}

std::vector<MySqlParser::UserLockOptionContext *> MySqlParser::AlterUserMysqlV80Context::userLockOption() {
  return getRuleContexts<MySqlParser::UserLockOptionContext>();
}

MySqlParser::UserLockOptionContext* MySqlParser::AlterUserMysqlV80Context::userLockOption(size_t i) {
  return getRuleContext<MySqlParser::UserLockOptionContext>(i);
}

tree::TerminalNode* MySqlParser::AlterUserMysqlV80Context::COMMENT() {
  return getToken(MySqlParser::COMMENT, 0);
}

tree::TerminalNode* MySqlParser::AlterUserMysqlV80Context::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::AlterUserMysqlV80Context::ATTRIBUTE() {
  return getToken(MySqlParser::ATTRIBUTE, 0);
}

std::vector<MySqlParser::TlsOptionContext *> MySqlParser::AlterUserMysqlV80Context::tlsOption() {
  return getRuleContexts<MySqlParser::TlsOptionContext>();
}

MySqlParser::TlsOptionContext* MySqlParser::AlterUserMysqlV80Context::tlsOption(size_t i) {
  return getRuleContext<MySqlParser::TlsOptionContext>(i);
}

tree::TerminalNode* MySqlParser::AlterUserMysqlV80Context::NONE() {
  return getToken(MySqlParser::NONE, 0);
}

std::vector<MySqlParser::UserResourceOptionContext *> MySqlParser::AlterUserMysqlV80Context::userResourceOption() {
  return getRuleContexts<MySqlParser::UserResourceOptionContext>();
}

MySqlParser::UserResourceOptionContext* MySqlParser::AlterUserMysqlV80Context::userResourceOption(size_t i) {
  return getRuleContext<MySqlParser::UserResourceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterUserMysqlV80Context::AND() {
  return getTokens(MySqlParser::AND);
}

tree::TerminalNode* MySqlParser::AlterUserMysqlV80Context::AND(size_t i) {
  return getToken(MySqlParser::AND, i);
}

tree::TerminalNode* MySqlParser::AlterUserMysqlV80Context::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::AlterUserMysqlV80Context::ROLE() {
  return getToken(MySqlParser::ROLE, 0);
}

MySqlParser::RoleOptionContext* MySqlParser::AlterUserMysqlV80Context::roleOption() {
  return getRuleContext<MySqlParser::RoleOptionContext>(0);
}

MySqlParser::UserNameContext* MySqlParser::AlterUserMysqlV80Context::userName() {
  return getRuleContext<MySqlParser::UserNameContext>(0);
}

MySqlParser::UidContext* MySqlParser::AlterUserMysqlV80Context::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::AlterUserMysqlV80Context::AlterUserMysqlV80Context(AlterUserContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterUserMysqlV80Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUserMysqlV80(this);
}
void MySqlParser::AlterUserMysqlV80Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUserMysqlV80(this);
}

std::any MySqlParser::AlterUserMysqlV80Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterUserMysqlV80(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AlterUserMysqlV56Context ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::AlterUserMysqlV56Context::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::AlterUserMysqlV56Context::USER() {
  return getToken(MySqlParser::USER, 0);
}

std::vector<MySqlParser::UserSpecificationContext *> MySqlParser::AlterUserMysqlV56Context::userSpecification() {
  return getRuleContexts<MySqlParser::UserSpecificationContext>();
}

MySqlParser::UserSpecificationContext* MySqlParser::AlterUserMysqlV56Context::userSpecification(size_t i) {
  return getRuleContext<MySqlParser::UserSpecificationContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::AlterUserMysqlV56Context::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::AlterUserMysqlV56Context::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::AlterUserMysqlV56Context::AlterUserMysqlV56Context(AlterUserContext *ctx) { copyFrom(ctx); }

void MySqlParser::AlterUserMysqlV56Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUserMysqlV56(this);
}
void MySqlParser::AlterUserMysqlV56Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUserMysqlV56(this);
}

std::any MySqlParser::AlterUserMysqlV56Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAlterUserMysqlV56(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::AlterUserContext* MySqlParser::alterUser() {
  AlterUserContext *_localctx = _tracker.createInstance<AlterUserContext>(_ctx, getState());
  enterRule(_localctx, 422, MySqlParser::RuleAlterUser);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4998);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 729, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::AlterUserMysqlV56Context>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(4925);
      match(MySqlParser::ALTER);
      setState(4926);
      match(MySqlParser::USER);
      setState(4927);
      userSpecification();
      setState(4932);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(4928);
        match(MySqlParser::COMMA);
        setState(4929);
        userSpecification();
        setState(4934);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::AlterUserMysqlV80Context>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(4935);
      match(MySqlParser::ALTER);
      setState(4936);
      match(MySqlParser::USER);
      setState(4938);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::IF) {
        setState(4937);
        ifExists();
      }
      setState(4940);
      userAuthOption();
      setState(4945);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(4941);
        match(MySqlParser::COMMA);
        setState(4942);
        userAuthOption();
        setState(4947);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(4962);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::REQUIRE) {
        setState(4948);
        match(MySqlParser::REQUIRE);
        setState(4960);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::NONE: {
            setState(4949);
            antlrcpp::downCast<AlterUserMysqlV80Context *>(_localctx)->tlsNone = match(MySqlParser::NONE);
            break;
          }

          case MySqlParser::SSL:
          case MySqlParser::CIPHER:
          case MySqlParser::ISSUER:
          case MySqlParser::SUBJECT:
          case MySqlParser::X509: {
            setState(4950);
            tlsOption();
            setState(4957);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == MySqlParser::AND || _la == MySqlParser::SSL || _la == MySqlParser::CIPHER || _la == MySqlParser::ISSUER || _la == MySqlParser::SUBJECT

            || _la == MySqlParser::X509) {
              setState(4952);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == MySqlParser::AND) {
                setState(4951);
                match(MySqlParser::AND);
              }
              setState(4954);
              tlsOption();
              setState(4959);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
      }
      setState(4970);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 723, _ctx)) {
      case 1: {
        setState(4964);
        match(MySqlParser::WITH);
        setState(4966); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(4965);
          userResourceOption();
          setState(4968); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (((((_la - 498) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 498)) & 51) != 0));
        break;
      }

      default:
        break;
      }
      setState(4976);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::ACCOUNT || _la == MySqlParser::FAILED_LOGIN_ATTEMPTS || _la == MySqlParser::PASSWORD

      || _la == MySqlParser::PASSWORD_LOCK_TIME) {
        setState(4974);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::FAILED_LOGIN_ATTEMPTS:
          case MySqlParser::PASSWORD:
          case MySqlParser::PASSWORD_LOCK_TIME: {
            setState(4972);
            userPasswordOption();
            break;
          }

          case MySqlParser::ACCOUNT: {
            setState(4973);
            userLockOption();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(4978);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(4983);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::COMMENT: {
          setState(4979);
          match(MySqlParser::COMMENT);
          setState(4980);
          match(MySqlParser::STRING_LITERAL);
          break;
        }

        case MySqlParser::ATTRIBUTE: {
          setState(4981);
          match(MySqlParser::ATTRIBUTE);
          setState(4982);
          match(MySqlParser::STRING_LITERAL);
          break;
        }

        case MySqlParser::EOF:
        case MySqlParser::ALTER:
        case MySqlParser::ANALYZE:
        case MySqlParser::CALL:
        case MySqlParser::CHANGE:
        case MySqlParser::CHECK:
        case MySqlParser::CREATE:
        case MySqlParser::DELETE:
        case MySqlParser::DESC:
        case MySqlParser::DESCRIBE:
        case MySqlParser::DROP:
        case MySqlParser::EXPLAIN:
        case MySqlParser::GET:
        case MySqlParser::GRANT:
        case MySqlParser::INSERT:
        case MySqlParser::KILL:
        case MySqlParser::LOAD:
        case MySqlParser::LOCK:
        case MySqlParser::OPTIMIZE:
        case MySqlParser::PURGE:
        case MySqlParser::RELEASE:
        case MySqlParser::RENAME:
        case MySqlParser::REPLACE:
        case MySqlParser::RESIGNAL:
        case MySqlParser::REVOKE:
        case MySqlParser::SELECT:
        case MySqlParser::SET:
        case MySqlParser::SHOW:
        case MySqlParser::SIGNAL:
        case MySqlParser::TABLE:
        case MySqlParser::UNLOCK:
        case MySqlParser::UPDATE:
        case MySqlParser::USE:
        case MySqlParser::VALUES:
        case MySqlParser::WITH:
        case MySqlParser::BEGIN:
        case MySqlParser::BINLOG:
        case MySqlParser::CACHE:
        case MySqlParser::CHECKSUM:
        case MySqlParser::COMMIT:
        case MySqlParser::DEALLOCATE:
        case MySqlParser::DO:
        case MySqlParser::FLUSH:
        case MySqlParser::HANDLER:
        case MySqlParser::HELP:
        case MySqlParser::INSTALL:
        case MySqlParser::PREPARE:
        case MySqlParser::REPAIR:
        case MySqlParser::RESET:
        case MySqlParser::ROLLBACK:
        case MySqlParser::SAVEPOINT:
        case MySqlParser::START:
        case MySqlParser::STOP:
        case MySqlParser::TRUNCATE:
        case MySqlParser::UNINSTALL:
        case MySqlParser::XA:
        case MySqlParser::EXECUTE:
        case MySqlParser::SHUTDOWN:
        case MySqlParser::MINUS:
        case MySqlParser::LR_BRACKET:
        case MySqlParser::SEMI: {
          break;
        }

      default:
        break;
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::AlterUserMysqlV80Context>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(4985);
      match(MySqlParser::ALTER);
      setState(4986);
      match(MySqlParser::USER);
      setState(4988);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 727, _ctx)) {
      case 1: {
        setState(4987);
        ifExists();
        break;
      }

      default:
        break;
      }
      setState(4992);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 728, _ctx)) {
      case 1: {
        setState(4990);
        userName();
        break;
      }

      case 2: {
        setState(4991);
        uid();
        break;
      }

      default:
        break;
      }
      setState(4994);
      match(MySqlParser::DEFAULT);
      setState(4995);
      match(MySqlParser::ROLE);
      setState(4996);
      roleOption();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserContext ------------------------------------------------------------------

MySqlParser::CreateUserContext::CreateUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::CreateUserContext::getRuleIndex() const {
  return MySqlParser::RuleCreateUser;
}

void MySqlParser::CreateUserContext::copyFrom(CreateUserContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- CreateUserMysqlV56Context ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::CreateUserMysqlV56Context::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateUserMysqlV56Context::USER() {
  return getToken(MySqlParser::USER, 0);
}

std::vector<MySqlParser::UserAuthOptionContext *> MySqlParser::CreateUserMysqlV56Context::userAuthOption() {
  return getRuleContexts<MySqlParser::UserAuthOptionContext>();
}

MySqlParser::UserAuthOptionContext* MySqlParser::CreateUserMysqlV56Context::userAuthOption(size_t i) {
  return getRuleContext<MySqlParser::UserAuthOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateUserMysqlV56Context::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::CreateUserMysqlV56Context::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::CreateUserMysqlV56Context::CreateUserMysqlV56Context(CreateUserContext *ctx) { copyFrom(ctx); }

void MySqlParser::CreateUserMysqlV56Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUserMysqlV56(this);
}
void MySqlParser::CreateUserMysqlV56Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUserMysqlV56(this);
}

std::any MySqlParser::CreateUserMysqlV56Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateUserMysqlV56(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CreateUserMysqlV80Context ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::CreateUserMysqlV80Context::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateUserMysqlV80Context::USER() {
  return getToken(MySqlParser::USER, 0);
}

std::vector<MySqlParser::UserAuthOptionContext *> MySqlParser::CreateUserMysqlV80Context::userAuthOption() {
  return getRuleContexts<MySqlParser::UserAuthOptionContext>();
}

MySqlParser::UserAuthOptionContext* MySqlParser::CreateUserMysqlV80Context::userAuthOption(size_t i) {
  return getRuleContext<MySqlParser::UserAuthOptionContext>(i);
}

MySqlParser::IfNotExistsContext* MySqlParser::CreateUserMysqlV80Context::ifNotExists() {
  return getRuleContext<MySqlParser::IfNotExistsContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateUserMysqlV80Context::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::CreateUserMysqlV80Context::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::CreateUserMysqlV80Context::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::CreateUserMysqlV80Context::ROLE() {
  return getToken(MySqlParser::ROLE, 0);
}

MySqlParser::RoleOptionContext* MySqlParser::CreateUserMysqlV80Context::roleOption() {
  return getRuleContext<MySqlParser::RoleOptionContext>(0);
}

tree::TerminalNode* MySqlParser::CreateUserMysqlV80Context::REQUIRE() {
  return getToken(MySqlParser::REQUIRE, 0);
}

tree::TerminalNode* MySqlParser::CreateUserMysqlV80Context::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

std::vector<MySqlParser::UserPasswordOptionContext *> MySqlParser::CreateUserMysqlV80Context::userPasswordOption() {
  return getRuleContexts<MySqlParser::UserPasswordOptionContext>();
}

MySqlParser::UserPasswordOptionContext* MySqlParser::CreateUserMysqlV80Context::userPasswordOption(size_t i) {
  return getRuleContext<MySqlParser::UserPasswordOptionContext>(i);
}

std::vector<MySqlParser::UserLockOptionContext *> MySqlParser::CreateUserMysqlV80Context::userLockOption() {
  return getRuleContexts<MySqlParser::UserLockOptionContext>();
}

MySqlParser::UserLockOptionContext* MySqlParser::CreateUserMysqlV80Context::userLockOption(size_t i) {
  return getRuleContext<MySqlParser::UserLockOptionContext>(i);
}

tree::TerminalNode* MySqlParser::CreateUserMysqlV80Context::COMMENT() {
  return getToken(MySqlParser::COMMENT, 0);
}

tree::TerminalNode* MySqlParser::CreateUserMysqlV80Context::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::CreateUserMysqlV80Context::ATTRIBUTE() {
  return getToken(MySqlParser::ATTRIBUTE, 0);
}

std::vector<MySqlParser::TlsOptionContext *> MySqlParser::CreateUserMysqlV80Context::tlsOption() {
  return getRuleContexts<MySqlParser::TlsOptionContext>();
}

MySqlParser::TlsOptionContext* MySqlParser::CreateUserMysqlV80Context::tlsOption(size_t i) {
  return getRuleContext<MySqlParser::TlsOptionContext>(i);
}

tree::TerminalNode* MySqlParser::CreateUserMysqlV80Context::NONE() {
  return getToken(MySqlParser::NONE, 0);
}

std::vector<MySqlParser::UserResourceOptionContext *> MySqlParser::CreateUserMysqlV80Context::userResourceOption() {
  return getRuleContexts<MySqlParser::UserResourceOptionContext>();
}

MySqlParser::UserResourceOptionContext* MySqlParser::CreateUserMysqlV80Context::userResourceOption(size_t i) {
  return getRuleContext<MySqlParser::UserResourceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::CreateUserMysqlV80Context::AND() {
  return getTokens(MySqlParser::AND);
}

tree::TerminalNode* MySqlParser::CreateUserMysqlV80Context::AND(size_t i) {
  return getToken(MySqlParser::AND, i);
}

MySqlParser::CreateUserMysqlV80Context::CreateUserMysqlV80Context(CreateUserContext *ctx) { copyFrom(ctx); }

void MySqlParser::CreateUserMysqlV80Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUserMysqlV80(this);
}
void MySqlParser::CreateUserMysqlV80Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUserMysqlV80(this);
}

std::any MySqlParser::CreateUserMysqlV80Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateUserMysqlV80(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::CreateUserContext* MySqlParser::createUser() {
  CreateUserContext *_localctx = _tracker.createInstance<CreateUserContext>(_ctx, getState());
  enterRule(_localctx, 424, MySqlParser::RuleCreateUser);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5065);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 743, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::CreateUserMysqlV56Context>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(5000);
      match(MySqlParser::CREATE);
      setState(5001);
      match(MySqlParser::USER);
      setState(5002);
      userAuthOption();
      setState(5007);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5003);
        match(MySqlParser::COMMA);
        setState(5004);
        userAuthOption();
        setState(5009);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::CreateUserMysqlV80Context>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(5010);
      match(MySqlParser::CREATE);
      setState(5011);
      match(MySqlParser::USER);
      setState(5013);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::IF) {
        setState(5012);
        ifNotExists();
      }
      setState(5015);
      userAuthOption();
      setState(5020);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5016);
        match(MySqlParser::COMMA);
        setState(5017);
        userAuthOption();
        setState(5022);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(5026);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::DEFAULT) {
        setState(5023);
        match(MySqlParser::DEFAULT);
        setState(5024);
        match(MySqlParser::ROLE);
        setState(5025);
        roleOption();
      }
      setState(5042);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::REQUIRE) {
        setState(5028);
        match(MySqlParser::REQUIRE);
        setState(5040);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::NONE: {
            setState(5029);
            antlrcpp::downCast<CreateUserMysqlV80Context *>(_localctx)->tlsNone = match(MySqlParser::NONE);
            break;
          }

          case MySqlParser::SSL:
          case MySqlParser::CIPHER:
          case MySqlParser::ISSUER:
          case MySqlParser::SUBJECT:
          case MySqlParser::X509: {
            setState(5030);
            tlsOption();
            setState(5037);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == MySqlParser::AND || _la == MySqlParser::SSL || _la == MySqlParser::CIPHER || _la == MySqlParser::ISSUER || _la == MySqlParser::SUBJECT

            || _la == MySqlParser::X509) {
              setState(5032);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == MySqlParser::AND) {
                setState(5031);
                match(MySqlParser::AND);
              }
              setState(5034);
              tlsOption();
              setState(5039);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
      }
      setState(5050);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 739, _ctx)) {
      case 1: {
        setState(5044);
        match(MySqlParser::WITH);
        setState(5046); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(5045);
          userResourceOption();
          setState(5048); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (((((_la - 498) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 498)) & 51) != 0));
        break;
      }

      default:
        break;
      }
      setState(5056);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::ACCOUNT || _la == MySqlParser::FAILED_LOGIN_ATTEMPTS || _la == MySqlParser::PASSWORD

      || _la == MySqlParser::PASSWORD_LOCK_TIME) {
        setState(5054);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::FAILED_LOGIN_ATTEMPTS:
          case MySqlParser::PASSWORD:
          case MySqlParser::PASSWORD_LOCK_TIME: {
            setState(5052);
            userPasswordOption();
            break;
          }

          case MySqlParser::ACCOUNT: {
            setState(5053);
            userLockOption();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(5058);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(5063);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::COMMENT: {
          setState(5059);
          match(MySqlParser::COMMENT);
          setState(5060);
          match(MySqlParser::STRING_LITERAL);
          break;
        }

        case MySqlParser::ATTRIBUTE: {
          setState(5061);
          match(MySqlParser::ATTRIBUTE);
          setState(5062);
          match(MySqlParser::STRING_LITERAL);
          break;
        }

        case MySqlParser::EOF:
        case MySqlParser::ALTER:
        case MySqlParser::ANALYZE:
        case MySqlParser::CALL:
        case MySqlParser::CHANGE:
        case MySqlParser::CHECK:
        case MySqlParser::CREATE:
        case MySqlParser::DELETE:
        case MySqlParser::DESC:
        case MySqlParser::DESCRIBE:
        case MySqlParser::DROP:
        case MySqlParser::EXPLAIN:
        case MySqlParser::GET:
        case MySqlParser::GRANT:
        case MySqlParser::INSERT:
        case MySqlParser::KILL:
        case MySqlParser::LOAD:
        case MySqlParser::LOCK:
        case MySqlParser::OPTIMIZE:
        case MySqlParser::PURGE:
        case MySqlParser::RELEASE:
        case MySqlParser::RENAME:
        case MySqlParser::REPLACE:
        case MySqlParser::RESIGNAL:
        case MySqlParser::REVOKE:
        case MySqlParser::SELECT:
        case MySqlParser::SET:
        case MySqlParser::SHOW:
        case MySqlParser::SIGNAL:
        case MySqlParser::TABLE:
        case MySqlParser::UNLOCK:
        case MySqlParser::UPDATE:
        case MySqlParser::USE:
        case MySqlParser::VALUES:
        case MySqlParser::WITH:
        case MySqlParser::BEGIN:
        case MySqlParser::BINLOG:
        case MySqlParser::CACHE:
        case MySqlParser::CHECKSUM:
        case MySqlParser::COMMIT:
        case MySqlParser::DEALLOCATE:
        case MySqlParser::DO:
        case MySqlParser::FLUSH:
        case MySqlParser::HANDLER:
        case MySqlParser::HELP:
        case MySqlParser::INSTALL:
        case MySqlParser::PREPARE:
        case MySqlParser::REPAIR:
        case MySqlParser::RESET:
        case MySqlParser::ROLLBACK:
        case MySqlParser::SAVEPOINT:
        case MySqlParser::START:
        case MySqlParser::STOP:
        case MySqlParser::TRUNCATE:
        case MySqlParser::UNINSTALL:
        case MySqlParser::XA:
        case MySqlParser::EXECUTE:
        case MySqlParser::SHUTDOWN:
        case MySqlParser::MINUS:
        case MySqlParser::LR_BRACKET:
        case MySqlParser::SEMI: {
          break;
        }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropUserContext ------------------------------------------------------------------

MySqlParser::DropUserContext::DropUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DropUserContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::DropUserContext::USER() {
  return getToken(MySqlParser::USER, 0);
}

std::vector<MySqlParser::UserNameContext *> MySqlParser::DropUserContext::userName() {
  return getRuleContexts<MySqlParser::UserNameContext>();
}

MySqlParser::UserNameContext* MySqlParser::DropUserContext::userName(size_t i) {
  return getRuleContext<MySqlParser::UserNameContext>(i);
}

MySqlParser::IfExistsContext* MySqlParser::DropUserContext::ifExists() {
  return getRuleContext<MySqlParser::IfExistsContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::DropUserContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::DropUserContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::DropUserContext::getRuleIndex() const {
  return MySqlParser::RuleDropUser;
}

void MySqlParser::DropUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropUser(this);
}

void MySqlParser::DropUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropUser(this);
}


std::any MySqlParser::DropUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDropUser(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DropUserContext* MySqlParser::dropUser() {
  DropUserContext *_localctx = _tracker.createInstance<DropUserContext>(_ctx, getState());
  enterRule(_localctx, 426, MySqlParser::RuleDropUser);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5067);
    match(MySqlParser::DROP);
    setState(5068);
    match(MySqlParser::USER);
    setState(5070);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IF) {
      setState(5069);
      ifExists();
    }
    setState(5072);
    userName();
    setState(5077);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(5073);
      match(MySqlParser::COMMA);
      setState(5074);
      userName();
      setState(5079);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantStatementContext ------------------------------------------------------------------

MySqlParser::GrantStatementContext::GrantStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySqlParser::GrantStatementContext::GRANT() {
  return getTokens(MySqlParser::GRANT);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::GRANT(size_t i) {
  return getToken(MySqlParser::GRANT, i);
}

std::vector<MySqlParser::PrivelegeClauseContext *> MySqlParser::GrantStatementContext::privelegeClause() {
  return getRuleContexts<MySqlParser::PrivelegeClauseContext>();
}

MySqlParser::PrivelegeClauseContext* MySqlParser::GrantStatementContext::privelegeClause(size_t i) {
  return getRuleContext<MySqlParser::PrivelegeClauseContext>(i);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

MySqlParser::PrivilegeLevelContext* MySqlParser::GrantStatementContext::privilegeLevel() {
  return getRuleContext<MySqlParser::PrivilegeLevelContext>(0);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::TO() {
  return getToken(MySqlParser::TO, 0);
}

std::vector<MySqlParser::UserAuthOptionContext *> MySqlParser::GrantStatementContext::userAuthOption() {
  return getRuleContexts<MySqlParser::UserAuthOptionContext>();
}

MySqlParser::UserAuthOptionContext* MySqlParser::GrantStatementContext::userAuthOption(size_t i) {
  return getRuleContext<MySqlParser::UserAuthOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::GrantStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::REQUIRE() {
  return getToken(MySqlParser::REQUIRE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::GrantStatementContext::WITH() {
  return getTokens(MySqlParser::WITH);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::WITH(size_t i) {
  return getToken(MySqlParser::WITH, i);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

std::vector<MySqlParser::UserNameContext *> MySqlParser::GrantStatementContext::userName() {
  return getRuleContexts<MySqlParser::UserNameContext>();
}

MySqlParser::UserNameContext* MySqlParser::GrantStatementContext::userName(size_t i) {
  return getRuleContext<MySqlParser::UserNameContext>(i);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::ROLE() {
  return getToken(MySqlParser::ROLE, 0);
}

MySqlParser::RoleOptionContext* MySqlParser::GrantStatementContext::roleOption() {
  return getRuleContext<MySqlParser::RoleOptionContext>(0);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::FUNCTION() {
  return getToken(MySqlParser::FUNCTION, 0);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::PROCEDURE() {
  return getToken(MySqlParser::PROCEDURE, 0);
}

std::vector<MySqlParser::TlsOptionContext *> MySqlParser::GrantStatementContext::tlsOption() {
  return getRuleContexts<MySqlParser::TlsOptionContext>();
}

MySqlParser::TlsOptionContext* MySqlParser::GrantStatementContext::tlsOption(size_t i) {
  return getRuleContext<MySqlParser::TlsOptionContext>(i);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::NONE() {
  return getToken(MySqlParser::NONE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::GrantStatementContext::OPTION() {
  return getTokens(MySqlParser::OPTION);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::OPTION(size_t i) {
  return getToken(MySqlParser::OPTION, i);
}

std::vector<MySqlParser::UserResourceOptionContext *> MySqlParser::GrantStatementContext::userResourceOption() {
  return getRuleContexts<MySqlParser::UserResourceOptionContext>();
}

MySqlParser::UserResourceOptionContext* MySqlParser::GrantStatementContext::userResourceOption(size_t i) {
  return getRuleContext<MySqlParser::UserResourceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::GrantStatementContext::AND() {
  return getTokens(MySqlParser::AND);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::AND(size_t i) {
  return getToken(MySqlParser::AND, i);
}

std::vector<MySqlParser::UidContext *> MySqlParser::GrantStatementContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::GrantStatementContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

tree::TerminalNode* MySqlParser::GrantStatementContext::ADMIN() {
  return getToken(MySqlParser::ADMIN, 0);
}


size_t MySqlParser::GrantStatementContext::getRuleIndex() const {
  return MySqlParser::RuleGrantStatement;
}

void MySqlParser::GrantStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantStatement(this);
}

void MySqlParser::GrantStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantStatement(this);
}


std::any MySqlParser::GrantStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitGrantStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::GrantStatementContext* MySqlParser::grantStatement() {
  GrantStatementContext *_localctx = _tracker.createInstance<GrantStatementContext>(_ctx, getState());
  enterRule(_localctx, 428, MySqlParser::RuleGrantStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(5173);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 764, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5080);
      match(MySqlParser::GRANT);
      setState(5081);
      privelegeClause();
      setState(5086);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5082);
        match(MySqlParser::COMMA);
        setState(5083);
        privelegeClause();
        setState(5088);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(5089);
      match(MySqlParser::ON);
      setState(5091);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 747, _ctx)) {
      case 1: {
        setState(5090);
        antlrcpp::downCast<GrantStatementContext *>(_localctx)->privilegeObject = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::PROCEDURE

        || _la == MySqlParser::TABLE || _la == MySqlParser::FUNCTION)) {
          antlrcpp::downCast<GrantStatementContext *>(_localctx)->privilegeObject = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
      }
      setState(5093);
      privilegeLevel();
      setState(5094);
      match(MySqlParser::TO);
      setState(5095);
      userAuthOption();
      setState(5100);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5096);
        match(MySqlParser::COMMA);
        setState(5097);
        userAuthOption();
        setState(5102);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(5117);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::REQUIRE) {
        setState(5103);
        match(MySqlParser::REQUIRE);
        setState(5115);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::NONE: {
            setState(5104);
            antlrcpp::downCast<GrantStatementContext *>(_localctx)->tlsNone = match(MySqlParser::NONE);
            break;
          }

          case MySqlParser::SSL:
          case MySqlParser::CIPHER:
          case MySqlParser::ISSUER:
          case MySqlParser::SUBJECT:
          case MySqlParser::X509: {
            setState(5105);
            tlsOption();
            setState(5112);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == MySqlParser::AND || _la == MySqlParser::SSL || _la == MySqlParser::CIPHER || _la == MySqlParser::ISSUER || _la == MySqlParser::SUBJECT

            || _la == MySqlParser::X509) {
              setState(5107);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == MySqlParser::AND) {
                setState(5106);
                match(MySqlParser::AND);
              }
              setState(5109);
              tlsOption();
              setState(5114);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
      }
      setState(5128);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 755, _ctx)) {
      case 1: {
        setState(5119);
        match(MySqlParser::WITH);
        setState(5125);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 754, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(5123);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case MySqlParser::GRANT: {
                setState(5120);
                match(MySqlParser::GRANT);
                setState(5121);
                match(MySqlParser::OPTION);
                break;
              }

              case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
              case MySqlParser::MAX_QUERIES_PER_HOUR:
              case MySqlParser::MAX_UPDATES_PER_HOUR:
              case MySqlParser::MAX_USER_CONNECTIONS: {
                setState(5122);
                userResourceOption();
                break;
              }

            default:
              throw NoViableAltException(this);
            } 
          }
          setState(5127);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 754, _ctx);
        }
        break;
      }

      default:
        break;
      }
      setState(5136);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::AS) {
        setState(5130);
        match(MySqlParser::AS);
        setState(5131);
        userName();
        setState(5132);
        match(MySqlParser::WITH);
        setState(5133);
        match(MySqlParser::ROLE);
        setState(5134);
        roleOption();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5138);
      match(MySqlParser::GRANT);
      setState(5141);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 757, _ctx)) {
      case 1: {
        setState(5139);
        userName();
        break;
      }

      case 2: {
        setState(5140);
        uid();
        break;
      }

      default:
        break;
      }
      setState(5150);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5143);
        match(MySqlParser::COMMA);
        setState(5146);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 758, _ctx)) {
        case 1: {
          setState(5144);
          userName();
          break;
        }

        case 2: {
          setState(5145);
          uid();
          break;
        }

        default:
          break;
        }
        setState(5152);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(5153);
      match(MySqlParser::TO);
      setState(5156);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 760, _ctx)) {
      case 1: {
        setState(5154);
        userName();
        break;
      }

      case 2: {
        setState(5155);
        uid();
        break;
      }

      default:
        break;
      }
      setState(5165);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5158);
        match(MySqlParser::COMMA);
        setState(5161);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 761, _ctx)) {
        case 1: {
          setState(5159);
          userName();
          break;
        }

        case 2: {
          setState(5160);
          uid();
          break;
        }

        default:
          break;
        }
        setState(5167);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(5171);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 763, _ctx)) {
      case 1: {
        setState(5168);
        match(MySqlParser::WITH);
        setState(5169);
        match(MySqlParser::ADMIN);
        setState(5170);
        match(MySqlParser::OPTION);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleOptionContext ------------------------------------------------------------------

MySqlParser::RoleOptionContext::RoleOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::RoleOptionContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::RoleOptionContext::NONE() {
  return getToken(MySqlParser::NONE, 0);
}

tree::TerminalNode* MySqlParser::RoleOptionContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

tree::TerminalNode* MySqlParser::RoleOptionContext::EXCEPT() {
  return getToken(MySqlParser::EXCEPT, 0);
}

std::vector<MySqlParser::UserNameContext *> MySqlParser::RoleOptionContext::userName() {
  return getRuleContexts<MySqlParser::UserNameContext>();
}

MySqlParser::UserNameContext* MySqlParser::RoleOptionContext::userName(size_t i) {
  return getRuleContext<MySqlParser::UserNameContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::RoleOptionContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::RoleOptionContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::RoleOptionContext::getRuleIndex() const {
  return MySqlParser::RuleRoleOption;
}

void MySqlParser::RoleOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleOption(this);
}

void MySqlParser::RoleOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleOption(this);
}


std::any MySqlParser::RoleOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRoleOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::RoleOptionContext* MySqlParser::roleOption() {
  RoleOptionContext *_localctx = _tracker.createInstance<RoleOptionContext>(_ctx, getState());
  enterRule(_localctx, 430, MySqlParser::RuleRoleOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5197);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 768, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5175);
      match(MySqlParser::DEFAULT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5176);
      match(MySqlParser::NONE);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5177);
      match(MySqlParser::ALL);
      setState(5187);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::EXCEPT) {
        setState(5178);
        match(MySqlParser::EXCEPT);
        setState(5179);
        userName();
        setState(5184);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySqlParser::COMMA) {
          setState(5180);
          match(MySqlParser::COMMA);
          setState(5181);
          userName();
          setState(5186);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5189);
      userName();
      setState(5194);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5190);
        match(MySqlParser::COMMA);
        setState(5191);
        userName();
        setState(5196);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantProxyContext ------------------------------------------------------------------

MySqlParser::GrantProxyContext::GrantProxyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySqlParser::GrantProxyContext::GRANT() {
  return getTokens(MySqlParser::GRANT);
}

tree::TerminalNode* MySqlParser::GrantProxyContext::GRANT(size_t i) {
  return getToken(MySqlParser::GRANT, i);
}

tree::TerminalNode* MySqlParser::GrantProxyContext::PROXY() {
  return getToken(MySqlParser::PROXY, 0);
}

tree::TerminalNode* MySqlParser::GrantProxyContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

tree::TerminalNode* MySqlParser::GrantProxyContext::TO() {
  return getToken(MySqlParser::TO, 0);
}

std::vector<MySqlParser::UserNameContext *> MySqlParser::GrantProxyContext::userName() {
  return getRuleContexts<MySqlParser::UserNameContext>();
}

MySqlParser::UserNameContext* MySqlParser::GrantProxyContext::userName(size_t i) {
  return getRuleContext<MySqlParser::UserNameContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::GrantProxyContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::GrantProxyContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::GrantProxyContext::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

tree::TerminalNode* MySqlParser::GrantProxyContext::OPTION() {
  return getToken(MySqlParser::OPTION, 0);
}


size_t MySqlParser::GrantProxyContext::getRuleIndex() const {
  return MySqlParser::RuleGrantProxy;
}

void MySqlParser::GrantProxyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantProxy(this);
}

void MySqlParser::GrantProxyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantProxy(this);
}


std::any MySqlParser::GrantProxyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitGrantProxy(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::GrantProxyContext* MySqlParser::grantProxy() {
  GrantProxyContext *_localctx = _tracker.createInstance<GrantProxyContext>(_ctx, getState());
  enterRule(_localctx, 432, MySqlParser::RuleGrantProxy);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5199);
    match(MySqlParser::GRANT);
    setState(5200);
    match(MySqlParser::PROXY);
    setState(5201);
    match(MySqlParser::ON);
    setState(5202);
    antlrcpp::downCast<GrantProxyContext *>(_localctx)->fromFirst = userName();
    setState(5203);
    match(MySqlParser::TO);
    setState(5204);
    antlrcpp::downCast<GrantProxyContext *>(_localctx)->toFirst = userName();
    setState(5209);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(5205);
      match(MySqlParser::COMMA);
      setState(5206);
      antlrcpp::downCast<GrantProxyContext *>(_localctx)->userNameContext = userName();
      antlrcpp::downCast<GrantProxyContext *>(_localctx)->toOther.push_back(antlrcpp::downCast<GrantProxyContext *>(_localctx)->userNameContext);
      setState(5211);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5215);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 770, _ctx)) {
    case 1: {
      setState(5212);
      match(MySqlParser::WITH);
      setState(5213);
      match(MySqlParser::GRANT);
      setState(5214);
      match(MySqlParser::OPTION);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenameUserContext ------------------------------------------------------------------

MySqlParser::RenameUserContext::RenameUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::RenameUserContext::RENAME() {
  return getToken(MySqlParser::RENAME, 0);
}

tree::TerminalNode* MySqlParser::RenameUserContext::USER() {
  return getToken(MySqlParser::USER, 0);
}

std::vector<MySqlParser::RenameUserClauseContext *> MySqlParser::RenameUserContext::renameUserClause() {
  return getRuleContexts<MySqlParser::RenameUserClauseContext>();
}

MySqlParser::RenameUserClauseContext* MySqlParser::RenameUserContext::renameUserClause(size_t i) {
  return getRuleContext<MySqlParser::RenameUserClauseContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::RenameUserContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::RenameUserContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::RenameUserContext::getRuleIndex() const {
  return MySqlParser::RuleRenameUser;
}

void MySqlParser::RenameUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameUser(this);
}

void MySqlParser::RenameUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameUser(this);
}


std::any MySqlParser::RenameUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRenameUser(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::RenameUserContext* MySqlParser::renameUser() {
  RenameUserContext *_localctx = _tracker.createInstance<RenameUserContext>(_ctx, getState());
  enterRule(_localctx, 434, MySqlParser::RuleRenameUser);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5217);
    match(MySqlParser::RENAME);
    setState(5218);
    match(MySqlParser::USER);
    setState(5219);
    renameUserClause();
    setState(5224);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(5220);
      match(MySqlParser::COMMA);
      setState(5221);
      renameUserClause();
      setState(5226);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RevokeStatementContext ------------------------------------------------------------------

MySqlParser::RevokeStatementContext::RevokeStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::RevokeStatementContext::getRuleIndex() const {
  return MySqlParser::RuleRevokeStatement;
}

void MySqlParser::RevokeStatementContext::copyFrom(RevokeStatementContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DetailRevokeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::DetailRevokeContext::REVOKE() {
  return getToken(MySqlParser::REVOKE, 0);
}

std::vector<MySqlParser::PrivelegeClauseContext *> MySqlParser::DetailRevokeContext::privelegeClause() {
  return getRuleContexts<MySqlParser::PrivelegeClauseContext>();
}

MySqlParser::PrivelegeClauseContext* MySqlParser::DetailRevokeContext::privelegeClause(size_t i) {
  return getRuleContext<MySqlParser::PrivelegeClauseContext>(i);
}

tree::TerminalNode* MySqlParser::DetailRevokeContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

MySqlParser::PrivilegeLevelContext* MySqlParser::DetailRevokeContext::privilegeLevel() {
  return getRuleContext<MySqlParser::PrivilegeLevelContext>(0);
}

tree::TerminalNode* MySqlParser::DetailRevokeContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

std::vector<MySqlParser::UserNameContext *> MySqlParser::DetailRevokeContext::userName() {
  return getRuleContexts<MySqlParser::UserNameContext>();
}

MySqlParser::UserNameContext* MySqlParser::DetailRevokeContext::userName(size_t i) {
  return getRuleContext<MySqlParser::UserNameContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::DetailRevokeContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::DetailRevokeContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::DetailRevokeContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

tree::TerminalNode* MySqlParser::DetailRevokeContext::FUNCTION() {
  return getToken(MySqlParser::FUNCTION, 0);
}

tree::TerminalNode* MySqlParser::DetailRevokeContext::PROCEDURE() {
  return getToken(MySqlParser::PROCEDURE, 0);
}

MySqlParser::DetailRevokeContext::DetailRevokeContext(RevokeStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::DetailRevokeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDetailRevoke(this);
}
void MySqlParser::DetailRevokeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDetailRevoke(this);
}

std::any MySqlParser::DetailRevokeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDetailRevoke(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RoleRevokeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::RoleRevokeContext::REVOKE() {
  return getToken(MySqlParser::REVOKE, 0);
}

tree::TerminalNode* MySqlParser::RoleRevokeContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

std::vector<MySqlParser::UserNameContext *> MySqlParser::RoleRevokeContext::userName() {
  return getRuleContexts<MySqlParser::UserNameContext>();
}

MySqlParser::UserNameContext* MySqlParser::RoleRevokeContext::userName(size_t i) {
  return getRuleContext<MySqlParser::UserNameContext>(i);
}

std::vector<MySqlParser::UidContext *> MySqlParser::RoleRevokeContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::RoleRevokeContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::RoleRevokeContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::RoleRevokeContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::RoleRevokeContext::RoleRevokeContext(RevokeStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::RoleRevokeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleRevoke(this);
}
void MySqlParser::RoleRevokeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleRevoke(this);
}

std::any MySqlParser::RoleRevokeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRoleRevoke(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShortRevokeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShortRevokeContext::REVOKE() {
  return getToken(MySqlParser::REVOKE, 0);
}

tree::TerminalNode* MySqlParser::ShortRevokeContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::ShortRevokeContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::ShortRevokeContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::ShortRevokeContext::GRANT() {
  return getToken(MySqlParser::GRANT, 0);
}

tree::TerminalNode* MySqlParser::ShortRevokeContext::OPTION() {
  return getToken(MySqlParser::OPTION, 0);
}

tree::TerminalNode* MySqlParser::ShortRevokeContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

std::vector<MySqlParser::UserNameContext *> MySqlParser::ShortRevokeContext::userName() {
  return getRuleContexts<MySqlParser::UserNameContext>();
}

MySqlParser::UserNameContext* MySqlParser::ShortRevokeContext::userName(size_t i) {
  return getRuleContext<MySqlParser::UserNameContext>(i);
}

tree::TerminalNode* MySqlParser::ShortRevokeContext::PRIVILEGES() {
  return getToken(MySqlParser::PRIVILEGES, 0);
}

MySqlParser::ShortRevokeContext::ShortRevokeContext(RevokeStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShortRevokeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShortRevoke(this);
}
void MySqlParser::ShortRevokeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShortRevoke(this);
}

std::any MySqlParser::ShortRevokeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShortRevoke(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::RevokeStatementContext* MySqlParser::revokeStatement() {
  RevokeStatementContext *_localctx = _tracker.createInstance<RevokeStatementContext>(_ctx, getState());
  enterRule(_localctx, 436, MySqlParser::RuleRevokeStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5297);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 783, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::DetailRevokeContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(5227);
      match(MySqlParser::REVOKE);
      setState(5228);
      privelegeClause();
      setState(5233);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5229);
        match(MySqlParser::COMMA);
        setState(5230);
        privelegeClause();
        setState(5235);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(5236);
      match(MySqlParser::ON);
      setState(5238);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 773, _ctx)) {
      case 1: {
        setState(5237);
        antlrcpp::downCast<DetailRevokeContext *>(_localctx)->privilegeObject = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::PROCEDURE

        || _la == MySqlParser::TABLE || _la == MySqlParser::FUNCTION)) {
          antlrcpp::downCast<DetailRevokeContext *>(_localctx)->privilegeObject = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
      }
      setState(5240);
      privilegeLevel();
      setState(5241);
      match(MySqlParser::FROM);
      setState(5242);
      userName();
      setState(5247);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5243);
        match(MySqlParser::COMMA);
        setState(5244);
        userName();
        setState(5249);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::ShortRevokeContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(5250);
      match(MySqlParser::REVOKE);
      setState(5251);
      match(MySqlParser::ALL);
      setState(5253);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::PRIVILEGES) {
        setState(5252);
        match(MySqlParser::PRIVILEGES);
      }
      setState(5255);
      match(MySqlParser::COMMA);
      setState(5256);
      match(MySqlParser::GRANT);
      setState(5257);
      match(MySqlParser::OPTION);
      setState(5258);
      match(MySqlParser::FROM);
      setState(5259);
      userName();
      setState(5264);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5260);
        match(MySqlParser::COMMA);
        setState(5261);
        userName();
        setState(5266);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::RoleRevokeContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(5267);
      match(MySqlParser::REVOKE);
      setState(5270);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 777, _ctx)) {
      case 1: {
        setState(5268);
        userName();
        break;
      }

      case 2: {
        setState(5269);
        uid();
        break;
      }

      default:
        break;
      }
      setState(5279);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5272);
        match(MySqlParser::COMMA);
        setState(5275);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 778, _ctx)) {
        case 1: {
          setState(5273);
          userName();
          break;
        }

        case 2: {
          setState(5274);
          uid();
          break;
        }

        default:
          break;
        }
        setState(5281);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(5282);
      match(MySqlParser::FROM);
      setState(5285);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 780, _ctx)) {
      case 1: {
        setState(5283);
        userName();
        break;
      }

      case 2: {
        setState(5284);
        uid();
        break;
      }

      default:
        break;
      }
      setState(5294);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5287);
        match(MySqlParser::COMMA);
        setState(5290);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 781, _ctx)) {
        case 1: {
          setState(5288);
          userName();
          break;
        }

        case 2: {
          setState(5289);
          uid();
          break;
        }

        default:
          break;
        }
        setState(5296);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RevokeProxyContext ------------------------------------------------------------------

MySqlParser::RevokeProxyContext::RevokeProxyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::RevokeProxyContext::REVOKE() {
  return getToken(MySqlParser::REVOKE, 0);
}

tree::TerminalNode* MySqlParser::RevokeProxyContext::PROXY() {
  return getToken(MySqlParser::PROXY, 0);
}

tree::TerminalNode* MySqlParser::RevokeProxyContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

tree::TerminalNode* MySqlParser::RevokeProxyContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

std::vector<MySqlParser::UserNameContext *> MySqlParser::RevokeProxyContext::userName() {
  return getRuleContexts<MySqlParser::UserNameContext>();
}

MySqlParser::UserNameContext* MySqlParser::RevokeProxyContext::userName(size_t i) {
  return getRuleContext<MySqlParser::UserNameContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::RevokeProxyContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::RevokeProxyContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::RevokeProxyContext::getRuleIndex() const {
  return MySqlParser::RuleRevokeProxy;
}

void MySqlParser::RevokeProxyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRevokeProxy(this);
}

void MySqlParser::RevokeProxyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRevokeProxy(this);
}


std::any MySqlParser::RevokeProxyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRevokeProxy(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::RevokeProxyContext* MySqlParser::revokeProxy() {
  RevokeProxyContext *_localctx = _tracker.createInstance<RevokeProxyContext>(_ctx, getState());
  enterRule(_localctx, 438, MySqlParser::RuleRevokeProxy);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5299);
    match(MySqlParser::REVOKE);
    setState(5300);
    match(MySqlParser::PROXY);
    setState(5301);
    match(MySqlParser::ON);
    setState(5302);
    antlrcpp::downCast<RevokeProxyContext *>(_localctx)->onUser = userName();
    setState(5303);
    match(MySqlParser::FROM);
    setState(5304);
    antlrcpp::downCast<RevokeProxyContext *>(_localctx)->fromFirst = userName();
    setState(5309);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(5305);
      match(MySqlParser::COMMA);
      setState(5306);
      antlrcpp::downCast<RevokeProxyContext *>(_localctx)->userNameContext = userName();
      antlrcpp::downCast<RevokeProxyContext *>(_localctx)->fromOther.push_back(antlrcpp::downCast<RevokeProxyContext *>(_localctx)->userNameContext);
      setState(5311);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetPasswordStatementContext ------------------------------------------------------------------

MySqlParser::SetPasswordStatementContext::SetPasswordStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SetPasswordStatementContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::SetPasswordStatementContext::PASSWORD() {
  return getToken(MySqlParser::PASSWORD, 0);
}

tree::TerminalNode* MySqlParser::SetPasswordStatementContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

MySqlParser::PasswordFunctionClauseContext* MySqlParser::SetPasswordStatementContext::passwordFunctionClause() {
  return getRuleContext<MySqlParser::PasswordFunctionClauseContext>(0);
}

tree::TerminalNode* MySqlParser::SetPasswordStatementContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::SetPasswordStatementContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

MySqlParser::UserNameContext* MySqlParser::SetPasswordStatementContext::userName() {
  return getRuleContext<MySqlParser::UserNameContext>(0);
}


size_t MySqlParser::SetPasswordStatementContext::getRuleIndex() const {
  return MySqlParser::RuleSetPasswordStatement;
}

void MySqlParser::SetPasswordStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetPasswordStatement(this);
}

void MySqlParser::SetPasswordStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetPasswordStatement(this);
}


std::any MySqlParser::SetPasswordStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSetPasswordStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SetPasswordStatementContext* MySqlParser::setPasswordStatement() {
  SetPasswordStatementContext *_localctx = _tracker.createInstance<SetPasswordStatementContext>(_ctx, getState());
  enterRule(_localctx, 440, MySqlParser::RuleSetPasswordStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5312);
    match(MySqlParser::SET);
    setState(5313);
    match(MySqlParser::PASSWORD);
    setState(5316);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::FOR) {
      setState(5314);
      match(MySqlParser::FOR);
      setState(5315);
      userName();
    }
    setState(5318);
    match(MySqlParser::EQUAL_SYMBOL);
    setState(5321);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::OLD_PASSWORD:
      case MySqlParser::PASSWORD: {
        setState(5319);
        passwordFunctionClause();
        break;
      }

      case MySqlParser::STRING_LITERAL: {
        setState(5320);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserSpecificationContext ------------------------------------------------------------------

MySqlParser::UserSpecificationContext::UserSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::UserNameContext* MySqlParser::UserSpecificationContext::userName() {
  return getRuleContext<MySqlParser::UserNameContext>(0);
}

MySqlParser::UserPasswordOptionContext* MySqlParser::UserSpecificationContext::userPasswordOption() {
  return getRuleContext<MySqlParser::UserPasswordOptionContext>(0);
}


size_t MySqlParser::UserSpecificationContext::getRuleIndex() const {
  return MySqlParser::RuleUserSpecification;
}

void MySqlParser::UserSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserSpecification(this);
}

void MySqlParser::UserSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserSpecification(this);
}


std::any MySqlParser::UserSpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUserSpecification(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UserSpecificationContext* MySqlParser::userSpecification() {
  UserSpecificationContext *_localctx = _tracker.createInstance<UserSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 442, MySqlParser::RuleUserSpecification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5323);
    userName();
    setState(5324);
    userPasswordOption();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserAuthOptionContext ------------------------------------------------------------------

MySqlParser::UserAuthOptionContext::UserAuthOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::UserAuthOptionContext::getRuleIndex() const {
  return MySqlParser::RuleUserAuthOption;
}

void MySqlParser::UserAuthOptionContext::copyFrom(UserAuthOptionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SimpleAuthOptionContext ------------------------------------------------------------------

MySqlParser::UserNameContext* MySqlParser::SimpleAuthOptionContext::userName() {
  return getRuleContext<MySqlParser::UserNameContext>(0);
}

MySqlParser::SimpleAuthOptionContext::SimpleAuthOptionContext(UserAuthOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::SimpleAuthOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleAuthOption(this);
}
void MySqlParser::SimpleAuthOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleAuthOption(this);
}

std::any MySqlParser::SimpleAuthOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSimpleAuthOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ModuleAuthOptionContext ------------------------------------------------------------------

MySqlParser::UserNameContext* MySqlParser::ModuleAuthOptionContext::userName() {
  return getRuleContext<MySqlParser::UserNameContext>(0);
}

tree::TerminalNode* MySqlParser::ModuleAuthOptionContext::IDENTIFIED() {
  return getToken(MySqlParser::IDENTIFIED, 0);
}

tree::TerminalNode* MySqlParser::ModuleAuthOptionContext::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

MySqlParser::AuthenticationRuleContext* MySqlParser::ModuleAuthOptionContext::authenticationRule() {
  return getRuleContext<MySqlParser::AuthenticationRuleContext>(0);
}

MySqlParser::ModuleAuthOptionContext::ModuleAuthOptionContext(UserAuthOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::ModuleAuthOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleAuthOption(this);
}
void MySqlParser::ModuleAuthOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleAuthOption(this);
}

std::any MySqlParser::ModuleAuthOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitModuleAuthOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- StringAuthOptionContext ------------------------------------------------------------------

MySqlParser::UserNameContext* MySqlParser::StringAuthOptionContext::userName() {
  return getRuleContext<MySqlParser::UserNameContext>(0);
}

tree::TerminalNode* MySqlParser::StringAuthOptionContext::IDENTIFIED() {
  return getToken(MySqlParser::IDENTIFIED, 0);
}

tree::TerminalNode* MySqlParser::StringAuthOptionContext::BY() {
  return getToken(MySqlParser::BY, 0);
}

tree::TerminalNode* MySqlParser::StringAuthOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::StringAuthOptionContext::RETAIN() {
  return getToken(MySqlParser::RETAIN, 0);
}

tree::TerminalNode* MySqlParser::StringAuthOptionContext::CURRENT() {
  return getToken(MySqlParser::CURRENT, 0);
}

tree::TerminalNode* MySqlParser::StringAuthOptionContext::PASSWORD() {
  return getToken(MySqlParser::PASSWORD, 0);
}

MySqlParser::StringAuthOptionContext::StringAuthOptionContext(UserAuthOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::StringAuthOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringAuthOption(this);
}
void MySqlParser::StringAuthOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringAuthOption(this);
}

std::any MySqlParser::StringAuthOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitStringAuthOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- HashAuthOptionContext ------------------------------------------------------------------

MySqlParser::UserNameContext* MySqlParser::HashAuthOptionContext::userName() {
  return getRuleContext<MySqlParser::UserNameContext>(0);
}

tree::TerminalNode* MySqlParser::HashAuthOptionContext::IDENTIFIED() {
  return getToken(MySqlParser::IDENTIFIED, 0);
}

tree::TerminalNode* MySqlParser::HashAuthOptionContext::BY() {
  return getToken(MySqlParser::BY, 0);
}

tree::TerminalNode* MySqlParser::HashAuthOptionContext::PASSWORD() {
  return getToken(MySqlParser::PASSWORD, 0);
}

tree::TerminalNode* MySqlParser::HashAuthOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

MySqlParser::HashAuthOptionContext::HashAuthOptionContext(UserAuthOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::HashAuthOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHashAuthOption(this);
}
void MySqlParser::HashAuthOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHashAuthOption(this);
}

std::any MySqlParser::HashAuthOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHashAuthOption(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::UserAuthOptionContext* MySqlParser::userAuthOption() {
  UserAuthOptionContext *_localctx = _tracker.createInstance<UserAuthOptionContext>(_ctx, getState());
  enterRule(_localctx, 444, MySqlParser::RuleUserAuthOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5347);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 788, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::HashAuthOptionContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(5326);
      userName();
      setState(5327);
      match(MySqlParser::IDENTIFIED);
      setState(5328);
      match(MySqlParser::BY);
      setState(5329);
      match(MySqlParser::PASSWORD);
      setState(5330);
      antlrcpp::downCast<HashAuthOptionContext *>(_localctx)->hashed = match(MySqlParser::STRING_LITERAL);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::StringAuthOptionContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(5332);
      userName();
      setState(5333);
      match(MySqlParser::IDENTIFIED);
      setState(5334);
      match(MySqlParser::BY);
      setState(5335);
      match(MySqlParser::STRING_LITERAL);
      setState(5339);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::RETAIN) {
        setState(5336);
        match(MySqlParser::RETAIN);
        setState(5337);
        match(MySqlParser::CURRENT);
        setState(5338);
        match(MySqlParser::PASSWORD);
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::ModuleAuthOptionContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(5341);
      userName();
      setState(5342);
      match(MySqlParser::IDENTIFIED);
      setState(5343);
      match(MySqlParser::WITH);
      setState(5344);
      authenticationRule();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::SimpleAuthOptionContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(5346);
      userName();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AuthenticationRuleContext ------------------------------------------------------------------

MySqlParser::AuthenticationRuleContext::AuthenticationRuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::AuthenticationRuleContext::getRuleIndex() const {
  return MySqlParser::RuleAuthenticationRule;
}

void MySqlParser::AuthenticationRuleContext::copyFrom(AuthenticationRuleContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PasswordModuleOptionContext ------------------------------------------------------------------

MySqlParser::AuthPluginContext* MySqlParser::PasswordModuleOptionContext::authPlugin() {
  return getRuleContext<MySqlParser::AuthPluginContext>(0);
}

tree::TerminalNode* MySqlParser::PasswordModuleOptionContext::USING() {
  return getToken(MySqlParser::USING, 0);
}

MySqlParser::PasswordFunctionClauseContext* MySqlParser::PasswordModuleOptionContext::passwordFunctionClause() {
  return getRuleContext<MySqlParser::PasswordFunctionClauseContext>(0);
}

MySqlParser::PasswordModuleOptionContext::PasswordModuleOptionContext(AuthenticationRuleContext *ctx) { copyFrom(ctx); }

void MySqlParser::PasswordModuleOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPasswordModuleOption(this);
}
void MySqlParser::PasswordModuleOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPasswordModuleOption(this);
}

std::any MySqlParser::PasswordModuleOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPasswordModuleOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ModuleContext ------------------------------------------------------------------

MySqlParser::AuthPluginContext* MySqlParser::ModuleContext::authPlugin() {
  return getRuleContext<MySqlParser::AuthPluginContext>(0);
}

tree::TerminalNode* MySqlParser::ModuleContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::ModuleContext::BY() {
  return getToken(MySqlParser::BY, 0);
}

tree::TerminalNode* MySqlParser::ModuleContext::USING() {
  return getToken(MySqlParser::USING, 0);
}

tree::TerminalNode* MySqlParser::ModuleContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

MySqlParser::ModuleContext::ModuleContext(AuthenticationRuleContext *ctx) { copyFrom(ctx); }

void MySqlParser::ModuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule(this);
}
void MySqlParser::ModuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule(this);
}

std::any MySqlParser::ModuleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitModule(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::AuthenticationRuleContext* MySqlParser::authenticationRule() {
  AuthenticationRuleContext *_localctx = _tracker.createInstance<AuthenticationRuleContext>(_ctx, getState());
  enterRule(_localctx, 446, MySqlParser::RuleAuthenticationRule);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5358);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 790, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::ModuleContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(5349);
      authPlugin();
      setState(5352);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 789, _ctx)) {
      case 1: {
        setState(5350);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::AS

        || _la == MySqlParser::BY || _la == MySqlParser::USING)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5351);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::PasswordModuleOptionContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(5354);
      authPlugin();
      setState(5355);
      match(MySqlParser::USING);
      setState(5356);
      passwordFunctionClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TlsOptionContext ------------------------------------------------------------------

MySqlParser::TlsOptionContext::TlsOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::TlsOptionContext::SSL() {
  return getToken(MySqlParser::SSL, 0);
}

tree::TerminalNode* MySqlParser::TlsOptionContext::X509() {
  return getToken(MySqlParser::X509, 0);
}

tree::TerminalNode* MySqlParser::TlsOptionContext::CIPHER() {
  return getToken(MySqlParser::CIPHER, 0);
}

tree::TerminalNode* MySqlParser::TlsOptionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::TlsOptionContext::ISSUER() {
  return getToken(MySqlParser::ISSUER, 0);
}

tree::TerminalNode* MySqlParser::TlsOptionContext::SUBJECT() {
  return getToken(MySqlParser::SUBJECT, 0);
}


size_t MySqlParser::TlsOptionContext::getRuleIndex() const {
  return MySqlParser::RuleTlsOption;
}

void MySqlParser::TlsOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTlsOption(this);
}

void MySqlParser::TlsOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTlsOption(this);
}


std::any MySqlParser::TlsOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTlsOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TlsOptionContext* MySqlParser::tlsOption() {
  TlsOptionContext *_localctx = _tracker.createInstance<TlsOptionContext>(_ctx, getState());
  enterRule(_localctx, 448, MySqlParser::RuleTlsOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5368);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::SSL: {
        enterOuterAlt(_localctx, 1);
        setState(5360);
        match(MySqlParser::SSL);
        break;
      }

      case MySqlParser::X509: {
        enterOuterAlt(_localctx, 2);
        setState(5361);
        match(MySqlParser::X509);
        break;
      }

      case MySqlParser::CIPHER: {
        enterOuterAlt(_localctx, 3);
        setState(5362);
        match(MySqlParser::CIPHER);
        setState(5363);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::ISSUER: {
        enterOuterAlt(_localctx, 4);
        setState(5364);
        match(MySqlParser::ISSUER);
        setState(5365);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::SUBJECT: {
        enterOuterAlt(_localctx, 5);
        setState(5366);
        match(MySqlParser::SUBJECT);
        setState(5367);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserResourceOptionContext ------------------------------------------------------------------

MySqlParser::UserResourceOptionContext::UserResourceOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::UserResourceOptionContext::MAX_QUERIES_PER_HOUR() {
  return getToken(MySqlParser::MAX_QUERIES_PER_HOUR, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::UserResourceOptionContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::UserResourceOptionContext::MAX_UPDATES_PER_HOUR() {
  return getToken(MySqlParser::MAX_UPDATES_PER_HOUR, 0);
}

tree::TerminalNode* MySqlParser::UserResourceOptionContext::MAX_CONNECTIONS_PER_HOUR() {
  return getToken(MySqlParser::MAX_CONNECTIONS_PER_HOUR, 0);
}

tree::TerminalNode* MySqlParser::UserResourceOptionContext::MAX_USER_CONNECTIONS() {
  return getToken(MySqlParser::MAX_USER_CONNECTIONS, 0);
}


size_t MySqlParser::UserResourceOptionContext::getRuleIndex() const {
  return MySqlParser::RuleUserResourceOption;
}

void MySqlParser::UserResourceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserResourceOption(this);
}

void MySqlParser::UserResourceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserResourceOption(this);
}


std::any MySqlParser::UserResourceOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUserResourceOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UserResourceOptionContext* MySqlParser::userResourceOption() {
  UserResourceOptionContext *_localctx = _tracker.createInstance<UserResourceOptionContext>(_ctx, getState());
  enterRule(_localctx, 450, MySqlParser::RuleUserResourceOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5378);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::MAX_QUERIES_PER_HOUR: {
        enterOuterAlt(_localctx, 1);
        setState(5370);
        match(MySqlParser::MAX_QUERIES_PER_HOUR);
        setState(5371);
        decimalLiteral();
        break;
      }

      case MySqlParser::MAX_UPDATES_PER_HOUR: {
        enterOuterAlt(_localctx, 2);
        setState(5372);
        match(MySqlParser::MAX_UPDATES_PER_HOUR);
        setState(5373);
        decimalLiteral();
        break;
      }

      case MySqlParser::MAX_CONNECTIONS_PER_HOUR: {
        enterOuterAlt(_localctx, 3);
        setState(5374);
        match(MySqlParser::MAX_CONNECTIONS_PER_HOUR);
        setState(5375);
        decimalLiteral();
        break;
      }

      case MySqlParser::MAX_USER_CONNECTIONS: {
        enterOuterAlt(_localctx, 4);
        setState(5376);
        match(MySqlParser::MAX_USER_CONNECTIONS);
        setState(5377);
        decimalLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserPasswordOptionContext ------------------------------------------------------------------

MySqlParser::UserPasswordOptionContext::UserPasswordOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::PASSWORD() {
  return getToken(MySqlParser::PASSWORD, 0);
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::EXPIRE() {
  return getToken(MySqlParser::EXPIRE, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::UserPasswordOptionContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::DAY() {
  return getToken(MySqlParser::DAY, 0);
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::NEVER() {
  return getToken(MySqlParser::NEVER, 0);
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::INTERVAL() {
  return getToken(MySqlParser::INTERVAL, 0);
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::HISTORY() {
  return getToken(MySqlParser::HISTORY, 0);
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::REUSE() {
  return getToken(MySqlParser::REUSE, 0);
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::REQUIRE() {
  return getToken(MySqlParser::REQUIRE, 0);
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::CURRENT() {
  return getToken(MySqlParser::CURRENT, 0);
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::OPTIONAL() {
  return getToken(MySqlParser::OPTIONAL, 0);
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::FAILED_LOGIN_ATTEMPTS() {
  return getToken(MySqlParser::FAILED_LOGIN_ATTEMPTS, 0);
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::PASSWORD_LOCK_TIME() {
  return getToken(MySqlParser::PASSWORD_LOCK_TIME, 0);
}

tree::TerminalNode* MySqlParser::UserPasswordOptionContext::UNBOUNDED() {
  return getToken(MySqlParser::UNBOUNDED, 0);
}


size_t MySqlParser::UserPasswordOptionContext::getRuleIndex() const {
  return MySqlParser::RuleUserPasswordOption;
}

void MySqlParser::UserPasswordOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserPasswordOption(this);
}

void MySqlParser::UserPasswordOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserPasswordOption(this);
}


std::any MySqlParser::UserPasswordOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUserPasswordOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UserPasswordOptionContext* MySqlParser::userPasswordOption() {
  UserPasswordOptionContext *_localctx = _tracker.createInstance<UserPasswordOptionContext>(_ctx, getState());
  enterRule(_localctx, 452, MySqlParser::RuleUserPasswordOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5418);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 798, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5380);
      match(MySqlParser::PASSWORD);
      setState(5381);
      match(MySqlParser::EXPIRE);
      setState(5388);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::DEFAULT: {
          setState(5382);
          antlrcpp::downCast<UserPasswordOptionContext *>(_localctx)->expireType = match(MySqlParser::DEFAULT);
          break;
        }

        case MySqlParser::NEVER: {
          setState(5383);
          antlrcpp::downCast<UserPasswordOptionContext *>(_localctx)->expireType = match(MySqlParser::NEVER);
          break;
        }

        case MySqlParser::INTERVAL: {
          setState(5384);
          antlrcpp::downCast<UserPasswordOptionContext *>(_localctx)->expireType = match(MySqlParser::INTERVAL);
          setState(5385);
          decimalLiteral();
          setState(5386);
          match(MySqlParser::DAY);
          break;
        }

        case MySqlParser::EOF:
        case MySqlParser::ALTER:
        case MySqlParser::ANALYZE:
        case MySqlParser::ATTRIBUTE:
        case MySqlParser::CALL:
        case MySqlParser::CHANGE:
        case MySqlParser::CHECK:
        case MySqlParser::CREATE:
        case MySqlParser::DELETE:
        case MySqlParser::DESC:
        case MySqlParser::DESCRIBE:
        case MySqlParser::DROP:
        case MySqlParser::EXPLAIN:
        case MySqlParser::GET:
        case MySqlParser::GRANT:
        case MySqlParser::INSERT:
        case MySqlParser::KILL:
        case MySqlParser::LOAD:
        case MySqlParser::LOCK:
        case MySqlParser::OPTIMIZE:
        case MySqlParser::PURGE:
        case MySqlParser::RELEASE:
        case MySqlParser::RENAME:
        case MySqlParser::REPLACE:
        case MySqlParser::RESIGNAL:
        case MySqlParser::REVOKE:
        case MySqlParser::SELECT:
        case MySqlParser::SET:
        case MySqlParser::SHOW:
        case MySqlParser::SIGNAL:
        case MySqlParser::TABLE:
        case MySqlParser::UNLOCK:
        case MySqlParser::UPDATE:
        case MySqlParser::USE:
        case MySqlParser::VALUES:
        case MySqlParser::WITH:
        case MySqlParser::ACCOUNT:
        case MySqlParser::BEGIN:
        case MySqlParser::BINLOG:
        case MySqlParser::CACHE:
        case MySqlParser::CHECKSUM:
        case MySqlParser::COMMENT:
        case MySqlParser::COMMIT:
        case MySqlParser::DEALLOCATE:
        case MySqlParser::DO:
        case MySqlParser::FAILED_LOGIN_ATTEMPTS:
        case MySqlParser::FLUSH:
        case MySqlParser::HANDLER:
        case MySqlParser::HELP:
        case MySqlParser::INSTALL:
        case MySqlParser::PASSWORD:
        case MySqlParser::PASSWORD_LOCK_TIME:
        case MySqlParser::PREPARE:
        case MySqlParser::REPAIR:
        case MySqlParser::RESET:
        case MySqlParser::ROLLBACK:
        case MySqlParser::SAVEPOINT:
        case MySqlParser::START:
        case MySqlParser::STOP:
        case MySqlParser::TRUNCATE:
        case MySqlParser::UNINSTALL:
        case MySqlParser::XA:
        case MySqlParser::EXECUTE:
        case MySqlParser::SHUTDOWN:
        case MySqlParser::MINUS:
        case MySqlParser::LR_BRACKET:
        case MySqlParser::COMMA:
        case MySqlParser::SEMI: {
          break;
        }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5390);
      match(MySqlParser::PASSWORD);
      setState(5391);
      match(MySqlParser::HISTORY);
      setState(5394);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::DEFAULT: {
          setState(5392);
          match(MySqlParser::DEFAULT);
          break;
        }

        case MySqlParser::ZERO_DECIMAL:
        case MySqlParser::ONE_DECIMAL:
        case MySqlParser::TWO_DECIMAL:
        case MySqlParser::DECIMAL_LITERAL:
        case MySqlParser::REAL_LITERAL: {
          setState(5393);
          decimalLiteral();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5396);
      match(MySqlParser::PASSWORD);
      setState(5397);
      match(MySqlParser::REUSE);
      setState(5398);
      match(MySqlParser::INTERVAL);
      setState(5403);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::DEFAULT: {
          setState(5399);
          match(MySqlParser::DEFAULT);
          break;
        }

        case MySqlParser::ZERO_DECIMAL:
        case MySqlParser::ONE_DECIMAL:
        case MySqlParser::TWO_DECIMAL:
        case MySqlParser::DECIMAL_LITERAL:
        case MySqlParser::REAL_LITERAL: {
          setState(5400);
          decimalLiteral();
          setState(5401);
          match(MySqlParser::DAY);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5405);
      match(MySqlParser::PASSWORD);
      setState(5406);
      match(MySqlParser::REQUIRE);
      setState(5407);
      match(MySqlParser::CURRENT);
      setState(5409);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::DEFAULT || _la == MySqlParser::OPTIONAL) {
        setState(5408);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::DEFAULT || _la == MySqlParser::OPTIONAL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5411);
      match(MySqlParser::FAILED_LOGIN_ATTEMPTS);
      setState(5412);
      decimalLiteral();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5413);
      match(MySqlParser::PASSWORD_LOCK_TIME);
      setState(5416);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::ZERO_DECIMAL:
        case MySqlParser::ONE_DECIMAL:
        case MySqlParser::TWO_DECIMAL:
        case MySqlParser::DECIMAL_LITERAL:
        case MySqlParser::REAL_LITERAL: {
          setState(5414);
          decimalLiteral();
          break;
        }

        case MySqlParser::UNBOUNDED: {
          setState(5415);
          match(MySqlParser::UNBOUNDED);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserLockOptionContext ------------------------------------------------------------------

MySqlParser::UserLockOptionContext::UserLockOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::UserLockOptionContext::ACCOUNT() {
  return getToken(MySqlParser::ACCOUNT, 0);
}

tree::TerminalNode* MySqlParser::UserLockOptionContext::LOCK() {
  return getToken(MySqlParser::LOCK, 0);
}

tree::TerminalNode* MySqlParser::UserLockOptionContext::UNLOCK() {
  return getToken(MySqlParser::UNLOCK, 0);
}


size_t MySqlParser::UserLockOptionContext::getRuleIndex() const {
  return MySqlParser::RuleUserLockOption;
}

void MySqlParser::UserLockOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserLockOption(this);
}

void MySqlParser::UserLockOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserLockOption(this);
}


std::any MySqlParser::UserLockOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUserLockOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UserLockOptionContext* MySqlParser::userLockOption() {
  UserLockOptionContext *_localctx = _tracker.createInstance<UserLockOptionContext>(_ctx, getState());
  enterRule(_localctx, 454, MySqlParser::RuleUserLockOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5420);
    match(MySqlParser::ACCOUNT);
    setState(5421);
    antlrcpp::downCast<UserLockOptionContext *>(_localctx)->lockType = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::LOCK || _la == MySqlParser::UNLOCK)) {
      antlrcpp::downCast<UserLockOptionContext *>(_localctx)->lockType = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivelegeClauseContext ------------------------------------------------------------------

MySqlParser::PrivelegeClauseContext::PrivelegeClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::PrivilegeContext* MySqlParser::PrivelegeClauseContext::privilege() {
  return getRuleContext<MySqlParser::PrivilegeContext>(0);
}

tree::TerminalNode* MySqlParser::PrivelegeClauseContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::UidListContext* MySqlParser::PrivelegeClauseContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::PrivelegeClauseContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}


size_t MySqlParser::PrivelegeClauseContext::getRuleIndex() const {
  return MySqlParser::RulePrivelegeClause;
}

void MySqlParser::PrivelegeClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivelegeClause(this);
}

void MySqlParser::PrivelegeClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivelegeClause(this);
}


std::any MySqlParser::PrivelegeClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPrivelegeClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::PrivelegeClauseContext* MySqlParser::privelegeClause() {
  PrivelegeClauseContext *_localctx = _tracker.createInstance<PrivelegeClauseContext>(_ctx, getState());
  enterRule(_localctx, 456, MySqlParser::RulePrivelegeClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5423);
    privilege();
    setState(5428);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LR_BRACKET) {
      setState(5424);
      match(MySqlParser::LR_BRACKET);
      setState(5425);
      uidList();
      setState(5426);
      match(MySqlParser::RR_BRACKET);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegeContext ------------------------------------------------------------------

MySqlParser::PrivilegeContext::PrivilegeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::PrivilegeContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::PRIVILEGES() {
  return getToken(MySqlParser::PRIVILEGES, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::ALTER() {
  return getToken(MySqlParser::ALTER, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::ROUTINE() {
  return getToken(MySqlParser::ROUTINE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::TEMPORARY() {
  return getToken(MySqlParser::TEMPORARY, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::TABLES() {
  return getToken(MySqlParser::TABLES, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::VIEW() {
  return getToken(MySqlParser::VIEW, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::USER() {
  return getToken(MySqlParser::USER, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::TABLESPACE() {
  return getToken(MySqlParser::TABLESPACE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::ROLE() {
  return getToken(MySqlParser::ROLE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::DELETE() {
  return getToken(MySqlParser::DELETE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::EVENT() {
  return getToken(MySqlParser::EVENT, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::EXECUTE() {
  return getToken(MySqlParser::EXECUTE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::FILE() {
  return getToken(MySqlParser::FILE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::GRANT() {
  return getToken(MySqlParser::GRANT, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::OPTION() {
  return getToken(MySqlParser::OPTION, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::INSERT() {
  return getToken(MySqlParser::INSERT, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::LOCK() {
  return getToken(MySqlParser::LOCK, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::PROCESS() {
  return getToken(MySqlParser::PROCESS, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::PROXY() {
  return getToken(MySqlParser::PROXY, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::REFERENCES() {
  return getToken(MySqlParser::REFERENCES, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::RELOAD() {
  return getToken(MySqlParser::RELOAD, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::REPLICATION() {
  return getToken(MySqlParser::REPLICATION, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::CLIENT() {
  return getToken(MySqlParser::CLIENT, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::SLAVE() {
  return getToken(MySqlParser::SLAVE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::SELECT() {
  return getToken(MySqlParser::SELECT, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::DATABASES() {
  return getToken(MySqlParser::DATABASES, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::SHUTDOWN() {
  return getToken(MySqlParser::SHUTDOWN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::SUPER() {
  return getToken(MySqlParser::SUPER, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::TRIGGER() {
  return getToken(MySqlParser::TRIGGER, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::UPDATE() {
  return getToken(MySqlParser::UPDATE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::USAGE() {
  return getToken(MySqlParser::USAGE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::APPLICATION_PASSWORD_ADMIN() {
  return getToken(MySqlParser::APPLICATION_PASSWORD_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::AUDIT_ABORT_EXEMPT() {
  return getToken(MySqlParser::AUDIT_ABORT_EXEMPT, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::AUDIT_ADMIN() {
  return getToken(MySqlParser::AUDIT_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::AUTHENTICATION_POLICY_ADMIN() {
  return getToken(MySqlParser::AUTHENTICATION_POLICY_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::BACKUP_ADMIN() {
  return getToken(MySqlParser::BACKUP_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::BINLOG_ADMIN() {
  return getToken(MySqlParser::BINLOG_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::BINLOG_ENCRYPTION_ADMIN() {
  return getToken(MySqlParser::BINLOG_ENCRYPTION_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::CLONE_ADMIN() {
  return getToken(MySqlParser::CLONE_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::CONNECTION_ADMIN() {
  return getToken(MySqlParser::CONNECTION_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::ENCRYPTION_KEY_ADMIN() {
  return getToken(MySqlParser::ENCRYPTION_KEY_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::FIREWALL_ADMIN() {
  return getToken(MySqlParser::FIREWALL_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::FIREWALL_EXEMPT() {
  return getToken(MySqlParser::FIREWALL_EXEMPT, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::FIREWALL_USER() {
  return getToken(MySqlParser::FIREWALL_USER, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::FLUSH_OPTIMIZER_COSTS() {
  return getToken(MySqlParser::FLUSH_OPTIMIZER_COSTS, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::FLUSH_STATUS() {
  return getToken(MySqlParser::FLUSH_STATUS, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::FLUSH_TABLES() {
  return getToken(MySqlParser::FLUSH_TABLES, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::FLUSH_USER_RESOURCES() {
  return getToken(MySqlParser::FLUSH_USER_RESOURCES, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::GROUP_REPLICATION_ADMIN() {
  return getToken(MySqlParser::GROUP_REPLICATION_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::INNODB_REDO_LOG_ARCHIVE() {
  return getToken(MySqlParser::INNODB_REDO_LOG_ARCHIVE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::INNODB_REDO_LOG_ENABLE() {
  return getToken(MySqlParser::INNODB_REDO_LOG_ENABLE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::NDB_STORED_USER() {
  return getToken(MySqlParser::NDB_STORED_USER, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::PASSWORDLESS_USER_ADMIN() {
  return getToken(MySqlParser::PASSWORDLESS_USER_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::PERSIST_RO_VARIABLES_ADMIN() {
  return getToken(MySqlParser::PERSIST_RO_VARIABLES_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::REPLICATION_APPLIER() {
  return getToken(MySqlParser::REPLICATION_APPLIER, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::REPLICATION_SLAVE_ADMIN() {
  return getToken(MySqlParser::REPLICATION_SLAVE_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::RESOURCE_GROUP_ADMIN() {
  return getToken(MySqlParser::RESOURCE_GROUP_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::RESOURCE_GROUP_USER() {
  return getToken(MySqlParser::RESOURCE_GROUP_USER, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::ROLE_ADMIN() {
  return getToken(MySqlParser::ROLE_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::SERVICE_CONNECTION_ADMIN() {
  return getToken(MySqlParser::SERVICE_CONNECTION_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::SESSION_VARIABLES_ADMIN() {
  return getToken(MySqlParser::SESSION_VARIABLES_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::SET_USER_ID() {
  return getToken(MySqlParser::SET_USER_ID, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::SKIP_QUERY_REWRITE() {
  return getToken(MySqlParser::SKIP_QUERY_REWRITE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::SHOW_ROUTINE() {
  return getToken(MySqlParser::SHOW_ROUTINE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::SYSTEM_USER() {
  return getToken(MySqlParser::SYSTEM_USER, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::SYSTEM_VARIABLES_ADMIN() {
  return getToken(MySqlParser::SYSTEM_VARIABLES_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::TABLE_ENCRYPTION_ADMIN() {
  return getToken(MySqlParser::TABLE_ENCRYPTION_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::TP_CONNECTION_ADMIN() {
  return getToken(MySqlParser::TP_CONNECTION_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::VERSION_TOKEN_ADMIN() {
  return getToken(MySqlParser::VERSION_TOKEN_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::XA_RECOVER_ADMIN() {
  return getToken(MySqlParser::XA_RECOVER_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::LOAD() {
  return getToken(MySqlParser::LOAD, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::S3() {
  return getToken(MySqlParser::S3, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::INTO() {
  return getToken(MySqlParser::INTO, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::INVOKE() {
  return getToken(MySqlParser::INVOKE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegeContext::LAMBDA() {
  return getToken(MySqlParser::LAMBDA, 0);
}


size_t MySqlParser::PrivilegeContext::getRuleIndex() const {
  return MySqlParser::RulePrivilege;
}

void MySqlParser::PrivilegeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivilege(this);
}

void MySqlParser::PrivilegeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivilege(this);
}


std::any MySqlParser::PrivilegeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPrivilege(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::PrivilegeContext* MySqlParser::privilege() {
  PrivilegeContext *_localctx = _tracker.createInstance<PrivilegeContext>(_ctx, getState());
  enterRule(_localctx, 458, MySqlParser::RulePrivilege);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5523);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 804, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5430);
      match(MySqlParser::ALL);
      setState(5432);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::PRIVILEGES) {
        setState(5431);
        match(MySqlParser::PRIVILEGES);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5434);
      match(MySqlParser::ALTER);
      setState(5436);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::ROUTINE) {
        setState(5435);
        match(MySqlParser::ROUTINE);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5438);
      match(MySqlParser::CREATE);
      setState(5446);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::TEMPORARY: {
          setState(5439);
          match(MySqlParser::TEMPORARY);
          setState(5440);
          match(MySqlParser::TABLES);
          break;
        }

        case MySqlParser::ROUTINE: {
          setState(5441);
          match(MySqlParser::ROUTINE);
          break;
        }

        case MySqlParser::VIEW: {
          setState(5442);
          match(MySqlParser::VIEW);
          break;
        }

        case MySqlParser::USER: {
          setState(5443);
          match(MySqlParser::USER);
          break;
        }

        case MySqlParser::TABLESPACE: {
          setState(5444);
          match(MySqlParser::TABLESPACE);
          break;
        }

        case MySqlParser::ROLE: {
          setState(5445);
          match(MySqlParser::ROLE);
          break;
        }

        case MySqlParser::ON:
        case MySqlParser::LR_BRACKET:
        case MySqlParser::COMMA: {
          break;
        }

      default:
        break;
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5448);
      match(MySqlParser::DELETE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5449);
      match(MySqlParser::DROP);
      setState(5451);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::ROLE) {
        setState(5450);
        match(MySqlParser::ROLE);
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5453);
      match(MySqlParser::EVENT);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(5454);
      match(MySqlParser::EXECUTE);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(5455);
      match(MySqlParser::FILE);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(5456);
      match(MySqlParser::GRANT);
      setState(5457);
      match(MySqlParser::OPTION);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(5458);
      match(MySqlParser::INDEX);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(5459);
      match(MySqlParser::INSERT);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(5460);
      match(MySqlParser::LOCK);
      setState(5461);
      match(MySqlParser::TABLES);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(5462);
      match(MySqlParser::PROCESS);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(5463);
      match(MySqlParser::PROXY);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(5464);
      match(MySqlParser::REFERENCES);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(5465);
      match(MySqlParser::RELOAD);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(5466);
      match(MySqlParser::REPLICATION);
      setState(5467);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::CLIENT || _la == MySqlParser::SLAVE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(5468);
      match(MySqlParser::SELECT);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(5469);
      match(MySqlParser::SHOW);
      setState(5470);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DATABASES || _la == MySqlParser::VIEW)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(5471);
      match(MySqlParser::SHUTDOWN);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(5472);
      match(MySqlParser::SUPER);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(5473);
      match(MySqlParser::TRIGGER);
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(5474);
      match(MySqlParser::UPDATE);
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(5475);
      match(MySqlParser::USAGE);
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(5476);
      match(MySqlParser::APPLICATION_PASSWORD_ADMIN);
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(5477);
      match(MySqlParser::AUDIT_ABORT_EXEMPT);
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(5478);
      match(MySqlParser::AUDIT_ADMIN);
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(5479);
      match(MySqlParser::AUTHENTICATION_POLICY_ADMIN);
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(5480);
      match(MySqlParser::BACKUP_ADMIN);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(5481);
      match(MySqlParser::BINLOG_ADMIN);
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(5482);
      match(MySqlParser::BINLOG_ENCRYPTION_ADMIN);
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(5483);
      match(MySqlParser::CLONE_ADMIN);
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(5484);
      match(MySqlParser::CONNECTION_ADMIN);
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(5485);
      match(MySqlParser::ENCRYPTION_KEY_ADMIN);
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(5486);
      match(MySqlParser::FIREWALL_ADMIN);
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(5487);
      match(MySqlParser::FIREWALL_EXEMPT);
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(5488);
      match(MySqlParser::FIREWALL_USER);
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(5489);
      match(MySqlParser::FLUSH_OPTIMIZER_COSTS);
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(5490);
      match(MySqlParser::FLUSH_STATUS);
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(5491);
      match(MySqlParser::FLUSH_TABLES);
      break;
    }

    case 41: {
      enterOuterAlt(_localctx, 41);
      setState(5492);
      match(MySqlParser::FLUSH_USER_RESOURCES);
      break;
    }

    case 42: {
      enterOuterAlt(_localctx, 42);
      setState(5493);
      match(MySqlParser::GROUP_REPLICATION_ADMIN);
      break;
    }

    case 43: {
      enterOuterAlt(_localctx, 43);
      setState(5494);
      match(MySqlParser::INNODB_REDO_LOG_ARCHIVE);
      break;
    }

    case 44: {
      enterOuterAlt(_localctx, 44);
      setState(5495);
      match(MySqlParser::INNODB_REDO_LOG_ENABLE);
      break;
    }

    case 45: {
      enterOuterAlt(_localctx, 45);
      setState(5496);
      match(MySqlParser::NDB_STORED_USER);
      break;
    }

    case 46: {
      enterOuterAlt(_localctx, 46);
      setState(5497);
      match(MySqlParser::PASSWORDLESS_USER_ADMIN);
      break;
    }

    case 47: {
      enterOuterAlt(_localctx, 47);
      setState(5498);
      match(MySqlParser::PERSIST_RO_VARIABLES_ADMIN);
      break;
    }

    case 48: {
      enterOuterAlt(_localctx, 48);
      setState(5499);
      match(MySqlParser::REPLICATION_APPLIER);
      break;
    }

    case 49: {
      enterOuterAlt(_localctx, 49);
      setState(5500);
      match(MySqlParser::REPLICATION_SLAVE_ADMIN);
      break;
    }

    case 50: {
      enterOuterAlt(_localctx, 50);
      setState(5501);
      match(MySqlParser::RESOURCE_GROUP_ADMIN);
      break;
    }

    case 51: {
      enterOuterAlt(_localctx, 51);
      setState(5502);
      match(MySqlParser::RESOURCE_GROUP_USER);
      break;
    }

    case 52: {
      enterOuterAlt(_localctx, 52);
      setState(5503);
      match(MySqlParser::ROLE_ADMIN);
      break;
    }

    case 53: {
      enterOuterAlt(_localctx, 53);
      setState(5504);
      match(MySqlParser::SERVICE_CONNECTION_ADMIN);
      break;
    }

    case 54: {
      enterOuterAlt(_localctx, 54);
      setState(5505);
      match(MySqlParser::SESSION_VARIABLES_ADMIN);
      break;
    }

    case 55: {
      enterOuterAlt(_localctx, 55);
      setState(5506);
      match(MySqlParser::SET_USER_ID);
      break;
    }

    case 56: {
      enterOuterAlt(_localctx, 56);
      setState(5507);
      match(MySqlParser::SKIP_QUERY_REWRITE);
      break;
    }

    case 57: {
      enterOuterAlt(_localctx, 57);
      setState(5508);
      match(MySqlParser::SHOW_ROUTINE);
      break;
    }

    case 58: {
      enterOuterAlt(_localctx, 58);
      setState(5509);
      match(MySqlParser::SYSTEM_USER);
      break;
    }

    case 59: {
      enterOuterAlt(_localctx, 59);
      setState(5510);
      match(MySqlParser::SYSTEM_VARIABLES_ADMIN);
      break;
    }

    case 60: {
      enterOuterAlt(_localctx, 60);
      setState(5511);
      match(MySqlParser::TABLE_ENCRYPTION_ADMIN);
      break;
    }

    case 61: {
      enterOuterAlt(_localctx, 61);
      setState(5512);
      match(MySqlParser::TP_CONNECTION_ADMIN);
      break;
    }

    case 62: {
      enterOuterAlt(_localctx, 62);
      setState(5513);
      match(MySqlParser::VERSION_TOKEN_ADMIN);
      break;
    }

    case 63: {
      enterOuterAlt(_localctx, 63);
      setState(5514);
      match(MySqlParser::XA_RECOVER_ADMIN);
      break;
    }

    case 64: {
      enterOuterAlt(_localctx, 64);
      setState(5515);
      match(MySqlParser::LOAD);
      setState(5516);
      match(MySqlParser::FROM);
      setState(5517);
      match(MySqlParser::S3);
      break;
    }

    case 65: {
      enterOuterAlt(_localctx, 65);
      setState(5518);
      match(MySqlParser::SELECT);
      setState(5519);
      match(MySqlParser::INTO);
      setState(5520);
      match(MySqlParser::S3);
      break;
    }

    case 66: {
      enterOuterAlt(_localctx, 66);
      setState(5521);
      match(MySqlParser::INVOKE);
      setState(5522);
      match(MySqlParser::LAMBDA);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegeLevelContext ------------------------------------------------------------------

MySqlParser::PrivilegeLevelContext::PrivilegeLevelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::PrivilegeLevelContext::getRuleIndex() const {
  return MySqlParser::RulePrivilegeLevel;
}

void MySqlParser::PrivilegeLevelContext::copyFrom(PrivilegeLevelContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DefiniteSchemaPrivLevelContext ------------------------------------------------------------------

MySqlParser::UidContext* MySqlParser::DefiniteSchemaPrivLevelContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::DefiniteSchemaPrivLevelContext::DOT() {
  return getToken(MySqlParser::DOT, 0);
}

tree::TerminalNode* MySqlParser::DefiniteSchemaPrivLevelContext::STAR() {
  return getToken(MySqlParser::STAR, 0);
}

MySqlParser::DefiniteSchemaPrivLevelContext::DefiniteSchemaPrivLevelContext(PrivilegeLevelContext *ctx) { copyFrom(ctx); }

void MySqlParser::DefiniteSchemaPrivLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefiniteSchemaPrivLevel(this);
}
void MySqlParser::DefiniteSchemaPrivLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefiniteSchemaPrivLevel(this);
}

std::any MySqlParser::DefiniteSchemaPrivLevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDefiniteSchemaPrivLevel(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DefiniteFullTablePrivLevel2Context ------------------------------------------------------------------

MySqlParser::UidContext* MySqlParser::DefiniteFullTablePrivLevel2Context::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::DottedIdContext* MySqlParser::DefiniteFullTablePrivLevel2Context::dottedId() {
  return getRuleContext<MySqlParser::DottedIdContext>(0);
}

MySqlParser::DefiniteFullTablePrivLevel2Context::DefiniteFullTablePrivLevel2Context(PrivilegeLevelContext *ctx) { copyFrom(ctx); }

void MySqlParser::DefiniteFullTablePrivLevel2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefiniteFullTablePrivLevel2(this);
}
void MySqlParser::DefiniteFullTablePrivLevel2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefiniteFullTablePrivLevel2(this);
}

std::any MySqlParser::DefiniteFullTablePrivLevel2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDefiniteFullTablePrivLevel2(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DefiniteFullTablePrivLevelContext ------------------------------------------------------------------

std::vector<MySqlParser::UidContext *> MySqlParser::DefiniteFullTablePrivLevelContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::DefiniteFullTablePrivLevelContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

tree::TerminalNode* MySqlParser::DefiniteFullTablePrivLevelContext::DOT() {
  return getToken(MySqlParser::DOT, 0);
}

MySqlParser::DefiniteFullTablePrivLevelContext::DefiniteFullTablePrivLevelContext(PrivilegeLevelContext *ctx) { copyFrom(ctx); }

void MySqlParser::DefiniteFullTablePrivLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefiniteFullTablePrivLevel(this);
}
void MySqlParser::DefiniteFullTablePrivLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefiniteFullTablePrivLevel(this);
}

std::any MySqlParser::DefiniteFullTablePrivLevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDefiniteFullTablePrivLevel(this);
  else
    return visitor->visitChildren(this);
}
//----------------- GlobalPrivLevelContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> MySqlParser::GlobalPrivLevelContext::STAR() {
  return getTokens(MySqlParser::STAR);
}

tree::TerminalNode* MySqlParser::GlobalPrivLevelContext::STAR(size_t i) {
  return getToken(MySqlParser::STAR, i);
}

tree::TerminalNode* MySqlParser::GlobalPrivLevelContext::DOT() {
  return getToken(MySqlParser::DOT, 0);
}

MySqlParser::GlobalPrivLevelContext::GlobalPrivLevelContext(PrivilegeLevelContext *ctx) { copyFrom(ctx); }

void MySqlParser::GlobalPrivLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobalPrivLevel(this);
}
void MySqlParser::GlobalPrivLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobalPrivLevel(this);
}

std::any MySqlParser::GlobalPrivLevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitGlobalPrivLevel(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DefiniteTablePrivLevelContext ------------------------------------------------------------------

MySqlParser::UidContext* MySqlParser::DefiniteTablePrivLevelContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::DefiniteTablePrivLevelContext::DefiniteTablePrivLevelContext(PrivilegeLevelContext *ctx) { copyFrom(ctx); }

void MySqlParser::DefiniteTablePrivLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefiniteTablePrivLevel(this);
}
void MySqlParser::DefiniteTablePrivLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefiniteTablePrivLevel(this);
}

std::any MySqlParser::DefiniteTablePrivLevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDefiniteTablePrivLevel(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CurrentSchemaPriviLevelContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::CurrentSchemaPriviLevelContext::STAR() {
  return getToken(MySqlParser::STAR, 0);
}

MySqlParser::CurrentSchemaPriviLevelContext::CurrentSchemaPriviLevelContext(PrivilegeLevelContext *ctx) { copyFrom(ctx); }

void MySqlParser::CurrentSchemaPriviLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCurrentSchemaPriviLevel(this);
}
void MySqlParser::CurrentSchemaPriviLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCurrentSchemaPriviLevel(this);
}

std::any MySqlParser::CurrentSchemaPriviLevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCurrentSchemaPriviLevel(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::PrivilegeLevelContext* MySqlParser::privilegeLevel() {
  PrivilegeLevelContext *_localctx = _tracker.createInstance<PrivilegeLevelContext>(_ctx, getState());
  enterRule(_localctx, 460, MySqlParser::RulePrivilegeLevel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5541);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 805, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::CurrentSchemaPriviLevelContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(5525);
      match(MySqlParser::STAR);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::GlobalPrivLevelContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(5526);
      match(MySqlParser::STAR);
      setState(5527);
      match(MySqlParser::DOT);
      setState(5528);
      match(MySqlParser::STAR);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::DefiniteSchemaPrivLevelContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(5529);
      uid();
      setState(5530);
      match(MySqlParser::DOT);
      setState(5531);
      match(MySqlParser::STAR);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::DefiniteFullTablePrivLevelContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(5533);
      uid();
      setState(5534);
      match(MySqlParser::DOT);
      setState(5535);
      uid();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<MySqlParser::DefiniteFullTablePrivLevel2Context>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(5537);
      uid();
      setState(5538);
      dottedId();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<MySqlParser::DefiniteTablePrivLevelContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(5540);
      uid();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenameUserClauseContext ------------------------------------------------------------------

MySqlParser::RenameUserClauseContext::RenameUserClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::RenameUserClauseContext::TO() {
  return getToken(MySqlParser::TO, 0);
}

std::vector<MySqlParser::UserNameContext *> MySqlParser::RenameUserClauseContext::userName() {
  return getRuleContexts<MySqlParser::UserNameContext>();
}

MySqlParser::UserNameContext* MySqlParser::RenameUserClauseContext::userName(size_t i) {
  return getRuleContext<MySqlParser::UserNameContext>(i);
}


size_t MySqlParser::RenameUserClauseContext::getRuleIndex() const {
  return MySqlParser::RuleRenameUserClause;
}

void MySqlParser::RenameUserClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameUserClause(this);
}

void MySqlParser::RenameUserClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameUserClause(this);
}


std::any MySqlParser::RenameUserClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRenameUserClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::RenameUserClauseContext* MySqlParser::renameUserClause() {
  RenameUserClauseContext *_localctx = _tracker.createInstance<RenameUserClauseContext>(_ctx, getState());
  enterRule(_localctx, 462, MySqlParser::RuleRenameUserClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5543);
    antlrcpp::downCast<RenameUserClauseContext *>(_localctx)->fromFirst = userName();
    setState(5544);
    match(MySqlParser::TO);
    setState(5545);
    antlrcpp::downCast<RenameUserClauseContext *>(_localctx)->toFirst = userName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnalyzeTableContext ------------------------------------------------------------------

MySqlParser::AnalyzeTableContext::AnalyzeTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::AnalyzeTableContext::ANALYZE() {
  return getToken(MySqlParser::ANALYZE, 0);
}

MySqlParser::TablesContext* MySqlParser::AnalyzeTableContext::tables() {
  return getRuleContext<MySqlParser::TablesContext>(0);
}

tree::TerminalNode* MySqlParser::AnalyzeTableContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

tree::TerminalNode* MySqlParser::AnalyzeTableContext::TABLES() {
  return getToken(MySqlParser::TABLES, 0);
}

tree::TerminalNode* MySqlParser::AnalyzeTableContext::UPDATE() {
  return getToken(MySqlParser::UPDATE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::AnalyzeTableContext::HISTOGRAM() {
  return getTokens(MySqlParser::HISTOGRAM);
}

tree::TerminalNode* MySqlParser::AnalyzeTableContext::HISTOGRAM(size_t i) {
  return getToken(MySqlParser::HISTOGRAM, i);
}

std::vector<tree::TerminalNode *> MySqlParser::AnalyzeTableContext::ON() {
  return getTokens(MySqlParser::ON);
}

tree::TerminalNode* MySqlParser::AnalyzeTableContext::ON(size_t i) {
  return getToken(MySqlParser::ON, i);
}

std::vector<MySqlParser::FullColumnNameContext *> MySqlParser::AnalyzeTableContext::fullColumnName() {
  return getRuleContexts<MySqlParser::FullColumnNameContext>();
}

MySqlParser::FullColumnNameContext* MySqlParser::AnalyzeTableContext::fullColumnName(size_t i) {
  return getRuleContext<MySqlParser::FullColumnNameContext>(i);
}

tree::TerminalNode* MySqlParser::AnalyzeTableContext::DROP() {
  return getToken(MySqlParser::DROP, 0);
}

tree::TerminalNode* MySqlParser::AnalyzeTableContext::NO_WRITE_TO_BINLOG() {
  return getToken(MySqlParser::NO_WRITE_TO_BINLOG, 0);
}

tree::TerminalNode* MySqlParser::AnalyzeTableContext::LOCAL() {
  return getToken(MySqlParser::LOCAL, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::AnalyzeTableContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::AnalyzeTableContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::AnalyzeTableContext::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::AnalyzeTableContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::AnalyzeTableContext::BUCKETS() {
  return getToken(MySqlParser::BUCKETS, 0);
}


size_t MySqlParser::AnalyzeTableContext::getRuleIndex() const {
  return MySqlParser::RuleAnalyzeTable;
}

void MySqlParser::AnalyzeTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalyzeTable(this);
}

void MySqlParser::AnalyzeTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalyzeTable(this);
}


std::any MySqlParser::AnalyzeTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAnalyzeTable(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AnalyzeTableContext* MySqlParser::analyzeTable() {
  AnalyzeTableContext *_localctx = _tracker.createInstance<AnalyzeTableContext>(_ctx, getState());
  enterRule(_localctx, 464, MySqlParser::RuleAnalyzeTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5547);
    match(MySqlParser::ANALYZE);
    setState(5549);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::NO_WRITE_TO_BINLOG || _la == MySqlParser::LOCAL) {
      setState(5548);
      antlrcpp::downCast<AnalyzeTableContext *>(_localctx)->actionOption = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::NO_WRITE_TO_BINLOG || _la == MySqlParser::LOCAL)) {
        antlrcpp::downCast<AnalyzeTableContext *>(_localctx)->actionOption = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(5551);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::TABLE || _la == MySqlParser::TABLES)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5552);
    tables();
    setState(5570);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 809, _ctx)) {
    case 1: {
      setState(5553);
      match(MySqlParser::UPDATE);
      setState(5554);
      match(MySqlParser::HISTOGRAM);
      setState(5555);
      match(MySqlParser::ON);
      setState(5556);
      fullColumnName();
      setState(5561);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5557);
        match(MySqlParser::COMMA);
        setState(5558);
        fullColumnName();
        setState(5563);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(5568);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 808, _ctx)) {
      case 1: {
        setState(5564);
        match(MySqlParser::WITH);
        setState(5565);
        decimalLiteral();
        setState(5566);
        match(MySqlParser::BUCKETS);
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    setState(5583);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 811, _ctx)) {
    case 1: {
      setState(5572);
      match(MySqlParser::DROP);
      setState(5573);
      match(MySqlParser::HISTOGRAM);
      setState(5574);
      match(MySqlParser::ON);
      setState(5575);
      fullColumnName();
      setState(5580);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5576);
        match(MySqlParser::COMMA);
        setState(5577);
        fullColumnName();
        setState(5582);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckTableContext ------------------------------------------------------------------

MySqlParser::CheckTableContext::CheckTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CheckTableContext::CHECK() {
  return getToken(MySqlParser::CHECK, 0);
}

tree::TerminalNode* MySqlParser::CheckTableContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

MySqlParser::TablesContext* MySqlParser::CheckTableContext::tables() {
  return getRuleContext<MySqlParser::TablesContext>(0);
}

std::vector<MySqlParser::CheckTableOptionContext *> MySqlParser::CheckTableContext::checkTableOption() {
  return getRuleContexts<MySqlParser::CheckTableOptionContext>();
}

MySqlParser::CheckTableOptionContext* MySqlParser::CheckTableContext::checkTableOption(size_t i) {
  return getRuleContext<MySqlParser::CheckTableOptionContext>(i);
}


size_t MySqlParser::CheckTableContext::getRuleIndex() const {
  return MySqlParser::RuleCheckTable;
}

void MySqlParser::CheckTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckTable(this);
}

void MySqlParser::CheckTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckTable(this);
}


std::any MySqlParser::CheckTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCheckTable(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CheckTableContext* MySqlParser::checkTable() {
  CheckTableContext *_localctx = _tracker.createInstance<CheckTableContext>(_ctx, getState());
  enterRule(_localctx, 466, MySqlParser::RuleCheckTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5585);
    match(MySqlParser::CHECK);
    setState(5586);
    match(MySqlParser::TABLE);
    setState(5587);
    tables();
    setState(5591);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::FOR || _la == MySqlParser::CHANGED || _la == MySqlParser::EXTENDED

    || _la == MySqlParser::FAST || _la == MySqlParser::MEDIUM || _la == MySqlParser::QUICK) {
      setState(5588);
      checkTableOption();
      setState(5593);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChecksumTableContext ------------------------------------------------------------------

MySqlParser::ChecksumTableContext::ChecksumTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ChecksumTableContext::CHECKSUM() {
  return getToken(MySqlParser::CHECKSUM, 0);
}

tree::TerminalNode* MySqlParser::ChecksumTableContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

MySqlParser::TablesContext* MySqlParser::ChecksumTableContext::tables() {
  return getRuleContext<MySqlParser::TablesContext>(0);
}

tree::TerminalNode* MySqlParser::ChecksumTableContext::QUICK() {
  return getToken(MySqlParser::QUICK, 0);
}

tree::TerminalNode* MySqlParser::ChecksumTableContext::EXTENDED() {
  return getToken(MySqlParser::EXTENDED, 0);
}


size_t MySqlParser::ChecksumTableContext::getRuleIndex() const {
  return MySqlParser::RuleChecksumTable;
}

void MySqlParser::ChecksumTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChecksumTable(this);
}

void MySqlParser::ChecksumTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChecksumTable(this);
}


std::any MySqlParser::ChecksumTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitChecksumTable(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ChecksumTableContext* MySqlParser::checksumTable() {
  ChecksumTableContext *_localctx = _tracker.createInstance<ChecksumTableContext>(_ctx, getState());
  enterRule(_localctx, 468, MySqlParser::RuleChecksumTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5594);
    match(MySqlParser::CHECKSUM);
    setState(5595);
    match(MySqlParser::TABLE);
    setState(5596);
    tables();
    setState(5598);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::EXTENDED || _la == MySqlParser::QUICK) {
      setState(5597);
      antlrcpp::downCast<ChecksumTableContext *>(_localctx)->actionOption = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::EXTENDED || _la == MySqlParser::QUICK)) {
        antlrcpp::downCast<ChecksumTableContext *>(_localctx)->actionOption = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptimizeTableContext ------------------------------------------------------------------

MySqlParser::OptimizeTableContext::OptimizeTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::OptimizeTableContext::OPTIMIZE() {
  return getToken(MySqlParser::OPTIMIZE, 0);
}

MySqlParser::TablesContext* MySqlParser::OptimizeTableContext::tables() {
  return getRuleContext<MySqlParser::TablesContext>(0);
}

tree::TerminalNode* MySqlParser::OptimizeTableContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

tree::TerminalNode* MySqlParser::OptimizeTableContext::TABLES() {
  return getToken(MySqlParser::TABLES, 0);
}

tree::TerminalNode* MySqlParser::OptimizeTableContext::NO_WRITE_TO_BINLOG() {
  return getToken(MySqlParser::NO_WRITE_TO_BINLOG, 0);
}

tree::TerminalNode* MySqlParser::OptimizeTableContext::LOCAL() {
  return getToken(MySqlParser::LOCAL, 0);
}


size_t MySqlParser::OptimizeTableContext::getRuleIndex() const {
  return MySqlParser::RuleOptimizeTable;
}

void MySqlParser::OptimizeTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptimizeTable(this);
}

void MySqlParser::OptimizeTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptimizeTable(this);
}


std::any MySqlParser::OptimizeTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitOptimizeTable(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::OptimizeTableContext* MySqlParser::optimizeTable() {
  OptimizeTableContext *_localctx = _tracker.createInstance<OptimizeTableContext>(_ctx, getState());
  enterRule(_localctx, 470, MySqlParser::RuleOptimizeTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5600);
    match(MySqlParser::OPTIMIZE);
    setState(5602);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::NO_WRITE_TO_BINLOG || _la == MySqlParser::LOCAL) {
      setState(5601);
      antlrcpp::downCast<OptimizeTableContext *>(_localctx)->actionOption = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::NO_WRITE_TO_BINLOG || _la == MySqlParser::LOCAL)) {
        antlrcpp::downCast<OptimizeTableContext *>(_localctx)->actionOption = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(5604);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::TABLE || _la == MySqlParser::TABLES)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5605);
    tables();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepairTableContext ------------------------------------------------------------------

MySqlParser::RepairTableContext::RepairTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::RepairTableContext::REPAIR() {
  return getToken(MySqlParser::REPAIR, 0);
}

tree::TerminalNode* MySqlParser::RepairTableContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

MySqlParser::TablesContext* MySqlParser::RepairTableContext::tables() {
  return getRuleContext<MySqlParser::TablesContext>(0);
}

tree::TerminalNode* MySqlParser::RepairTableContext::QUICK() {
  return getToken(MySqlParser::QUICK, 0);
}

tree::TerminalNode* MySqlParser::RepairTableContext::EXTENDED() {
  return getToken(MySqlParser::EXTENDED, 0);
}

tree::TerminalNode* MySqlParser::RepairTableContext::USE_FRM() {
  return getToken(MySqlParser::USE_FRM, 0);
}

tree::TerminalNode* MySqlParser::RepairTableContext::NO_WRITE_TO_BINLOG() {
  return getToken(MySqlParser::NO_WRITE_TO_BINLOG, 0);
}

tree::TerminalNode* MySqlParser::RepairTableContext::LOCAL() {
  return getToken(MySqlParser::LOCAL, 0);
}


size_t MySqlParser::RepairTableContext::getRuleIndex() const {
  return MySqlParser::RuleRepairTable;
}

void MySqlParser::RepairTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepairTable(this);
}

void MySqlParser::RepairTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepairTable(this);
}


std::any MySqlParser::RepairTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRepairTable(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::RepairTableContext* MySqlParser::repairTable() {
  RepairTableContext *_localctx = _tracker.createInstance<RepairTableContext>(_ctx, getState());
  enterRule(_localctx, 472, MySqlParser::RuleRepairTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5607);
    match(MySqlParser::REPAIR);
    setState(5609);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::NO_WRITE_TO_BINLOG || _la == MySqlParser::LOCAL) {
      setState(5608);
      antlrcpp::downCast<RepairTableContext *>(_localctx)->actionOption = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::NO_WRITE_TO_BINLOG || _la == MySqlParser::LOCAL)) {
        antlrcpp::downCast<RepairTableContext *>(_localctx)->actionOption = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(5611);
    match(MySqlParser::TABLE);
    setState(5612);
    tables();
    setState(5614);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::QUICK) {
      setState(5613);
      match(MySqlParser::QUICK);
    }
    setState(5617);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::EXTENDED) {
      setState(5616);
      match(MySqlParser::EXTENDED);
    }
    setState(5620);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::USE_FRM) {
      setState(5619);
      match(MySqlParser::USE_FRM);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckTableOptionContext ------------------------------------------------------------------

MySqlParser::CheckTableOptionContext::CheckTableOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CheckTableOptionContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

tree::TerminalNode* MySqlParser::CheckTableOptionContext::UPGRADE() {
  return getToken(MySqlParser::UPGRADE, 0);
}

tree::TerminalNode* MySqlParser::CheckTableOptionContext::QUICK() {
  return getToken(MySqlParser::QUICK, 0);
}

tree::TerminalNode* MySqlParser::CheckTableOptionContext::FAST() {
  return getToken(MySqlParser::FAST, 0);
}

tree::TerminalNode* MySqlParser::CheckTableOptionContext::MEDIUM() {
  return getToken(MySqlParser::MEDIUM, 0);
}

tree::TerminalNode* MySqlParser::CheckTableOptionContext::EXTENDED() {
  return getToken(MySqlParser::EXTENDED, 0);
}

tree::TerminalNode* MySqlParser::CheckTableOptionContext::CHANGED() {
  return getToken(MySqlParser::CHANGED, 0);
}


size_t MySqlParser::CheckTableOptionContext::getRuleIndex() const {
  return MySqlParser::RuleCheckTableOption;
}

void MySqlParser::CheckTableOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckTableOption(this);
}

void MySqlParser::CheckTableOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckTableOption(this);
}


std::any MySqlParser::CheckTableOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCheckTableOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CheckTableOptionContext* MySqlParser::checkTableOption() {
  CheckTableOptionContext *_localctx = _tracker.createInstance<CheckTableOptionContext>(_ctx, getState());
  enterRule(_localctx, 474, MySqlParser::RuleCheckTableOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5629);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::FOR: {
        enterOuterAlt(_localctx, 1);
        setState(5622);
        match(MySqlParser::FOR);
        setState(5623);
        match(MySqlParser::UPGRADE);
        break;
      }

      case MySqlParser::QUICK: {
        enterOuterAlt(_localctx, 2);
        setState(5624);
        match(MySqlParser::QUICK);
        break;
      }

      case MySqlParser::FAST: {
        enterOuterAlt(_localctx, 3);
        setState(5625);
        match(MySqlParser::FAST);
        break;
      }

      case MySqlParser::MEDIUM: {
        enterOuterAlt(_localctx, 4);
        setState(5626);
        match(MySqlParser::MEDIUM);
        break;
      }

      case MySqlParser::EXTENDED: {
        enterOuterAlt(_localctx, 5);
        setState(5627);
        match(MySqlParser::EXTENDED);
        break;
      }

      case MySqlParser::CHANGED: {
        enterOuterAlt(_localctx, 6);
        setState(5628);
        match(MySqlParser::CHANGED);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUdfunctionContext ------------------------------------------------------------------

MySqlParser::CreateUdfunctionContext::CreateUdfunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CreateUdfunctionContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::CreateUdfunctionContext::FUNCTION() {
  return getToken(MySqlParser::FUNCTION, 0);
}

MySqlParser::UidContext* MySqlParser::CreateUdfunctionContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::CreateUdfunctionContext::RETURNS() {
  return getToken(MySqlParser::RETURNS, 0);
}

tree::TerminalNode* MySqlParser::CreateUdfunctionContext::SONAME() {
  return getToken(MySqlParser::SONAME, 0);
}

tree::TerminalNode* MySqlParser::CreateUdfunctionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::CreateUdfunctionContext::STRING() {
  return getToken(MySqlParser::STRING, 0);
}

tree::TerminalNode* MySqlParser::CreateUdfunctionContext::INTEGER() {
  return getToken(MySqlParser::INTEGER, 0);
}

tree::TerminalNode* MySqlParser::CreateUdfunctionContext::REAL() {
  return getToken(MySqlParser::REAL, 0);
}

tree::TerminalNode* MySqlParser::CreateUdfunctionContext::DECIMAL() {
  return getToken(MySqlParser::DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::CreateUdfunctionContext::AGGREGATE() {
  return getToken(MySqlParser::AGGREGATE, 0);
}

MySqlParser::IfNotExistsContext* MySqlParser::CreateUdfunctionContext::ifNotExists() {
  return getRuleContext<MySqlParser::IfNotExistsContext>(0);
}


size_t MySqlParser::CreateUdfunctionContext::getRuleIndex() const {
  return MySqlParser::RuleCreateUdfunction;
}

void MySqlParser::CreateUdfunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUdfunction(this);
}

void MySqlParser::CreateUdfunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUdfunction(this);
}


std::any MySqlParser::CreateUdfunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCreateUdfunction(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CreateUdfunctionContext* MySqlParser::createUdfunction() {
  CreateUdfunctionContext *_localctx = _tracker.createInstance<CreateUdfunctionContext>(_ctx, getState());
  enterRule(_localctx, 476, MySqlParser::RuleCreateUdfunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5631);
    match(MySqlParser::CREATE);
    setState(5633);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::AGGREGATE) {
      setState(5632);
      match(MySqlParser::AGGREGATE);
    }
    setState(5635);
    match(MySqlParser::FUNCTION);
    setState(5637);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 821, _ctx)) {
    case 1: {
      setState(5636);
      ifNotExists();
      break;
    }

    default:
      break;
    }
    setState(5639);
    uid();
    setState(5640);
    match(MySqlParser::RETURNS);
    setState(5641);
    antlrcpp::downCast<CreateUdfunctionContext *>(_localctx)->returnType = _input->LT(1);
    _la = _input->LA(1);
    if (!(((((_la - 206) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 206)) & 261) != 0) || _la == MySqlParser::STRING)) {
      antlrcpp::downCast<CreateUdfunctionContext *>(_localctx)->returnType = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5642);
    match(MySqlParser::SONAME);
    setState(5643);
    match(MySqlParser::STRING_LITERAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InstallPluginContext ------------------------------------------------------------------

MySqlParser::InstallPluginContext::InstallPluginContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::InstallPluginContext::INSTALL() {
  return getToken(MySqlParser::INSTALL, 0);
}

tree::TerminalNode* MySqlParser::InstallPluginContext::PLUGIN() {
  return getToken(MySqlParser::PLUGIN, 0);
}

MySqlParser::UidContext* MySqlParser::InstallPluginContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::InstallPluginContext::SONAME() {
  return getToken(MySqlParser::SONAME, 0);
}

tree::TerminalNode* MySqlParser::InstallPluginContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}


size_t MySqlParser::InstallPluginContext::getRuleIndex() const {
  return MySqlParser::RuleInstallPlugin;
}

void MySqlParser::InstallPluginContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstallPlugin(this);
}

void MySqlParser::InstallPluginContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstallPlugin(this);
}


std::any MySqlParser::InstallPluginContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitInstallPlugin(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::InstallPluginContext* MySqlParser::installPlugin() {
  InstallPluginContext *_localctx = _tracker.createInstance<InstallPluginContext>(_ctx, getState());
  enterRule(_localctx, 478, MySqlParser::RuleInstallPlugin);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5645);
    match(MySqlParser::INSTALL);
    setState(5646);
    match(MySqlParser::PLUGIN);
    setState(5647);
    uid();
    setState(5648);
    match(MySqlParser::SONAME);
    setState(5649);
    match(MySqlParser::STRING_LITERAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UninstallPluginContext ------------------------------------------------------------------

MySqlParser::UninstallPluginContext::UninstallPluginContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::UninstallPluginContext::UNINSTALL() {
  return getToken(MySqlParser::UNINSTALL, 0);
}

tree::TerminalNode* MySqlParser::UninstallPluginContext::PLUGIN() {
  return getToken(MySqlParser::PLUGIN, 0);
}

MySqlParser::UidContext* MySqlParser::UninstallPluginContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}


size_t MySqlParser::UninstallPluginContext::getRuleIndex() const {
  return MySqlParser::RuleUninstallPlugin;
}

void MySqlParser::UninstallPluginContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUninstallPlugin(this);
}

void MySqlParser::UninstallPluginContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUninstallPlugin(this);
}


std::any MySqlParser::UninstallPluginContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUninstallPlugin(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UninstallPluginContext* MySqlParser::uninstallPlugin() {
  UninstallPluginContext *_localctx = _tracker.createInstance<UninstallPluginContext>(_ctx, getState());
  enterRule(_localctx, 480, MySqlParser::RuleUninstallPlugin);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5651);
    match(MySqlParser::UNINSTALL);
    setState(5652);
    match(MySqlParser::PLUGIN);
    setState(5653);
    uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetStatementContext ------------------------------------------------------------------

MySqlParser::SetStatementContext::SetStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::SetStatementContext::getRuleIndex() const {
  return MySqlParser::RuleSetStatement;
}

void MySqlParser::SetStatementContext::copyFrom(SetStatementContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SetTransactionContext ------------------------------------------------------------------

MySqlParser::SetTransactionStatementContext* MySqlParser::SetTransactionContext::setTransactionStatement() {
  return getRuleContext<MySqlParser::SetTransactionStatementContext>(0);
}

MySqlParser::SetTransactionContext::SetTransactionContext(SetStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::SetTransactionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetTransaction(this);
}
void MySqlParser::SetTransactionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetTransaction(this);
}

std::any MySqlParser::SetTransactionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSetTransaction(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SetCharsetContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SetCharsetContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

MySqlParser::CharSetContext* MySqlParser::SetCharsetContext::charSet() {
  return getRuleContext<MySqlParser::CharSetContext>(0);
}

MySqlParser::CharsetNameContext* MySqlParser::SetCharsetContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySqlParser::SetCharsetContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

MySqlParser::SetCharsetContext::SetCharsetContext(SetStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::SetCharsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetCharset(this);
}
void MySqlParser::SetCharsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetCharset(this);
}

std::any MySqlParser::SetCharsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSetCharset(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SetNamesContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SetNamesContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::SetNamesContext::NAMES() {
  return getToken(MySqlParser::NAMES, 0);
}

MySqlParser::CharsetNameContext* MySqlParser::SetNamesContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySqlParser::SetNamesContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::SetNamesContext::COLLATE() {
  return getToken(MySqlParser::COLLATE, 0);
}

MySqlParser::CollationNameContext* MySqlParser::SetNamesContext::collationName() {
  return getRuleContext<MySqlParser::CollationNameContext>(0);
}

MySqlParser::SetNamesContext::SetNamesContext(SetStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::SetNamesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetNames(this);
}
void MySqlParser::SetNamesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetNames(this);
}

std::any MySqlParser::SetNamesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSetNames(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SetPasswordContext ------------------------------------------------------------------

MySqlParser::SetPasswordStatementContext* MySqlParser::SetPasswordContext::setPasswordStatement() {
  return getRuleContext<MySqlParser::SetPasswordStatementContext>(0);
}

MySqlParser::SetPasswordContext::SetPasswordContext(SetStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::SetPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetPassword(this);
}
void MySqlParser::SetPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetPassword(this);
}

std::any MySqlParser::SetPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSetPassword(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SetAutocommitContext ------------------------------------------------------------------

MySqlParser::SetAutocommitStatementContext* MySqlParser::SetAutocommitContext::setAutocommitStatement() {
  return getRuleContext<MySqlParser::SetAutocommitStatementContext>(0);
}

MySqlParser::SetAutocommitContext::SetAutocommitContext(SetStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::SetAutocommitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetAutocommit(this);
}
void MySqlParser::SetAutocommitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetAutocommit(this);
}

std::any MySqlParser::SetAutocommitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSetAutocommit(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SetNewValueInsideTriggerContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SetNewValueInsideTriggerContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

std::vector<MySqlParser::FullIdContext *> MySqlParser::SetNewValueInsideTriggerContext::fullId() {
  return getRuleContexts<MySqlParser::FullIdContext>();
}

MySqlParser::FullIdContext* MySqlParser::SetNewValueInsideTriggerContext::fullId(size_t i) {
  return getRuleContext<MySqlParser::FullIdContext>(i);
}

std::vector<MySqlParser::ExpressionContext *> MySqlParser::SetNewValueInsideTriggerContext::expression() {
  return getRuleContexts<MySqlParser::ExpressionContext>();
}

MySqlParser::ExpressionContext* MySqlParser::SetNewValueInsideTriggerContext::expression(size_t i) {
  return getRuleContext<MySqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::SetNewValueInsideTriggerContext::EQUAL_SYMBOL() {
  return getTokens(MySqlParser::EQUAL_SYMBOL);
}

tree::TerminalNode* MySqlParser::SetNewValueInsideTriggerContext::EQUAL_SYMBOL(size_t i) {
  return getToken(MySqlParser::EQUAL_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySqlParser::SetNewValueInsideTriggerContext::VAR_ASSIGN() {
  return getTokens(MySqlParser::VAR_ASSIGN);
}

tree::TerminalNode* MySqlParser::SetNewValueInsideTriggerContext::VAR_ASSIGN(size_t i) {
  return getToken(MySqlParser::VAR_ASSIGN, i);
}

std::vector<tree::TerminalNode *> MySqlParser::SetNewValueInsideTriggerContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::SetNewValueInsideTriggerContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::SetNewValueInsideTriggerContext::SetNewValueInsideTriggerContext(SetStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::SetNewValueInsideTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetNewValueInsideTrigger(this);
}
void MySqlParser::SetNewValueInsideTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetNewValueInsideTrigger(this);
}

std::any MySqlParser::SetNewValueInsideTriggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSetNewValueInsideTrigger(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SetVariableContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SetVariableContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

std::vector<MySqlParser::VariableClauseContext *> MySqlParser::SetVariableContext::variableClause() {
  return getRuleContexts<MySqlParser::VariableClauseContext>();
}

MySqlParser::VariableClauseContext* MySqlParser::SetVariableContext::variableClause(size_t i) {
  return getRuleContext<MySqlParser::VariableClauseContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::SetVariableContext::EQUAL_SYMBOL() {
  return getTokens(MySqlParser::EQUAL_SYMBOL);
}

tree::TerminalNode* MySqlParser::SetVariableContext::EQUAL_SYMBOL(size_t i) {
  return getToken(MySqlParser::EQUAL_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySqlParser::SetVariableContext::VAR_ASSIGN() {
  return getTokens(MySqlParser::VAR_ASSIGN);
}

tree::TerminalNode* MySqlParser::SetVariableContext::VAR_ASSIGN(size_t i) {
  return getToken(MySqlParser::VAR_ASSIGN, i);
}

std::vector<MySqlParser::ExpressionContext *> MySqlParser::SetVariableContext::expression() {
  return getRuleContexts<MySqlParser::ExpressionContext>();
}

MySqlParser::ExpressionContext* MySqlParser::SetVariableContext::expression(size_t i) {
  return getRuleContext<MySqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::SetVariableContext::ON() {
  return getTokens(MySqlParser::ON);
}

tree::TerminalNode* MySqlParser::SetVariableContext::ON(size_t i) {
  return getToken(MySqlParser::ON, i);
}

std::vector<tree::TerminalNode *> MySqlParser::SetVariableContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::SetVariableContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::SetVariableContext::SetVariableContext(SetStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::SetVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetVariable(this);
}
void MySqlParser::SetVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetVariable(this);
}

std::any MySqlParser::SetVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSetVariable(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::SetStatementContext* MySqlParser::setStatement() {
  SetStatementContext *_localctx = _tracker.createInstance<SetStatementContext>(_ctx, getState());
  enterRule(_localctx, 482, MySqlParser::RuleSetStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5707);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 829, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::SetVariableContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(5655);
      match(MySqlParser::SET);
      setState(5656);
      variableClause();
      setState(5657);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::VAR_ASSIGN

      || _la == MySqlParser::EQUAL_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5660);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 822, _ctx)) {
      case 1: {
        setState(5658);
        expression(0);
        break;
      }

      case 2: {
        setState(5659);
        match(MySqlParser::ON);
        break;
      }

      default:
        break;
      }
      setState(5671);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5662);
        match(MySqlParser::COMMA);
        setState(5663);
        variableClause();
        setState(5664);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::VAR_ASSIGN

        || _la == MySqlParser::EQUAL_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5667);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 823, _ctx)) {
        case 1: {
          setState(5665);
          expression(0);
          break;
        }

        case 2: {
          setState(5666);
          match(MySqlParser::ON);
          break;
        }

        default:
          break;
        }
        setState(5673);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::SetCharsetContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(5674);
      match(MySqlParser::SET);
      setState(5675);
      charSet();
      setState(5678);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::BINARY:
        case MySqlParser::ARMSCII8:
        case MySqlParser::ASCII:
        case MySqlParser::BIG5:
        case MySqlParser::CP1250:
        case MySqlParser::CP1251:
        case MySqlParser::CP1256:
        case MySqlParser::CP1257:
        case MySqlParser::CP850:
        case MySqlParser::CP852:
        case MySqlParser::CP866:
        case MySqlParser::CP932:
        case MySqlParser::DEC8:
        case MySqlParser::EUCJPMS:
        case MySqlParser::EUCKR:
        case MySqlParser::GB18030:
        case MySqlParser::GB2312:
        case MySqlParser::GBK:
        case MySqlParser::GEOSTD8:
        case MySqlParser::GREEK:
        case MySqlParser::HEBREW:
        case MySqlParser::HP8:
        case MySqlParser::KEYBCS2:
        case MySqlParser::KOI8R:
        case MySqlParser::KOI8U:
        case MySqlParser::LATIN1:
        case MySqlParser::LATIN2:
        case MySqlParser::LATIN5:
        case MySqlParser::LATIN7:
        case MySqlParser::MACCE:
        case MySqlParser::MACROMAN:
        case MySqlParser::SJIS:
        case MySqlParser::SWE7:
        case MySqlParser::TIS620:
        case MySqlParser::UCS2:
        case MySqlParser::UJIS:
        case MySqlParser::UTF16:
        case MySqlParser::UTF16LE:
        case MySqlParser::UTF32:
        case MySqlParser::UTF8:
        case MySqlParser::UTF8MB3:
        case MySqlParser::UTF8MB4:
        case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
        case MySqlParser::STRING_LITERAL: {
          setState(5676);
          charsetName();
          break;
        }

        case MySqlParser::DEFAULT: {
          setState(5677);
          match(MySqlParser::DEFAULT);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::SetNamesContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(5680);
      match(MySqlParser::SET);
      setState(5681);
      match(MySqlParser::NAMES);
      setState(5688);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::BINARY:
        case MySqlParser::ARMSCII8:
        case MySqlParser::ASCII:
        case MySqlParser::BIG5:
        case MySqlParser::CP1250:
        case MySqlParser::CP1251:
        case MySqlParser::CP1256:
        case MySqlParser::CP1257:
        case MySqlParser::CP850:
        case MySqlParser::CP852:
        case MySqlParser::CP866:
        case MySqlParser::CP932:
        case MySqlParser::DEC8:
        case MySqlParser::EUCJPMS:
        case MySqlParser::EUCKR:
        case MySqlParser::GB18030:
        case MySqlParser::GB2312:
        case MySqlParser::GBK:
        case MySqlParser::GEOSTD8:
        case MySqlParser::GREEK:
        case MySqlParser::HEBREW:
        case MySqlParser::HP8:
        case MySqlParser::KEYBCS2:
        case MySqlParser::KOI8R:
        case MySqlParser::KOI8U:
        case MySqlParser::LATIN1:
        case MySqlParser::LATIN2:
        case MySqlParser::LATIN5:
        case MySqlParser::LATIN7:
        case MySqlParser::MACCE:
        case MySqlParser::MACROMAN:
        case MySqlParser::SJIS:
        case MySqlParser::SWE7:
        case MySqlParser::TIS620:
        case MySqlParser::UCS2:
        case MySqlParser::UJIS:
        case MySqlParser::UTF16:
        case MySqlParser::UTF16LE:
        case MySqlParser::UTF32:
        case MySqlParser::UTF8:
        case MySqlParser::UTF8MB3:
        case MySqlParser::UTF8MB4:
        case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
        case MySqlParser::STRING_LITERAL: {
          setState(5682);
          charsetName();
          setState(5685);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::COLLATE) {
            setState(5683);
            match(MySqlParser::COLLATE);
            setState(5684);
            collationName();
          }
          break;
        }

        case MySqlParser::DEFAULT: {
          setState(5687);
          match(MySqlParser::DEFAULT);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::SetPasswordContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(5690);
      setPasswordStatement();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<MySqlParser::SetTransactionContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(5691);
      setTransactionStatement();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<MySqlParser::SetAutocommitContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(5692);
      setAutocommitStatement();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<MySqlParser::SetNewValueInsideTriggerContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(5693);
      match(MySqlParser::SET);
      setState(5694);
      fullId();
      setState(5695);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::VAR_ASSIGN

      || _la == MySqlParser::EQUAL_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5696);
      expression(0);
      setState(5704);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5697);
        match(MySqlParser::COMMA);
        setState(5698);
        fullId();
        setState(5699);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::VAR_ASSIGN

        || _la == MySqlParser::EQUAL_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5700);
        expression(0);
        setState(5706);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowStatementContext ------------------------------------------------------------------

MySqlParser::ShowStatementContext::ShowStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::ShowStatementContext::getRuleIndex() const {
  return MySqlParser::RuleShowStatement;
}

void MySqlParser::ShowStatementContext::copyFrom(ShowStatementContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ShowOpenTablesContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowOpenTablesContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::ShowOpenTablesContext::OPEN() {
  return getToken(MySqlParser::OPEN, 0);
}

tree::TerminalNode* MySqlParser::ShowOpenTablesContext::TABLES() {
  return getToken(MySqlParser::TABLES, 0);
}

MySqlParser::UidContext* MySqlParser::ShowOpenTablesContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::ShowFilterContext* MySqlParser::ShowOpenTablesContext::showFilter() {
  return getRuleContext<MySqlParser::ShowFilterContext>(0);
}

tree::TerminalNode* MySqlParser::ShowOpenTablesContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

tree::TerminalNode* MySqlParser::ShowOpenTablesContext::IN() {
  return getToken(MySqlParser::IN, 0);
}

MySqlParser::ShowOpenTablesContext::ShowOpenTablesContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowOpenTablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowOpenTables(this);
}
void MySqlParser::ShowOpenTablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowOpenTables(this);
}

std::any MySqlParser::ShowOpenTablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowOpenTables(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowGlobalInfoContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowGlobalInfoContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

MySqlParser::ShowGlobalInfoClauseContext* MySqlParser::ShowGlobalInfoContext::showGlobalInfoClause() {
  return getRuleContext<MySqlParser::ShowGlobalInfoClauseContext>(0);
}

MySqlParser::ShowGlobalInfoContext::ShowGlobalInfoContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowGlobalInfoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowGlobalInfo(this);
}
void MySqlParser::ShowGlobalInfoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowGlobalInfo(this);
}

std::any MySqlParser::ShowGlobalInfoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowGlobalInfo(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowCreateFullIdObjectContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowCreateFullIdObjectContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::ShowCreateFullIdObjectContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

MySqlParser::FullIdContext* MySqlParser::ShowCreateFullIdObjectContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

tree::TerminalNode* MySqlParser::ShowCreateFullIdObjectContext::EVENT() {
  return getToken(MySqlParser::EVENT, 0);
}

tree::TerminalNode* MySqlParser::ShowCreateFullIdObjectContext::FUNCTION() {
  return getToken(MySqlParser::FUNCTION, 0);
}

tree::TerminalNode* MySqlParser::ShowCreateFullIdObjectContext::PROCEDURE() {
  return getToken(MySqlParser::PROCEDURE, 0);
}

tree::TerminalNode* MySqlParser::ShowCreateFullIdObjectContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

tree::TerminalNode* MySqlParser::ShowCreateFullIdObjectContext::TRIGGER() {
  return getToken(MySqlParser::TRIGGER, 0);
}

tree::TerminalNode* MySqlParser::ShowCreateFullIdObjectContext::VIEW() {
  return getToken(MySqlParser::VIEW, 0);
}

MySqlParser::ShowCreateFullIdObjectContext::ShowCreateFullIdObjectContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowCreateFullIdObjectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateFullIdObject(this);
}
void MySqlParser::ShowCreateFullIdObjectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateFullIdObject(this);
}

std::any MySqlParser::ShowCreateFullIdObjectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowCreateFullIdObject(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowCreateUserContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowCreateUserContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::ShowCreateUserContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

tree::TerminalNode* MySqlParser::ShowCreateUserContext::USER() {
  return getToken(MySqlParser::USER, 0);
}

MySqlParser::UserNameContext* MySqlParser::ShowCreateUserContext::userName() {
  return getRuleContext<MySqlParser::UserNameContext>(0);
}

MySqlParser::ShowCreateUserContext::ShowCreateUserContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowCreateUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateUser(this);
}
void MySqlParser::ShowCreateUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateUser(this);
}

std::any MySqlParser::ShowCreateUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowCreateUser(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowErrorsContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowErrorsContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::ShowErrorsContext::ERRORS() {
  return getToken(MySqlParser::ERRORS, 0);
}

tree::TerminalNode* MySqlParser::ShowErrorsContext::WARNINGS() {
  return getToken(MySqlParser::WARNINGS, 0);
}

tree::TerminalNode* MySqlParser::ShowErrorsContext::LIMIT() {
  return getToken(MySqlParser::LIMIT, 0);
}

std::vector<MySqlParser::DecimalLiteralContext *> MySqlParser::ShowErrorsContext::decimalLiteral() {
  return getRuleContexts<MySqlParser::DecimalLiteralContext>();
}

MySqlParser::DecimalLiteralContext* MySqlParser::ShowErrorsContext::decimalLiteral(size_t i) {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(i);
}

tree::TerminalNode* MySqlParser::ShowErrorsContext::COMMA() {
  return getToken(MySqlParser::COMMA, 0);
}

MySqlParser::ShowErrorsContext::ShowErrorsContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowErrorsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowErrors(this);
}
void MySqlParser::ShowErrorsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowErrors(this);
}

std::any MySqlParser::ShowErrorsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowErrors(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowCountErrorsContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowCountErrorsContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::ShowCountErrorsContext::COUNT() {
  return getToken(MySqlParser::COUNT, 0);
}

tree::TerminalNode* MySqlParser::ShowCountErrorsContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::ShowCountErrorsContext::STAR() {
  return getToken(MySqlParser::STAR, 0);
}

tree::TerminalNode* MySqlParser::ShowCountErrorsContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::ShowCountErrorsContext::ERRORS() {
  return getToken(MySqlParser::ERRORS, 0);
}

tree::TerminalNode* MySqlParser::ShowCountErrorsContext::WARNINGS() {
  return getToken(MySqlParser::WARNINGS, 0);
}

MySqlParser::ShowCountErrorsContext::ShowCountErrorsContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowCountErrorsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCountErrors(this);
}
void MySqlParser::ShowCountErrorsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCountErrors(this);
}

std::any MySqlParser::ShowCountErrorsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowCountErrors(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowObjectFilterContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowObjectFilterContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

MySqlParser::ShowCommonEntityContext* MySqlParser::ShowObjectFilterContext::showCommonEntity() {
  return getRuleContext<MySqlParser::ShowCommonEntityContext>(0);
}

MySqlParser::ShowFilterContext* MySqlParser::ShowObjectFilterContext::showFilter() {
  return getRuleContext<MySqlParser::ShowFilterContext>(0);
}

MySqlParser::ShowObjectFilterContext::ShowObjectFilterContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowObjectFilterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowObjectFilter(this);
}
void MySqlParser::ShowObjectFilterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowObjectFilter(this);
}

std::any MySqlParser::ShowObjectFilterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowObjectFilter(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowCreateDbContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowCreateDbContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::ShowCreateDbContext::CREATE() {
  return getToken(MySqlParser::CREATE, 0);
}

MySqlParser::UidContext* MySqlParser::ShowCreateDbContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::ShowCreateDbContext::DATABASE() {
  return getToken(MySqlParser::DATABASE, 0);
}

tree::TerminalNode* MySqlParser::ShowCreateDbContext::SCHEMA() {
  return getToken(MySqlParser::SCHEMA, 0);
}

MySqlParser::IfNotExistsContext* MySqlParser::ShowCreateDbContext::ifNotExists() {
  return getRuleContext<MySqlParser::IfNotExistsContext>(0);
}

MySqlParser::ShowCreateDbContext::ShowCreateDbContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowCreateDbContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateDb(this);
}
void MySqlParser::ShowCreateDbContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateDb(this);
}

std::any MySqlParser::ShowCreateDbContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowCreateDb(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowEngineContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowEngineContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::ShowEngineContext::ENGINE() {
  return getToken(MySqlParser::ENGINE, 0);
}

MySqlParser::EngineNameContext* MySqlParser::ShowEngineContext::engineName() {
  return getRuleContext<MySqlParser::EngineNameContext>(0);
}

tree::TerminalNode* MySqlParser::ShowEngineContext::STATUS() {
  return getToken(MySqlParser::STATUS, 0);
}

tree::TerminalNode* MySqlParser::ShowEngineContext::MUTEX() {
  return getToken(MySqlParser::MUTEX, 0);
}

MySqlParser::ShowEngineContext::ShowEngineContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowEngineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowEngine(this);
}
void MySqlParser::ShowEngineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowEngine(this);
}

std::any MySqlParser::ShowEngineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowEngine(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowSchemaFilterContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowSchemaFilterContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

MySqlParser::ShowSchemaEntityContext* MySqlParser::ShowSchemaFilterContext::showSchemaEntity() {
  return getRuleContext<MySqlParser::ShowSchemaEntityContext>(0);
}

MySqlParser::UidContext* MySqlParser::ShowSchemaFilterContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::ShowFilterContext* MySqlParser::ShowSchemaFilterContext::showFilter() {
  return getRuleContext<MySqlParser::ShowFilterContext>(0);
}

tree::TerminalNode* MySqlParser::ShowSchemaFilterContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

tree::TerminalNode* MySqlParser::ShowSchemaFilterContext::IN() {
  return getToken(MySqlParser::IN, 0);
}

MySqlParser::ShowSchemaFilterContext::ShowSchemaFilterContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowSchemaFilterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowSchemaFilter(this);
}
void MySqlParser::ShowSchemaFilterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowSchemaFilter(this);
}

std::any MySqlParser::ShowSchemaFilterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowSchemaFilter(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowIndexesContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowIndexesContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

MySqlParser::TableNameContext* MySqlParser::ShowIndexesContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::ShowIndexesContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::ShowIndexesContext::INDEXES() {
  return getToken(MySqlParser::INDEXES, 0);
}

tree::TerminalNode* MySqlParser::ShowIndexesContext::KEYS() {
  return getToken(MySqlParser::KEYS, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::ShowIndexesContext::FROM() {
  return getTokens(MySqlParser::FROM);
}

tree::TerminalNode* MySqlParser::ShowIndexesContext::FROM(size_t i) {
  return getToken(MySqlParser::FROM, i);
}

std::vector<tree::TerminalNode *> MySqlParser::ShowIndexesContext::IN() {
  return getTokens(MySqlParser::IN);
}

tree::TerminalNode* MySqlParser::ShowIndexesContext::IN(size_t i) {
  return getToken(MySqlParser::IN, i);
}

MySqlParser::UidContext* MySqlParser::ShowIndexesContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::ShowIndexesContext::WHERE() {
  return getToken(MySqlParser::WHERE, 0);
}

MySqlParser::ExpressionContext* MySqlParser::ShowIndexesContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

MySqlParser::ShowIndexesContext::ShowIndexesContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowIndexesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowIndexes(this);
}
void MySqlParser::ShowIndexesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowIndexes(this);
}

std::any MySqlParser::ShowIndexesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowIndexes(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowLogEventsContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowLogEventsContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::ShowLogEventsContext::EVENTS() {
  return getToken(MySqlParser::EVENTS, 0);
}

tree::TerminalNode* MySqlParser::ShowLogEventsContext::BINLOG() {
  return getToken(MySqlParser::BINLOG, 0);
}

tree::TerminalNode* MySqlParser::ShowLogEventsContext::RELAYLOG() {
  return getToken(MySqlParser::RELAYLOG, 0);
}

tree::TerminalNode* MySqlParser::ShowLogEventsContext::IN() {
  return getToken(MySqlParser::IN, 0);
}

tree::TerminalNode* MySqlParser::ShowLogEventsContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

tree::TerminalNode* MySqlParser::ShowLogEventsContext::LIMIT() {
  return getToken(MySqlParser::LIMIT, 0);
}

tree::TerminalNode* MySqlParser::ShowLogEventsContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

std::vector<MySqlParser::DecimalLiteralContext *> MySqlParser::ShowLogEventsContext::decimalLiteral() {
  return getRuleContexts<MySqlParser::DecimalLiteralContext>();
}

MySqlParser::DecimalLiteralContext* MySqlParser::ShowLogEventsContext::decimalLiteral(size_t i) {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(i);
}

tree::TerminalNode* MySqlParser::ShowLogEventsContext::COMMA() {
  return getToken(MySqlParser::COMMA, 0);
}

MySqlParser::ShowLogEventsContext::ShowLogEventsContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowLogEventsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowLogEvents(this);
}
void MySqlParser::ShowLogEventsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowLogEvents(this);
}

std::any MySqlParser::ShowLogEventsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowLogEvents(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowMasterLogsContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowMasterLogsContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::ShowMasterLogsContext::LOGS() {
  return getToken(MySqlParser::LOGS, 0);
}

tree::TerminalNode* MySqlParser::ShowMasterLogsContext::BINARY() {
  return getToken(MySqlParser::BINARY, 0);
}

tree::TerminalNode* MySqlParser::ShowMasterLogsContext::MASTER() {
  return getToken(MySqlParser::MASTER, 0);
}

MySqlParser::ShowMasterLogsContext::ShowMasterLogsContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowMasterLogsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowMasterLogs(this);
}
void MySqlParser::ShowMasterLogsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowMasterLogs(this);
}

std::any MySqlParser::ShowMasterLogsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowMasterLogs(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowGrantsContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowGrantsContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::ShowGrantsContext::GRANTS() {
  return getToken(MySqlParser::GRANTS, 0);
}

tree::TerminalNode* MySqlParser::ShowGrantsContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

MySqlParser::UserNameContext* MySqlParser::ShowGrantsContext::userName() {
  return getRuleContext<MySqlParser::UserNameContext>(0);
}

MySqlParser::ShowGrantsContext::ShowGrantsContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowGrantsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowGrants(this);
}
void MySqlParser::ShowGrantsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowGrants(this);
}

std::any MySqlParser::ShowGrantsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowGrants(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowSlaveStatusContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowSlaveStatusContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::ShowSlaveStatusContext::SLAVE() {
  return getToken(MySqlParser::SLAVE, 0);
}

tree::TerminalNode* MySqlParser::ShowSlaveStatusContext::STATUS() {
  return getToken(MySqlParser::STATUS, 0);
}

tree::TerminalNode* MySqlParser::ShowSlaveStatusContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

tree::TerminalNode* MySqlParser::ShowSlaveStatusContext::CHANNEL() {
  return getToken(MySqlParser::CHANNEL, 0);
}

tree::TerminalNode* MySqlParser::ShowSlaveStatusContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

MySqlParser::ShowSlaveStatusContext::ShowSlaveStatusContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowSlaveStatusContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowSlaveStatus(this);
}
void MySqlParser::ShowSlaveStatusContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowSlaveStatus(this);
}

std::any MySqlParser::ShowSlaveStatusContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowSlaveStatus(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowRoutineContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowRoutineContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::ShowRoutineContext::CODE() {
  return getToken(MySqlParser::CODE, 0);
}

MySqlParser::FullIdContext* MySqlParser::ShowRoutineContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

tree::TerminalNode* MySqlParser::ShowRoutineContext::FUNCTION() {
  return getToken(MySqlParser::FUNCTION, 0);
}

tree::TerminalNode* MySqlParser::ShowRoutineContext::PROCEDURE() {
  return getToken(MySqlParser::PROCEDURE, 0);
}

MySqlParser::ShowRoutineContext::ShowRoutineContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowRoutineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowRoutine(this);
}
void MySqlParser::ShowRoutineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowRoutine(this);
}

std::any MySqlParser::ShowRoutineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowRoutine(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowProfileContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowProfileContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

tree::TerminalNode* MySqlParser::ShowProfileContext::PROFILE() {
  return getToken(MySqlParser::PROFILE, 0);
}

std::vector<MySqlParser::ShowProfileTypeContext *> MySqlParser::ShowProfileContext::showProfileType() {
  return getRuleContexts<MySqlParser::ShowProfileTypeContext>();
}

MySqlParser::ShowProfileTypeContext* MySqlParser::ShowProfileContext::showProfileType(size_t i) {
  return getRuleContext<MySqlParser::ShowProfileTypeContext>(i);
}

tree::TerminalNode* MySqlParser::ShowProfileContext::LIMIT() {
  return getToken(MySqlParser::LIMIT, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::ShowProfileContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::ShowProfileContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::ShowProfileContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

tree::TerminalNode* MySqlParser::ShowProfileContext::QUERY() {
  return getToken(MySqlParser::QUERY, 0);
}

std::vector<MySqlParser::DecimalLiteralContext *> MySqlParser::ShowProfileContext::decimalLiteral() {
  return getRuleContexts<MySqlParser::DecimalLiteralContext>();
}

MySqlParser::DecimalLiteralContext* MySqlParser::ShowProfileContext::decimalLiteral(size_t i) {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(i);
}

MySqlParser::ShowProfileContext::ShowProfileContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowProfileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowProfile(this);
}
void MySqlParser::ShowProfileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowProfile(this);
}

std::any MySqlParser::ShowProfileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowProfile(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ShowColumnsContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ShowColumnsContext::SHOW() {
  return getToken(MySqlParser::SHOW, 0);
}

MySqlParser::TableNameContext* MySqlParser::ShowColumnsContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::ShowColumnsContext::COLUMNS() {
  return getToken(MySqlParser::COLUMNS, 0);
}

tree::TerminalNode* MySqlParser::ShowColumnsContext::FIELDS() {
  return getToken(MySqlParser::FIELDS, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::ShowColumnsContext::FROM() {
  return getTokens(MySqlParser::FROM);
}

tree::TerminalNode* MySqlParser::ShowColumnsContext::FROM(size_t i) {
  return getToken(MySqlParser::FROM, i);
}

std::vector<tree::TerminalNode *> MySqlParser::ShowColumnsContext::IN() {
  return getTokens(MySqlParser::IN);
}

tree::TerminalNode* MySqlParser::ShowColumnsContext::IN(size_t i) {
  return getToken(MySqlParser::IN, i);
}

tree::TerminalNode* MySqlParser::ShowColumnsContext::FULL() {
  return getToken(MySqlParser::FULL, 0);
}

MySqlParser::UidContext* MySqlParser::ShowColumnsContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::ShowFilterContext* MySqlParser::ShowColumnsContext::showFilter() {
  return getRuleContext<MySqlParser::ShowFilterContext>(0);
}

MySqlParser::ShowColumnsContext::ShowColumnsContext(ShowStatementContext *ctx) { copyFrom(ctx); }

void MySqlParser::ShowColumnsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowColumns(this);
}
void MySqlParser::ShowColumnsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowColumns(this);
}

std::any MySqlParser::ShowColumnsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowColumns(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::ShowStatementContext* MySqlParser::showStatement() {
  ShowStatementContext *_localctx = _tracker.createInstance<ShowStatementContext>(_ctx, getState());
  enterRule(_localctx, 484, MySqlParser::RuleShowStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5862);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 852, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::ShowMasterLogsContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(5709);
      match(MySqlParser::SHOW);
      setState(5710);
      antlrcpp::downCast<ShowMasterLogsContext *>(_localctx)->logFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::BINARY || _la == MySqlParser::MASTER)) {
        antlrcpp::downCast<ShowMasterLogsContext *>(_localctx)->logFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5711);
      match(MySqlParser::LOGS);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::ShowLogEventsContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(5712);
      match(MySqlParser::SHOW);
      setState(5713);
      antlrcpp::downCast<ShowLogEventsContext *>(_localctx)->logFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::BINLOG || _la == MySqlParser::RELAYLOG)) {
        antlrcpp::downCast<ShowLogEventsContext *>(_localctx)->logFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5714);
      match(MySqlParser::EVENTS);
      setState(5717);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::IN) {
        setState(5715);
        match(MySqlParser::IN);
        setState(5716);
        antlrcpp::downCast<ShowLogEventsContext *>(_localctx)->filename = match(MySqlParser::STRING_LITERAL);
      }
      setState(5721);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::FROM) {
        setState(5719);
        match(MySqlParser::FROM);
        setState(5720);
        antlrcpp::downCast<ShowLogEventsContext *>(_localctx)->fromPosition = decimalLiteral();
      }
      setState(5730);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LIMIT) {
        setState(5723);
        match(MySqlParser::LIMIT);
        setState(5727);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 832, _ctx)) {
        case 1: {
          setState(5724);
          antlrcpp::downCast<ShowLogEventsContext *>(_localctx)->offset = decimalLiteral();
          setState(5725);
          match(MySqlParser::COMMA);
          break;
        }

        default:
          break;
        }
        setState(5729);
        antlrcpp::downCast<ShowLogEventsContext *>(_localctx)->rowCount = decimalLiteral();
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::ShowObjectFilterContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(5732);
      match(MySqlParser::SHOW);
      setState(5733);
      showCommonEntity();
      setState(5735);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LIKE || _la == MySqlParser::WHERE) {
        setState(5734);
        showFilter();
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::ShowColumnsContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(5737);
      match(MySqlParser::SHOW);
      setState(5739);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::FULL) {
        setState(5738);
        match(MySqlParser::FULL);
      }
      setState(5741);
      antlrcpp::downCast<ShowColumnsContext *>(_localctx)->columnsFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::COLUMNS

      || _la == MySqlParser::FIELDS)) {
        antlrcpp::downCast<ShowColumnsContext *>(_localctx)->columnsFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5742);
      antlrcpp::downCast<ShowColumnsContext *>(_localctx)->tableFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::FROM

      || _la == MySqlParser::IN)) {
        antlrcpp::downCast<ShowColumnsContext *>(_localctx)->tableFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5743);
      tableName();
      setState(5746);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::FROM

      || _la == MySqlParser::IN) {
        setState(5744);
        antlrcpp::downCast<ShowColumnsContext *>(_localctx)->schemaFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::FROM

        || _la == MySqlParser::IN)) {
          antlrcpp::downCast<ShowColumnsContext *>(_localctx)->schemaFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5745);
        uid();
      }
      setState(5749);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LIKE || _la == MySqlParser::WHERE) {
        setState(5748);
        showFilter();
      }
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<MySqlParser::ShowCreateDbContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(5751);
      match(MySqlParser::SHOW);
      setState(5752);
      match(MySqlParser::CREATE);
      setState(5753);
      antlrcpp::downCast<ShowCreateDbContext *>(_localctx)->schemaFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::DATABASE || _la == MySqlParser::SCHEMA)) {
        antlrcpp::downCast<ShowCreateDbContext *>(_localctx)->schemaFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5755);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 838, _ctx)) {
      case 1: {
        setState(5754);
        ifNotExists();
        break;
      }

      default:
        break;
      }
      setState(5757);
      uid();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<MySqlParser::ShowCreateFullIdObjectContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(5758);
      match(MySqlParser::SHOW);
      setState(5759);
      match(MySqlParser::CREATE);
      setState(5760);
      antlrcpp::downCast<ShowCreateFullIdObjectContext *>(_localctx)->namedEntity = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 131) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 131)) & 72567767433217) != 0) || _la == MySqlParser::EVENT

      || _la == MySqlParser::FUNCTION || _la == MySqlParser::VIEW)) {
        antlrcpp::downCast<ShowCreateFullIdObjectContext *>(_localctx)->namedEntity = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5761);
      fullId();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<MySqlParser::ShowCreateUserContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(5762);
      match(MySqlParser::SHOW);
      setState(5763);
      match(MySqlParser::CREATE);
      setState(5764);
      match(MySqlParser::USER);
      setState(5765);
      userName();
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<MySqlParser::ShowEngineContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(5766);
      match(MySqlParser::SHOW);
      setState(5767);
      match(MySqlParser::ENGINE);
      setState(5768);
      engineName();
      setState(5769);
      antlrcpp::downCast<ShowEngineContext *>(_localctx)->engineOption = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::MUTEX || _la == MySqlParser::STATUS)) {
        antlrcpp::downCast<ShowEngineContext *>(_localctx)->engineOption = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<MySqlParser::ShowGlobalInfoContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(5771);
      match(MySqlParser::SHOW);
      setState(5772);
      showGlobalInfoClause();
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<MySqlParser::ShowErrorsContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(5773);
      match(MySqlParser::SHOW);
      setState(5774);
      antlrcpp::downCast<ShowErrorsContext *>(_localctx)->errorFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::ERRORS || _la == MySqlParser::WARNINGS)) {
        antlrcpp::downCast<ShowErrorsContext *>(_localctx)->errorFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5782);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LIMIT) {
        setState(5775);
        match(MySqlParser::LIMIT);
        setState(5779);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 839, _ctx)) {
        case 1: {
          setState(5776);
          antlrcpp::downCast<ShowErrorsContext *>(_localctx)->offset = decimalLiteral();
          setState(5777);
          match(MySqlParser::COMMA);
          break;
        }

        default:
          break;
        }
        setState(5781);
        antlrcpp::downCast<ShowErrorsContext *>(_localctx)->rowCount = decimalLiteral();
      }
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<MySqlParser::ShowCountErrorsContext>(_localctx);
      enterOuterAlt(_localctx, 11);
      setState(5784);
      match(MySqlParser::SHOW);
      setState(5785);
      match(MySqlParser::COUNT);
      setState(5786);
      match(MySqlParser::LR_BRACKET);
      setState(5787);
      match(MySqlParser::STAR);
      setState(5788);
      match(MySqlParser::RR_BRACKET);
      setState(5789);
      antlrcpp::downCast<ShowCountErrorsContext *>(_localctx)->errorFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::ERRORS || _la == MySqlParser::WARNINGS)) {
        antlrcpp::downCast<ShowCountErrorsContext *>(_localctx)->errorFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<MySqlParser::ShowSchemaFilterContext>(_localctx);
      enterOuterAlt(_localctx, 12);
      setState(5790);
      match(MySqlParser::SHOW);
      setState(5791);
      showSchemaEntity();
      setState(5794);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::FROM

      || _la == MySqlParser::IN) {
        setState(5792);
        antlrcpp::downCast<ShowSchemaFilterContext *>(_localctx)->schemaFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::FROM

        || _la == MySqlParser::IN)) {
          antlrcpp::downCast<ShowSchemaFilterContext *>(_localctx)->schemaFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5793);
        uid();
      }
      setState(5797);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LIKE || _la == MySqlParser::WHERE) {
        setState(5796);
        showFilter();
      }
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<MySqlParser::ShowRoutineContext>(_localctx);
      enterOuterAlt(_localctx, 13);
      setState(5799);
      match(MySqlParser::SHOW);
      setState(5800);
      antlrcpp::downCast<ShowRoutineContext *>(_localctx)->routine = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::PROCEDURE || _la == MySqlParser::FUNCTION)) {
        antlrcpp::downCast<ShowRoutineContext *>(_localctx)->routine = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5801);
      match(MySqlParser::CODE);
      setState(5802);
      fullId();
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<MySqlParser::ShowGrantsContext>(_localctx);
      enterOuterAlt(_localctx, 14);
      setState(5803);
      match(MySqlParser::SHOW);
      setState(5804);
      match(MySqlParser::GRANTS);
      setState(5807);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::FOR) {
        setState(5805);
        match(MySqlParser::FOR);
        setState(5806);
        userName();
      }
      break;
    }

    case 15: {
      _localctx = _tracker.createInstance<MySqlParser::ShowIndexesContext>(_localctx);
      enterOuterAlt(_localctx, 15);
      setState(5809);
      match(MySqlParser::SHOW);
      setState(5810);
      antlrcpp::downCast<ShowIndexesContext *>(_localctx)->indexFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::INDEX

      || _la == MySqlParser::KEYS || _la == MySqlParser::INDEXES)) {
        antlrcpp::downCast<ShowIndexesContext *>(_localctx)->indexFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5811);
      antlrcpp::downCast<ShowIndexesContext *>(_localctx)->tableFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::FROM

      || _la == MySqlParser::IN)) {
        antlrcpp::downCast<ShowIndexesContext *>(_localctx)->tableFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5812);
      tableName();
      setState(5815);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::FROM

      || _la == MySqlParser::IN) {
        setState(5813);
        antlrcpp::downCast<ShowIndexesContext *>(_localctx)->schemaFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::FROM

        || _la == MySqlParser::IN)) {
          antlrcpp::downCast<ShowIndexesContext *>(_localctx)->schemaFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5814);
        uid();
      }
      setState(5819);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::WHERE) {
        setState(5817);
        match(MySqlParser::WHERE);
        setState(5818);
        expression(0);
      }
      break;
    }

    case 16: {
      _localctx = _tracker.createInstance<MySqlParser::ShowOpenTablesContext>(_localctx);
      enterOuterAlt(_localctx, 16);
      setState(5821);
      match(MySqlParser::SHOW);
      setState(5822);
      match(MySqlParser::OPEN);
      setState(5823);
      match(MySqlParser::TABLES);
      setState(5826);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::FROM

      || _la == MySqlParser::IN) {
        setState(5824);
        antlrcpp::downCast<ShowOpenTablesContext *>(_localctx)->schemaFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::FROM

        || _la == MySqlParser::IN)) {
          antlrcpp::downCast<ShowOpenTablesContext *>(_localctx)->schemaFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5825);
        uid();
      }
      setState(5829);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LIKE || _la == MySqlParser::WHERE) {
        setState(5828);
        showFilter();
      }
      break;
    }

    case 17: {
      _localctx = _tracker.createInstance<MySqlParser::ShowProfileContext>(_localctx);
      enterOuterAlt(_localctx, 17);
      setState(5831);
      match(MySqlParser::SHOW);
      setState(5832);
      match(MySqlParser::PROFILE);
      setState(5833);
      showProfileType();
      setState(5838);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(5834);
        match(MySqlParser::COMMA);
        setState(5835);
        showProfileType();
        setState(5840);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(5844);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::FOR) {
        setState(5841);
        match(MySqlParser::FOR);
        setState(5842);
        match(MySqlParser::QUERY);
        setState(5843);
        antlrcpp::downCast<ShowProfileContext *>(_localctx)->queryCount = decimalLiteral();
      }

      setState(5846);
      match(MySqlParser::LIMIT);
      setState(5850);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 850, _ctx)) {
      case 1: {
        setState(5847);
        antlrcpp::downCast<ShowProfileContext *>(_localctx)->offset = decimalLiteral();
        setState(5848);
        match(MySqlParser::COMMA);
        break;
      }

      default:
        break;
      }
      setState(5852);
      antlrcpp::downCast<ShowProfileContext *>(_localctx)->rowCount = decimalLiteral();
      break;
    }

    case 18: {
      _localctx = _tracker.createInstance<MySqlParser::ShowSlaveStatusContext>(_localctx);
      enterOuterAlt(_localctx, 18);
      setState(5854);
      match(MySqlParser::SHOW);
      setState(5855);
      match(MySqlParser::SLAVE);
      setState(5856);
      match(MySqlParser::STATUS);
      setState(5860);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::FOR) {
        setState(5857);
        match(MySqlParser::FOR);
        setState(5858);
        match(MySqlParser::CHANNEL);
        setState(5859);
        match(MySqlParser::STRING_LITERAL);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableClauseContext ------------------------------------------------------------------

MySqlParser::VariableClauseContext::VariableClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::VariableClauseContext::LOCAL_ID() {
  return getToken(MySqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* MySqlParser::VariableClauseContext::GLOBAL_ID() {
  return getToken(MySqlParser::GLOBAL_ID, 0);
}

MySqlParser::UidContext* MySqlParser::VariableClauseContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::VariableClauseContext::GLOBAL() {
  return getToken(MySqlParser::GLOBAL, 0);
}

tree::TerminalNode* MySqlParser::VariableClauseContext::SESSION() {
  return getToken(MySqlParser::SESSION, 0);
}

tree::TerminalNode* MySqlParser::VariableClauseContext::LOCAL() {
  return getToken(MySqlParser::LOCAL, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::VariableClauseContext::AT_SIGN() {
  return getTokens(MySqlParser::AT_SIGN);
}

tree::TerminalNode* MySqlParser::VariableClauseContext::AT_SIGN(size_t i) {
  return getToken(MySqlParser::AT_SIGN, i);
}


size_t MySqlParser::VariableClauseContext::getRuleIndex() const {
  return MySqlParser::RuleVariableClause;
}

void MySqlParser::VariableClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableClause(this);
}

void MySqlParser::VariableClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableClause(this);
}


std::any MySqlParser::VariableClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitVariableClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::VariableClauseContext* MySqlParser::variableClause() {
  VariableClauseContext *_localctx = _tracker.createInstance<VariableClauseContext>(_ctx, getState());
  enterRule(_localctx, 486, MySqlParser::RuleVariableClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5874);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::LOCAL_ID: {
        enterOuterAlt(_localctx, 1);
        setState(5864);
        match(MySqlParser::LOCAL_ID);
        break;
      }

      case MySqlParser::GLOBAL_ID: {
        enterOuterAlt(_localctx, 2);
        setState(5865);
        match(MySqlParser::GLOBAL_ID);
        break;
      }

      case MySqlParser::ATTRIBUTE:
      case MySqlParser::BUCKETS:
      case MySqlParser::CONDITION:
      case MySqlParser::CURRENT:
      case MySqlParser::CURRENT_USER:
      case MySqlParser::DATABASE:
      case MySqlParser::DEFAULT:
      case MySqlParser::DIAGNOSTICS:
      case MySqlParser::EMPTY:
      case MySqlParser::ENFORCED:
      case MySqlParser::EXCEPT:
      case MySqlParser::GROUP:
      case MySqlParser::IF:
      case MySqlParser::IGNORED:
      case MySqlParser::INSERT:
      case MySqlParser::LATERAL:
      case MySqlParser::LEFT:
      case MySqlParser::NUMBER:
      case MySqlParser::OPTIONAL:
      case MySqlParser::ORDER:
      case MySqlParser::PRIMARY:
      case MySqlParser::REPLACE:
      case MySqlParser::RIGHT:
      case MySqlParser::SCHEMA:
      case MySqlParser::SKIP_QUERY_REWRITE:
      case MySqlParser::STACKED:
      case MySqlParser::DATE:
      case MySqlParser::TIME:
      case MySqlParser::TIMESTAMP:
      case MySqlParser::DATETIME:
      case MySqlParser::YEAR:
      case MySqlParser::BINARY:
      case MySqlParser::TEXT:
      case MySqlParser::ENUM:
      case MySqlParser::SERIAL:
      case MySqlParser::JSON_ARRAY:
      case MySqlParser::JSON_ARRAYAGG:
      case MySqlParser::JSON_ARRAY_APPEND:
      case MySqlParser::JSON_ARRAY_INSERT:
      case MySqlParser::JSON_CONTAINS:
      case MySqlParser::JSON_CONTAINS_PATH:
      case MySqlParser::JSON_DEPTH:
      case MySqlParser::JSON_EXTRACT:
      case MySqlParser::JSON_INSERT:
      case MySqlParser::JSON_KEYS:
      case MySqlParser::JSON_LENGTH:
      case MySqlParser::JSON_MERGE:
      case MySqlParser::JSON_MERGE_PATCH:
      case MySqlParser::JSON_MERGE_PRESERVE:
      case MySqlParser::JSON_OBJECT:
      case MySqlParser::JSON_OBJECTAGG:
      case MySqlParser::JSON_OVERLAPS:
      case MySqlParser::JSON_PRETTY:
      case MySqlParser::JSON_QUOTE:
      case MySqlParser::JSON_REMOVE:
      case MySqlParser::JSON_REPLACE:
      case MySqlParser::JSON_SCHEMA_VALID:
      case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
      case MySqlParser::JSON_SEARCH:
      case MySqlParser::JSON_SET:
      case MySqlParser::JSON_STORAGE_FREE:
      case MySqlParser::JSON_STORAGE_SIZE:
      case MySqlParser::JSON_TABLE:
      case MySqlParser::JSON_TYPE:
      case MySqlParser::JSON_UNQUOTE:
      case MySqlParser::JSON_VALID:
      case MySqlParser::JSON_VALUE:
      case MySqlParser::NESTED:
      case MySqlParser::ORDINALITY:
      case MySqlParser::PATH:
      case MySqlParser::AVG:
      case MySqlParser::BIT_AND:
      case MySqlParser::BIT_OR:
      case MySqlParser::BIT_XOR:
      case MySqlParser::COUNT:
      case MySqlParser::CUME_DIST:
      case MySqlParser::DENSE_RANK:
      case MySqlParser::FIRST_VALUE:
      case MySqlParser::GROUP_CONCAT:
      case MySqlParser::LAG:
      case MySqlParser::LAST_VALUE:
      case MySqlParser::LEAD:
      case MySqlParser::MAX:
      case MySqlParser::MIN:
      case MySqlParser::NTILE:
      case MySqlParser::NTH_VALUE:
      case MySqlParser::PERCENT_RANK:
      case MySqlParser::RANK:
      case MySqlParser::ROW_NUMBER:
      case MySqlParser::STD:
      case MySqlParser::STDDEV:
      case MySqlParser::STDDEV_POP:
      case MySqlParser::STDDEV_SAMP:
      case MySqlParser::SUM:
      case MySqlParser::VAR_POP:
      case MySqlParser::VAR_SAMP:
      case MySqlParser::VARIANCE:
      case MySqlParser::CURRENT_DATE:
      case MySqlParser::CURRENT_TIME:
      case MySqlParser::CURRENT_TIMESTAMP:
      case MySqlParser::LOCALTIME:
      case MySqlParser::CURDATE:
      case MySqlParser::CURTIME:
      case MySqlParser::DATE_ADD:
      case MySqlParser::DATE_SUB:
      case MySqlParser::LOCALTIMESTAMP:
      case MySqlParser::NOW:
      case MySqlParser::POSITION:
      case MySqlParser::SUBSTR:
      case MySqlParser::SUBSTRING:
      case MySqlParser::SYSDATE:
      case MySqlParser::TRIM:
      case MySqlParser::UTC_DATE:
      case MySqlParser::UTC_TIME:
      case MySqlParser::UTC_TIMESTAMP:
      case MySqlParser::ACCOUNT:
      case MySqlParser::ACTION:
      case MySqlParser::AFTER:
      case MySqlParser::AGGREGATE:
      case MySqlParser::ALGORITHM:
      case MySqlParser::ANY:
      case MySqlParser::AT:
      case MySqlParser::AUTHORS:
      case MySqlParser::AUTOCOMMIT:
      case MySqlParser::AUTOEXTEND_SIZE:
      case MySqlParser::AUTO_INCREMENT:
      case MySqlParser::AVG_ROW_LENGTH:
      case MySqlParser::BEGIN:
      case MySqlParser::BINLOG:
      case MySqlParser::BIT:
      case MySqlParser::BLOCK:
      case MySqlParser::BOOL:
      case MySqlParser::BOOLEAN:
      case MySqlParser::BTREE:
      case MySqlParser::CACHE:
      case MySqlParser::CASCADED:
      case MySqlParser::CHAIN:
      case MySqlParser::CHANGED:
      case MySqlParser::CHANNEL:
      case MySqlParser::CHECKSUM:
      case MySqlParser::PAGE_CHECKSUM:
      case MySqlParser::CIPHER:
      case MySqlParser::CLASS_ORIGIN:
      case MySqlParser::CLIENT:
      case MySqlParser::CLOSE:
      case MySqlParser::CLUSTERING:
      case MySqlParser::COALESCE:
      case MySqlParser::CODE:
      case MySqlParser::COLUMNS:
      case MySqlParser::COLUMN_FORMAT:
      case MySqlParser::COLUMN_NAME:
      case MySqlParser::COMMENT:
      case MySqlParser::COMMIT:
      case MySqlParser::COMPACT:
      case MySqlParser::COMPLETION:
      case MySqlParser::COMPRESSED:
      case MySqlParser::COMPRESSION:
      case MySqlParser::CONCURRENT:
      case MySqlParser::CONNECT:
      case MySqlParser::CONNECTION:
      case MySqlParser::CONSISTENT:
      case MySqlParser::CONSTRAINT_CATALOG:
      case MySqlParser::CONSTRAINT_SCHEMA:
      case MySqlParser::CONSTRAINT_NAME:
      case MySqlParser::CONTAINS:
      case MySqlParser::CONTEXT:
      case MySqlParser::CONTRIBUTORS:
      case MySqlParser::COPY:
      case MySqlParser::CPU:
      case MySqlParser::CURSOR_NAME:
      case MySqlParser::DATA:
      case MySqlParser::DATAFILE:
      case MySqlParser::DEALLOCATE:
      case MySqlParser::DEFAULT_AUTH:
      case MySqlParser::DEFINER:
      case MySqlParser::DELAY_KEY_WRITE:
      case MySqlParser::DES_KEY_FILE:
      case MySqlParser::DIRECTORY:
      case MySqlParser::DISABLE:
      case MySqlParser::DISCARD:
      case MySqlParser::DISK:
      case MySqlParser::DO:
      case MySqlParser::DUMPFILE:
      case MySqlParser::DUPLICATE:
      case MySqlParser::DYNAMIC:
      case MySqlParser::ENABLE:
      case MySqlParser::ENCRYPTION:
      case MySqlParser::END:
      case MySqlParser::ENDS:
      case MySqlParser::ENGINE:
      case MySqlParser::ENGINES:
      case MySqlParser::ERROR:
      case MySqlParser::ERRORS:
      case MySqlParser::ESCAPE:
      case MySqlParser::EVEN:
      case MySqlParser::EVENT:
      case MySqlParser::EVENTS:
      case MySqlParser::EVERY:
      case MySqlParser::EXCHANGE:
      case MySqlParser::EXCLUSIVE:
      case MySqlParser::EXPIRE:
      case MySqlParser::EXPORT:
      case MySqlParser::EXTENDED:
      case MySqlParser::EXTENT_SIZE:
      case MySqlParser::FAILED_LOGIN_ATTEMPTS:
      case MySqlParser::FAST:
      case MySqlParser::FAULTS:
      case MySqlParser::FIELDS:
      case MySqlParser::FILE_BLOCK_SIZE:
      case MySqlParser::FILTER:
      case MySqlParser::FIRST:
      case MySqlParser::FIXED:
      case MySqlParser::FLUSH:
      case MySqlParser::FOLLOWS:
      case MySqlParser::FOUND:
      case MySqlParser::FULL:
      case MySqlParser::FUNCTION:
      case MySqlParser::GENERAL:
      case MySqlParser::GLOBAL:
      case MySqlParser::GRANTS:
      case MySqlParser::GROUP_REPLICATION:
      case MySqlParser::HANDLER:
      case MySqlParser::HASH:
      case MySqlParser::HELP:
      case MySqlParser::HISTORY:
      case MySqlParser::HOST:
      case MySqlParser::HOSTS:
      case MySqlParser::IDENTIFIED:
      case MySqlParser::IGNORE_SERVER_IDS:
      case MySqlParser::IMPORT:
      case MySqlParser::INDEXES:
      case MySqlParser::INITIAL_SIZE:
      case MySqlParser::INPLACE:
      case MySqlParser::INSERT_METHOD:
      case MySqlParser::INSTALL:
      case MySqlParser::INSTANCE:
      case MySqlParser::INSTANT:
      case MySqlParser::INVISIBLE:
      case MySqlParser::INVOKER:
      case MySqlParser::IO:
      case MySqlParser::IO_THREAD:
      case MySqlParser::IPC:
      case MySqlParser::ISOLATION:
      case MySqlParser::ISSUER:
      case MySqlParser::JSON:
      case MySqlParser::KEY_BLOCK_SIZE:
      case MySqlParser::LANGUAGE:
      case MySqlParser::LAST:
      case MySqlParser::LEAVES:
      case MySqlParser::LESS:
      case MySqlParser::LEVEL:
      case MySqlParser::LIST:
      case MySqlParser::LOCAL:
      case MySqlParser::LOGFILE:
      case MySqlParser::LOGS:
      case MySqlParser::MASTER:
      case MySqlParser::MASTER_AUTO_POSITION:
      case MySqlParser::MASTER_CONNECT_RETRY:
      case MySqlParser::MASTER_DELAY:
      case MySqlParser::MASTER_HEARTBEAT_PERIOD:
      case MySqlParser::MASTER_HOST:
      case MySqlParser::MASTER_LOG_FILE:
      case MySqlParser::MASTER_LOG_POS:
      case MySqlParser::MASTER_PASSWORD:
      case MySqlParser::MASTER_PORT:
      case MySqlParser::MASTER_RETRY_COUNT:
      case MySqlParser::MASTER_SSL:
      case MySqlParser::MASTER_SSL_CA:
      case MySqlParser::MASTER_SSL_CAPATH:
      case MySqlParser::MASTER_SSL_CERT:
      case MySqlParser::MASTER_SSL_CIPHER:
      case MySqlParser::MASTER_SSL_CRL:
      case MySqlParser::MASTER_SSL_CRLPATH:
      case MySqlParser::MASTER_SSL_KEY:
      case MySqlParser::MASTER_TLS_VERSION:
      case MySqlParser::MASTER_USER:
      case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
      case MySqlParser::MAX_QUERIES_PER_HOUR:
      case MySqlParser::MAX_ROWS:
      case MySqlParser::MAX_SIZE:
      case MySqlParser::MAX_UPDATES_PER_HOUR:
      case MySqlParser::MAX_USER_CONNECTIONS:
      case MySqlParser::MEDIUM:
      case MySqlParser::MEMBER:
      case MySqlParser::MERGE:
      case MySqlParser::MESSAGE_TEXT:
      case MySqlParser::MID:
      case MySqlParser::MIGRATE:
      case MySqlParser::MIN_ROWS:
      case MySqlParser::MODE:
      case MySqlParser::MODIFY:
      case MySqlParser::MUTEX:
      case MySqlParser::MYSQL:
      case MySqlParser::MYSQL_ERRNO:
      case MySqlParser::NAME:
      case MySqlParser::NAMES:
      case MySqlParser::NCHAR:
      case MySqlParser::NEVER:
      case MySqlParser::NEXT:
      case MySqlParser::NO:
      case MySqlParser::NOCOPY:
      case MySqlParser::NOWAIT:
      case MySqlParser::NODEGROUP:
      case MySqlParser::NONE:
      case MySqlParser::ODBC:
      case MySqlParser::OFFLINE:
      case MySqlParser::OFFSET:
      case MySqlParser::OF:
      case MySqlParser::OJ:
      case MySqlParser::OLD_PASSWORD:
      case MySqlParser::ONE:
      case MySqlParser::ONLINE:
      case MySqlParser::ONLY:
      case MySqlParser::OPEN:
      case MySqlParser::OPTIMIZER_COSTS:
      case MySqlParser::OPTIONS:
      case MySqlParser::OWNER:
      case MySqlParser::PACK_KEYS:
      case MySqlParser::PAGE:
      case MySqlParser::PARSER:
      case MySqlParser::PARTIAL:
      case MySqlParser::PARTITIONING:
      case MySqlParser::PARTITIONS:
      case MySqlParser::PASSWORD:
      case MySqlParser::PASSWORD_LOCK_TIME:
      case MySqlParser::PHASE:
      case MySqlParser::PLUGIN:
      case MySqlParser::PLUGIN_DIR:
      case MySqlParser::PLUGINS:
      case MySqlParser::PORT:
      case MySqlParser::PRECEDES:
      case MySqlParser::PREPARE:
      case MySqlParser::PRESERVE:
      case MySqlParser::PREV:
      case MySqlParser::PROCESSLIST:
      case MySqlParser::PROFILE:
      case MySqlParser::PROFILES:
      case MySqlParser::PROXY:
      case MySqlParser::QUERY:
      case MySqlParser::QUICK:
      case MySqlParser::REBUILD:
      case MySqlParser::RECOVER:
      case MySqlParser::RECURSIVE:
      case MySqlParser::REDO_BUFFER_SIZE:
      case MySqlParser::REDUNDANT:
      case MySqlParser::RELAY:
      case MySqlParser::RELAY_LOG_FILE:
      case MySqlParser::RELAY_LOG_POS:
      case MySqlParser::RELAYLOG:
      case MySqlParser::REMOVE:
      case MySqlParser::REORGANIZE:
      case MySqlParser::REPAIR:
      case MySqlParser::REPLICATE_DO_DB:
      case MySqlParser::REPLICATE_DO_TABLE:
      case MySqlParser::REPLICATE_IGNORE_DB:
      case MySqlParser::REPLICATE_IGNORE_TABLE:
      case MySqlParser::REPLICATE_REWRITE_DB:
      case MySqlParser::REPLICATE_WILD_DO_TABLE:
      case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySqlParser::REPLICATION:
      case MySqlParser::RESET:
      case MySqlParser::RESUME:
      case MySqlParser::RETURNED_SQLSTATE:
      case MySqlParser::RETURNS:
      case MySqlParser::REUSE:
      case MySqlParser::ROLE:
      case MySqlParser::ROLLBACK:
      case MySqlParser::ROLLUP:
      case MySqlParser::ROTATE:
      case MySqlParser::ROW:
      case MySqlParser::ROWS:
      case MySqlParser::ROW_FORMAT:
      case MySqlParser::RTREE:
      case MySqlParser::SAVEPOINT:
      case MySqlParser::SCHEDULE:
      case MySqlParser::SECURITY:
      case MySqlParser::SERVER:
      case MySqlParser::SESSION:
      case MySqlParser::SHARE:
      case MySqlParser::SHARED:
      case MySqlParser::SIGNED:
      case MySqlParser::SIMPLE:
      case MySqlParser::SLAVE:
      case MySqlParser::SLOW:
      case MySqlParser::SNAPSHOT:
      case MySqlParser::SOCKET:
      case MySqlParser::SOME:
      case MySqlParser::SONAME:
      case MySqlParser::SOUNDS:
      case MySqlParser::SOURCE:
      case MySqlParser::SQL_AFTER_GTIDS:
      case MySqlParser::SQL_AFTER_MTS_GAPS:
      case MySqlParser::SQL_BEFORE_GTIDS:
      case MySqlParser::SQL_BUFFER_RESULT:
      case MySqlParser::SQL_CACHE:
      case MySqlParser::SQL_NO_CACHE:
      case MySqlParser::SQL_THREAD:
      case MySqlParser::START:
      case MySqlParser::STARTS:
      case MySqlParser::STATS_AUTO_RECALC:
      case MySqlParser::STATS_PERSISTENT:
      case MySqlParser::STATS_SAMPLE_PAGES:
      case MySqlParser::STATUS:
      case MySqlParser::STOP:
      case MySqlParser::STORAGE:
      case MySqlParser::STRING:
      case MySqlParser::SUBCLASS_ORIGIN:
      case MySqlParser::SUBJECT:
      case MySqlParser::SUBPARTITION:
      case MySqlParser::SUBPARTITIONS:
      case MySqlParser::SUSPEND:
      case MySqlParser::SWAPS:
      case MySqlParser::SWITCHES:
      case MySqlParser::TABLE_NAME:
      case MySqlParser::TABLESPACE:
      case MySqlParser::TABLE_TYPE:
      case MySqlParser::TEMPORARY:
      case MySqlParser::TEMPTABLE:
      case MySqlParser::THAN:
      case MySqlParser::TRADITIONAL:
      case MySqlParser::TRANSACTION:
      case MySqlParser::TRANSACTIONAL:
      case MySqlParser::TRIGGERS:
      case MySqlParser::TRUNCATE:
      case MySqlParser::UNBOUNDED:
      case MySqlParser::UNDEFINED:
      case MySqlParser::UNDOFILE:
      case MySqlParser::UNDO_BUFFER_SIZE:
      case MySqlParser::UNINSTALL:
      case MySqlParser::UNKNOWN:
      case MySqlParser::UNTIL:
      case MySqlParser::UPGRADE:
      case MySqlParser::USER:
      case MySqlParser::USE_FRM:
      case MySqlParser::USER_RESOURCES:
      case MySqlParser::VALIDATION:
      case MySqlParser::VALUE:
      case MySqlParser::VARIABLES:
      case MySqlParser::VIEW:
      case MySqlParser::VIRTUAL:
      case MySqlParser::VISIBLE:
      case MySqlParser::WAIT:
      case MySqlParser::WARNINGS:
      case MySqlParser::WITHOUT:
      case MySqlParser::WORK:
      case MySqlParser::WRAPPER:
      case MySqlParser::X509:
      case MySqlParser::XA:
      case MySqlParser::XML:
      case MySqlParser::EUR:
      case MySqlParser::USA:
      case MySqlParser::JIS:
      case MySqlParser::ISO:
      case MySqlParser::INTERNAL:
      case MySqlParser::QUARTER:
      case MySqlParser::MONTH:
      case MySqlParser::DAY:
      case MySqlParser::HOUR:
      case MySqlParser::MINUTE:
      case MySqlParser::WEEK:
      case MySqlParser::SECOND:
      case MySqlParser::MICROSECOND:
      case MySqlParser::ADMIN:
      case MySqlParser::AUDIT_ABORT_EXEMPT:
      case MySqlParser::AUDIT_ADMIN:
      case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
      case MySqlParser::BACKUP_ADMIN:
      case MySqlParser::BINLOG_ADMIN:
      case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
      case MySqlParser::CLONE_ADMIN:
      case MySqlParser::CONNECTION_ADMIN:
      case MySqlParser::ENCRYPTION_KEY_ADMIN:
      case MySqlParser::EXECUTE:
      case MySqlParser::FILE:
      case MySqlParser::FIREWALL_ADMIN:
      case MySqlParser::FIREWALL_EXEMPT:
      case MySqlParser::FIREWALL_USER:
      case MySqlParser::GROUP_REPLICATION_ADMIN:
      case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
      case MySqlParser::INVOKE:
      case MySqlParser::LAMBDA:
      case MySqlParser::NDB_STORED_USER:
      case MySqlParser::PASSWORDLESS_USER_ADMIN:
      case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
      case MySqlParser::PRIVILEGES:
      case MySqlParser::PROCESS:
      case MySqlParser::RELOAD:
      case MySqlParser::REPLICATION_APPLIER:
      case MySqlParser::REPLICATION_SLAVE_ADMIN:
      case MySqlParser::RESOURCE_GROUP_ADMIN:
      case MySqlParser::RESOURCE_GROUP_USER:
      case MySqlParser::ROLE_ADMIN:
      case MySqlParser::ROUTINE:
      case MySqlParser::S3:
      case MySqlParser::SESSION_VARIABLES_ADMIN:
      case MySqlParser::SET_USER_ID:
      case MySqlParser::SHOW_ROUTINE:
      case MySqlParser::SHUTDOWN:
      case MySqlParser::SUPER:
      case MySqlParser::SYSTEM_VARIABLES_ADMIN:
      case MySqlParser::TABLES:
      case MySqlParser::TABLE_ENCRYPTION_ADMIN:
      case MySqlParser::VERSION_TOKEN_ADMIN:
      case MySqlParser::XA_RECOVER_ADMIN:
      case MySqlParser::ARMSCII8:
      case MySqlParser::ASCII:
      case MySqlParser::BIG5:
      case MySqlParser::CP1250:
      case MySqlParser::CP1251:
      case MySqlParser::CP1256:
      case MySqlParser::CP1257:
      case MySqlParser::CP850:
      case MySqlParser::CP852:
      case MySqlParser::CP866:
      case MySqlParser::CP932:
      case MySqlParser::DEC8:
      case MySqlParser::EUCJPMS:
      case MySqlParser::EUCKR:
      case MySqlParser::GB18030:
      case MySqlParser::GB2312:
      case MySqlParser::GBK:
      case MySqlParser::GEOSTD8:
      case MySqlParser::GREEK:
      case MySqlParser::HEBREW:
      case MySqlParser::HP8:
      case MySqlParser::KEYBCS2:
      case MySqlParser::KOI8R:
      case MySqlParser::KOI8U:
      case MySqlParser::LATIN1:
      case MySqlParser::LATIN2:
      case MySqlParser::LATIN5:
      case MySqlParser::LATIN7:
      case MySqlParser::MACCE:
      case MySqlParser::MACROMAN:
      case MySqlParser::SJIS:
      case MySqlParser::SWE7:
      case MySqlParser::TIS620:
      case MySqlParser::UCS2:
      case MySqlParser::UJIS:
      case MySqlParser::UTF16:
      case MySqlParser::UTF16LE:
      case MySqlParser::UTF32:
      case MySqlParser::UTF8:
      case MySqlParser::UTF8MB3:
      case MySqlParser::UTF8MB4:
      case MySqlParser::ARCHIVE:
      case MySqlParser::BLACKHOLE:
      case MySqlParser::CSV:
      case MySqlParser::FEDERATED:
      case MySqlParser::INNODB:
      case MySqlParser::MEMORY:
      case MySqlParser::MRG_MYISAM:
      case MySqlParser::MYISAM:
      case MySqlParser::NDB:
      case MySqlParser::NDBCLUSTER:
      case MySqlParser::PERFORMANCE_SCHEMA:
      case MySqlParser::TOKUDB:
      case MySqlParser::REPEATABLE:
      case MySqlParser::COMMITTED:
      case MySqlParser::UNCOMMITTED:
      case MySqlParser::SERIALIZABLE:
      case MySqlParser::GEOMETRYCOLLECTION:
      case MySqlParser::LINESTRING:
      case MySqlParser::MULTILINESTRING:
      case MySqlParser::MULTIPOINT:
      case MySqlParser::MULTIPOLYGON:
      case MySqlParser::POINT:
      case MySqlParser::POLYGON:
      case MySqlParser::ABS:
      case MySqlParser::ACOS:
      case MySqlParser::ADDDATE:
      case MySqlParser::ADDTIME:
      case MySqlParser::AES_DECRYPT:
      case MySqlParser::AES_ENCRYPT:
      case MySqlParser::AREA:
      case MySqlParser::ASBINARY:
      case MySqlParser::ASIN:
      case MySqlParser::ASTEXT:
      case MySqlParser::ASWKB:
      case MySqlParser::ASWKT:
      case MySqlParser::ASYMMETRIC_DECRYPT:
      case MySqlParser::ASYMMETRIC_DERIVE:
      case MySqlParser::ASYMMETRIC_ENCRYPT:
      case MySqlParser::ASYMMETRIC_SIGN:
      case MySqlParser::ASYMMETRIC_VERIFY:
      case MySqlParser::ATAN:
      case MySqlParser::ATAN2:
      case MySqlParser::BENCHMARK:
      case MySqlParser::BIN:
      case MySqlParser::BIT_COUNT:
      case MySqlParser::BIT_LENGTH:
      case MySqlParser::BUFFER:
      case MySqlParser::CATALOG_NAME:
      case MySqlParser::CEIL:
      case MySqlParser::CEILING:
      case MySqlParser::CENTROID:
      case MySqlParser::CHARACTER_LENGTH:
      case MySqlParser::CHARSET:
      case MySqlParser::CHAR_LENGTH:
      case MySqlParser::COERCIBILITY:
      case MySqlParser::COLLATION:
      case MySqlParser::COMPRESS:
      case MySqlParser::CONCAT:
      case MySqlParser::CONCAT_WS:
      case MySqlParser::CONNECTION_ID:
      case MySqlParser::CONV:
      case MySqlParser::CONVERT_TZ:
      case MySqlParser::COS:
      case MySqlParser::COT:
      case MySqlParser::CRC32:
      case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
      case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
      case MySqlParser::CREATE_DH_PARAMETERS:
      case MySqlParser::CREATE_DIGEST:
      case MySqlParser::CROSSES:
      case MySqlParser::DATEDIFF:
      case MySqlParser::DATE_FORMAT:
      case MySqlParser::DAYNAME:
      case MySqlParser::DAYOFMONTH:
      case MySqlParser::DAYOFWEEK:
      case MySqlParser::DAYOFYEAR:
      case MySqlParser::DECODE:
      case MySqlParser::DEGREES:
      case MySqlParser::DES_DECRYPT:
      case MySqlParser::DES_ENCRYPT:
      case MySqlParser::DIMENSION:
      case MySqlParser::DISJOINT:
      case MySqlParser::ELT:
      case MySqlParser::ENCODE:
      case MySqlParser::ENCRYPT:
      case MySqlParser::ENDPOINT:
      case MySqlParser::ENGINE_ATTRIBUTE:
      case MySqlParser::ENVELOPE:
      case MySqlParser::EQUALS:
      case MySqlParser::EXP:
      case MySqlParser::EXPORT_SET:
      case MySqlParser::EXTERIORRING:
      case MySqlParser::EXTRACTVALUE:
      case MySqlParser::FIELD:
      case MySqlParser::FIND_IN_SET:
      case MySqlParser::FLOOR:
      case MySqlParser::FORMAT:
      case MySqlParser::FOUND_ROWS:
      case MySqlParser::FROM_BASE64:
      case MySqlParser::FROM_DAYS:
      case MySqlParser::FROM_UNIXTIME:
      case MySqlParser::GEOMCOLLFROMTEXT:
      case MySqlParser::GEOMCOLLFROMWKB:
      case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::GEOMETRYFROMTEXT:
      case MySqlParser::GEOMETRYFROMWKB:
      case MySqlParser::GEOMETRYN:
      case MySqlParser::GEOMETRYTYPE:
      case MySqlParser::GEOMFROMTEXT:
      case MySqlParser::GEOMFROMWKB:
      case MySqlParser::GET_FORMAT:
      case MySqlParser::GET_LOCK:
      case MySqlParser::GLENGTH:
      case MySqlParser::GREATEST:
      case MySqlParser::GTID_SUBSET:
      case MySqlParser::GTID_SUBTRACT:
      case MySqlParser::HEX:
      case MySqlParser::IFNULL:
      case MySqlParser::INET6_ATON:
      case MySqlParser::INET6_NTOA:
      case MySqlParser::INET_ATON:
      case MySqlParser::INET_NTOA:
      case MySqlParser::INSTR:
      case MySqlParser::INTERIORRINGN:
      case MySqlParser::INTERSECTS:
      case MySqlParser::ISCLOSED:
      case MySqlParser::ISEMPTY:
      case MySqlParser::ISNULL:
      case MySqlParser::ISSIMPLE:
      case MySqlParser::IS_FREE_LOCK:
      case MySqlParser::IS_IPV4:
      case MySqlParser::IS_IPV4_COMPAT:
      case MySqlParser::IS_IPV4_MAPPED:
      case MySqlParser::IS_IPV6:
      case MySqlParser::IS_USED_LOCK:
      case MySqlParser::LAST_INSERT_ID:
      case MySqlParser::LCASE:
      case MySqlParser::LEAST:
      case MySqlParser::LENGTH:
      case MySqlParser::LINEFROMTEXT:
      case MySqlParser::LINEFROMWKB:
      case MySqlParser::LINESTRINGFROMTEXT:
      case MySqlParser::LINESTRINGFROMWKB:
      case MySqlParser::LN:
      case MySqlParser::LOAD_FILE:
      case MySqlParser::LOCATE:
      case MySqlParser::LOG:
      case MySqlParser::LOG10:
      case MySqlParser::LOG2:
      case MySqlParser::LOWER:
      case MySqlParser::LPAD:
      case MySqlParser::LTRIM:
      case MySqlParser::MAKEDATE:
      case MySqlParser::MAKETIME:
      case MySqlParser::MAKE_SET:
      case MySqlParser::MASTER_POS_WAIT:
      case MySqlParser::MBRCONTAINS:
      case MySqlParser::MBRDISJOINT:
      case MySqlParser::MBREQUAL:
      case MySqlParser::MBRINTERSECTS:
      case MySqlParser::MBROVERLAPS:
      case MySqlParser::MBRTOUCHES:
      case MySqlParser::MBRWITHIN:
      case MySqlParser::MD5:
      case MySqlParser::MLINEFROMTEXT:
      case MySqlParser::MLINEFROMWKB:
      case MySqlParser::MONTHNAME:
      case MySqlParser::MPOINTFROMTEXT:
      case MySqlParser::MPOINTFROMWKB:
      case MySqlParser::MPOLYFROMTEXT:
      case MySqlParser::MPOLYFROMWKB:
      case MySqlParser::MULTILINESTRINGFROMTEXT:
      case MySqlParser::MULTILINESTRINGFROMWKB:
      case MySqlParser::MULTIPOINTFROMTEXT:
      case MySqlParser::MULTIPOINTFROMWKB:
      case MySqlParser::MULTIPOLYGONFROMTEXT:
      case MySqlParser::MULTIPOLYGONFROMWKB:
      case MySqlParser::NAME_CONST:
      case MySqlParser::NULLIF:
      case MySqlParser::NUMGEOMETRIES:
      case MySqlParser::NUMINTERIORRINGS:
      case MySqlParser::NUMPOINTS:
      case MySqlParser::OCT:
      case MySqlParser::OCTET_LENGTH:
      case MySqlParser::ORD:
      case MySqlParser::OVERLAPS:
      case MySqlParser::PERIOD_ADD:
      case MySqlParser::PERIOD_DIFF:
      case MySqlParser::PI:
      case MySqlParser::POINTFROMTEXT:
      case MySqlParser::POINTFROMWKB:
      case MySqlParser::POINTN:
      case MySqlParser::POLYFROMTEXT:
      case MySqlParser::POLYFROMWKB:
      case MySqlParser::POLYGONFROMTEXT:
      case MySqlParser::POLYGONFROMWKB:
      case MySqlParser::POW:
      case MySqlParser::POWER:
      case MySqlParser::QUOTE:
      case MySqlParser::RADIANS:
      case MySqlParser::RAND:
      case MySqlParser::RANDOM_BYTES:
      case MySqlParser::RELEASE_LOCK:
      case MySqlParser::REVERSE:
      case MySqlParser::ROUND:
      case MySqlParser::ROW_COUNT:
      case MySqlParser::RPAD:
      case MySqlParser::RTRIM:
      case MySqlParser::SEC_TO_TIME:
      case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySqlParser::SESSION_USER:
      case MySqlParser::SHA:
      case MySqlParser::SHA1:
      case MySqlParser::SHA2:
      case MySqlParser::SCHEMA_NAME:
      case MySqlParser::SIGN:
      case MySqlParser::SIN:
      case MySqlParser::SLEEP:
      case MySqlParser::SOUNDEX:
      case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
      case MySqlParser::SQRT:
      case MySqlParser::SRID:
      case MySqlParser::STARTPOINT:
      case MySqlParser::STRCMP:
      case MySqlParser::STR_TO_DATE:
      case MySqlParser::ST_AREA:
      case MySqlParser::ST_ASBINARY:
      case MySqlParser::ST_ASTEXT:
      case MySqlParser::ST_ASWKB:
      case MySqlParser::ST_ASWKT:
      case MySqlParser::ST_BUFFER:
      case MySqlParser::ST_CENTROID:
      case MySqlParser::ST_CONTAINS:
      case MySqlParser::ST_CROSSES:
      case MySqlParser::ST_DIFFERENCE:
      case MySqlParser::ST_DIMENSION:
      case MySqlParser::ST_DISJOINT:
      case MySqlParser::ST_DISTANCE:
      case MySqlParser::ST_ENDPOINT:
      case MySqlParser::ST_ENVELOPE:
      case MySqlParser::ST_EQUALS:
      case MySqlParser::ST_EXTERIORRING:
      case MySqlParser::ST_GEOMCOLLFROMTEXT:
      case MySqlParser::ST_GEOMCOLLFROMTXT:
      case MySqlParser::ST_GEOMCOLLFROMWKB:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::ST_GEOMETRYFROMTEXT:
      case MySqlParser::ST_GEOMETRYFROMWKB:
      case MySqlParser::ST_GEOMETRYN:
      case MySqlParser::ST_GEOMETRYTYPE:
      case MySqlParser::ST_GEOMFROMTEXT:
      case MySqlParser::ST_GEOMFROMWKB:
      case MySqlParser::ST_INTERIORRINGN:
      case MySqlParser::ST_INTERSECTION:
      case MySqlParser::ST_INTERSECTS:
      case MySqlParser::ST_ISCLOSED:
      case MySqlParser::ST_ISEMPTY:
      case MySqlParser::ST_ISSIMPLE:
      case MySqlParser::ST_LINEFROMTEXT:
      case MySqlParser::ST_LINEFROMWKB:
      case MySqlParser::ST_LINESTRINGFROMTEXT:
      case MySqlParser::ST_LINESTRINGFROMWKB:
      case MySqlParser::ST_NUMGEOMETRIES:
      case MySqlParser::ST_NUMINTERIORRING:
      case MySqlParser::ST_NUMINTERIORRINGS:
      case MySqlParser::ST_NUMPOINTS:
      case MySqlParser::ST_OVERLAPS:
      case MySqlParser::ST_POINTFROMTEXT:
      case MySqlParser::ST_POINTFROMWKB:
      case MySqlParser::ST_POINTN:
      case MySqlParser::ST_POLYFROMTEXT:
      case MySqlParser::ST_POLYFROMWKB:
      case MySqlParser::ST_POLYGONFROMTEXT:
      case MySqlParser::ST_POLYGONFROMWKB:
      case MySqlParser::ST_SRID:
      case MySqlParser::ST_STARTPOINT:
      case MySqlParser::ST_SYMDIFFERENCE:
      case MySqlParser::ST_TOUCHES:
      case MySqlParser::ST_UNION:
      case MySqlParser::ST_WITHIN:
      case MySqlParser::ST_X:
      case MySqlParser::ST_Y:
      case MySqlParser::SUBDATE:
      case MySqlParser::SUBSTRING_INDEX:
      case MySqlParser::SUBTIME:
      case MySqlParser::SYSTEM_USER:
      case MySqlParser::TAN:
      case MySqlParser::TIMEDIFF:
      case MySqlParser::TIMESTAMPADD:
      case MySqlParser::TIMESTAMPDIFF:
      case MySqlParser::TIME_FORMAT:
      case MySqlParser::TIME_TO_SEC:
      case MySqlParser::TOUCHES:
      case MySqlParser::TO_BASE64:
      case MySqlParser::TO_DAYS:
      case MySqlParser::TO_SECONDS:
      case MySqlParser::TP_CONNECTION_ADMIN:
      case MySqlParser::UCASE:
      case MySqlParser::UNCOMPRESS:
      case MySqlParser::UNCOMPRESSED_LENGTH:
      case MySqlParser::UNHEX:
      case MySqlParser::UNIX_TIMESTAMP:
      case MySqlParser::UPDATEXML:
      case MySqlParser::UPPER:
      case MySqlParser::UUID:
      case MySqlParser::UUID_SHORT:
      case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
      case MySqlParser::VERSION:
      case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
      case MySqlParser::WEEKDAY:
      case MySqlParser::WEEKOFYEAR:
      case MySqlParser::WEIGHT_STRING:
      case MySqlParser::WITHIN:
      case MySqlParser::YEARWEEK:
      case MySqlParser::Y_FUNCTION:
      case MySqlParser::X_FUNCTION:
      case MySqlParser::MOD:
      case MySqlParser::AT_SIGN:
      case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
      case MySqlParser::STRING_LITERAL:
      case MySqlParser::ID: {
        enterOuterAlt(_localctx, 3);
        setState(5871);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 854, _ctx)) {
        case 1: {
          setState(5868);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::AT_SIGN) {
            setState(5866);
            match(MySqlParser::AT_SIGN);
            setState(5867);
            match(MySqlParser::AT_SIGN);
          }
          setState(5870);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::GLOBAL

          || _la == MySqlParser::LOCAL || _la == MySqlParser::SESSION)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        }
        setState(5873);
        uid();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCommonEntityContext ------------------------------------------------------------------

MySqlParser::ShowCommonEntityContext::ShowCommonEntityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ShowCommonEntityContext::CHARACTER() {
  return getToken(MySqlParser::CHARACTER, 0);
}

tree::TerminalNode* MySqlParser::ShowCommonEntityContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::ShowCommonEntityContext::COLLATION() {
  return getToken(MySqlParser::COLLATION, 0);
}

tree::TerminalNode* MySqlParser::ShowCommonEntityContext::DATABASES() {
  return getToken(MySqlParser::DATABASES, 0);
}

tree::TerminalNode* MySqlParser::ShowCommonEntityContext::SCHEMAS() {
  return getToken(MySqlParser::SCHEMAS, 0);
}

tree::TerminalNode* MySqlParser::ShowCommonEntityContext::FUNCTION() {
  return getToken(MySqlParser::FUNCTION, 0);
}

tree::TerminalNode* MySqlParser::ShowCommonEntityContext::STATUS() {
  return getToken(MySqlParser::STATUS, 0);
}

tree::TerminalNode* MySqlParser::ShowCommonEntityContext::PROCEDURE() {
  return getToken(MySqlParser::PROCEDURE, 0);
}

tree::TerminalNode* MySqlParser::ShowCommonEntityContext::VARIABLES() {
  return getToken(MySqlParser::VARIABLES, 0);
}

tree::TerminalNode* MySqlParser::ShowCommonEntityContext::GLOBAL() {
  return getToken(MySqlParser::GLOBAL, 0);
}

tree::TerminalNode* MySqlParser::ShowCommonEntityContext::SESSION() {
  return getToken(MySqlParser::SESSION, 0);
}


size_t MySqlParser::ShowCommonEntityContext::getRuleIndex() const {
  return MySqlParser::RuleShowCommonEntity;
}

void MySqlParser::ShowCommonEntityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCommonEntity(this);
}

void MySqlParser::ShowCommonEntityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCommonEntity(this);
}


std::any MySqlParser::ShowCommonEntityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowCommonEntity(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ShowCommonEntityContext* MySqlParser::showCommonEntity() {
  ShowCommonEntityContext *_localctx = _tracker.createInstance<ShowCommonEntityContext>(_ctx, getState());
  enterRule(_localctx, 488, MySqlParser::RuleShowCommonEntity);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5889);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::CHARACTER: {
        enterOuterAlt(_localctx, 1);
        setState(5876);
        match(MySqlParser::CHARACTER);
        setState(5877);
        match(MySqlParser::SET);
        break;
      }

      case MySqlParser::COLLATION: {
        enterOuterAlt(_localctx, 2);
        setState(5878);
        match(MySqlParser::COLLATION);
        break;
      }

      case MySqlParser::DATABASES: {
        enterOuterAlt(_localctx, 3);
        setState(5879);
        match(MySqlParser::DATABASES);
        break;
      }

      case MySqlParser::SCHEMAS: {
        enterOuterAlt(_localctx, 4);
        setState(5880);
        match(MySqlParser::SCHEMAS);
        break;
      }

      case MySqlParser::FUNCTION: {
        enterOuterAlt(_localctx, 5);
        setState(5881);
        match(MySqlParser::FUNCTION);
        setState(5882);
        match(MySqlParser::STATUS);
        break;
      }

      case MySqlParser::PROCEDURE: {
        enterOuterAlt(_localctx, 6);
        setState(5883);
        match(MySqlParser::PROCEDURE);
        setState(5884);
        match(MySqlParser::STATUS);
        break;
      }

      case MySqlParser::GLOBAL:
      case MySqlParser::SESSION:
      case MySqlParser::STATUS:
      case MySqlParser::VARIABLES: {
        enterOuterAlt(_localctx, 7);
        setState(5886);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::GLOBAL || _la == MySqlParser::SESSION) {
          setState(5885);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::GLOBAL || _la == MySqlParser::SESSION)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(5888);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::STATUS

        || _la == MySqlParser::VARIABLES)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowFilterContext ------------------------------------------------------------------

MySqlParser::ShowFilterContext::ShowFilterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ShowFilterContext::LIKE() {
  return getToken(MySqlParser::LIKE, 0);
}

tree::TerminalNode* MySqlParser::ShowFilterContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::ShowFilterContext::WHERE() {
  return getToken(MySqlParser::WHERE, 0);
}

MySqlParser::ExpressionContext* MySqlParser::ShowFilterContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}


size_t MySqlParser::ShowFilterContext::getRuleIndex() const {
  return MySqlParser::RuleShowFilter;
}

void MySqlParser::ShowFilterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowFilter(this);
}

void MySqlParser::ShowFilterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowFilter(this);
}


std::any MySqlParser::ShowFilterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowFilter(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ShowFilterContext* MySqlParser::showFilter() {
  ShowFilterContext *_localctx = _tracker.createInstance<ShowFilterContext>(_ctx, getState());
  enterRule(_localctx, 490, MySqlParser::RuleShowFilter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5895);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::LIKE: {
        enterOuterAlt(_localctx, 1);
        setState(5891);
        match(MySqlParser::LIKE);
        setState(5892);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::WHERE: {
        enterOuterAlt(_localctx, 2);
        setState(5893);
        match(MySqlParser::WHERE);
        setState(5894);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowGlobalInfoClauseContext ------------------------------------------------------------------

MySqlParser::ShowGlobalInfoClauseContext::ShowGlobalInfoClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ShowGlobalInfoClauseContext::ENGINES() {
  return getToken(MySqlParser::ENGINES, 0);
}

tree::TerminalNode* MySqlParser::ShowGlobalInfoClauseContext::STORAGE() {
  return getToken(MySqlParser::STORAGE, 0);
}

tree::TerminalNode* MySqlParser::ShowGlobalInfoClauseContext::MASTER() {
  return getToken(MySqlParser::MASTER, 0);
}

tree::TerminalNode* MySqlParser::ShowGlobalInfoClauseContext::STATUS() {
  return getToken(MySqlParser::STATUS, 0);
}

tree::TerminalNode* MySqlParser::ShowGlobalInfoClauseContext::PLUGINS() {
  return getToken(MySqlParser::PLUGINS, 0);
}

tree::TerminalNode* MySqlParser::ShowGlobalInfoClauseContext::PRIVILEGES() {
  return getToken(MySqlParser::PRIVILEGES, 0);
}

tree::TerminalNode* MySqlParser::ShowGlobalInfoClauseContext::PROCESSLIST() {
  return getToken(MySqlParser::PROCESSLIST, 0);
}

tree::TerminalNode* MySqlParser::ShowGlobalInfoClauseContext::FULL() {
  return getToken(MySqlParser::FULL, 0);
}

tree::TerminalNode* MySqlParser::ShowGlobalInfoClauseContext::PROFILES() {
  return getToken(MySqlParser::PROFILES, 0);
}

tree::TerminalNode* MySqlParser::ShowGlobalInfoClauseContext::SLAVE() {
  return getToken(MySqlParser::SLAVE, 0);
}

tree::TerminalNode* MySqlParser::ShowGlobalInfoClauseContext::HOSTS() {
  return getToken(MySqlParser::HOSTS, 0);
}

tree::TerminalNode* MySqlParser::ShowGlobalInfoClauseContext::AUTHORS() {
  return getToken(MySqlParser::AUTHORS, 0);
}

tree::TerminalNode* MySqlParser::ShowGlobalInfoClauseContext::CONTRIBUTORS() {
  return getToken(MySqlParser::CONTRIBUTORS, 0);
}


size_t MySqlParser::ShowGlobalInfoClauseContext::getRuleIndex() const {
  return MySqlParser::RuleShowGlobalInfoClause;
}

void MySqlParser::ShowGlobalInfoClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowGlobalInfoClause(this);
}

void MySqlParser::ShowGlobalInfoClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowGlobalInfoClause(this);
}


std::any MySqlParser::ShowGlobalInfoClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowGlobalInfoClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ShowGlobalInfoClauseContext* MySqlParser::showGlobalInfoClause() {
  ShowGlobalInfoClauseContext *_localctx = _tracker.createInstance<ShowGlobalInfoClauseContext>(_ctx, getState());
  enterRule(_localctx, 492, MySqlParser::RuleShowGlobalInfoClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5914);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::ENGINES:
      case MySqlParser::STORAGE: {
        enterOuterAlt(_localctx, 1);
        setState(5898);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::STORAGE) {
          setState(5897);
          match(MySqlParser::STORAGE);
        }
        setState(5900);
        match(MySqlParser::ENGINES);
        break;
      }

      case MySqlParser::MASTER: {
        enterOuterAlt(_localctx, 2);
        setState(5901);
        match(MySqlParser::MASTER);
        setState(5902);
        match(MySqlParser::STATUS);
        break;
      }

      case MySqlParser::PLUGINS: {
        enterOuterAlt(_localctx, 3);
        setState(5903);
        match(MySqlParser::PLUGINS);
        break;
      }

      case MySqlParser::PRIVILEGES: {
        enterOuterAlt(_localctx, 4);
        setState(5904);
        match(MySqlParser::PRIVILEGES);
        break;
      }

      case MySqlParser::FULL:
      case MySqlParser::PROCESSLIST: {
        enterOuterAlt(_localctx, 5);
        setState(5906);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::FULL) {
          setState(5905);
          match(MySqlParser::FULL);
        }
        setState(5908);
        match(MySqlParser::PROCESSLIST);
        break;
      }

      case MySqlParser::PROFILES: {
        enterOuterAlt(_localctx, 6);
        setState(5909);
        match(MySqlParser::PROFILES);
        break;
      }

      case MySqlParser::SLAVE: {
        enterOuterAlt(_localctx, 7);
        setState(5910);
        match(MySqlParser::SLAVE);
        setState(5911);
        match(MySqlParser::HOSTS);
        break;
      }

      case MySqlParser::AUTHORS: {
        enterOuterAlt(_localctx, 8);
        setState(5912);
        match(MySqlParser::AUTHORS);
        break;
      }

      case MySqlParser::CONTRIBUTORS: {
        enterOuterAlt(_localctx, 9);
        setState(5913);
        match(MySqlParser::CONTRIBUTORS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowSchemaEntityContext ------------------------------------------------------------------

MySqlParser::ShowSchemaEntityContext::ShowSchemaEntityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ShowSchemaEntityContext::EVENTS() {
  return getToken(MySqlParser::EVENTS, 0);
}

tree::TerminalNode* MySqlParser::ShowSchemaEntityContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

tree::TerminalNode* MySqlParser::ShowSchemaEntityContext::STATUS() {
  return getToken(MySqlParser::STATUS, 0);
}

tree::TerminalNode* MySqlParser::ShowSchemaEntityContext::TABLES() {
  return getToken(MySqlParser::TABLES, 0);
}

tree::TerminalNode* MySqlParser::ShowSchemaEntityContext::FULL() {
  return getToken(MySqlParser::FULL, 0);
}

tree::TerminalNode* MySqlParser::ShowSchemaEntityContext::TRIGGERS() {
  return getToken(MySqlParser::TRIGGERS, 0);
}


size_t MySqlParser::ShowSchemaEntityContext::getRuleIndex() const {
  return MySqlParser::RuleShowSchemaEntity;
}

void MySqlParser::ShowSchemaEntityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowSchemaEntity(this);
}

void MySqlParser::ShowSchemaEntityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowSchemaEntity(this);
}


std::any MySqlParser::ShowSchemaEntityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowSchemaEntity(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ShowSchemaEntityContext* MySqlParser::showSchemaEntity() {
  ShowSchemaEntityContext *_localctx = _tracker.createInstance<ShowSchemaEntityContext>(_ctx, getState());
  enterRule(_localctx, 494, MySqlParser::RuleShowSchemaEntity);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5924);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::EVENTS: {
        enterOuterAlt(_localctx, 1);
        setState(5916);
        match(MySqlParser::EVENTS);
        break;
      }

      case MySqlParser::TABLE: {
        enterOuterAlt(_localctx, 2);
        setState(5917);
        match(MySqlParser::TABLE);
        setState(5918);
        match(MySqlParser::STATUS);
        break;
      }

      case MySqlParser::FULL:
      case MySqlParser::TABLES: {
        enterOuterAlt(_localctx, 3);
        setState(5920);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::FULL) {
          setState(5919);
          match(MySqlParser::FULL);
        }
        setState(5922);
        match(MySqlParser::TABLES);
        break;
      }

      case MySqlParser::TRIGGERS: {
        enterOuterAlt(_localctx, 4);
        setState(5923);
        match(MySqlParser::TRIGGERS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowProfileTypeContext ------------------------------------------------------------------

MySqlParser::ShowProfileTypeContext::ShowProfileTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ShowProfileTypeContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

tree::TerminalNode* MySqlParser::ShowProfileTypeContext::BLOCK() {
  return getToken(MySqlParser::BLOCK, 0);
}

tree::TerminalNode* MySqlParser::ShowProfileTypeContext::IO() {
  return getToken(MySqlParser::IO, 0);
}

tree::TerminalNode* MySqlParser::ShowProfileTypeContext::CONTEXT() {
  return getToken(MySqlParser::CONTEXT, 0);
}

tree::TerminalNode* MySqlParser::ShowProfileTypeContext::SWITCHES() {
  return getToken(MySqlParser::SWITCHES, 0);
}

tree::TerminalNode* MySqlParser::ShowProfileTypeContext::CPU() {
  return getToken(MySqlParser::CPU, 0);
}

tree::TerminalNode* MySqlParser::ShowProfileTypeContext::IPC() {
  return getToken(MySqlParser::IPC, 0);
}

tree::TerminalNode* MySqlParser::ShowProfileTypeContext::MEMORY() {
  return getToken(MySqlParser::MEMORY, 0);
}

tree::TerminalNode* MySqlParser::ShowProfileTypeContext::PAGE() {
  return getToken(MySqlParser::PAGE, 0);
}

tree::TerminalNode* MySqlParser::ShowProfileTypeContext::FAULTS() {
  return getToken(MySqlParser::FAULTS, 0);
}

tree::TerminalNode* MySqlParser::ShowProfileTypeContext::SOURCE() {
  return getToken(MySqlParser::SOURCE, 0);
}

tree::TerminalNode* MySqlParser::ShowProfileTypeContext::SWAPS() {
  return getToken(MySqlParser::SWAPS, 0);
}


size_t MySqlParser::ShowProfileTypeContext::getRuleIndex() const {
  return MySqlParser::RuleShowProfileType;
}

void MySqlParser::ShowProfileTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowProfileType(this);
}

void MySqlParser::ShowProfileTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowProfileType(this);
}


std::any MySqlParser::ShowProfileTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShowProfileType(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ShowProfileTypeContext* MySqlParser::showProfileType() {
  ShowProfileTypeContext *_localctx = _tracker.createInstance<ShowProfileTypeContext>(_ctx, getState());
  enterRule(_localctx, 496, MySqlParser::RuleShowProfileType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5938);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::ALL: {
        enterOuterAlt(_localctx, 1);
        setState(5926);
        match(MySqlParser::ALL);
        break;
      }

      case MySqlParser::BLOCK: {
        enterOuterAlt(_localctx, 2);
        setState(5927);
        match(MySqlParser::BLOCK);
        setState(5928);
        match(MySqlParser::IO);
        break;
      }

      case MySqlParser::CONTEXT: {
        enterOuterAlt(_localctx, 3);
        setState(5929);
        match(MySqlParser::CONTEXT);
        setState(5930);
        match(MySqlParser::SWITCHES);
        break;
      }

      case MySqlParser::CPU: {
        enterOuterAlt(_localctx, 4);
        setState(5931);
        match(MySqlParser::CPU);
        break;
      }

      case MySqlParser::IPC: {
        enterOuterAlt(_localctx, 5);
        setState(5932);
        match(MySqlParser::IPC);
        break;
      }

      case MySqlParser::MEMORY: {
        enterOuterAlt(_localctx, 6);
        setState(5933);
        match(MySqlParser::MEMORY);
        break;
      }

      case MySqlParser::PAGE: {
        enterOuterAlt(_localctx, 7);
        setState(5934);
        match(MySqlParser::PAGE);
        setState(5935);
        match(MySqlParser::FAULTS);
        break;
      }

      case MySqlParser::SOURCE: {
        enterOuterAlt(_localctx, 8);
        setState(5936);
        match(MySqlParser::SOURCE);
        break;
      }

      case MySqlParser::SWAPS: {
        enterOuterAlt(_localctx, 9);
        setState(5937);
        match(MySqlParser::SWAPS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinlogStatementContext ------------------------------------------------------------------

MySqlParser::BinlogStatementContext::BinlogStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::BinlogStatementContext::BINLOG() {
  return getToken(MySqlParser::BINLOG, 0);
}

tree::TerminalNode* MySqlParser::BinlogStatementContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}


size_t MySqlParser::BinlogStatementContext::getRuleIndex() const {
  return MySqlParser::RuleBinlogStatement;
}

void MySqlParser::BinlogStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinlogStatement(this);
}

void MySqlParser::BinlogStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinlogStatement(this);
}


std::any MySqlParser::BinlogStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitBinlogStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::BinlogStatementContext* MySqlParser::binlogStatement() {
  BinlogStatementContext *_localctx = _tracker.createInstance<BinlogStatementContext>(_ctx, getState());
  enterRule(_localctx, 498, MySqlParser::RuleBinlogStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5940);
    match(MySqlParser::BINLOG);
    setState(5941);
    match(MySqlParser::STRING_LITERAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CacheIndexStatementContext ------------------------------------------------------------------

MySqlParser::CacheIndexStatementContext::CacheIndexStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CacheIndexStatementContext::CACHE() {
  return getToken(MySqlParser::CACHE, 0);
}

tree::TerminalNode* MySqlParser::CacheIndexStatementContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

std::vector<MySqlParser::TableIndexesContext *> MySqlParser::CacheIndexStatementContext::tableIndexes() {
  return getRuleContexts<MySqlParser::TableIndexesContext>();
}

MySqlParser::TableIndexesContext* MySqlParser::CacheIndexStatementContext::tableIndexes(size_t i) {
  return getRuleContext<MySqlParser::TableIndexesContext>(i);
}

tree::TerminalNode* MySqlParser::CacheIndexStatementContext::IN() {
  return getToken(MySqlParser::IN, 0);
}

MySqlParser::UidContext* MySqlParser::CacheIndexStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::CacheIndexStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::CacheIndexStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::CacheIndexStatementContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

tree::TerminalNode* MySqlParser::CacheIndexStatementContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::CacheIndexStatementContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::UidListContext* MySqlParser::CacheIndexStatementContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::CacheIndexStatementContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}


size_t MySqlParser::CacheIndexStatementContext::getRuleIndex() const {
  return MySqlParser::RuleCacheIndexStatement;
}

void MySqlParser::CacheIndexStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCacheIndexStatement(this);
}

void MySqlParser::CacheIndexStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCacheIndexStatement(this);
}


std::any MySqlParser::CacheIndexStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCacheIndexStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CacheIndexStatementContext* MySqlParser::cacheIndexStatement() {
  CacheIndexStatementContext *_localctx = _tracker.createInstance<CacheIndexStatementContext>(_ctx, getState());
  enterRule(_localctx, 500, MySqlParser::RuleCacheIndexStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5943);
    match(MySqlParser::CACHE);
    setState(5944);
    match(MySqlParser::INDEX);
    setState(5945);
    tableIndexes();
    setState(5950);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(5946);
      match(MySqlParser::COMMA);
      setState(5947);
      tableIndexes();
      setState(5952);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(5960);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::PARTITION) {
      setState(5953);
      match(MySqlParser::PARTITION);
      setState(5954);
      match(MySqlParser::LR_BRACKET);
      setState(5957);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::ATTRIBUTE:
        case MySqlParser::BUCKETS:
        case MySqlParser::CONDITION:
        case MySqlParser::CURRENT:
        case MySqlParser::CURRENT_USER:
        case MySqlParser::DATABASE:
        case MySqlParser::DEFAULT:
        case MySqlParser::DIAGNOSTICS:
        case MySqlParser::EMPTY:
        case MySqlParser::ENFORCED:
        case MySqlParser::EXCEPT:
        case MySqlParser::GROUP:
        case MySqlParser::IF:
        case MySqlParser::IGNORED:
        case MySqlParser::INSERT:
        case MySqlParser::LATERAL:
        case MySqlParser::LEFT:
        case MySqlParser::NUMBER:
        case MySqlParser::OPTIONAL:
        case MySqlParser::ORDER:
        case MySqlParser::PRIMARY:
        case MySqlParser::REPLACE:
        case MySqlParser::RIGHT:
        case MySqlParser::SCHEMA:
        case MySqlParser::SKIP_QUERY_REWRITE:
        case MySqlParser::STACKED:
        case MySqlParser::DATE:
        case MySqlParser::TIME:
        case MySqlParser::TIMESTAMP:
        case MySqlParser::DATETIME:
        case MySqlParser::YEAR:
        case MySqlParser::BINARY:
        case MySqlParser::TEXT:
        case MySqlParser::ENUM:
        case MySqlParser::SERIAL:
        case MySqlParser::JSON_ARRAY:
        case MySqlParser::JSON_ARRAYAGG:
        case MySqlParser::JSON_ARRAY_APPEND:
        case MySqlParser::JSON_ARRAY_INSERT:
        case MySqlParser::JSON_CONTAINS:
        case MySqlParser::JSON_CONTAINS_PATH:
        case MySqlParser::JSON_DEPTH:
        case MySqlParser::JSON_EXTRACT:
        case MySqlParser::JSON_INSERT:
        case MySqlParser::JSON_KEYS:
        case MySqlParser::JSON_LENGTH:
        case MySqlParser::JSON_MERGE:
        case MySqlParser::JSON_MERGE_PATCH:
        case MySqlParser::JSON_MERGE_PRESERVE:
        case MySqlParser::JSON_OBJECT:
        case MySqlParser::JSON_OBJECTAGG:
        case MySqlParser::JSON_OVERLAPS:
        case MySqlParser::JSON_PRETTY:
        case MySqlParser::JSON_QUOTE:
        case MySqlParser::JSON_REMOVE:
        case MySqlParser::JSON_REPLACE:
        case MySqlParser::JSON_SCHEMA_VALID:
        case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
        case MySqlParser::JSON_SEARCH:
        case MySqlParser::JSON_SET:
        case MySqlParser::JSON_STORAGE_FREE:
        case MySqlParser::JSON_STORAGE_SIZE:
        case MySqlParser::JSON_TABLE:
        case MySqlParser::JSON_TYPE:
        case MySqlParser::JSON_UNQUOTE:
        case MySqlParser::JSON_VALID:
        case MySqlParser::JSON_VALUE:
        case MySqlParser::NESTED:
        case MySqlParser::ORDINALITY:
        case MySqlParser::PATH:
        case MySqlParser::AVG:
        case MySqlParser::BIT_AND:
        case MySqlParser::BIT_OR:
        case MySqlParser::BIT_XOR:
        case MySqlParser::COUNT:
        case MySqlParser::CUME_DIST:
        case MySqlParser::DENSE_RANK:
        case MySqlParser::FIRST_VALUE:
        case MySqlParser::GROUP_CONCAT:
        case MySqlParser::LAG:
        case MySqlParser::LAST_VALUE:
        case MySqlParser::LEAD:
        case MySqlParser::MAX:
        case MySqlParser::MIN:
        case MySqlParser::NTILE:
        case MySqlParser::NTH_VALUE:
        case MySqlParser::PERCENT_RANK:
        case MySqlParser::RANK:
        case MySqlParser::ROW_NUMBER:
        case MySqlParser::STD:
        case MySqlParser::STDDEV:
        case MySqlParser::STDDEV_POP:
        case MySqlParser::STDDEV_SAMP:
        case MySqlParser::SUM:
        case MySqlParser::VAR_POP:
        case MySqlParser::VAR_SAMP:
        case MySqlParser::VARIANCE:
        case MySqlParser::CURRENT_DATE:
        case MySqlParser::CURRENT_TIME:
        case MySqlParser::CURRENT_TIMESTAMP:
        case MySqlParser::LOCALTIME:
        case MySqlParser::CURDATE:
        case MySqlParser::CURTIME:
        case MySqlParser::DATE_ADD:
        case MySqlParser::DATE_SUB:
        case MySqlParser::LOCALTIMESTAMP:
        case MySqlParser::NOW:
        case MySqlParser::POSITION:
        case MySqlParser::SUBSTR:
        case MySqlParser::SUBSTRING:
        case MySqlParser::SYSDATE:
        case MySqlParser::TRIM:
        case MySqlParser::UTC_DATE:
        case MySqlParser::UTC_TIME:
        case MySqlParser::UTC_TIMESTAMP:
        case MySqlParser::ACCOUNT:
        case MySqlParser::ACTION:
        case MySqlParser::AFTER:
        case MySqlParser::AGGREGATE:
        case MySqlParser::ALGORITHM:
        case MySqlParser::ANY:
        case MySqlParser::AT:
        case MySqlParser::AUTHORS:
        case MySqlParser::AUTOCOMMIT:
        case MySqlParser::AUTOEXTEND_SIZE:
        case MySqlParser::AUTO_INCREMENT:
        case MySqlParser::AVG_ROW_LENGTH:
        case MySqlParser::BEGIN:
        case MySqlParser::BINLOG:
        case MySqlParser::BIT:
        case MySqlParser::BLOCK:
        case MySqlParser::BOOL:
        case MySqlParser::BOOLEAN:
        case MySqlParser::BTREE:
        case MySqlParser::CACHE:
        case MySqlParser::CASCADED:
        case MySqlParser::CHAIN:
        case MySqlParser::CHANGED:
        case MySqlParser::CHANNEL:
        case MySqlParser::CHECKSUM:
        case MySqlParser::PAGE_CHECKSUM:
        case MySqlParser::CIPHER:
        case MySqlParser::CLASS_ORIGIN:
        case MySqlParser::CLIENT:
        case MySqlParser::CLOSE:
        case MySqlParser::CLUSTERING:
        case MySqlParser::COALESCE:
        case MySqlParser::CODE:
        case MySqlParser::COLUMNS:
        case MySqlParser::COLUMN_FORMAT:
        case MySqlParser::COLUMN_NAME:
        case MySqlParser::COMMENT:
        case MySqlParser::COMMIT:
        case MySqlParser::COMPACT:
        case MySqlParser::COMPLETION:
        case MySqlParser::COMPRESSED:
        case MySqlParser::COMPRESSION:
        case MySqlParser::CONCURRENT:
        case MySqlParser::CONNECT:
        case MySqlParser::CONNECTION:
        case MySqlParser::CONSISTENT:
        case MySqlParser::CONSTRAINT_CATALOG:
        case MySqlParser::CONSTRAINT_SCHEMA:
        case MySqlParser::CONSTRAINT_NAME:
        case MySqlParser::CONTAINS:
        case MySqlParser::CONTEXT:
        case MySqlParser::CONTRIBUTORS:
        case MySqlParser::COPY:
        case MySqlParser::CPU:
        case MySqlParser::CURSOR_NAME:
        case MySqlParser::DATA:
        case MySqlParser::DATAFILE:
        case MySqlParser::DEALLOCATE:
        case MySqlParser::DEFAULT_AUTH:
        case MySqlParser::DEFINER:
        case MySqlParser::DELAY_KEY_WRITE:
        case MySqlParser::DES_KEY_FILE:
        case MySqlParser::DIRECTORY:
        case MySqlParser::DISABLE:
        case MySqlParser::DISCARD:
        case MySqlParser::DISK:
        case MySqlParser::DO:
        case MySqlParser::DUMPFILE:
        case MySqlParser::DUPLICATE:
        case MySqlParser::DYNAMIC:
        case MySqlParser::ENABLE:
        case MySqlParser::ENCRYPTION:
        case MySqlParser::END:
        case MySqlParser::ENDS:
        case MySqlParser::ENGINE:
        case MySqlParser::ENGINES:
        case MySqlParser::ERROR:
        case MySqlParser::ERRORS:
        case MySqlParser::ESCAPE:
        case MySqlParser::EVEN:
        case MySqlParser::EVENT:
        case MySqlParser::EVENTS:
        case MySqlParser::EVERY:
        case MySqlParser::EXCHANGE:
        case MySqlParser::EXCLUSIVE:
        case MySqlParser::EXPIRE:
        case MySqlParser::EXPORT:
        case MySqlParser::EXTENDED:
        case MySqlParser::EXTENT_SIZE:
        case MySqlParser::FAILED_LOGIN_ATTEMPTS:
        case MySqlParser::FAST:
        case MySqlParser::FAULTS:
        case MySqlParser::FIELDS:
        case MySqlParser::FILE_BLOCK_SIZE:
        case MySqlParser::FILTER:
        case MySqlParser::FIRST:
        case MySqlParser::FIXED:
        case MySqlParser::FLUSH:
        case MySqlParser::FOLLOWS:
        case MySqlParser::FOUND:
        case MySqlParser::FULL:
        case MySqlParser::FUNCTION:
        case MySqlParser::GENERAL:
        case MySqlParser::GLOBAL:
        case MySqlParser::GRANTS:
        case MySqlParser::GROUP_REPLICATION:
        case MySqlParser::HANDLER:
        case MySqlParser::HASH:
        case MySqlParser::HELP:
        case MySqlParser::HISTORY:
        case MySqlParser::HOST:
        case MySqlParser::HOSTS:
        case MySqlParser::IDENTIFIED:
        case MySqlParser::IGNORE_SERVER_IDS:
        case MySqlParser::IMPORT:
        case MySqlParser::INDEXES:
        case MySqlParser::INITIAL_SIZE:
        case MySqlParser::INPLACE:
        case MySqlParser::INSERT_METHOD:
        case MySqlParser::INSTALL:
        case MySqlParser::INSTANCE:
        case MySqlParser::INSTANT:
        case MySqlParser::INVISIBLE:
        case MySqlParser::INVOKER:
        case MySqlParser::IO:
        case MySqlParser::IO_THREAD:
        case MySqlParser::IPC:
        case MySqlParser::ISOLATION:
        case MySqlParser::ISSUER:
        case MySqlParser::JSON:
        case MySqlParser::KEY_BLOCK_SIZE:
        case MySqlParser::LANGUAGE:
        case MySqlParser::LAST:
        case MySqlParser::LEAVES:
        case MySqlParser::LESS:
        case MySqlParser::LEVEL:
        case MySqlParser::LIST:
        case MySqlParser::LOCAL:
        case MySqlParser::LOGFILE:
        case MySqlParser::LOGS:
        case MySqlParser::MASTER:
        case MySqlParser::MASTER_AUTO_POSITION:
        case MySqlParser::MASTER_CONNECT_RETRY:
        case MySqlParser::MASTER_DELAY:
        case MySqlParser::MASTER_HEARTBEAT_PERIOD:
        case MySqlParser::MASTER_HOST:
        case MySqlParser::MASTER_LOG_FILE:
        case MySqlParser::MASTER_LOG_POS:
        case MySqlParser::MASTER_PASSWORD:
        case MySqlParser::MASTER_PORT:
        case MySqlParser::MASTER_RETRY_COUNT:
        case MySqlParser::MASTER_SSL:
        case MySqlParser::MASTER_SSL_CA:
        case MySqlParser::MASTER_SSL_CAPATH:
        case MySqlParser::MASTER_SSL_CERT:
        case MySqlParser::MASTER_SSL_CIPHER:
        case MySqlParser::MASTER_SSL_CRL:
        case MySqlParser::MASTER_SSL_CRLPATH:
        case MySqlParser::MASTER_SSL_KEY:
        case MySqlParser::MASTER_TLS_VERSION:
        case MySqlParser::MASTER_USER:
        case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
        case MySqlParser::MAX_QUERIES_PER_HOUR:
        case MySqlParser::MAX_ROWS:
        case MySqlParser::MAX_SIZE:
        case MySqlParser::MAX_UPDATES_PER_HOUR:
        case MySqlParser::MAX_USER_CONNECTIONS:
        case MySqlParser::MEDIUM:
        case MySqlParser::MEMBER:
        case MySqlParser::MERGE:
        case MySqlParser::MESSAGE_TEXT:
        case MySqlParser::MID:
        case MySqlParser::MIGRATE:
        case MySqlParser::MIN_ROWS:
        case MySqlParser::MODE:
        case MySqlParser::MODIFY:
        case MySqlParser::MUTEX:
        case MySqlParser::MYSQL:
        case MySqlParser::MYSQL_ERRNO:
        case MySqlParser::NAME:
        case MySqlParser::NAMES:
        case MySqlParser::NCHAR:
        case MySqlParser::NEVER:
        case MySqlParser::NEXT:
        case MySqlParser::NO:
        case MySqlParser::NOCOPY:
        case MySqlParser::NOWAIT:
        case MySqlParser::NODEGROUP:
        case MySqlParser::NONE:
        case MySqlParser::ODBC:
        case MySqlParser::OFFLINE:
        case MySqlParser::OFFSET:
        case MySqlParser::OF:
        case MySqlParser::OJ:
        case MySqlParser::OLD_PASSWORD:
        case MySqlParser::ONE:
        case MySqlParser::ONLINE:
        case MySqlParser::ONLY:
        case MySqlParser::OPEN:
        case MySqlParser::OPTIMIZER_COSTS:
        case MySqlParser::OPTIONS:
        case MySqlParser::OWNER:
        case MySqlParser::PACK_KEYS:
        case MySqlParser::PAGE:
        case MySqlParser::PARSER:
        case MySqlParser::PARTIAL:
        case MySqlParser::PARTITIONING:
        case MySqlParser::PARTITIONS:
        case MySqlParser::PASSWORD:
        case MySqlParser::PASSWORD_LOCK_TIME:
        case MySqlParser::PHASE:
        case MySqlParser::PLUGIN:
        case MySqlParser::PLUGIN_DIR:
        case MySqlParser::PLUGINS:
        case MySqlParser::PORT:
        case MySqlParser::PRECEDES:
        case MySqlParser::PREPARE:
        case MySqlParser::PRESERVE:
        case MySqlParser::PREV:
        case MySqlParser::PROCESSLIST:
        case MySqlParser::PROFILE:
        case MySqlParser::PROFILES:
        case MySqlParser::PROXY:
        case MySqlParser::QUERY:
        case MySqlParser::QUICK:
        case MySqlParser::REBUILD:
        case MySqlParser::RECOVER:
        case MySqlParser::RECURSIVE:
        case MySqlParser::REDO_BUFFER_SIZE:
        case MySqlParser::REDUNDANT:
        case MySqlParser::RELAY:
        case MySqlParser::RELAY_LOG_FILE:
        case MySqlParser::RELAY_LOG_POS:
        case MySqlParser::RELAYLOG:
        case MySqlParser::REMOVE:
        case MySqlParser::REORGANIZE:
        case MySqlParser::REPAIR:
        case MySqlParser::REPLICATE_DO_DB:
        case MySqlParser::REPLICATE_DO_TABLE:
        case MySqlParser::REPLICATE_IGNORE_DB:
        case MySqlParser::REPLICATE_IGNORE_TABLE:
        case MySqlParser::REPLICATE_REWRITE_DB:
        case MySqlParser::REPLICATE_WILD_DO_TABLE:
        case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
        case MySqlParser::REPLICATION:
        case MySqlParser::RESET:
        case MySqlParser::RESUME:
        case MySqlParser::RETURNED_SQLSTATE:
        case MySqlParser::RETURNS:
        case MySqlParser::REUSE:
        case MySqlParser::ROLE:
        case MySqlParser::ROLLBACK:
        case MySqlParser::ROLLUP:
        case MySqlParser::ROTATE:
        case MySqlParser::ROW:
        case MySqlParser::ROWS:
        case MySqlParser::ROW_FORMAT:
        case MySqlParser::RTREE:
        case MySqlParser::SAVEPOINT:
        case MySqlParser::SCHEDULE:
        case MySqlParser::SECURITY:
        case MySqlParser::SERVER:
        case MySqlParser::SESSION:
        case MySqlParser::SHARE:
        case MySqlParser::SHARED:
        case MySqlParser::SIGNED:
        case MySqlParser::SIMPLE:
        case MySqlParser::SLAVE:
        case MySqlParser::SLOW:
        case MySqlParser::SNAPSHOT:
        case MySqlParser::SOCKET:
        case MySqlParser::SOME:
        case MySqlParser::SONAME:
        case MySqlParser::SOUNDS:
        case MySqlParser::SOURCE:
        case MySqlParser::SQL_AFTER_GTIDS:
        case MySqlParser::SQL_AFTER_MTS_GAPS:
        case MySqlParser::SQL_BEFORE_GTIDS:
        case MySqlParser::SQL_BUFFER_RESULT:
        case MySqlParser::SQL_CACHE:
        case MySqlParser::SQL_NO_CACHE:
        case MySqlParser::SQL_THREAD:
        case MySqlParser::START:
        case MySqlParser::STARTS:
        case MySqlParser::STATS_AUTO_RECALC:
        case MySqlParser::STATS_PERSISTENT:
        case MySqlParser::STATS_SAMPLE_PAGES:
        case MySqlParser::STATUS:
        case MySqlParser::STOP:
        case MySqlParser::STORAGE:
        case MySqlParser::STRING:
        case MySqlParser::SUBCLASS_ORIGIN:
        case MySqlParser::SUBJECT:
        case MySqlParser::SUBPARTITION:
        case MySqlParser::SUBPARTITIONS:
        case MySqlParser::SUSPEND:
        case MySqlParser::SWAPS:
        case MySqlParser::SWITCHES:
        case MySqlParser::TABLE_NAME:
        case MySqlParser::TABLESPACE:
        case MySqlParser::TABLE_TYPE:
        case MySqlParser::TEMPORARY:
        case MySqlParser::TEMPTABLE:
        case MySqlParser::THAN:
        case MySqlParser::TRADITIONAL:
        case MySqlParser::TRANSACTION:
        case MySqlParser::TRANSACTIONAL:
        case MySqlParser::TRIGGERS:
        case MySqlParser::TRUNCATE:
        case MySqlParser::UNBOUNDED:
        case MySqlParser::UNDEFINED:
        case MySqlParser::UNDOFILE:
        case MySqlParser::UNDO_BUFFER_SIZE:
        case MySqlParser::UNINSTALL:
        case MySqlParser::UNKNOWN:
        case MySqlParser::UNTIL:
        case MySqlParser::UPGRADE:
        case MySqlParser::USER:
        case MySqlParser::USE_FRM:
        case MySqlParser::USER_RESOURCES:
        case MySqlParser::VALIDATION:
        case MySqlParser::VALUE:
        case MySqlParser::VARIABLES:
        case MySqlParser::VIEW:
        case MySqlParser::VIRTUAL:
        case MySqlParser::VISIBLE:
        case MySqlParser::WAIT:
        case MySqlParser::WARNINGS:
        case MySqlParser::WITHOUT:
        case MySqlParser::WORK:
        case MySqlParser::WRAPPER:
        case MySqlParser::X509:
        case MySqlParser::XA:
        case MySqlParser::XML:
        case MySqlParser::EUR:
        case MySqlParser::USA:
        case MySqlParser::JIS:
        case MySqlParser::ISO:
        case MySqlParser::INTERNAL:
        case MySqlParser::QUARTER:
        case MySqlParser::MONTH:
        case MySqlParser::DAY:
        case MySqlParser::HOUR:
        case MySqlParser::MINUTE:
        case MySqlParser::WEEK:
        case MySqlParser::SECOND:
        case MySqlParser::MICROSECOND:
        case MySqlParser::ADMIN:
        case MySqlParser::AUDIT_ABORT_EXEMPT:
        case MySqlParser::AUDIT_ADMIN:
        case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
        case MySqlParser::BACKUP_ADMIN:
        case MySqlParser::BINLOG_ADMIN:
        case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
        case MySqlParser::CLONE_ADMIN:
        case MySqlParser::CONNECTION_ADMIN:
        case MySqlParser::ENCRYPTION_KEY_ADMIN:
        case MySqlParser::EXECUTE:
        case MySqlParser::FILE:
        case MySqlParser::FIREWALL_ADMIN:
        case MySqlParser::FIREWALL_EXEMPT:
        case MySqlParser::FIREWALL_USER:
        case MySqlParser::GROUP_REPLICATION_ADMIN:
        case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
        case MySqlParser::INVOKE:
        case MySqlParser::LAMBDA:
        case MySqlParser::NDB_STORED_USER:
        case MySqlParser::PASSWORDLESS_USER_ADMIN:
        case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
        case MySqlParser::PRIVILEGES:
        case MySqlParser::PROCESS:
        case MySqlParser::RELOAD:
        case MySqlParser::REPLICATION_APPLIER:
        case MySqlParser::REPLICATION_SLAVE_ADMIN:
        case MySqlParser::RESOURCE_GROUP_ADMIN:
        case MySqlParser::RESOURCE_GROUP_USER:
        case MySqlParser::ROLE_ADMIN:
        case MySqlParser::ROUTINE:
        case MySqlParser::S3:
        case MySqlParser::SESSION_VARIABLES_ADMIN:
        case MySqlParser::SET_USER_ID:
        case MySqlParser::SHOW_ROUTINE:
        case MySqlParser::SHUTDOWN:
        case MySqlParser::SUPER:
        case MySqlParser::SYSTEM_VARIABLES_ADMIN:
        case MySqlParser::TABLES:
        case MySqlParser::TABLE_ENCRYPTION_ADMIN:
        case MySqlParser::VERSION_TOKEN_ADMIN:
        case MySqlParser::XA_RECOVER_ADMIN:
        case MySqlParser::ARMSCII8:
        case MySqlParser::ASCII:
        case MySqlParser::BIG5:
        case MySqlParser::CP1250:
        case MySqlParser::CP1251:
        case MySqlParser::CP1256:
        case MySqlParser::CP1257:
        case MySqlParser::CP850:
        case MySqlParser::CP852:
        case MySqlParser::CP866:
        case MySqlParser::CP932:
        case MySqlParser::DEC8:
        case MySqlParser::EUCJPMS:
        case MySqlParser::EUCKR:
        case MySqlParser::GB18030:
        case MySqlParser::GB2312:
        case MySqlParser::GBK:
        case MySqlParser::GEOSTD8:
        case MySqlParser::GREEK:
        case MySqlParser::HEBREW:
        case MySqlParser::HP8:
        case MySqlParser::KEYBCS2:
        case MySqlParser::KOI8R:
        case MySqlParser::KOI8U:
        case MySqlParser::LATIN1:
        case MySqlParser::LATIN2:
        case MySqlParser::LATIN5:
        case MySqlParser::LATIN7:
        case MySqlParser::MACCE:
        case MySqlParser::MACROMAN:
        case MySqlParser::SJIS:
        case MySqlParser::SWE7:
        case MySqlParser::TIS620:
        case MySqlParser::UCS2:
        case MySqlParser::UJIS:
        case MySqlParser::UTF16:
        case MySqlParser::UTF16LE:
        case MySqlParser::UTF32:
        case MySqlParser::UTF8:
        case MySqlParser::UTF8MB3:
        case MySqlParser::UTF8MB4:
        case MySqlParser::ARCHIVE:
        case MySqlParser::BLACKHOLE:
        case MySqlParser::CSV:
        case MySqlParser::FEDERATED:
        case MySqlParser::INNODB:
        case MySqlParser::MEMORY:
        case MySqlParser::MRG_MYISAM:
        case MySqlParser::MYISAM:
        case MySqlParser::NDB:
        case MySqlParser::NDBCLUSTER:
        case MySqlParser::PERFORMANCE_SCHEMA:
        case MySqlParser::TOKUDB:
        case MySqlParser::REPEATABLE:
        case MySqlParser::COMMITTED:
        case MySqlParser::UNCOMMITTED:
        case MySqlParser::SERIALIZABLE:
        case MySqlParser::GEOMETRYCOLLECTION:
        case MySqlParser::LINESTRING:
        case MySqlParser::MULTILINESTRING:
        case MySqlParser::MULTIPOINT:
        case MySqlParser::MULTIPOLYGON:
        case MySqlParser::POINT:
        case MySqlParser::POLYGON:
        case MySqlParser::ABS:
        case MySqlParser::ACOS:
        case MySqlParser::ADDDATE:
        case MySqlParser::ADDTIME:
        case MySqlParser::AES_DECRYPT:
        case MySqlParser::AES_ENCRYPT:
        case MySqlParser::AREA:
        case MySqlParser::ASBINARY:
        case MySqlParser::ASIN:
        case MySqlParser::ASTEXT:
        case MySqlParser::ASWKB:
        case MySqlParser::ASWKT:
        case MySqlParser::ASYMMETRIC_DECRYPT:
        case MySqlParser::ASYMMETRIC_DERIVE:
        case MySqlParser::ASYMMETRIC_ENCRYPT:
        case MySqlParser::ASYMMETRIC_SIGN:
        case MySqlParser::ASYMMETRIC_VERIFY:
        case MySqlParser::ATAN:
        case MySqlParser::ATAN2:
        case MySqlParser::BENCHMARK:
        case MySqlParser::BIN:
        case MySqlParser::BIT_COUNT:
        case MySqlParser::BIT_LENGTH:
        case MySqlParser::BUFFER:
        case MySqlParser::CATALOG_NAME:
        case MySqlParser::CEIL:
        case MySqlParser::CEILING:
        case MySqlParser::CENTROID:
        case MySqlParser::CHARACTER_LENGTH:
        case MySqlParser::CHARSET:
        case MySqlParser::CHAR_LENGTH:
        case MySqlParser::COERCIBILITY:
        case MySqlParser::COLLATION:
        case MySqlParser::COMPRESS:
        case MySqlParser::CONCAT:
        case MySqlParser::CONCAT_WS:
        case MySqlParser::CONNECTION_ID:
        case MySqlParser::CONV:
        case MySqlParser::CONVERT_TZ:
        case MySqlParser::COS:
        case MySqlParser::COT:
        case MySqlParser::CRC32:
        case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
        case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
        case MySqlParser::CREATE_DH_PARAMETERS:
        case MySqlParser::CREATE_DIGEST:
        case MySqlParser::CROSSES:
        case MySqlParser::DATEDIFF:
        case MySqlParser::DATE_FORMAT:
        case MySqlParser::DAYNAME:
        case MySqlParser::DAYOFMONTH:
        case MySqlParser::DAYOFWEEK:
        case MySqlParser::DAYOFYEAR:
        case MySqlParser::DECODE:
        case MySqlParser::DEGREES:
        case MySqlParser::DES_DECRYPT:
        case MySqlParser::DES_ENCRYPT:
        case MySqlParser::DIMENSION:
        case MySqlParser::DISJOINT:
        case MySqlParser::ELT:
        case MySqlParser::ENCODE:
        case MySqlParser::ENCRYPT:
        case MySqlParser::ENDPOINT:
        case MySqlParser::ENGINE_ATTRIBUTE:
        case MySqlParser::ENVELOPE:
        case MySqlParser::EQUALS:
        case MySqlParser::EXP:
        case MySqlParser::EXPORT_SET:
        case MySqlParser::EXTERIORRING:
        case MySqlParser::EXTRACTVALUE:
        case MySqlParser::FIELD:
        case MySqlParser::FIND_IN_SET:
        case MySqlParser::FLOOR:
        case MySqlParser::FORMAT:
        case MySqlParser::FOUND_ROWS:
        case MySqlParser::FROM_BASE64:
        case MySqlParser::FROM_DAYS:
        case MySqlParser::FROM_UNIXTIME:
        case MySqlParser::GEOMCOLLFROMTEXT:
        case MySqlParser::GEOMCOLLFROMWKB:
        case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
        case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
        case MySqlParser::GEOMETRYFROMTEXT:
        case MySqlParser::GEOMETRYFROMWKB:
        case MySqlParser::GEOMETRYN:
        case MySqlParser::GEOMETRYTYPE:
        case MySqlParser::GEOMFROMTEXT:
        case MySqlParser::GEOMFROMWKB:
        case MySqlParser::GET_FORMAT:
        case MySqlParser::GET_LOCK:
        case MySqlParser::GLENGTH:
        case MySqlParser::GREATEST:
        case MySqlParser::GTID_SUBSET:
        case MySqlParser::GTID_SUBTRACT:
        case MySqlParser::HEX:
        case MySqlParser::IFNULL:
        case MySqlParser::INET6_ATON:
        case MySqlParser::INET6_NTOA:
        case MySqlParser::INET_ATON:
        case MySqlParser::INET_NTOA:
        case MySqlParser::INSTR:
        case MySqlParser::INTERIORRINGN:
        case MySqlParser::INTERSECTS:
        case MySqlParser::ISCLOSED:
        case MySqlParser::ISEMPTY:
        case MySqlParser::ISNULL:
        case MySqlParser::ISSIMPLE:
        case MySqlParser::IS_FREE_LOCK:
        case MySqlParser::IS_IPV4:
        case MySqlParser::IS_IPV4_COMPAT:
        case MySqlParser::IS_IPV4_MAPPED:
        case MySqlParser::IS_IPV6:
        case MySqlParser::IS_USED_LOCK:
        case MySqlParser::LAST_INSERT_ID:
        case MySqlParser::LCASE:
        case MySqlParser::LEAST:
        case MySqlParser::LENGTH:
        case MySqlParser::LINEFROMTEXT:
        case MySqlParser::LINEFROMWKB:
        case MySqlParser::LINESTRINGFROMTEXT:
        case MySqlParser::LINESTRINGFROMWKB:
        case MySqlParser::LN:
        case MySqlParser::LOAD_FILE:
        case MySqlParser::LOCATE:
        case MySqlParser::LOG:
        case MySqlParser::LOG10:
        case MySqlParser::LOG2:
        case MySqlParser::LOWER:
        case MySqlParser::LPAD:
        case MySqlParser::LTRIM:
        case MySqlParser::MAKEDATE:
        case MySqlParser::MAKETIME:
        case MySqlParser::MAKE_SET:
        case MySqlParser::MASTER_POS_WAIT:
        case MySqlParser::MBRCONTAINS:
        case MySqlParser::MBRDISJOINT:
        case MySqlParser::MBREQUAL:
        case MySqlParser::MBRINTERSECTS:
        case MySqlParser::MBROVERLAPS:
        case MySqlParser::MBRTOUCHES:
        case MySqlParser::MBRWITHIN:
        case MySqlParser::MD5:
        case MySqlParser::MLINEFROMTEXT:
        case MySqlParser::MLINEFROMWKB:
        case MySqlParser::MONTHNAME:
        case MySqlParser::MPOINTFROMTEXT:
        case MySqlParser::MPOINTFROMWKB:
        case MySqlParser::MPOLYFROMTEXT:
        case MySqlParser::MPOLYFROMWKB:
        case MySqlParser::MULTILINESTRINGFROMTEXT:
        case MySqlParser::MULTILINESTRINGFROMWKB:
        case MySqlParser::MULTIPOINTFROMTEXT:
        case MySqlParser::MULTIPOINTFROMWKB:
        case MySqlParser::MULTIPOLYGONFROMTEXT:
        case MySqlParser::MULTIPOLYGONFROMWKB:
        case MySqlParser::NAME_CONST:
        case MySqlParser::NULLIF:
        case MySqlParser::NUMGEOMETRIES:
        case MySqlParser::NUMINTERIORRINGS:
        case MySqlParser::NUMPOINTS:
        case MySqlParser::OCT:
        case MySqlParser::OCTET_LENGTH:
        case MySqlParser::ORD:
        case MySqlParser::OVERLAPS:
        case MySqlParser::PERIOD_ADD:
        case MySqlParser::PERIOD_DIFF:
        case MySqlParser::PI:
        case MySqlParser::POINTFROMTEXT:
        case MySqlParser::POINTFROMWKB:
        case MySqlParser::POINTN:
        case MySqlParser::POLYFROMTEXT:
        case MySqlParser::POLYFROMWKB:
        case MySqlParser::POLYGONFROMTEXT:
        case MySqlParser::POLYGONFROMWKB:
        case MySqlParser::POW:
        case MySqlParser::POWER:
        case MySqlParser::QUOTE:
        case MySqlParser::RADIANS:
        case MySqlParser::RAND:
        case MySqlParser::RANDOM_BYTES:
        case MySqlParser::RELEASE_LOCK:
        case MySqlParser::REVERSE:
        case MySqlParser::ROUND:
        case MySqlParser::ROW_COUNT:
        case MySqlParser::RPAD:
        case MySqlParser::RTRIM:
        case MySqlParser::SEC_TO_TIME:
        case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
        case MySqlParser::SESSION_USER:
        case MySqlParser::SHA:
        case MySqlParser::SHA1:
        case MySqlParser::SHA2:
        case MySqlParser::SCHEMA_NAME:
        case MySqlParser::SIGN:
        case MySqlParser::SIN:
        case MySqlParser::SLEEP:
        case MySqlParser::SOUNDEX:
        case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
        case MySqlParser::SQRT:
        case MySqlParser::SRID:
        case MySqlParser::STARTPOINT:
        case MySqlParser::STRCMP:
        case MySqlParser::STR_TO_DATE:
        case MySqlParser::ST_AREA:
        case MySqlParser::ST_ASBINARY:
        case MySqlParser::ST_ASTEXT:
        case MySqlParser::ST_ASWKB:
        case MySqlParser::ST_ASWKT:
        case MySqlParser::ST_BUFFER:
        case MySqlParser::ST_CENTROID:
        case MySqlParser::ST_CONTAINS:
        case MySqlParser::ST_CROSSES:
        case MySqlParser::ST_DIFFERENCE:
        case MySqlParser::ST_DIMENSION:
        case MySqlParser::ST_DISJOINT:
        case MySqlParser::ST_DISTANCE:
        case MySqlParser::ST_ENDPOINT:
        case MySqlParser::ST_ENVELOPE:
        case MySqlParser::ST_EQUALS:
        case MySqlParser::ST_EXTERIORRING:
        case MySqlParser::ST_GEOMCOLLFROMTEXT:
        case MySqlParser::ST_GEOMCOLLFROMTXT:
        case MySqlParser::ST_GEOMCOLLFROMWKB:
        case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
        case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
        case MySqlParser::ST_GEOMETRYFROMTEXT:
        case MySqlParser::ST_GEOMETRYFROMWKB:
        case MySqlParser::ST_GEOMETRYN:
        case MySqlParser::ST_GEOMETRYTYPE:
        case MySqlParser::ST_GEOMFROMTEXT:
        case MySqlParser::ST_GEOMFROMWKB:
        case MySqlParser::ST_INTERIORRINGN:
        case MySqlParser::ST_INTERSECTION:
        case MySqlParser::ST_INTERSECTS:
        case MySqlParser::ST_ISCLOSED:
        case MySqlParser::ST_ISEMPTY:
        case MySqlParser::ST_ISSIMPLE:
        case MySqlParser::ST_LINEFROMTEXT:
        case MySqlParser::ST_LINEFROMWKB:
        case MySqlParser::ST_LINESTRINGFROMTEXT:
        case MySqlParser::ST_LINESTRINGFROMWKB:
        case MySqlParser::ST_NUMGEOMETRIES:
        case MySqlParser::ST_NUMINTERIORRING:
        case MySqlParser::ST_NUMINTERIORRINGS:
        case MySqlParser::ST_NUMPOINTS:
        case MySqlParser::ST_OVERLAPS:
        case MySqlParser::ST_POINTFROMTEXT:
        case MySqlParser::ST_POINTFROMWKB:
        case MySqlParser::ST_POINTN:
        case MySqlParser::ST_POLYFROMTEXT:
        case MySqlParser::ST_POLYFROMWKB:
        case MySqlParser::ST_POLYGONFROMTEXT:
        case MySqlParser::ST_POLYGONFROMWKB:
        case MySqlParser::ST_SRID:
        case MySqlParser::ST_STARTPOINT:
        case MySqlParser::ST_SYMDIFFERENCE:
        case MySqlParser::ST_TOUCHES:
        case MySqlParser::ST_UNION:
        case MySqlParser::ST_WITHIN:
        case MySqlParser::ST_X:
        case MySqlParser::ST_Y:
        case MySqlParser::SUBDATE:
        case MySqlParser::SUBSTRING_INDEX:
        case MySqlParser::SUBTIME:
        case MySqlParser::SYSTEM_USER:
        case MySqlParser::TAN:
        case MySqlParser::TIMEDIFF:
        case MySqlParser::TIMESTAMPADD:
        case MySqlParser::TIMESTAMPDIFF:
        case MySqlParser::TIME_FORMAT:
        case MySqlParser::TIME_TO_SEC:
        case MySqlParser::TOUCHES:
        case MySqlParser::TO_BASE64:
        case MySqlParser::TO_DAYS:
        case MySqlParser::TO_SECONDS:
        case MySqlParser::TP_CONNECTION_ADMIN:
        case MySqlParser::UCASE:
        case MySqlParser::UNCOMPRESS:
        case MySqlParser::UNCOMPRESSED_LENGTH:
        case MySqlParser::UNHEX:
        case MySqlParser::UNIX_TIMESTAMP:
        case MySqlParser::UPDATEXML:
        case MySqlParser::UPPER:
        case MySqlParser::UUID:
        case MySqlParser::UUID_SHORT:
        case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
        case MySqlParser::VERSION:
        case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
        case MySqlParser::WEEKDAY:
        case MySqlParser::WEEKOFYEAR:
        case MySqlParser::WEIGHT_STRING:
        case MySqlParser::WITHIN:
        case MySqlParser::YEARWEEK:
        case MySqlParser::Y_FUNCTION:
        case MySqlParser::X_FUNCTION:
        case MySqlParser::MOD:
        case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
        case MySqlParser::STRING_LITERAL:
        case MySqlParser::ID: {
          setState(5955);
          uidList();
          break;
        }

        case MySqlParser::ALL: {
          setState(5956);
          match(MySqlParser::ALL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(5959);
      match(MySqlParser::RR_BRACKET);
    }
    setState(5962);
    match(MySqlParser::IN);
    setState(5963);
    antlrcpp::downCast<CacheIndexStatementContext *>(_localctx)->schema = uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushStatementContext ------------------------------------------------------------------

MySqlParser::FlushStatementContext::FlushStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::FlushStatementContext::FLUSH() {
  return getToken(MySqlParser::FLUSH, 0);
}

std::vector<MySqlParser::FlushOptionContext *> MySqlParser::FlushStatementContext::flushOption() {
  return getRuleContexts<MySqlParser::FlushOptionContext>();
}

MySqlParser::FlushOptionContext* MySqlParser::FlushStatementContext::flushOption(size_t i) {
  return getRuleContext<MySqlParser::FlushOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::FlushStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::FlushStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::FlushStatementContext::NO_WRITE_TO_BINLOG() {
  return getToken(MySqlParser::NO_WRITE_TO_BINLOG, 0);
}

tree::TerminalNode* MySqlParser::FlushStatementContext::LOCAL() {
  return getToken(MySqlParser::LOCAL, 0);
}


size_t MySqlParser::FlushStatementContext::getRuleIndex() const {
  return MySqlParser::RuleFlushStatement;
}

void MySqlParser::FlushStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlushStatement(this);
}

void MySqlParser::FlushStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlushStatement(this);
}


std::any MySqlParser::FlushStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFlushStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FlushStatementContext* MySqlParser::flushStatement() {
  FlushStatementContext *_localctx = _tracker.createInstance<FlushStatementContext>(_ctx, getState());
  enterRule(_localctx, 502, MySqlParser::RuleFlushStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5965);
    match(MySqlParser::FLUSH);
    setState(5967);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::NO_WRITE_TO_BINLOG || _la == MySqlParser::LOCAL) {
      setState(5966);
      antlrcpp::downCast<FlushStatementContext *>(_localctx)->flushFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::NO_WRITE_TO_BINLOG || _la == MySqlParser::LOCAL)) {
        antlrcpp::downCast<FlushStatementContext *>(_localctx)->flushFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(5969);
    flushOption();
    setState(5974);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(5970);
      match(MySqlParser::COMMA);
      setState(5971);
      flushOption();
      setState(5976);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KillStatementContext ------------------------------------------------------------------

MySqlParser::KillStatementContext::KillStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::KillStatementContext::KILL() {
  return getToken(MySqlParser::KILL, 0);
}

MySqlParser::ExpressionContext* MySqlParser::KillStatementContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::KillStatementContext::CONNECTION() {
  return getToken(MySqlParser::CONNECTION, 0);
}

tree::TerminalNode* MySqlParser::KillStatementContext::QUERY() {
  return getToken(MySqlParser::QUERY, 0);
}


size_t MySqlParser::KillStatementContext::getRuleIndex() const {
  return MySqlParser::RuleKillStatement;
}

void MySqlParser::KillStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKillStatement(this);
}

void MySqlParser::KillStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKillStatement(this);
}


std::any MySqlParser::KillStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitKillStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::KillStatementContext* MySqlParser::killStatement() {
  KillStatementContext *_localctx = _tracker.createInstance<KillStatementContext>(_ctx, getState());
  enterRule(_localctx, 504, MySqlParser::RuleKillStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5977);
    match(MySqlParser::KILL);
    setState(5979);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 870, _ctx)) {
    case 1: {
      setState(5978);
      antlrcpp::downCast<KillStatementContext *>(_localctx)->connectionFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::CONNECTION || _la == MySqlParser::QUERY)) {
        antlrcpp::downCast<KillStatementContext *>(_localctx)->connectionFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(5981);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadIndexIntoCacheContext ------------------------------------------------------------------

MySqlParser::LoadIndexIntoCacheContext::LoadIndexIntoCacheContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::LoadIndexIntoCacheContext::LOAD() {
  return getToken(MySqlParser::LOAD, 0);
}

tree::TerminalNode* MySqlParser::LoadIndexIntoCacheContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::LoadIndexIntoCacheContext::INTO() {
  return getToken(MySqlParser::INTO, 0);
}

tree::TerminalNode* MySqlParser::LoadIndexIntoCacheContext::CACHE() {
  return getToken(MySqlParser::CACHE, 0);
}

std::vector<MySqlParser::LoadedTableIndexesContext *> MySqlParser::LoadIndexIntoCacheContext::loadedTableIndexes() {
  return getRuleContexts<MySqlParser::LoadedTableIndexesContext>();
}

MySqlParser::LoadedTableIndexesContext* MySqlParser::LoadIndexIntoCacheContext::loadedTableIndexes(size_t i) {
  return getRuleContext<MySqlParser::LoadedTableIndexesContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadIndexIntoCacheContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::LoadIndexIntoCacheContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::LoadIndexIntoCacheContext::getRuleIndex() const {
  return MySqlParser::RuleLoadIndexIntoCache;
}

void MySqlParser::LoadIndexIntoCacheContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadIndexIntoCache(this);
}

void MySqlParser::LoadIndexIntoCacheContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadIndexIntoCache(this);
}


std::any MySqlParser::LoadIndexIntoCacheContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLoadIndexIntoCache(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LoadIndexIntoCacheContext* MySqlParser::loadIndexIntoCache() {
  LoadIndexIntoCacheContext *_localctx = _tracker.createInstance<LoadIndexIntoCacheContext>(_ctx, getState());
  enterRule(_localctx, 506, MySqlParser::RuleLoadIndexIntoCache);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5983);
    match(MySqlParser::LOAD);
    setState(5984);
    match(MySqlParser::INDEX);
    setState(5985);
    match(MySqlParser::INTO);
    setState(5986);
    match(MySqlParser::CACHE);
    setState(5987);
    loadedTableIndexes();
    setState(5992);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(5988);
      match(MySqlParser::COMMA);
      setState(5989);
      loadedTableIndexes();
      setState(5994);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResetStatementContext ------------------------------------------------------------------

MySqlParser::ResetStatementContext::ResetStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ResetStatementContext::RESET() {
  return getToken(MySqlParser::RESET, 0);
}

tree::TerminalNode* MySqlParser::ResetStatementContext::QUERY() {
  return getToken(MySqlParser::QUERY, 0);
}

tree::TerminalNode* MySqlParser::ResetStatementContext::CACHE() {
  return getToken(MySqlParser::CACHE, 0);
}


size_t MySqlParser::ResetStatementContext::getRuleIndex() const {
  return MySqlParser::RuleResetStatement;
}

void MySqlParser::ResetStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResetStatement(this);
}

void MySqlParser::ResetStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResetStatement(this);
}


std::any MySqlParser::ResetStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitResetStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ResetStatementContext* MySqlParser::resetStatement() {
  ResetStatementContext *_localctx = _tracker.createInstance<ResetStatementContext>(_ctx, getState());
  enterRule(_localctx, 508, MySqlParser::RuleResetStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5995);
    match(MySqlParser::RESET);
    setState(5996);
    match(MySqlParser::QUERY);
    setState(5997);
    match(MySqlParser::CACHE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShutdownStatementContext ------------------------------------------------------------------

MySqlParser::ShutdownStatementContext::ShutdownStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ShutdownStatementContext::SHUTDOWN() {
  return getToken(MySqlParser::SHUTDOWN, 0);
}


size_t MySqlParser::ShutdownStatementContext::getRuleIndex() const {
  return MySqlParser::RuleShutdownStatement;
}

void MySqlParser::ShutdownStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShutdownStatement(this);
}

void MySqlParser::ShutdownStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShutdownStatement(this);
}


std::any MySqlParser::ShutdownStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitShutdownStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ShutdownStatementContext* MySqlParser::shutdownStatement() {
  ShutdownStatementContext *_localctx = _tracker.createInstance<ShutdownStatementContext>(_ctx, getState());
  enterRule(_localctx, 510, MySqlParser::RuleShutdownStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5999);
    match(MySqlParser::SHUTDOWN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableIndexesContext ------------------------------------------------------------------

MySqlParser::TableIndexesContext::TableIndexesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::TableNameContext* MySqlParser::TableIndexesContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::TableIndexesContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::UidListContext* MySqlParser::TableIndexesContext::uidList() {
  return getRuleContext<MySqlParser::UidListContext>(0);
}

tree::TerminalNode* MySqlParser::TableIndexesContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::TableIndexesContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::TableIndexesContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}


size_t MySqlParser::TableIndexesContext::getRuleIndex() const {
  return MySqlParser::RuleTableIndexes;
}

void MySqlParser::TableIndexesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableIndexes(this);
}

void MySqlParser::TableIndexesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableIndexes(this);
}


std::any MySqlParser::TableIndexesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableIndexes(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TableIndexesContext* MySqlParser::tableIndexes() {
  TableIndexesContext *_localctx = _tracker.createInstance<TableIndexesContext>(_ctx, getState());
  enterRule(_localctx, 512, MySqlParser::RuleTableIndexes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6001);
    tableName();
    setState(6009);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::INDEX

    || _la == MySqlParser::KEY || _la == MySqlParser::LR_BRACKET) {
      setState(6003);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::INDEX

      || _la == MySqlParser::KEY) {
        setState(6002);
        antlrcpp::downCast<TableIndexesContext *>(_localctx)->indexFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::INDEX

        || _la == MySqlParser::KEY)) {
          antlrcpp::downCast<TableIndexesContext *>(_localctx)->indexFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(6005);
      match(MySqlParser::LR_BRACKET);
      setState(6006);
      uidList();
      setState(6007);
      match(MySqlParser::RR_BRACKET);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushOptionContext ------------------------------------------------------------------

MySqlParser::FlushOptionContext::FlushOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::FlushOptionContext::getRuleIndex() const {
  return MySqlParser::RuleFlushOption;
}

void MySqlParser::FlushOptionContext::copyFrom(FlushOptionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- TableFlushOptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TableFlushOptionContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

tree::TerminalNode* MySqlParser::TableFlushOptionContext::TABLES() {
  return getToken(MySqlParser::TABLES, 0);
}

MySqlParser::TablesContext* MySqlParser::TableFlushOptionContext::tables() {
  return getRuleContext<MySqlParser::TablesContext>(0);
}

MySqlParser::FlushTableOptionContext* MySqlParser::TableFlushOptionContext::flushTableOption() {
  return getRuleContext<MySqlParser::FlushTableOptionContext>(0);
}

MySqlParser::TableFlushOptionContext::TableFlushOptionContext(FlushOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TableFlushOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableFlushOption(this);
}
void MySqlParser::TableFlushOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableFlushOption(this);
}

std::any MySqlParser::TableFlushOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableFlushOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ChannelFlushOptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ChannelFlushOptionContext::RELAY() {
  return getToken(MySqlParser::RELAY, 0);
}

tree::TerminalNode* MySqlParser::ChannelFlushOptionContext::LOGS() {
  return getToken(MySqlParser::LOGS, 0);
}

MySqlParser::ChannelOptionContext* MySqlParser::ChannelFlushOptionContext::channelOption() {
  return getRuleContext<MySqlParser::ChannelOptionContext>(0);
}

MySqlParser::ChannelFlushOptionContext::ChannelFlushOptionContext(FlushOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::ChannelFlushOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChannelFlushOption(this);
}
void MySqlParser::ChannelFlushOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChannelFlushOption(this);
}

std::any MySqlParser::ChannelFlushOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitChannelFlushOption(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleFlushOptionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::DES_KEY_FILE() {
  return getToken(MySqlParser::DES_KEY_FILE, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::HOSTS() {
  return getToken(MySqlParser::HOSTS, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::LOGS() {
  return getToken(MySqlParser::LOGS, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::OPTIMIZER_COSTS() {
  return getToken(MySqlParser::OPTIMIZER_COSTS, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::PRIVILEGES() {
  return getToken(MySqlParser::PRIVILEGES, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::QUERY() {
  return getToken(MySqlParser::QUERY, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::CACHE() {
  return getToken(MySqlParser::CACHE, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::STATUS() {
  return getToken(MySqlParser::STATUS, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::USER_RESOURCES() {
  return getToken(MySqlParser::USER_RESOURCES, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::TABLES() {
  return getToken(MySqlParser::TABLES, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::READ() {
  return getToken(MySqlParser::READ, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::LOCK() {
  return getToken(MySqlParser::LOCK, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::BINARY() {
  return getToken(MySqlParser::BINARY, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::ENGINE() {
  return getToken(MySqlParser::ENGINE, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::ERROR() {
  return getToken(MySqlParser::ERROR, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::GENERAL() {
  return getToken(MySqlParser::GENERAL, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::RELAY() {
  return getToken(MySqlParser::RELAY, 0);
}

tree::TerminalNode* MySqlParser::SimpleFlushOptionContext::SLOW() {
  return getToken(MySqlParser::SLOW, 0);
}

MySqlParser::SimpleFlushOptionContext::SimpleFlushOptionContext(FlushOptionContext *ctx) { copyFrom(ctx); }

void MySqlParser::SimpleFlushOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleFlushOption(this);
}
void MySqlParser::SimpleFlushOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleFlushOption(this);
}

std::any MySqlParser::SimpleFlushOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSimpleFlushOption(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::FlushOptionContext* MySqlParser::flushOption() {
  FlushOptionContext *_localctx = _tracker.createInstance<FlushOptionContext>(_ctx, getState());
  enterRule(_localctx, 514, MySqlParser::RuleFlushOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6043);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 880, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::SimpleFlushOptionContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(6029);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::DES_KEY_FILE: {
          setState(6011);
          match(MySqlParser::DES_KEY_FILE);
          break;
        }

        case MySqlParser::HOSTS: {
          setState(6012);
          match(MySqlParser::HOSTS);
          break;
        }

        case MySqlParser::BINARY:
        case MySqlParser::ENGINE:
        case MySqlParser::ERROR:
        case MySqlParser::GENERAL:
        case MySqlParser::LOGS:
        case MySqlParser::RELAY:
        case MySqlParser::SLOW: {
          setState(6014);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::BINARY || ((((_la - 409) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 409)) & 536870917) != 0) || _la == MySqlParser::RELAY

          || _la == MySqlParser::SLOW) {
            setState(6013);
            _la = _input->LA(1);
            if (!(_la == MySqlParser::BINARY || ((((_la - 409) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 409)) & 536870917) != 0) || _la == MySqlParser::RELAY

            || _la == MySqlParser::SLOW)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
          }
          setState(6016);
          match(MySqlParser::LOGS);
          break;
        }

        case MySqlParser::OPTIMIZER_COSTS: {
          setState(6017);
          match(MySqlParser::OPTIMIZER_COSTS);
          break;
        }

        case MySqlParser::PRIVILEGES: {
          setState(6018);
          match(MySqlParser::PRIVILEGES);
          break;
        }

        case MySqlParser::QUERY: {
          setState(6019);
          match(MySqlParser::QUERY);
          setState(6020);
          match(MySqlParser::CACHE);
          break;
        }

        case MySqlParser::STATUS: {
          setState(6021);
          match(MySqlParser::STATUS);
          break;
        }

        case MySqlParser::USER_RESOURCES: {
          setState(6022);
          match(MySqlParser::USER_RESOURCES);
          break;
        }

        case MySqlParser::TABLES: {
          setState(6023);
          match(MySqlParser::TABLES);
          setState(6027);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 875, _ctx)) {
          case 1: {
            setState(6024);
            match(MySqlParser::WITH);
            setState(6025);
            match(MySqlParser::READ);
            setState(6026);
            match(MySqlParser::LOCK);
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::ChannelFlushOptionContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(6031);
      match(MySqlParser::RELAY);
      setState(6032);
      match(MySqlParser::LOGS);
      setState(6034);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::FOR) {
        setState(6033);
        channelOption();
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::TableFlushOptionContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(6036);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::TABLE || _la == MySqlParser::TABLES)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6038);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 878, _ctx)) {
      case 1: {
        setState(6037);
        tables();
        break;
      }

      default:
        break;
      }
      setState(6041);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 879, _ctx)) {
      case 1: {
        setState(6040);
        flushTableOption();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushTableOptionContext ------------------------------------------------------------------

MySqlParser::FlushTableOptionContext::FlushTableOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::FlushTableOptionContext::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

tree::TerminalNode* MySqlParser::FlushTableOptionContext::READ() {
  return getToken(MySqlParser::READ, 0);
}

tree::TerminalNode* MySqlParser::FlushTableOptionContext::LOCK() {
  return getToken(MySqlParser::LOCK, 0);
}

tree::TerminalNode* MySqlParser::FlushTableOptionContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

tree::TerminalNode* MySqlParser::FlushTableOptionContext::EXPORT() {
  return getToken(MySqlParser::EXPORT, 0);
}


size_t MySqlParser::FlushTableOptionContext::getRuleIndex() const {
  return MySqlParser::RuleFlushTableOption;
}

void MySqlParser::FlushTableOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlushTableOption(this);
}

void MySqlParser::FlushTableOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlushTableOption(this);
}


std::any MySqlParser::FlushTableOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFlushTableOption(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FlushTableOptionContext* MySqlParser::flushTableOption() {
  FlushTableOptionContext *_localctx = _tracker.createInstance<FlushTableOptionContext>(_ctx, getState());
  enterRule(_localctx, 516, MySqlParser::RuleFlushTableOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6050);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::WITH: {
        enterOuterAlt(_localctx, 1);
        setState(6045);
        match(MySqlParser::WITH);
        setState(6046);
        match(MySqlParser::READ);
        setState(6047);
        match(MySqlParser::LOCK);
        break;
      }

      case MySqlParser::FOR: {
        enterOuterAlt(_localctx, 2);
        setState(6048);
        match(MySqlParser::FOR);
        setState(6049);
        match(MySqlParser::EXPORT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadedTableIndexesContext ------------------------------------------------------------------

MySqlParser::LoadedTableIndexesContext::LoadedTableIndexesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::TableNameContext* MySqlParser::LoadedTableIndexesContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::LoadedTableIndexesContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadedTableIndexesContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::LoadedTableIndexesContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> MySqlParser::LoadedTableIndexesContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::LoadedTableIndexesContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

tree::TerminalNode* MySqlParser::LoadedTableIndexesContext::IGNORE() {
  return getToken(MySqlParser::IGNORE, 0);
}

tree::TerminalNode* MySqlParser::LoadedTableIndexesContext::LEAVES() {
  return getToken(MySqlParser::LEAVES, 0);
}

std::vector<MySqlParser::UidListContext *> MySqlParser::LoadedTableIndexesContext::uidList() {
  return getRuleContexts<MySqlParser::UidListContext>();
}

MySqlParser::UidListContext* MySqlParser::LoadedTableIndexesContext::uidList(size_t i) {
  return getRuleContext<MySqlParser::UidListContext>(i);
}

tree::TerminalNode* MySqlParser::LoadedTableIndexesContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

tree::TerminalNode* MySqlParser::LoadedTableIndexesContext::INDEX() {
  return getToken(MySqlParser::INDEX, 0);
}

tree::TerminalNode* MySqlParser::LoadedTableIndexesContext::KEY() {
  return getToken(MySqlParser::KEY, 0);
}


size_t MySqlParser::LoadedTableIndexesContext::getRuleIndex() const {
  return MySqlParser::RuleLoadedTableIndexes;
}

void MySqlParser::LoadedTableIndexesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadedTableIndexes(this);
}

void MySqlParser::LoadedTableIndexesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadedTableIndexes(this);
}


std::any MySqlParser::LoadedTableIndexesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLoadedTableIndexes(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LoadedTableIndexesContext* MySqlParser::loadedTableIndexes() {
  LoadedTableIndexesContext *_localctx = _tracker.createInstance<LoadedTableIndexesContext>(_ctx, getState());
  enterRule(_localctx, 518, MySqlParser::RuleLoadedTableIndexes);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6052);
    tableName();
    setState(6060);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::PARTITION) {
      setState(6053);
      match(MySqlParser::PARTITION);
      setState(6054);
      match(MySqlParser::LR_BRACKET);
      setState(6057);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::ATTRIBUTE:
        case MySqlParser::BUCKETS:
        case MySqlParser::CONDITION:
        case MySqlParser::CURRENT:
        case MySqlParser::CURRENT_USER:
        case MySqlParser::DATABASE:
        case MySqlParser::DEFAULT:
        case MySqlParser::DIAGNOSTICS:
        case MySqlParser::EMPTY:
        case MySqlParser::ENFORCED:
        case MySqlParser::EXCEPT:
        case MySqlParser::GROUP:
        case MySqlParser::IF:
        case MySqlParser::IGNORED:
        case MySqlParser::INSERT:
        case MySqlParser::LATERAL:
        case MySqlParser::LEFT:
        case MySqlParser::NUMBER:
        case MySqlParser::OPTIONAL:
        case MySqlParser::ORDER:
        case MySqlParser::PRIMARY:
        case MySqlParser::REPLACE:
        case MySqlParser::RIGHT:
        case MySqlParser::SCHEMA:
        case MySqlParser::SKIP_QUERY_REWRITE:
        case MySqlParser::STACKED:
        case MySqlParser::DATE:
        case MySqlParser::TIME:
        case MySqlParser::TIMESTAMP:
        case MySqlParser::DATETIME:
        case MySqlParser::YEAR:
        case MySqlParser::BINARY:
        case MySqlParser::TEXT:
        case MySqlParser::ENUM:
        case MySqlParser::SERIAL:
        case MySqlParser::JSON_ARRAY:
        case MySqlParser::JSON_ARRAYAGG:
        case MySqlParser::JSON_ARRAY_APPEND:
        case MySqlParser::JSON_ARRAY_INSERT:
        case MySqlParser::JSON_CONTAINS:
        case MySqlParser::JSON_CONTAINS_PATH:
        case MySqlParser::JSON_DEPTH:
        case MySqlParser::JSON_EXTRACT:
        case MySqlParser::JSON_INSERT:
        case MySqlParser::JSON_KEYS:
        case MySqlParser::JSON_LENGTH:
        case MySqlParser::JSON_MERGE:
        case MySqlParser::JSON_MERGE_PATCH:
        case MySqlParser::JSON_MERGE_PRESERVE:
        case MySqlParser::JSON_OBJECT:
        case MySqlParser::JSON_OBJECTAGG:
        case MySqlParser::JSON_OVERLAPS:
        case MySqlParser::JSON_PRETTY:
        case MySqlParser::JSON_QUOTE:
        case MySqlParser::JSON_REMOVE:
        case MySqlParser::JSON_REPLACE:
        case MySqlParser::JSON_SCHEMA_VALID:
        case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
        case MySqlParser::JSON_SEARCH:
        case MySqlParser::JSON_SET:
        case MySqlParser::JSON_STORAGE_FREE:
        case MySqlParser::JSON_STORAGE_SIZE:
        case MySqlParser::JSON_TABLE:
        case MySqlParser::JSON_TYPE:
        case MySqlParser::JSON_UNQUOTE:
        case MySqlParser::JSON_VALID:
        case MySqlParser::JSON_VALUE:
        case MySqlParser::NESTED:
        case MySqlParser::ORDINALITY:
        case MySqlParser::PATH:
        case MySqlParser::AVG:
        case MySqlParser::BIT_AND:
        case MySqlParser::BIT_OR:
        case MySqlParser::BIT_XOR:
        case MySqlParser::COUNT:
        case MySqlParser::CUME_DIST:
        case MySqlParser::DENSE_RANK:
        case MySqlParser::FIRST_VALUE:
        case MySqlParser::GROUP_CONCAT:
        case MySqlParser::LAG:
        case MySqlParser::LAST_VALUE:
        case MySqlParser::LEAD:
        case MySqlParser::MAX:
        case MySqlParser::MIN:
        case MySqlParser::NTILE:
        case MySqlParser::NTH_VALUE:
        case MySqlParser::PERCENT_RANK:
        case MySqlParser::RANK:
        case MySqlParser::ROW_NUMBER:
        case MySqlParser::STD:
        case MySqlParser::STDDEV:
        case MySqlParser::STDDEV_POP:
        case MySqlParser::STDDEV_SAMP:
        case MySqlParser::SUM:
        case MySqlParser::VAR_POP:
        case MySqlParser::VAR_SAMP:
        case MySqlParser::VARIANCE:
        case MySqlParser::CURRENT_DATE:
        case MySqlParser::CURRENT_TIME:
        case MySqlParser::CURRENT_TIMESTAMP:
        case MySqlParser::LOCALTIME:
        case MySqlParser::CURDATE:
        case MySqlParser::CURTIME:
        case MySqlParser::DATE_ADD:
        case MySqlParser::DATE_SUB:
        case MySqlParser::LOCALTIMESTAMP:
        case MySqlParser::NOW:
        case MySqlParser::POSITION:
        case MySqlParser::SUBSTR:
        case MySqlParser::SUBSTRING:
        case MySqlParser::SYSDATE:
        case MySqlParser::TRIM:
        case MySqlParser::UTC_DATE:
        case MySqlParser::UTC_TIME:
        case MySqlParser::UTC_TIMESTAMP:
        case MySqlParser::ACCOUNT:
        case MySqlParser::ACTION:
        case MySqlParser::AFTER:
        case MySqlParser::AGGREGATE:
        case MySqlParser::ALGORITHM:
        case MySqlParser::ANY:
        case MySqlParser::AT:
        case MySqlParser::AUTHORS:
        case MySqlParser::AUTOCOMMIT:
        case MySqlParser::AUTOEXTEND_SIZE:
        case MySqlParser::AUTO_INCREMENT:
        case MySqlParser::AVG_ROW_LENGTH:
        case MySqlParser::BEGIN:
        case MySqlParser::BINLOG:
        case MySqlParser::BIT:
        case MySqlParser::BLOCK:
        case MySqlParser::BOOL:
        case MySqlParser::BOOLEAN:
        case MySqlParser::BTREE:
        case MySqlParser::CACHE:
        case MySqlParser::CASCADED:
        case MySqlParser::CHAIN:
        case MySqlParser::CHANGED:
        case MySqlParser::CHANNEL:
        case MySqlParser::CHECKSUM:
        case MySqlParser::PAGE_CHECKSUM:
        case MySqlParser::CIPHER:
        case MySqlParser::CLASS_ORIGIN:
        case MySqlParser::CLIENT:
        case MySqlParser::CLOSE:
        case MySqlParser::CLUSTERING:
        case MySqlParser::COALESCE:
        case MySqlParser::CODE:
        case MySqlParser::COLUMNS:
        case MySqlParser::COLUMN_FORMAT:
        case MySqlParser::COLUMN_NAME:
        case MySqlParser::COMMENT:
        case MySqlParser::COMMIT:
        case MySqlParser::COMPACT:
        case MySqlParser::COMPLETION:
        case MySqlParser::COMPRESSED:
        case MySqlParser::COMPRESSION:
        case MySqlParser::CONCURRENT:
        case MySqlParser::CONNECT:
        case MySqlParser::CONNECTION:
        case MySqlParser::CONSISTENT:
        case MySqlParser::CONSTRAINT_CATALOG:
        case MySqlParser::CONSTRAINT_SCHEMA:
        case MySqlParser::CONSTRAINT_NAME:
        case MySqlParser::CONTAINS:
        case MySqlParser::CONTEXT:
        case MySqlParser::CONTRIBUTORS:
        case MySqlParser::COPY:
        case MySqlParser::CPU:
        case MySqlParser::CURSOR_NAME:
        case MySqlParser::DATA:
        case MySqlParser::DATAFILE:
        case MySqlParser::DEALLOCATE:
        case MySqlParser::DEFAULT_AUTH:
        case MySqlParser::DEFINER:
        case MySqlParser::DELAY_KEY_WRITE:
        case MySqlParser::DES_KEY_FILE:
        case MySqlParser::DIRECTORY:
        case MySqlParser::DISABLE:
        case MySqlParser::DISCARD:
        case MySqlParser::DISK:
        case MySqlParser::DO:
        case MySqlParser::DUMPFILE:
        case MySqlParser::DUPLICATE:
        case MySqlParser::DYNAMIC:
        case MySqlParser::ENABLE:
        case MySqlParser::ENCRYPTION:
        case MySqlParser::END:
        case MySqlParser::ENDS:
        case MySqlParser::ENGINE:
        case MySqlParser::ENGINES:
        case MySqlParser::ERROR:
        case MySqlParser::ERRORS:
        case MySqlParser::ESCAPE:
        case MySqlParser::EVEN:
        case MySqlParser::EVENT:
        case MySqlParser::EVENTS:
        case MySqlParser::EVERY:
        case MySqlParser::EXCHANGE:
        case MySqlParser::EXCLUSIVE:
        case MySqlParser::EXPIRE:
        case MySqlParser::EXPORT:
        case MySqlParser::EXTENDED:
        case MySqlParser::EXTENT_SIZE:
        case MySqlParser::FAILED_LOGIN_ATTEMPTS:
        case MySqlParser::FAST:
        case MySqlParser::FAULTS:
        case MySqlParser::FIELDS:
        case MySqlParser::FILE_BLOCK_SIZE:
        case MySqlParser::FILTER:
        case MySqlParser::FIRST:
        case MySqlParser::FIXED:
        case MySqlParser::FLUSH:
        case MySqlParser::FOLLOWS:
        case MySqlParser::FOUND:
        case MySqlParser::FULL:
        case MySqlParser::FUNCTION:
        case MySqlParser::GENERAL:
        case MySqlParser::GLOBAL:
        case MySqlParser::GRANTS:
        case MySqlParser::GROUP_REPLICATION:
        case MySqlParser::HANDLER:
        case MySqlParser::HASH:
        case MySqlParser::HELP:
        case MySqlParser::HISTORY:
        case MySqlParser::HOST:
        case MySqlParser::HOSTS:
        case MySqlParser::IDENTIFIED:
        case MySqlParser::IGNORE_SERVER_IDS:
        case MySqlParser::IMPORT:
        case MySqlParser::INDEXES:
        case MySqlParser::INITIAL_SIZE:
        case MySqlParser::INPLACE:
        case MySqlParser::INSERT_METHOD:
        case MySqlParser::INSTALL:
        case MySqlParser::INSTANCE:
        case MySqlParser::INSTANT:
        case MySqlParser::INVISIBLE:
        case MySqlParser::INVOKER:
        case MySqlParser::IO:
        case MySqlParser::IO_THREAD:
        case MySqlParser::IPC:
        case MySqlParser::ISOLATION:
        case MySqlParser::ISSUER:
        case MySqlParser::JSON:
        case MySqlParser::KEY_BLOCK_SIZE:
        case MySqlParser::LANGUAGE:
        case MySqlParser::LAST:
        case MySqlParser::LEAVES:
        case MySqlParser::LESS:
        case MySqlParser::LEVEL:
        case MySqlParser::LIST:
        case MySqlParser::LOCAL:
        case MySqlParser::LOGFILE:
        case MySqlParser::LOGS:
        case MySqlParser::MASTER:
        case MySqlParser::MASTER_AUTO_POSITION:
        case MySqlParser::MASTER_CONNECT_RETRY:
        case MySqlParser::MASTER_DELAY:
        case MySqlParser::MASTER_HEARTBEAT_PERIOD:
        case MySqlParser::MASTER_HOST:
        case MySqlParser::MASTER_LOG_FILE:
        case MySqlParser::MASTER_LOG_POS:
        case MySqlParser::MASTER_PASSWORD:
        case MySqlParser::MASTER_PORT:
        case MySqlParser::MASTER_RETRY_COUNT:
        case MySqlParser::MASTER_SSL:
        case MySqlParser::MASTER_SSL_CA:
        case MySqlParser::MASTER_SSL_CAPATH:
        case MySqlParser::MASTER_SSL_CERT:
        case MySqlParser::MASTER_SSL_CIPHER:
        case MySqlParser::MASTER_SSL_CRL:
        case MySqlParser::MASTER_SSL_CRLPATH:
        case MySqlParser::MASTER_SSL_KEY:
        case MySqlParser::MASTER_TLS_VERSION:
        case MySqlParser::MASTER_USER:
        case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
        case MySqlParser::MAX_QUERIES_PER_HOUR:
        case MySqlParser::MAX_ROWS:
        case MySqlParser::MAX_SIZE:
        case MySqlParser::MAX_UPDATES_PER_HOUR:
        case MySqlParser::MAX_USER_CONNECTIONS:
        case MySqlParser::MEDIUM:
        case MySqlParser::MEMBER:
        case MySqlParser::MERGE:
        case MySqlParser::MESSAGE_TEXT:
        case MySqlParser::MID:
        case MySqlParser::MIGRATE:
        case MySqlParser::MIN_ROWS:
        case MySqlParser::MODE:
        case MySqlParser::MODIFY:
        case MySqlParser::MUTEX:
        case MySqlParser::MYSQL:
        case MySqlParser::MYSQL_ERRNO:
        case MySqlParser::NAME:
        case MySqlParser::NAMES:
        case MySqlParser::NCHAR:
        case MySqlParser::NEVER:
        case MySqlParser::NEXT:
        case MySqlParser::NO:
        case MySqlParser::NOCOPY:
        case MySqlParser::NOWAIT:
        case MySqlParser::NODEGROUP:
        case MySqlParser::NONE:
        case MySqlParser::ODBC:
        case MySqlParser::OFFLINE:
        case MySqlParser::OFFSET:
        case MySqlParser::OF:
        case MySqlParser::OJ:
        case MySqlParser::OLD_PASSWORD:
        case MySqlParser::ONE:
        case MySqlParser::ONLINE:
        case MySqlParser::ONLY:
        case MySqlParser::OPEN:
        case MySqlParser::OPTIMIZER_COSTS:
        case MySqlParser::OPTIONS:
        case MySqlParser::OWNER:
        case MySqlParser::PACK_KEYS:
        case MySqlParser::PAGE:
        case MySqlParser::PARSER:
        case MySqlParser::PARTIAL:
        case MySqlParser::PARTITIONING:
        case MySqlParser::PARTITIONS:
        case MySqlParser::PASSWORD:
        case MySqlParser::PASSWORD_LOCK_TIME:
        case MySqlParser::PHASE:
        case MySqlParser::PLUGIN:
        case MySqlParser::PLUGIN_DIR:
        case MySqlParser::PLUGINS:
        case MySqlParser::PORT:
        case MySqlParser::PRECEDES:
        case MySqlParser::PREPARE:
        case MySqlParser::PRESERVE:
        case MySqlParser::PREV:
        case MySqlParser::PROCESSLIST:
        case MySqlParser::PROFILE:
        case MySqlParser::PROFILES:
        case MySqlParser::PROXY:
        case MySqlParser::QUERY:
        case MySqlParser::QUICK:
        case MySqlParser::REBUILD:
        case MySqlParser::RECOVER:
        case MySqlParser::RECURSIVE:
        case MySqlParser::REDO_BUFFER_SIZE:
        case MySqlParser::REDUNDANT:
        case MySqlParser::RELAY:
        case MySqlParser::RELAY_LOG_FILE:
        case MySqlParser::RELAY_LOG_POS:
        case MySqlParser::RELAYLOG:
        case MySqlParser::REMOVE:
        case MySqlParser::REORGANIZE:
        case MySqlParser::REPAIR:
        case MySqlParser::REPLICATE_DO_DB:
        case MySqlParser::REPLICATE_DO_TABLE:
        case MySqlParser::REPLICATE_IGNORE_DB:
        case MySqlParser::REPLICATE_IGNORE_TABLE:
        case MySqlParser::REPLICATE_REWRITE_DB:
        case MySqlParser::REPLICATE_WILD_DO_TABLE:
        case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
        case MySqlParser::REPLICATION:
        case MySqlParser::RESET:
        case MySqlParser::RESUME:
        case MySqlParser::RETURNED_SQLSTATE:
        case MySqlParser::RETURNS:
        case MySqlParser::REUSE:
        case MySqlParser::ROLE:
        case MySqlParser::ROLLBACK:
        case MySqlParser::ROLLUP:
        case MySqlParser::ROTATE:
        case MySqlParser::ROW:
        case MySqlParser::ROWS:
        case MySqlParser::ROW_FORMAT:
        case MySqlParser::RTREE:
        case MySqlParser::SAVEPOINT:
        case MySqlParser::SCHEDULE:
        case MySqlParser::SECURITY:
        case MySqlParser::SERVER:
        case MySqlParser::SESSION:
        case MySqlParser::SHARE:
        case MySqlParser::SHARED:
        case MySqlParser::SIGNED:
        case MySqlParser::SIMPLE:
        case MySqlParser::SLAVE:
        case MySqlParser::SLOW:
        case MySqlParser::SNAPSHOT:
        case MySqlParser::SOCKET:
        case MySqlParser::SOME:
        case MySqlParser::SONAME:
        case MySqlParser::SOUNDS:
        case MySqlParser::SOURCE:
        case MySqlParser::SQL_AFTER_GTIDS:
        case MySqlParser::SQL_AFTER_MTS_GAPS:
        case MySqlParser::SQL_BEFORE_GTIDS:
        case MySqlParser::SQL_BUFFER_RESULT:
        case MySqlParser::SQL_CACHE:
        case MySqlParser::SQL_NO_CACHE:
        case MySqlParser::SQL_THREAD:
        case MySqlParser::START:
        case MySqlParser::STARTS:
        case MySqlParser::STATS_AUTO_RECALC:
        case MySqlParser::STATS_PERSISTENT:
        case MySqlParser::STATS_SAMPLE_PAGES:
        case MySqlParser::STATUS:
        case MySqlParser::STOP:
        case MySqlParser::STORAGE:
        case MySqlParser::STRING:
        case MySqlParser::SUBCLASS_ORIGIN:
        case MySqlParser::SUBJECT:
        case MySqlParser::SUBPARTITION:
        case MySqlParser::SUBPARTITIONS:
        case MySqlParser::SUSPEND:
        case MySqlParser::SWAPS:
        case MySqlParser::SWITCHES:
        case MySqlParser::TABLE_NAME:
        case MySqlParser::TABLESPACE:
        case MySqlParser::TABLE_TYPE:
        case MySqlParser::TEMPORARY:
        case MySqlParser::TEMPTABLE:
        case MySqlParser::THAN:
        case MySqlParser::TRADITIONAL:
        case MySqlParser::TRANSACTION:
        case MySqlParser::TRANSACTIONAL:
        case MySqlParser::TRIGGERS:
        case MySqlParser::TRUNCATE:
        case MySqlParser::UNBOUNDED:
        case MySqlParser::UNDEFINED:
        case MySqlParser::UNDOFILE:
        case MySqlParser::UNDO_BUFFER_SIZE:
        case MySqlParser::UNINSTALL:
        case MySqlParser::UNKNOWN:
        case MySqlParser::UNTIL:
        case MySqlParser::UPGRADE:
        case MySqlParser::USER:
        case MySqlParser::USE_FRM:
        case MySqlParser::USER_RESOURCES:
        case MySqlParser::VALIDATION:
        case MySqlParser::VALUE:
        case MySqlParser::VARIABLES:
        case MySqlParser::VIEW:
        case MySqlParser::VIRTUAL:
        case MySqlParser::VISIBLE:
        case MySqlParser::WAIT:
        case MySqlParser::WARNINGS:
        case MySqlParser::WITHOUT:
        case MySqlParser::WORK:
        case MySqlParser::WRAPPER:
        case MySqlParser::X509:
        case MySqlParser::XA:
        case MySqlParser::XML:
        case MySqlParser::EUR:
        case MySqlParser::USA:
        case MySqlParser::JIS:
        case MySqlParser::ISO:
        case MySqlParser::INTERNAL:
        case MySqlParser::QUARTER:
        case MySqlParser::MONTH:
        case MySqlParser::DAY:
        case MySqlParser::HOUR:
        case MySqlParser::MINUTE:
        case MySqlParser::WEEK:
        case MySqlParser::SECOND:
        case MySqlParser::MICROSECOND:
        case MySqlParser::ADMIN:
        case MySqlParser::AUDIT_ABORT_EXEMPT:
        case MySqlParser::AUDIT_ADMIN:
        case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
        case MySqlParser::BACKUP_ADMIN:
        case MySqlParser::BINLOG_ADMIN:
        case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
        case MySqlParser::CLONE_ADMIN:
        case MySqlParser::CONNECTION_ADMIN:
        case MySqlParser::ENCRYPTION_KEY_ADMIN:
        case MySqlParser::EXECUTE:
        case MySqlParser::FILE:
        case MySqlParser::FIREWALL_ADMIN:
        case MySqlParser::FIREWALL_EXEMPT:
        case MySqlParser::FIREWALL_USER:
        case MySqlParser::GROUP_REPLICATION_ADMIN:
        case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
        case MySqlParser::INVOKE:
        case MySqlParser::LAMBDA:
        case MySqlParser::NDB_STORED_USER:
        case MySqlParser::PASSWORDLESS_USER_ADMIN:
        case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
        case MySqlParser::PRIVILEGES:
        case MySqlParser::PROCESS:
        case MySqlParser::RELOAD:
        case MySqlParser::REPLICATION_APPLIER:
        case MySqlParser::REPLICATION_SLAVE_ADMIN:
        case MySqlParser::RESOURCE_GROUP_ADMIN:
        case MySqlParser::RESOURCE_GROUP_USER:
        case MySqlParser::ROLE_ADMIN:
        case MySqlParser::ROUTINE:
        case MySqlParser::S3:
        case MySqlParser::SESSION_VARIABLES_ADMIN:
        case MySqlParser::SET_USER_ID:
        case MySqlParser::SHOW_ROUTINE:
        case MySqlParser::SHUTDOWN:
        case MySqlParser::SUPER:
        case MySqlParser::SYSTEM_VARIABLES_ADMIN:
        case MySqlParser::TABLES:
        case MySqlParser::TABLE_ENCRYPTION_ADMIN:
        case MySqlParser::VERSION_TOKEN_ADMIN:
        case MySqlParser::XA_RECOVER_ADMIN:
        case MySqlParser::ARMSCII8:
        case MySqlParser::ASCII:
        case MySqlParser::BIG5:
        case MySqlParser::CP1250:
        case MySqlParser::CP1251:
        case MySqlParser::CP1256:
        case MySqlParser::CP1257:
        case MySqlParser::CP850:
        case MySqlParser::CP852:
        case MySqlParser::CP866:
        case MySqlParser::CP932:
        case MySqlParser::DEC8:
        case MySqlParser::EUCJPMS:
        case MySqlParser::EUCKR:
        case MySqlParser::GB18030:
        case MySqlParser::GB2312:
        case MySqlParser::GBK:
        case MySqlParser::GEOSTD8:
        case MySqlParser::GREEK:
        case MySqlParser::HEBREW:
        case MySqlParser::HP8:
        case MySqlParser::KEYBCS2:
        case MySqlParser::KOI8R:
        case MySqlParser::KOI8U:
        case MySqlParser::LATIN1:
        case MySqlParser::LATIN2:
        case MySqlParser::LATIN5:
        case MySqlParser::LATIN7:
        case MySqlParser::MACCE:
        case MySqlParser::MACROMAN:
        case MySqlParser::SJIS:
        case MySqlParser::SWE7:
        case MySqlParser::TIS620:
        case MySqlParser::UCS2:
        case MySqlParser::UJIS:
        case MySqlParser::UTF16:
        case MySqlParser::UTF16LE:
        case MySqlParser::UTF32:
        case MySqlParser::UTF8:
        case MySqlParser::UTF8MB3:
        case MySqlParser::UTF8MB4:
        case MySqlParser::ARCHIVE:
        case MySqlParser::BLACKHOLE:
        case MySqlParser::CSV:
        case MySqlParser::FEDERATED:
        case MySqlParser::INNODB:
        case MySqlParser::MEMORY:
        case MySqlParser::MRG_MYISAM:
        case MySqlParser::MYISAM:
        case MySqlParser::NDB:
        case MySqlParser::NDBCLUSTER:
        case MySqlParser::PERFORMANCE_SCHEMA:
        case MySqlParser::TOKUDB:
        case MySqlParser::REPEATABLE:
        case MySqlParser::COMMITTED:
        case MySqlParser::UNCOMMITTED:
        case MySqlParser::SERIALIZABLE:
        case MySqlParser::GEOMETRYCOLLECTION:
        case MySqlParser::LINESTRING:
        case MySqlParser::MULTILINESTRING:
        case MySqlParser::MULTIPOINT:
        case MySqlParser::MULTIPOLYGON:
        case MySqlParser::POINT:
        case MySqlParser::POLYGON:
        case MySqlParser::ABS:
        case MySqlParser::ACOS:
        case MySqlParser::ADDDATE:
        case MySqlParser::ADDTIME:
        case MySqlParser::AES_DECRYPT:
        case MySqlParser::AES_ENCRYPT:
        case MySqlParser::AREA:
        case MySqlParser::ASBINARY:
        case MySqlParser::ASIN:
        case MySqlParser::ASTEXT:
        case MySqlParser::ASWKB:
        case MySqlParser::ASWKT:
        case MySqlParser::ASYMMETRIC_DECRYPT:
        case MySqlParser::ASYMMETRIC_DERIVE:
        case MySqlParser::ASYMMETRIC_ENCRYPT:
        case MySqlParser::ASYMMETRIC_SIGN:
        case MySqlParser::ASYMMETRIC_VERIFY:
        case MySqlParser::ATAN:
        case MySqlParser::ATAN2:
        case MySqlParser::BENCHMARK:
        case MySqlParser::BIN:
        case MySqlParser::BIT_COUNT:
        case MySqlParser::BIT_LENGTH:
        case MySqlParser::BUFFER:
        case MySqlParser::CATALOG_NAME:
        case MySqlParser::CEIL:
        case MySqlParser::CEILING:
        case MySqlParser::CENTROID:
        case MySqlParser::CHARACTER_LENGTH:
        case MySqlParser::CHARSET:
        case MySqlParser::CHAR_LENGTH:
        case MySqlParser::COERCIBILITY:
        case MySqlParser::COLLATION:
        case MySqlParser::COMPRESS:
        case MySqlParser::CONCAT:
        case MySqlParser::CONCAT_WS:
        case MySqlParser::CONNECTION_ID:
        case MySqlParser::CONV:
        case MySqlParser::CONVERT_TZ:
        case MySqlParser::COS:
        case MySqlParser::COT:
        case MySqlParser::CRC32:
        case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
        case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
        case MySqlParser::CREATE_DH_PARAMETERS:
        case MySqlParser::CREATE_DIGEST:
        case MySqlParser::CROSSES:
        case MySqlParser::DATEDIFF:
        case MySqlParser::DATE_FORMAT:
        case MySqlParser::DAYNAME:
        case MySqlParser::DAYOFMONTH:
        case MySqlParser::DAYOFWEEK:
        case MySqlParser::DAYOFYEAR:
        case MySqlParser::DECODE:
        case MySqlParser::DEGREES:
        case MySqlParser::DES_DECRYPT:
        case MySqlParser::DES_ENCRYPT:
        case MySqlParser::DIMENSION:
        case MySqlParser::DISJOINT:
        case MySqlParser::ELT:
        case MySqlParser::ENCODE:
        case MySqlParser::ENCRYPT:
        case MySqlParser::ENDPOINT:
        case MySqlParser::ENGINE_ATTRIBUTE:
        case MySqlParser::ENVELOPE:
        case MySqlParser::EQUALS:
        case MySqlParser::EXP:
        case MySqlParser::EXPORT_SET:
        case MySqlParser::EXTERIORRING:
        case MySqlParser::EXTRACTVALUE:
        case MySqlParser::FIELD:
        case MySqlParser::FIND_IN_SET:
        case MySqlParser::FLOOR:
        case MySqlParser::FORMAT:
        case MySqlParser::FOUND_ROWS:
        case MySqlParser::FROM_BASE64:
        case MySqlParser::FROM_DAYS:
        case MySqlParser::FROM_UNIXTIME:
        case MySqlParser::GEOMCOLLFROMTEXT:
        case MySqlParser::GEOMCOLLFROMWKB:
        case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
        case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
        case MySqlParser::GEOMETRYFROMTEXT:
        case MySqlParser::GEOMETRYFROMWKB:
        case MySqlParser::GEOMETRYN:
        case MySqlParser::GEOMETRYTYPE:
        case MySqlParser::GEOMFROMTEXT:
        case MySqlParser::GEOMFROMWKB:
        case MySqlParser::GET_FORMAT:
        case MySqlParser::GET_LOCK:
        case MySqlParser::GLENGTH:
        case MySqlParser::GREATEST:
        case MySqlParser::GTID_SUBSET:
        case MySqlParser::GTID_SUBTRACT:
        case MySqlParser::HEX:
        case MySqlParser::IFNULL:
        case MySqlParser::INET6_ATON:
        case MySqlParser::INET6_NTOA:
        case MySqlParser::INET_ATON:
        case MySqlParser::INET_NTOA:
        case MySqlParser::INSTR:
        case MySqlParser::INTERIORRINGN:
        case MySqlParser::INTERSECTS:
        case MySqlParser::ISCLOSED:
        case MySqlParser::ISEMPTY:
        case MySqlParser::ISNULL:
        case MySqlParser::ISSIMPLE:
        case MySqlParser::IS_FREE_LOCK:
        case MySqlParser::IS_IPV4:
        case MySqlParser::IS_IPV4_COMPAT:
        case MySqlParser::IS_IPV4_MAPPED:
        case MySqlParser::IS_IPV6:
        case MySqlParser::IS_USED_LOCK:
        case MySqlParser::LAST_INSERT_ID:
        case MySqlParser::LCASE:
        case MySqlParser::LEAST:
        case MySqlParser::LENGTH:
        case MySqlParser::LINEFROMTEXT:
        case MySqlParser::LINEFROMWKB:
        case MySqlParser::LINESTRINGFROMTEXT:
        case MySqlParser::LINESTRINGFROMWKB:
        case MySqlParser::LN:
        case MySqlParser::LOAD_FILE:
        case MySqlParser::LOCATE:
        case MySqlParser::LOG:
        case MySqlParser::LOG10:
        case MySqlParser::LOG2:
        case MySqlParser::LOWER:
        case MySqlParser::LPAD:
        case MySqlParser::LTRIM:
        case MySqlParser::MAKEDATE:
        case MySqlParser::MAKETIME:
        case MySqlParser::MAKE_SET:
        case MySqlParser::MASTER_POS_WAIT:
        case MySqlParser::MBRCONTAINS:
        case MySqlParser::MBRDISJOINT:
        case MySqlParser::MBREQUAL:
        case MySqlParser::MBRINTERSECTS:
        case MySqlParser::MBROVERLAPS:
        case MySqlParser::MBRTOUCHES:
        case MySqlParser::MBRWITHIN:
        case MySqlParser::MD5:
        case MySqlParser::MLINEFROMTEXT:
        case MySqlParser::MLINEFROMWKB:
        case MySqlParser::MONTHNAME:
        case MySqlParser::MPOINTFROMTEXT:
        case MySqlParser::MPOINTFROMWKB:
        case MySqlParser::MPOLYFROMTEXT:
        case MySqlParser::MPOLYFROMWKB:
        case MySqlParser::MULTILINESTRINGFROMTEXT:
        case MySqlParser::MULTILINESTRINGFROMWKB:
        case MySqlParser::MULTIPOINTFROMTEXT:
        case MySqlParser::MULTIPOINTFROMWKB:
        case MySqlParser::MULTIPOLYGONFROMTEXT:
        case MySqlParser::MULTIPOLYGONFROMWKB:
        case MySqlParser::NAME_CONST:
        case MySqlParser::NULLIF:
        case MySqlParser::NUMGEOMETRIES:
        case MySqlParser::NUMINTERIORRINGS:
        case MySqlParser::NUMPOINTS:
        case MySqlParser::OCT:
        case MySqlParser::OCTET_LENGTH:
        case MySqlParser::ORD:
        case MySqlParser::OVERLAPS:
        case MySqlParser::PERIOD_ADD:
        case MySqlParser::PERIOD_DIFF:
        case MySqlParser::PI:
        case MySqlParser::POINTFROMTEXT:
        case MySqlParser::POINTFROMWKB:
        case MySqlParser::POINTN:
        case MySqlParser::POLYFROMTEXT:
        case MySqlParser::POLYFROMWKB:
        case MySqlParser::POLYGONFROMTEXT:
        case MySqlParser::POLYGONFROMWKB:
        case MySqlParser::POW:
        case MySqlParser::POWER:
        case MySqlParser::QUOTE:
        case MySqlParser::RADIANS:
        case MySqlParser::RAND:
        case MySqlParser::RANDOM_BYTES:
        case MySqlParser::RELEASE_LOCK:
        case MySqlParser::REVERSE:
        case MySqlParser::ROUND:
        case MySqlParser::ROW_COUNT:
        case MySqlParser::RPAD:
        case MySqlParser::RTRIM:
        case MySqlParser::SEC_TO_TIME:
        case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
        case MySqlParser::SESSION_USER:
        case MySqlParser::SHA:
        case MySqlParser::SHA1:
        case MySqlParser::SHA2:
        case MySqlParser::SCHEMA_NAME:
        case MySqlParser::SIGN:
        case MySqlParser::SIN:
        case MySqlParser::SLEEP:
        case MySqlParser::SOUNDEX:
        case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
        case MySqlParser::SQRT:
        case MySqlParser::SRID:
        case MySqlParser::STARTPOINT:
        case MySqlParser::STRCMP:
        case MySqlParser::STR_TO_DATE:
        case MySqlParser::ST_AREA:
        case MySqlParser::ST_ASBINARY:
        case MySqlParser::ST_ASTEXT:
        case MySqlParser::ST_ASWKB:
        case MySqlParser::ST_ASWKT:
        case MySqlParser::ST_BUFFER:
        case MySqlParser::ST_CENTROID:
        case MySqlParser::ST_CONTAINS:
        case MySqlParser::ST_CROSSES:
        case MySqlParser::ST_DIFFERENCE:
        case MySqlParser::ST_DIMENSION:
        case MySqlParser::ST_DISJOINT:
        case MySqlParser::ST_DISTANCE:
        case MySqlParser::ST_ENDPOINT:
        case MySqlParser::ST_ENVELOPE:
        case MySqlParser::ST_EQUALS:
        case MySqlParser::ST_EXTERIORRING:
        case MySqlParser::ST_GEOMCOLLFROMTEXT:
        case MySqlParser::ST_GEOMCOLLFROMTXT:
        case MySqlParser::ST_GEOMCOLLFROMWKB:
        case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
        case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
        case MySqlParser::ST_GEOMETRYFROMTEXT:
        case MySqlParser::ST_GEOMETRYFROMWKB:
        case MySqlParser::ST_GEOMETRYN:
        case MySqlParser::ST_GEOMETRYTYPE:
        case MySqlParser::ST_GEOMFROMTEXT:
        case MySqlParser::ST_GEOMFROMWKB:
        case MySqlParser::ST_INTERIORRINGN:
        case MySqlParser::ST_INTERSECTION:
        case MySqlParser::ST_INTERSECTS:
        case MySqlParser::ST_ISCLOSED:
        case MySqlParser::ST_ISEMPTY:
        case MySqlParser::ST_ISSIMPLE:
        case MySqlParser::ST_LINEFROMTEXT:
        case MySqlParser::ST_LINEFROMWKB:
        case MySqlParser::ST_LINESTRINGFROMTEXT:
        case MySqlParser::ST_LINESTRINGFROMWKB:
        case MySqlParser::ST_NUMGEOMETRIES:
        case MySqlParser::ST_NUMINTERIORRING:
        case MySqlParser::ST_NUMINTERIORRINGS:
        case MySqlParser::ST_NUMPOINTS:
        case MySqlParser::ST_OVERLAPS:
        case MySqlParser::ST_POINTFROMTEXT:
        case MySqlParser::ST_POINTFROMWKB:
        case MySqlParser::ST_POINTN:
        case MySqlParser::ST_POLYFROMTEXT:
        case MySqlParser::ST_POLYFROMWKB:
        case MySqlParser::ST_POLYGONFROMTEXT:
        case MySqlParser::ST_POLYGONFROMWKB:
        case MySqlParser::ST_SRID:
        case MySqlParser::ST_STARTPOINT:
        case MySqlParser::ST_SYMDIFFERENCE:
        case MySqlParser::ST_TOUCHES:
        case MySqlParser::ST_UNION:
        case MySqlParser::ST_WITHIN:
        case MySqlParser::ST_X:
        case MySqlParser::ST_Y:
        case MySqlParser::SUBDATE:
        case MySqlParser::SUBSTRING_INDEX:
        case MySqlParser::SUBTIME:
        case MySqlParser::SYSTEM_USER:
        case MySqlParser::TAN:
        case MySqlParser::TIMEDIFF:
        case MySqlParser::TIMESTAMPADD:
        case MySqlParser::TIMESTAMPDIFF:
        case MySqlParser::TIME_FORMAT:
        case MySqlParser::TIME_TO_SEC:
        case MySqlParser::TOUCHES:
        case MySqlParser::TO_BASE64:
        case MySqlParser::TO_DAYS:
        case MySqlParser::TO_SECONDS:
        case MySqlParser::TP_CONNECTION_ADMIN:
        case MySqlParser::UCASE:
        case MySqlParser::UNCOMPRESS:
        case MySqlParser::UNCOMPRESSED_LENGTH:
        case MySqlParser::UNHEX:
        case MySqlParser::UNIX_TIMESTAMP:
        case MySqlParser::UPDATEXML:
        case MySqlParser::UPPER:
        case MySqlParser::UUID:
        case MySqlParser::UUID_SHORT:
        case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
        case MySqlParser::VERSION:
        case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
        case MySqlParser::WEEKDAY:
        case MySqlParser::WEEKOFYEAR:
        case MySqlParser::WEIGHT_STRING:
        case MySqlParser::WITHIN:
        case MySqlParser::YEARWEEK:
        case MySqlParser::Y_FUNCTION:
        case MySqlParser::X_FUNCTION:
        case MySqlParser::MOD:
        case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
        case MySqlParser::STRING_LITERAL:
        case MySqlParser::ID: {
          setState(6055);
          antlrcpp::downCast<LoadedTableIndexesContext *>(_localctx)->partitionList = uidList();
          break;
        }

        case MySqlParser::ALL: {
          setState(6056);
          match(MySqlParser::ALL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(6059);
      match(MySqlParser::RR_BRACKET);
    }
    setState(6069);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 885, _ctx)) {
    case 1: {
      setState(6063);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::INDEX

      || _la == MySqlParser::KEY) {
        setState(6062);
        antlrcpp::downCast<LoadedTableIndexesContext *>(_localctx)->indexFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::INDEX

        || _la == MySqlParser::KEY)) {
          antlrcpp::downCast<LoadedTableIndexesContext *>(_localctx)->indexFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(6065);
      match(MySqlParser::LR_BRACKET);
      setState(6066);
      antlrcpp::downCast<LoadedTableIndexesContext *>(_localctx)->indexList = uidList();
      setState(6067);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
    setState(6073);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::IGNORE) {
      setState(6071);
      match(MySqlParser::IGNORE);
      setState(6072);
      match(MySqlParser::LEAVES);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleDescribeStatementContext ------------------------------------------------------------------

MySqlParser::SimpleDescribeStatementContext::SimpleDescribeStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::TableNameContext* MySqlParser::SimpleDescribeStatementContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

tree::TerminalNode* MySqlParser::SimpleDescribeStatementContext::EXPLAIN() {
  return getToken(MySqlParser::EXPLAIN, 0);
}

tree::TerminalNode* MySqlParser::SimpleDescribeStatementContext::DESCRIBE() {
  return getToken(MySqlParser::DESCRIBE, 0);
}

tree::TerminalNode* MySqlParser::SimpleDescribeStatementContext::DESC() {
  return getToken(MySqlParser::DESC, 0);
}

MySqlParser::UidContext* MySqlParser::SimpleDescribeStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::SimpleDescribeStatementContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}


size_t MySqlParser::SimpleDescribeStatementContext::getRuleIndex() const {
  return MySqlParser::RuleSimpleDescribeStatement;
}

void MySqlParser::SimpleDescribeStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleDescribeStatement(this);
}

void MySqlParser::SimpleDescribeStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleDescribeStatement(this);
}


std::any MySqlParser::SimpleDescribeStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSimpleDescribeStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SimpleDescribeStatementContext* MySqlParser::simpleDescribeStatement() {
  SimpleDescribeStatementContext *_localctx = _tracker.createInstance<SimpleDescribeStatementContext>(_ctx, getState());
  enterRule(_localctx, 520, MySqlParser::RuleSimpleDescribeStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6075);
    antlrcpp::downCast<SimpleDescribeStatementContext *>(_localctx)->command = _input->LT(1);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4611791571543654400) != 0))) {
      antlrcpp::downCast<SimpleDescribeStatementContext *>(_localctx)->command = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6076);
    tableName();
    setState(6079);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 887, _ctx)) {
    case 1: {
      setState(6077);
      antlrcpp::downCast<SimpleDescribeStatementContext *>(_localctx)->column = uid();
      break;
    }

    case 2: {
      setState(6078);
      antlrcpp::downCast<SimpleDescribeStatementContext *>(_localctx)->pattern = match(MySqlParser::STRING_LITERAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FullDescribeStatementContext ------------------------------------------------------------------

MySqlParser::FullDescribeStatementContext::FullDescribeStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::DescribeObjectClauseContext* MySqlParser::FullDescribeStatementContext::describeObjectClause() {
  return getRuleContext<MySqlParser::DescribeObjectClauseContext>(0);
}

tree::TerminalNode* MySqlParser::FullDescribeStatementContext::EXPLAIN() {
  return getToken(MySqlParser::EXPLAIN, 0);
}

tree::TerminalNode* MySqlParser::FullDescribeStatementContext::DESCRIBE() {
  return getToken(MySqlParser::DESCRIBE, 0);
}

tree::TerminalNode* MySqlParser::FullDescribeStatementContext::DESC() {
  return getToken(MySqlParser::DESC, 0);
}

tree::TerminalNode* MySqlParser::FullDescribeStatementContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::FullDescribeStatementContext::EXTENDED() {
  return getToken(MySqlParser::EXTENDED, 0);
}

tree::TerminalNode* MySqlParser::FullDescribeStatementContext::PARTITIONS() {
  return getToken(MySqlParser::PARTITIONS, 0);
}

tree::TerminalNode* MySqlParser::FullDescribeStatementContext::FORMAT() {
  return getToken(MySqlParser::FORMAT, 0);
}

tree::TerminalNode* MySqlParser::FullDescribeStatementContext::TRADITIONAL() {
  return getToken(MySqlParser::TRADITIONAL, 0);
}

tree::TerminalNode* MySqlParser::FullDescribeStatementContext::JSON() {
  return getToken(MySqlParser::JSON, 0);
}


size_t MySqlParser::FullDescribeStatementContext::getRuleIndex() const {
  return MySqlParser::RuleFullDescribeStatement;
}

void MySqlParser::FullDescribeStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFullDescribeStatement(this);
}

void MySqlParser::FullDescribeStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFullDescribeStatement(this);
}


std::any MySqlParser::FullDescribeStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFullDescribeStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FullDescribeStatementContext* MySqlParser::fullDescribeStatement() {
  FullDescribeStatementContext *_localctx = _tracker.createInstance<FullDescribeStatementContext>(_ctx, getState());
  enterRule(_localctx, 522, MySqlParser::RuleFullDescribeStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6081);
    antlrcpp::downCast<FullDescribeStatementContext *>(_localctx)->command = _input->LT(1);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4611791571543654400) != 0))) {
      antlrcpp::downCast<FullDescribeStatementContext *>(_localctx)->command = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6085);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::EXTENDED || _la == MySqlParser::PARTITIONS || _la == MySqlParser::FORMAT) {
      setState(6082);
      antlrcpp::downCast<FullDescribeStatementContext *>(_localctx)->formatType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::EXTENDED || _la == MySqlParser::PARTITIONS || _la == MySqlParser::FORMAT)) {
        antlrcpp::downCast<FullDescribeStatementContext *>(_localctx)->formatType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6083);
      match(MySqlParser::EQUAL_SYMBOL);
      setState(6084);
      antlrcpp::downCast<FullDescribeStatementContext *>(_localctx)->formatValue = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::JSON || _la == MySqlParser::TRADITIONAL)) {
        antlrcpp::downCast<FullDescribeStatementContext *>(_localctx)->formatValue = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(6087);
    describeObjectClause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HelpStatementContext ------------------------------------------------------------------

MySqlParser::HelpStatementContext::HelpStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::HelpStatementContext::HELP() {
  return getToken(MySqlParser::HELP, 0);
}

tree::TerminalNode* MySqlParser::HelpStatementContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}


size_t MySqlParser::HelpStatementContext::getRuleIndex() const {
  return MySqlParser::RuleHelpStatement;
}

void MySqlParser::HelpStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHelpStatement(this);
}

void MySqlParser::HelpStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHelpStatement(this);
}


std::any MySqlParser::HelpStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHelpStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::HelpStatementContext* MySqlParser::helpStatement() {
  HelpStatementContext *_localctx = _tracker.createInstance<HelpStatementContext>(_ctx, getState());
  enterRule(_localctx, 524, MySqlParser::RuleHelpStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6089);
    match(MySqlParser::HELP);
    setState(6090);
    match(MySqlParser::STRING_LITERAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UseStatementContext ------------------------------------------------------------------

MySqlParser::UseStatementContext::UseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::UseStatementContext::USE() {
  return getToken(MySqlParser::USE, 0);
}

MySqlParser::UidContext* MySqlParser::UseStatementContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}


size_t MySqlParser::UseStatementContext::getRuleIndex() const {
  return MySqlParser::RuleUseStatement;
}

void MySqlParser::UseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUseStatement(this);
}

void MySqlParser::UseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUseStatement(this);
}


std::any MySqlParser::UseStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUseStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UseStatementContext* MySqlParser::useStatement() {
  UseStatementContext *_localctx = _tracker.createInstance<UseStatementContext>(_ctx, getState());
  enterRule(_localctx, 526, MySqlParser::RuleUseStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6092);
    match(MySqlParser::USE);
    setState(6093);
    uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalStatementContext ------------------------------------------------------------------

MySqlParser::SignalStatementContext::SignalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SignalStatementContext::SIGNAL() {
  return getToken(MySqlParser::SIGNAL, 0);
}

tree::TerminalNode* MySqlParser::SignalStatementContext::ID() {
  return getToken(MySqlParser::ID, 0);
}

tree::TerminalNode* MySqlParser::SignalStatementContext::REVERSE_QUOTE_ID() {
  return getToken(MySqlParser::REVERSE_QUOTE_ID, 0);
}

tree::TerminalNode* MySqlParser::SignalStatementContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

std::vector<MySqlParser::SignalConditionInformationContext *> MySqlParser::SignalStatementContext::signalConditionInformation() {
  return getRuleContexts<MySqlParser::SignalConditionInformationContext>();
}

MySqlParser::SignalConditionInformationContext* MySqlParser::SignalStatementContext::signalConditionInformation(size_t i) {
  return getRuleContext<MySqlParser::SignalConditionInformationContext>(i);
}

tree::TerminalNode* MySqlParser::SignalStatementContext::SQLSTATE() {
  return getToken(MySqlParser::SQLSTATE, 0);
}

MySqlParser::StringLiteralContext* MySqlParser::SignalStatementContext::stringLiteral() {
  return getRuleContext<MySqlParser::StringLiteralContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::SignalStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::SignalStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::SignalStatementContext::VALUE() {
  return getToken(MySqlParser::VALUE, 0);
}


size_t MySqlParser::SignalStatementContext::getRuleIndex() const {
  return MySqlParser::RuleSignalStatement;
}

void MySqlParser::SignalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalStatement(this);
}

void MySqlParser::SignalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalStatement(this);
}


std::any MySqlParser::SignalStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSignalStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SignalStatementContext* MySqlParser::signalStatement() {
  SignalStatementContext *_localctx = _tracker.createInstance<SignalStatementContext>(_ctx, getState());
  enterRule(_localctx, 528, MySqlParser::RuleSignalStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6095);
    match(MySqlParser::SIGNAL);
    setState(6103);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::SQLSTATE: {
        setState(6096);
        match(MySqlParser::SQLSTATE);
        setState(6098);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::VALUE) {
          setState(6097);
          match(MySqlParser::VALUE);
        }
        setState(6100);
        stringLiteral();
        break;
      }

      case MySqlParser::ID: {
        setState(6101);
        match(MySqlParser::ID);
        break;
      }

      case MySqlParser::REVERSE_QUOTE_ID: {
        setState(6102);
        match(MySqlParser::REVERSE_QUOTE_ID);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(6114);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 892, _ctx)) {
    case 1: {
      setState(6105);
      match(MySqlParser::SET);
      setState(6106);
      signalConditionInformation();
      setState(6111);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(6107);
        match(MySqlParser::COMMA);
        setState(6108);
        signalConditionInformation();
        setState(6113);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResignalStatementContext ------------------------------------------------------------------

MySqlParser::ResignalStatementContext::ResignalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ResignalStatementContext::RESIGNAL() {
  return getToken(MySqlParser::RESIGNAL, 0);
}

tree::TerminalNode* MySqlParser::ResignalStatementContext::ID() {
  return getToken(MySqlParser::ID, 0);
}

tree::TerminalNode* MySqlParser::ResignalStatementContext::REVERSE_QUOTE_ID() {
  return getToken(MySqlParser::REVERSE_QUOTE_ID, 0);
}

tree::TerminalNode* MySqlParser::ResignalStatementContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

std::vector<MySqlParser::SignalConditionInformationContext *> MySqlParser::ResignalStatementContext::signalConditionInformation() {
  return getRuleContexts<MySqlParser::SignalConditionInformationContext>();
}

MySqlParser::SignalConditionInformationContext* MySqlParser::ResignalStatementContext::signalConditionInformation(size_t i) {
  return getRuleContext<MySqlParser::SignalConditionInformationContext>(i);
}

tree::TerminalNode* MySqlParser::ResignalStatementContext::SQLSTATE() {
  return getToken(MySqlParser::SQLSTATE, 0);
}

MySqlParser::StringLiteralContext* MySqlParser::ResignalStatementContext::stringLiteral() {
  return getRuleContext<MySqlParser::StringLiteralContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::ResignalStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::ResignalStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

tree::TerminalNode* MySqlParser::ResignalStatementContext::VALUE() {
  return getToken(MySqlParser::VALUE, 0);
}


size_t MySqlParser::ResignalStatementContext::getRuleIndex() const {
  return MySqlParser::RuleResignalStatement;
}

void MySqlParser::ResignalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResignalStatement(this);
}

void MySqlParser::ResignalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResignalStatement(this);
}


std::any MySqlParser::ResignalStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitResignalStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ResignalStatementContext* MySqlParser::resignalStatement() {
  ResignalStatementContext *_localctx = _tracker.createInstance<ResignalStatementContext>(_ctx, getState());
  enterRule(_localctx, 530, MySqlParser::RuleResignalStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6116);
    match(MySqlParser::RESIGNAL);
    setState(6124);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::SQLSTATE: {
        setState(6117);
        match(MySqlParser::SQLSTATE);
        setState(6119);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::VALUE) {
          setState(6118);
          match(MySqlParser::VALUE);
        }
        setState(6121);
        stringLiteral();
        break;
      }

      case MySqlParser::ID: {
        setState(6122);
        match(MySqlParser::ID);
        break;
      }

      case MySqlParser::REVERSE_QUOTE_ID: {
        setState(6123);
        match(MySqlParser::REVERSE_QUOTE_ID);
        break;
      }

      case MySqlParser::EOF:
      case MySqlParser::ALTER:
      case MySqlParser::ANALYZE:
      case MySqlParser::CALL:
      case MySqlParser::CHANGE:
      case MySqlParser::CHECK:
      case MySqlParser::CREATE:
      case MySqlParser::DELETE:
      case MySqlParser::DESC:
      case MySqlParser::DESCRIBE:
      case MySqlParser::DROP:
      case MySqlParser::EXPLAIN:
      case MySqlParser::GET:
      case MySqlParser::GRANT:
      case MySqlParser::INSERT:
      case MySqlParser::KILL:
      case MySqlParser::LOAD:
      case MySqlParser::LOCK:
      case MySqlParser::OPTIMIZE:
      case MySqlParser::PURGE:
      case MySqlParser::RELEASE:
      case MySqlParser::RENAME:
      case MySqlParser::REPLACE:
      case MySqlParser::RESIGNAL:
      case MySqlParser::REVOKE:
      case MySqlParser::SELECT:
      case MySqlParser::SET:
      case MySqlParser::SHOW:
      case MySqlParser::SIGNAL:
      case MySqlParser::TABLE:
      case MySqlParser::UNLOCK:
      case MySqlParser::UPDATE:
      case MySqlParser::USE:
      case MySqlParser::VALUES:
      case MySqlParser::WITH:
      case MySqlParser::BEGIN:
      case MySqlParser::BINLOG:
      case MySqlParser::CACHE:
      case MySqlParser::CHECKSUM:
      case MySqlParser::COMMIT:
      case MySqlParser::DEALLOCATE:
      case MySqlParser::DO:
      case MySqlParser::FLUSH:
      case MySqlParser::HANDLER:
      case MySqlParser::HELP:
      case MySqlParser::INSTALL:
      case MySqlParser::PREPARE:
      case MySqlParser::REPAIR:
      case MySqlParser::RESET:
      case MySqlParser::ROLLBACK:
      case MySqlParser::SAVEPOINT:
      case MySqlParser::START:
      case MySqlParser::STOP:
      case MySqlParser::TRUNCATE:
      case MySqlParser::UNINSTALL:
      case MySqlParser::XA:
      case MySqlParser::EXECUTE:
      case MySqlParser::SHUTDOWN:
      case MySqlParser::MINUS:
      case MySqlParser::LR_BRACKET:
      case MySqlParser::SEMI: {
        break;
      }

    default:
      break;
    }
    setState(6135);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 896, _ctx)) {
    case 1: {
      setState(6126);
      match(MySqlParser::SET);
      setState(6127);
      signalConditionInformation();
      setState(6132);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(6128);
        match(MySqlParser::COMMA);
        setState(6129);
        signalConditionInformation();
        setState(6134);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalConditionInformationContext ------------------------------------------------------------------

MySqlParser::SignalConditionInformationContext::SignalConditionInformationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::CLASS_ORIGIN() {
  return getToken(MySqlParser::CLASS_ORIGIN, 0);
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::SUBCLASS_ORIGIN() {
  return getToken(MySqlParser::SUBCLASS_ORIGIN, 0);
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::MESSAGE_TEXT() {
  return getToken(MySqlParser::MESSAGE_TEXT, 0);
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::MYSQL_ERRNO() {
  return getToken(MySqlParser::MYSQL_ERRNO, 0);
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::CONSTRAINT_CATALOG() {
  return getToken(MySqlParser::CONSTRAINT_CATALOG, 0);
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::CONSTRAINT_SCHEMA() {
  return getToken(MySqlParser::CONSTRAINT_SCHEMA, 0);
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::CONSTRAINT_NAME() {
  return getToken(MySqlParser::CONSTRAINT_NAME, 0);
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::CATALOG_NAME() {
  return getToken(MySqlParser::CATALOG_NAME, 0);
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::SCHEMA_NAME() {
  return getToken(MySqlParser::SCHEMA_NAME, 0);
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::TABLE_NAME() {
  return getToken(MySqlParser::TABLE_NAME, 0);
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::COLUMN_NAME() {
  return getToken(MySqlParser::COLUMN_NAME, 0);
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::CURSOR_NAME() {
  return getToken(MySqlParser::CURSOR_NAME, 0);
}

MySqlParser::StringLiteralContext* MySqlParser::SignalConditionInformationContext::stringLiteral() {
  return getRuleContext<MySqlParser::StringLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::SignalConditionInformationContext::DECIMAL_LITERAL() {
  return getToken(MySqlParser::DECIMAL_LITERAL, 0);
}

MySqlParser::MysqlVariableContext* MySqlParser::SignalConditionInformationContext::mysqlVariable() {
  return getRuleContext<MySqlParser::MysqlVariableContext>(0);
}

MySqlParser::SimpleIdContext* MySqlParser::SignalConditionInformationContext::simpleId() {
  return getRuleContext<MySqlParser::SimpleIdContext>(0);
}


size_t MySqlParser::SignalConditionInformationContext::getRuleIndex() const {
  return MySqlParser::RuleSignalConditionInformation;
}

void MySqlParser::SignalConditionInformationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalConditionInformation(this);
}

void MySqlParser::SignalConditionInformationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalConditionInformation(this);
}


std::any MySqlParser::SignalConditionInformationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSignalConditionInformation(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SignalConditionInformationContext* MySqlParser::signalConditionInformation() {
  SignalConditionInformationContext *_localctx = _tracker.createInstance<SignalConditionInformationContext>(_ctx, getState());
  enterRule(_localctx, 532, MySqlParser::RuleSignalConditionInformation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6137);
    _la = _input->LA(1);
    if (!(((((_la - 359) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 359)) & 272105729) != 0) || _la == MySqlParser::MESSAGE_TEXT

    || _la == MySqlParser::MYSQL_ERRNO || _la == MySqlParser::SUBCLASS_ORIGIN

    || _la == MySqlParser::TABLE_NAME || _la == MySqlParser::CATALOG_NAME || _la == MySqlParser::SCHEMA_NAME)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6138);
    match(MySqlParser::EQUAL_SYMBOL);
    setState(6143);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::START_NATIONAL_STRING_LITERAL:
      case MySqlParser::STRING_LITERAL:
      case MySqlParser::STRING_CHARSET_NAME: {
        setState(6139);
        stringLiteral();
        break;
      }

      case MySqlParser::DECIMAL_LITERAL: {
        setState(6140);
        match(MySqlParser::DECIMAL_LITERAL);
        break;
      }

      case MySqlParser::LOCAL_ID:
      case MySqlParser::GLOBAL_ID: {
        setState(6141);
        mysqlVariable();
        break;
      }

      case MySqlParser::ATTRIBUTE:
      case MySqlParser::BUCKETS:
      case MySqlParser::CONDITION:
      case MySqlParser::CURRENT:
      case MySqlParser::CURRENT_USER:
      case MySqlParser::DATABASE:
      case MySqlParser::DEFAULT:
      case MySqlParser::DIAGNOSTICS:
      case MySqlParser::EMPTY:
      case MySqlParser::ENFORCED:
      case MySqlParser::EXCEPT:
      case MySqlParser::GROUP:
      case MySqlParser::IF:
      case MySqlParser::IGNORED:
      case MySqlParser::INSERT:
      case MySqlParser::LATERAL:
      case MySqlParser::LEFT:
      case MySqlParser::NUMBER:
      case MySqlParser::OPTIONAL:
      case MySqlParser::ORDER:
      case MySqlParser::PRIMARY:
      case MySqlParser::REPLACE:
      case MySqlParser::RIGHT:
      case MySqlParser::SCHEMA:
      case MySqlParser::SKIP_QUERY_REWRITE:
      case MySqlParser::STACKED:
      case MySqlParser::DATE:
      case MySqlParser::TIME:
      case MySqlParser::TIMESTAMP:
      case MySqlParser::DATETIME:
      case MySqlParser::YEAR:
      case MySqlParser::BINARY:
      case MySqlParser::TEXT:
      case MySqlParser::ENUM:
      case MySqlParser::SERIAL:
      case MySqlParser::JSON_ARRAY:
      case MySqlParser::JSON_ARRAYAGG:
      case MySqlParser::JSON_ARRAY_APPEND:
      case MySqlParser::JSON_ARRAY_INSERT:
      case MySqlParser::JSON_CONTAINS:
      case MySqlParser::JSON_CONTAINS_PATH:
      case MySqlParser::JSON_DEPTH:
      case MySqlParser::JSON_EXTRACT:
      case MySqlParser::JSON_INSERT:
      case MySqlParser::JSON_KEYS:
      case MySqlParser::JSON_LENGTH:
      case MySqlParser::JSON_MERGE:
      case MySqlParser::JSON_MERGE_PATCH:
      case MySqlParser::JSON_MERGE_PRESERVE:
      case MySqlParser::JSON_OBJECT:
      case MySqlParser::JSON_OBJECTAGG:
      case MySqlParser::JSON_OVERLAPS:
      case MySqlParser::JSON_PRETTY:
      case MySqlParser::JSON_QUOTE:
      case MySqlParser::JSON_REMOVE:
      case MySqlParser::JSON_REPLACE:
      case MySqlParser::JSON_SCHEMA_VALID:
      case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
      case MySqlParser::JSON_SEARCH:
      case MySqlParser::JSON_SET:
      case MySqlParser::JSON_STORAGE_FREE:
      case MySqlParser::JSON_STORAGE_SIZE:
      case MySqlParser::JSON_TABLE:
      case MySqlParser::JSON_TYPE:
      case MySqlParser::JSON_UNQUOTE:
      case MySqlParser::JSON_VALID:
      case MySqlParser::JSON_VALUE:
      case MySqlParser::NESTED:
      case MySqlParser::ORDINALITY:
      case MySqlParser::PATH:
      case MySqlParser::AVG:
      case MySqlParser::BIT_AND:
      case MySqlParser::BIT_OR:
      case MySqlParser::BIT_XOR:
      case MySqlParser::COUNT:
      case MySqlParser::CUME_DIST:
      case MySqlParser::DENSE_RANK:
      case MySqlParser::FIRST_VALUE:
      case MySqlParser::GROUP_CONCAT:
      case MySqlParser::LAG:
      case MySqlParser::LAST_VALUE:
      case MySqlParser::LEAD:
      case MySqlParser::MAX:
      case MySqlParser::MIN:
      case MySqlParser::NTILE:
      case MySqlParser::NTH_VALUE:
      case MySqlParser::PERCENT_RANK:
      case MySqlParser::RANK:
      case MySqlParser::ROW_NUMBER:
      case MySqlParser::STD:
      case MySqlParser::STDDEV:
      case MySqlParser::STDDEV_POP:
      case MySqlParser::STDDEV_SAMP:
      case MySqlParser::SUM:
      case MySqlParser::VAR_POP:
      case MySqlParser::VAR_SAMP:
      case MySqlParser::VARIANCE:
      case MySqlParser::CURRENT_DATE:
      case MySqlParser::CURRENT_TIME:
      case MySqlParser::CURRENT_TIMESTAMP:
      case MySqlParser::LOCALTIME:
      case MySqlParser::CURDATE:
      case MySqlParser::CURTIME:
      case MySqlParser::DATE_ADD:
      case MySqlParser::DATE_SUB:
      case MySqlParser::LOCALTIMESTAMP:
      case MySqlParser::NOW:
      case MySqlParser::POSITION:
      case MySqlParser::SUBSTR:
      case MySqlParser::SUBSTRING:
      case MySqlParser::SYSDATE:
      case MySqlParser::TRIM:
      case MySqlParser::UTC_DATE:
      case MySqlParser::UTC_TIME:
      case MySqlParser::UTC_TIMESTAMP:
      case MySqlParser::ACCOUNT:
      case MySqlParser::ACTION:
      case MySqlParser::AFTER:
      case MySqlParser::AGGREGATE:
      case MySqlParser::ALGORITHM:
      case MySqlParser::ANY:
      case MySqlParser::AT:
      case MySqlParser::AUTHORS:
      case MySqlParser::AUTOCOMMIT:
      case MySqlParser::AUTOEXTEND_SIZE:
      case MySqlParser::AUTO_INCREMENT:
      case MySqlParser::AVG_ROW_LENGTH:
      case MySqlParser::BEGIN:
      case MySqlParser::BINLOG:
      case MySqlParser::BIT:
      case MySqlParser::BLOCK:
      case MySqlParser::BOOL:
      case MySqlParser::BOOLEAN:
      case MySqlParser::BTREE:
      case MySqlParser::CACHE:
      case MySqlParser::CASCADED:
      case MySqlParser::CHAIN:
      case MySqlParser::CHANGED:
      case MySqlParser::CHANNEL:
      case MySqlParser::CHECKSUM:
      case MySqlParser::PAGE_CHECKSUM:
      case MySqlParser::CIPHER:
      case MySqlParser::CLASS_ORIGIN:
      case MySqlParser::CLIENT:
      case MySqlParser::CLOSE:
      case MySqlParser::CLUSTERING:
      case MySqlParser::COALESCE:
      case MySqlParser::CODE:
      case MySqlParser::COLUMNS:
      case MySqlParser::COLUMN_FORMAT:
      case MySqlParser::COLUMN_NAME:
      case MySqlParser::COMMENT:
      case MySqlParser::COMMIT:
      case MySqlParser::COMPACT:
      case MySqlParser::COMPLETION:
      case MySqlParser::COMPRESSED:
      case MySqlParser::COMPRESSION:
      case MySqlParser::CONCURRENT:
      case MySqlParser::CONNECT:
      case MySqlParser::CONNECTION:
      case MySqlParser::CONSISTENT:
      case MySqlParser::CONSTRAINT_CATALOG:
      case MySqlParser::CONSTRAINT_SCHEMA:
      case MySqlParser::CONSTRAINT_NAME:
      case MySqlParser::CONTAINS:
      case MySqlParser::CONTEXT:
      case MySqlParser::CONTRIBUTORS:
      case MySqlParser::COPY:
      case MySqlParser::CPU:
      case MySqlParser::CURSOR_NAME:
      case MySqlParser::DATA:
      case MySqlParser::DATAFILE:
      case MySqlParser::DEALLOCATE:
      case MySqlParser::DEFAULT_AUTH:
      case MySqlParser::DEFINER:
      case MySqlParser::DELAY_KEY_WRITE:
      case MySqlParser::DES_KEY_FILE:
      case MySqlParser::DIRECTORY:
      case MySqlParser::DISABLE:
      case MySqlParser::DISCARD:
      case MySqlParser::DISK:
      case MySqlParser::DO:
      case MySqlParser::DUMPFILE:
      case MySqlParser::DUPLICATE:
      case MySqlParser::DYNAMIC:
      case MySqlParser::ENABLE:
      case MySqlParser::ENCRYPTION:
      case MySqlParser::END:
      case MySqlParser::ENDS:
      case MySqlParser::ENGINE:
      case MySqlParser::ENGINES:
      case MySqlParser::ERROR:
      case MySqlParser::ERRORS:
      case MySqlParser::ESCAPE:
      case MySqlParser::EVEN:
      case MySqlParser::EVENT:
      case MySqlParser::EVENTS:
      case MySqlParser::EVERY:
      case MySqlParser::EXCHANGE:
      case MySqlParser::EXCLUSIVE:
      case MySqlParser::EXPIRE:
      case MySqlParser::EXPORT:
      case MySqlParser::EXTENDED:
      case MySqlParser::EXTENT_SIZE:
      case MySqlParser::FAILED_LOGIN_ATTEMPTS:
      case MySqlParser::FAST:
      case MySqlParser::FAULTS:
      case MySqlParser::FIELDS:
      case MySqlParser::FILE_BLOCK_SIZE:
      case MySqlParser::FILTER:
      case MySqlParser::FIRST:
      case MySqlParser::FIXED:
      case MySqlParser::FLUSH:
      case MySqlParser::FOLLOWS:
      case MySqlParser::FOUND:
      case MySqlParser::FULL:
      case MySqlParser::FUNCTION:
      case MySqlParser::GENERAL:
      case MySqlParser::GLOBAL:
      case MySqlParser::GRANTS:
      case MySqlParser::GROUP_REPLICATION:
      case MySqlParser::HANDLER:
      case MySqlParser::HASH:
      case MySqlParser::HELP:
      case MySqlParser::HISTORY:
      case MySqlParser::HOST:
      case MySqlParser::HOSTS:
      case MySqlParser::IDENTIFIED:
      case MySqlParser::IGNORE_SERVER_IDS:
      case MySqlParser::IMPORT:
      case MySqlParser::INDEXES:
      case MySqlParser::INITIAL_SIZE:
      case MySqlParser::INPLACE:
      case MySqlParser::INSERT_METHOD:
      case MySqlParser::INSTALL:
      case MySqlParser::INSTANCE:
      case MySqlParser::INSTANT:
      case MySqlParser::INVISIBLE:
      case MySqlParser::INVOKER:
      case MySqlParser::IO:
      case MySqlParser::IO_THREAD:
      case MySqlParser::IPC:
      case MySqlParser::ISOLATION:
      case MySqlParser::ISSUER:
      case MySqlParser::JSON:
      case MySqlParser::KEY_BLOCK_SIZE:
      case MySqlParser::LANGUAGE:
      case MySqlParser::LAST:
      case MySqlParser::LEAVES:
      case MySqlParser::LESS:
      case MySqlParser::LEVEL:
      case MySqlParser::LIST:
      case MySqlParser::LOCAL:
      case MySqlParser::LOGFILE:
      case MySqlParser::LOGS:
      case MySqlParser::MASTER:
      case MySqlParser::MASTER_AUTO_POSITION:
      case MySqlParser::MASTER_CONNECT_RETRY:
      case MySqlParser::MASTER_DELAY:
      case MySqlParser::MASTER_HEARTBEAT_PERIOD:
      case MySqlParser::MASTER_HOST:
      case MySqlParser::MASTER_LOG_FILE:
      case MySqlParser::MASTER_LOG_POS:
      case MySqlParser::MASTER_PASSWORD:
      case MySqlParser::MASTER_PORT:
      case MySqlParser::MASTER_RETRY_COUNT:
      case MySqlParser::MASTER_SSL:
      case MySqlParser::MASTER_SSL_CA:
      case MySqlParser::MASTER_SSL_CAPATH:
      case MySqlParser::MASTER_SSL_CERT:
      case MySqlParser::MASTER_SSL_CIPHER:
      case MySqlParser::MASTER_SSL_CRL:
      case MySqlParser::MASTER_SSL_CRLPATH:
      case MySqlParser::MASTER_SSL_KEY:
      case MySqlParser::MASTER_TLS_VERSION:
      case MySqlParser::MASTER_USER:
      case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
      case MySqlParser::MAX_QUERIES_PER_HOUR:
      case MySqlParser::MAX_ROWS:
      case MySqlParser::MAX_SIZE:
      case MySqlParser::MAX_UPDATES_PER_HOUR:
      case MySqlParser::MAX_USER_CONNECTIONS:
      case MySqlParser::MEDIUM:
      case MySqlParser::MEMBER:
      case MySqlParser::MERGE:
      case MySqlParser::MESSAGE_TEXT:
      case MySqlParser::MID:
      case MySqlParser::MIGRATE:
      case MySqlParser::MIN_ROWS:
      case MySqlParser::MODE:
      case MySqlParser::MODIFY:
      case MySqlParser::MUTEX:
      case MySqlParser::MYSQL:
      case MySqlParser::MYSQL_ERRNO:
      case MySqlParser::NAME:
      case MySqlParser::NAMES:
      case MySqlParser::NCHAR:
      case MySqlParser::NEVER:
      case MySqlParser::NEXT:
      case MySqlParser::NO:
      case MySqlParser::NOCOPY:
      case MySqlParser::NOWAIT:
      case MySqlParser::NODEGROUP:
      case MySqlParser::NONE:
      case MySqlParser::ODBC:
      case MySqlParser::OFFLINE:
      case MySqlParser::OFFSET:
      case MySqlParser::OF:
      case MySqlParser::OJ:
      case MySqlParser::OLD_PASSWORD:
      case MySqlParser::ONE:
      case MySqlParser::ONLINE:
      case MySqlParser::ONLY:
      case MySqlParser::OPEN:
      case MySqlParser::OPTIMIZER_COSTS:
      case MySqlParser::OPTIONS:
      case MySqlParser::OWNER:
      case MySqlParser::PACK_KEYS:
      case MySqlParser::PAGE:
      case MySqlParser::PARSER:
      case MySqlParser::PARTIAL:
      case MySqlParser::PARTITIONING:
      case MySqlParser::PARTITIONS:
      case MySqlParser::PASSWORD:
      case MySqlParser::PASSWORD_LOCK_TIME:
      case MySqlParser::PHASE:
      case MySqlParser::PLUGIN:
      case MySqlParser::PLUGIN_DIR:
      case MySqlParser::PLUGINS:
      case MySqlParser::PORT:
      case MySqlParser::PRECEDES:
      case MySqlParser::PREPARE:
      case MySqlParser::PRESERVE:
      case MySqlParser::PREV:
      case MySqlParser::PROCESSLIST:
      case MySqlParser::PROFILE:
      case MySqlParser::PROFILES:
      case MySqlParser::PROXY:
      case MySqlParser::QUERY:
      case MySqlParser::QUICK:
      case MySqlParser::REBUILD:
      case MySqlParser::RECOVER:
      case MySqlParser::RECURSIVE:
      case MySqlParser::REDO_BUFFER_SIZE:
      case MySqlParser::REDUNDANT:
      case MySqlParser::RELAY:
      case MySqlParser::RELAY_LOG_FILE:
      case MySqlParser::RELAY_LOG_POS:
      case MySqlParser::RELAYLOG:
      case MySqlParser::REMOVE:
      case MySqlParser::REORGANIZE:
      case MySqlParser::REPAIR:
      case MySqlParser::REPLICATE_DO_DB:
      case MySqlParser::REPLICATE_DO_TABLE:
      case MySqlParser::REPLICATE_IGNORE_DB:
      case MySqlParser::REPLICATE_IGNORE_TABLE:
      case MySqlParser::REPLICATE_REWRITE_DB:
      case MySqlParser::REPLICATE_WILD_DO_TABLE:
      case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySqlParser::REPLICATION:
      case MySqlParser::RESET:
      case MySqlParser::RESUME:
      case MySqlParser::RETURNED_SQLSTATE:
      case MySqlParser::RETURNS:
      case MySqlParser::REUSE:
      case MySqlParser::ROLE:
      case MySqlParser::ROLLBACK:
      case MySqlParser::ROLLUP:
      case MySqlParser::ROTATE:
      case MySqlParser::ROW:
      case MySqlParser::ROWS:
      case MySqlParser::ROW_FORMAT:
      case MySqlParser::RTREE:
      case MySqlParser::SAVEPOINT:
      case MySqlParser::SCHEDULE:
      case MySqlParser::SECURITY:
      case MySqlParser::SERVER:
      case MySqlParser::SESSION:
      case MySqlParser::SHARE:
      case MySqlParser::SHARED:
      case MySqlParser::SIGNED:
      case MySqlParser::SIMPLE:
      case MySqlParser::SLAVE:
      case MySqlParser::SLOW:
      case MySqlParser::SNAPSHOT:
      case MySqlParser::SOCKET:
      case MySqlParser::SOME:
      case MySqlParser::SONAME:
      case MySqlParser::SOUNDS:
      case MySqlParser::SOURCE:
      case MySqlParser::SQL_AFTER_GTIDS:
      case MySqlParser::SQL_AFTER_MTS_GAPS:
      case MySqlParser::SQL_BEFORE_GTIDS:
      case MySqlParser::SQL_BUFFER_RESULT:
      case MySqlParser::SQL_CACHE:
      case MySqlParser::SQL_NO_CACHE:
      case MySqlParser::SQL_THREAD:
      case MySqlParser::START:
      case MySqlParser::STARTS:
      case MySqlParser::STATS_AUTO_RECALC:
      case MySqlParser::STATS_PERSISTENT:
      case MySqlParser::STATS_SAMPLE_PAGES:
      case MySqlParser::STATUS:
      case MySqlParser::STOP:
      case MySqlParser::STORAGE:
      case MySqlParser::STRING:
      case MySqlParser::SUBCLASS_ORIGIN:
      case MySqlParser::SUBJECT:
      case MySqlParser::SUBPARTITION:
      case MySqlParser::SUBPARTITIONS:
      case MySqlParser::SUSPEND:
      case MySqlParser::SWAPS:
      case MySqlParser::SWITCHES:
      case MySqlParser::TABLE_NAME:
      case MySqlParser::TABLESPACE:
      case MySqlParser::TABLE_TYPE:
      case MySqlParser::TEMPORARY:
      case MySqlParser::TEMPTABLE:
      case MySqlParser::THAN:
      case MySqlParser::TRADITIONAL:
      case MySqlParser::TRANSACTION:
      case MySqlParser::TRANSACTIONAL:
      case MySqlParser::TRIGGERS:
      case MySqlParser::TRUNCATE:
      case MySqlParser::UNBOUNDED:
      case MySqlParser::UNDEFINED:
      case MySqlParser::UNDOFILE:
      case MySqlParser::UNDO_BUFFER_SIZE:
      case MySqlParser::UNINSTALL:
      case MySqlParser::UNKNOWN:
      case MySqlParser::UNTIL:
      case MySqlParser::UPGRADE:
      case MySqlParser::USER:
      case MySqlParser::USE_FRM:
      case MySqlParser::USER_RESOURCES:
      case MySqlParser::VALIDATION:
      case MySqlParser::VALUE:
      case MySqlParser::VARIABLES:
      case MySqlParser::VIEW:
      case MySqlParser::VIRTUAL:
      case MySqlParser::VISIBLE:
      case MySqlParser::WAIT:
      case MySqlParser::WARNINGS:
      case MySqlParser::WITHOUT:
      case MySqlParser::WORK:
      case MySqlParser::WRAPPER:
      case MySqlParser::X509:
      case MySqlParser::XA:
      case MySqlParser::XML:
      case MySqlParser::EUR:
      case MySqlParser::USA:
      case MySqlParser::JIS:
      case MySqlParser::ISO:
      case MySqlParser::INTERNAL:
      case MySqlParser::QUARTER:
      case MySqlParser::MONTH:
      case MySqlParser::DAY:
      case MySqlParser::HOUR:
      case MySqlParser::MINUTE:
      case MySqlParser::WEEK:
      case MySqlParser::SECOND:
      case MySqlParser::MICROSECOND:
      case MySqlParser::ADMIN:
      case MySqlParser::AUDIT_ABORT_EXEMPT:
      case MySqlParser::AUDIT_ADMIN:
      case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
      case MySqlParser::BACKUP_ADMIN:
      case MySqlParser::BINLOG_ADMIN:
      case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
      case MySqlParser::CLONE_ADMIN:
      case MySqlParser::CONNECTION_ADMIN:
      case MySqlParser::ENCRYPTION_KEY_ADMIN:
      case MySqlParser::EXECUTE:
      case MySqlParser::FILE:
      case MySqlParser::FIREWALL_ADMIN:
      case MySqlParser::FIREWALL_EXEMPT:
      case MySqlParser::FIREWALL_USER:
      case MySqlParser::GROUP_REPLICATION_ADMIN:
      case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
      case MySqlParser::INVOKE:
      case MySqlParser::LAMBDA:
      case MySqlParser::NDB_STORED_USER:
      case MySqlParser::PASSWORDLESS_USER_ADMIN:
      case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
      case MySqlParser::PRIVILEGES:
      case MySqlParser::PROCESS:
      case MySqlParser::RELOAD:
      case MySqlParser::REPLICATION_APPLIER:
      case MySqlParser::REPLICATION_SLAVE_ADMIN:
      case MySqlParser::RESOURCE_GROUP_ADMIN:
      case MySqlParser::RESOURCE_GROUP_USER:
      case MySqlParser::ROLE_ADMIN:
      case MySqlParser::ROUTINE:
      case MySqlParser::S3:
      case MySqlParser::SESSION_VARIABLES_ADMIN:
      case MySqlParser::SET_USER_ID:
      case MySqlParser::SHOW_ROUTINE:
      case MySqlParser::SHUTDOWN:
      case MySqlParser::SUPER:
      case MySqlParser::SYSTEM_VARIABLES_ADMIN:
      case MySqlParser::TABLES:
      case MySqlParser::TABLE_ENCRYPTION_ADMIN:
      case MySqlParser::VERSION_TOKEN_ADMIN:
      case MySqlParser::XA_RECOVER_ADMIN:
      case MySqlParser::ARMSCII8:
      case MySqlParser::ASCII:
      case MySqlParser::BIG5:
      case MySqlParser::CP1250:
      case MySqlParser::CP1251:
      case MySqlParser::CP1256:
      case MySqlParser::CP1257:
      case MySqlParser::CP850:
      case MySqlParser::CP852:
      case MySqlParser::CP866:
      case MySqlParser::CP932:
      case MySqlParser::DEC8:
      case MySqlParser::EUCJPMS:
      case MySqlParser::EUCKR:
      case MySqlParser::GB18030:
      case MySqlParser::GB2312:
      case MySqlParser::GBK:
      case MySqlParser::GEOSTD8:
      case MySqlParser::GREEK:
      case MySqlParser::HEBREW:
      case MySqlParser::HP8:
      case MySqlParser::KEYBCS2:
      case MySqlParser::KOI8R:
      case MySqlParser::KOI8U:
      case MySqlParser::LATIN1:
      case MySqlParser::LATIN2:
      case MySqlParser::LATIN5:
      case MySqlParser::LATIN7:
      case MySqlParser::MACCE:
      case MySqlParser::MACROMAN:
      case MySqlParser::SJIS:
      case MySqlParser::SWE7:
      case MySqlParser::TIS620:
      case MySqlParser::UCS2:
      case MySqlParser::UJIS:
      case MySqlParser::UTF16:
      case MySqlParser::UTF16LE:
      case MySqlParser::UTF32:
      case MySqlParser::UTF8:
      case MySqlParser::UTF8MB3:
      case MySqlParser::UTF8MB4:
      case MySqlParser::ARCHIVE:
      case MySqlParser::BLACKHOLE:
      case MySqlParser::CSV:
      case MySqlParser::FEDERATED:
      case MySqlParser::INNODB:
      case MySqlParser::MEMORY:
      case MySqlParser::MRG_MYISAM:
      case MySqlParser::MYISAM:
      case MySqlParser::NDB:
      case MySqlParser::NDBCLUSTER:
      case MySqlParser::PERFORMANCE_SCHEMA:
      case MySqlParser::TOKUDB:
      case MySqlParser::REPEATABLE:
      case MySqlParser::COMMITTED:
      case MySqlParser::UNCOMMITTED:
      case MySqlParser::SERIALIZABLE:
      case MySqlParser::GEOMETRYCOLLECTION:
      case MySqlParser::LINESTRING:
      case MySqlParser::MULTILINESTRING:
      case MySqlParser::MULTIPOINT:
      case MySqlParser::MULTIPOLYGON:
      case MySqlParser::POINT:
      case MySqlParser::POLYGON:
      case MySqlParser::ABS:
      case MySqlParser::ACOS:
      case MySqlParser::ADDDATE:
      case MySqlParser::ADDTIME:
      case MySqlParser::AES_DECRYPT:
      case MySqlParser::AES_ENCRYPT:
      case MySqlParser::AREA:
      case MySqlParser::ASBINARY:
      case MySqlParser::ASIN:
      case MySqlParser::ASTEXT:
      case MySqlParser::ASWKB:
      case MySqlParser::ASWKT:
      case MySqlParser::ASYMMETRIC_DECRYPT:
      case MySqlParser::ASYMMETRIC_DERIVE:
      case MySqlParser::ASYMMETRIC_ENCRYPT:
      case MySqlParser::ASYMMETRIC_SIGN:
      case MySqlParser::ASYMMETRIC_VERIFY:
      case MySqlParser::ATAN:
      case MySqlParser::ATAN2:
      case MySqlParser::BENCHMARK:
      case MySqlParser::BIN:
      case MySqlParser::BIT_COUNT:
      case MySqlParser::BIT_LENGTH:
      case MySqlParser::BUFFER:
      case MySqlParser::CATALOG_NAME:
      case MySqlParser::CEIL:
      case MySqlParser::CEILING:
      case MySqlParser::CENTROID:
      case MySqlParser::CHARACTER_LENGTH:
      case MySqlParser::CHARSET:
      case MySqlParser::CHAR_LENGTH:
      case MySqlParser::COERCIBILITY:
      case MySqlParser::COLLATION:
      case MySqlParser::COMPRESS:
      case MySqlParser::CONCAT:
      case MySqlParser::CONCAT_WS:
      case MySqlParser::CONNECTION_ID:
      case MySqlParser::CONV:
      case MySqlParser::CONVERT_TZ:
      case MySqlParser::COS:
      case MySqlParser::COT:
      case MySqlParser::CRC32:
      case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
      case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
      case MySqlParser::CREATE_DH_PARAMETERS:
      case MySqlParser::CREATE_DIGEST:
      case MySqlParser::CROSSES:
      case MySqlParser::DATEDIFF:
      case MySqlParser::DATE_FORMAT:
      case MySqlParser::DAYNAME:
      case MySqlParser::DAYOFMONTH:
      case MySqlParser::DAYOFWEEK:
      case MySqlParser::DAYOFYEAR:
      case MySqlParser::DECODE:
      case MySqlParser::DEGREES:
      case MySqlParser::DES_DECRYPT:
      case MySqlParser::DES_ENCRYPT:
      case MySqlParser::DIMENSION:
      case MySqlParser::DISJOINT:
      case MySqlParser::ELT:
      case MySqlParser::ENCODE:
      case MySqlParser::ENCRYPT:
      case MySqlParser::ENDPOINT:
      case MySqlParser::ENGINE_ATTRIBUTE:
      case MySqlParser::ENVELOPE:
      case MySqlParser::EQUALS:
      case MySqlParser::EXP:
      case MySqlParser::EXPORT_SET:
      case MySqlParser::EXTERIORRING:
      case MySqlParser::EXTRACTVALUE:
      case MySqlParser::FIELD:
      case MySqlParser::FIND_IN_SET:
      case MySqlParser::FLOOR:
      case MySqlParser::FORMAT:
      case MySqlParser::FOUND_ROWS:
      case MySqlParser::FROM_BASE64:
      case MySqlParser::FROM_DAYS:
      case MySqlParser::FROM_UNIXTIME:
      case MySqlParser::GEOMCOLLFROMTEXT:
      case MySqlParser::GEOMCOLLFROMWKB:
      case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::GEOMETRYFROMTEXT:
      case MySqlParser::GEOMETRYFROMWKB:
      case MySqlParser::GEOMETRYN:
      case MySqlParser::GEOMETRYTYPE:
      case MySqlParser::GEOMFROMTEXT:
      case MySqlParser::GEOMFROMWKB:
      case MySqlParser::GET_FORMAT:
      case MySqlParser::GET_LOCK:
      case MySqlParser::GLENGTH:
      case MySqlParser::GREATEST:
      case MySqlParser::GTID_SUBSET:
      case MySqlParser::GTID_SUBTRACT:
      case MySqlParser::HEX:
      case MySqlParser::IFNULL:
      case MySqlParser::INET6_ATON:
      case MySqlParser::INET6_NTOA:
      case MySqlParser::INET_ATON:
      case MySqlParser::INET_NTOA:
      case MySqlParser::INSTR:
      case MySqlParser::INTERIORRINGN:
      case MySqlParser::INTERSECTS:
      case MySqlParser::ISCLOSED:
      case MySqlParser::ISEMPTY:
      case MySqlParser::ISNULL:
      case MySqlParser::ISSIMPLE:
      case MySqlParser::IS_FREE_LOCK:
      case MySqlParser::IS_IPV4:
      case MySqlParser::IS_IPV4_COMPAT:
      case MySqlParser::IS_IPV4_MAPPED:
      case MySqlParser::IS_IPV6:
      case MySqlParser::IS_USED_LOCK:
      case MySqlParser::LAST_INSERT_ID:
      case MySqlParser::LCASE:
      case MySqlParser::LEAST:
      case MySqlParser::LENGTH:
      case MySqlParser::LINEFROMTEXT:
      case MySqlParser::LINEFROMWKB:
      case MySqlParser::LINESTRINGFROMTEXT:
      case MySqlParser::LINESTRINGFROMWKB:
      case MySqlParser::LN:
      case MySqlParser::LOAD_FILE:
      case MySqlParser::LOCATE:
      case MySqlParser::LOG:
      case MySqlParser::LOG10:
      case MySqlParser::LOG2:
      case MySqlParser::LOWER:
      case MySqlParser::LPAD:
      case MySqlParser::LTRIM:
      case MySqlParser::MAKEDATE:
      case MySqlParser::MAKETIME:
      case MySqlParser::MAKE_SET:
      case MySqlParser::MASTER_POS_WAIT:
      case MySqlParser::MBRCONTAINS:
      case MySqlParser::MBRDISJOINT:
      case MySqlParser::MBREQUAL:
      case MySqlParser::MBRINTERSECTS:
      case MySqlParser::MBROVERLAPS:
      case MySqlParser::MBRTOUCHES:
      case MySqlParser::MBRWITHIN:
      case MySqlParser::MD5:
      case MySqlParser::MLINEFROMTEXT:
      case MySqlParser::MLINEFROMWKB:
      case MySqlParser::MONTHNAME:
      case MySqlParser::MPOINTFROMTEXT:
      case MySqlParser::MPOINTFROMWKB:
      case MySqlParser::MPOLYFROMTEXT:
      case MySqlParser::MPOLYFROMWKB:
      case MySqlParser::MULTILINESTRINGFROMTEXT:
      case MySqlParser::MULTILINESTRINGFROMWKB:
      case MySqlParser::MULTIPOINTFROMTEXT:
      case MySqlParser::MULTIPOINTFROMWKB:
      case MySqlParser::MULTIPOLYGONFROMTEXT:
      case MySqlParser::MULTIPOLYGONFROMWKB:
      case MySqlParser::NAME_CONST:
      case MySqlParser::NULLIF:
      case MySqlParser::NUMGEOMETRIES:
      case MySqlParser::NUMINTERIORRINGS:
      case MySqlParser::NUMPOINTS:
      case MySqlParser::OCT:
      case MySqlParser::OCTET_LENGTH:
      case MySqlParser::ORD:
      case MySqlParser::OVERLAPS:
      case MySqlParser::PERIOD_ADD:
      case MySqlParser::PERIOD_DIFF:
      case MySqlParser::PI:
      case MySqlParser::POINTFROMTEXT:
      case MySqlParser::POINTFROMWKB:
      case MySqlParser::POINTN:
      case MySqlParser::POLYFROMTEXT:
      case MySqlParser::POLYFROMWKB:
      case MySqlParser::POLYGONFROMTEXT:
      case MySqlParser::POLYGONFROMWKB:
      case MySqlParser::POW:
      case MySqlParser::POWER:
      case MySqlParser::QUOTE:
      case MySqlParser::RADIANS:
      case MySqlParser::RAND:
      case MySqlParser::RANDOM_BYTES:
      case MySqlParser::RELEASE_LOCK:
      case MySqlParser::REVERSE:
      case MySqlParser::ROUND:
      case MySqlParser::ROW_COUNT:
      case MySqlParser::RPAD:
      case MySqlParser::RTRIM:
      case MySqlParser::SEC_TO_TIME:
      case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySqlParser::SESSION_USER:
      case MySqlParser::SHA:
      case MySqlParser::SHA1:
      case MySqlParser::SHA2:
      case MySqlParser::SCHEMA_NAME:
      case MySqlParser::SIGN:
      case MySqlParser::SIN:
      case MySqlParser::SLEEP:
      case MySqlParser::SOUNDEX:
      case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
      case MySqlParser::SQRT:
      case MySqlParser::SRID:
      case MySqlParser::STARTPOINT:
      case MySqlParser::STRCMP:
      case MySqlParser::STR_TO_DATE:
      case MySqlParser::ST_AREA:
      case MySqlParser::ST_ASBINARY:
      case MySqlParser::ST_ASTEXT:
      case MySqlParser::ST_ASWKB:
      case MySqlParser::ST_ASWKT:
      case MySqlParser::ST_BUFFER:
      case MySqlParser::ST_CENTROID:
      case MySqlParser::ST_CONTAINS:
      case MySqlParser::ST_CROSSES:
      case MySqlParser::ST_DIFFERENCE:
      case MySqlParser::ST_DIMENSION:
      case MySqlParser::ST_DISJOINT:
      case MySqlParser::ST_DISTANCE:
      case MySqlParser::ST_ENDPOINT:
      case MySqlParser::ST_ENVELOPE:
      case MySqlParser::ST_EQUALS:
      case MySqlParser::ST_EXTERIORRING:
      case MySqlParser::ST_GEOMCOLLFROMTEXT:
      case MySqlParser::ST_GEOMCOLLFROMTXT:
      case MySqlParser::ST_GEOMCOLLFROMWKB:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::ST_GEOMETRYFROMTEXT:
      case MySqlParser::ST_GEOMETRYFROMWKB:
      case MySqlParser::ST_GEOMETRYN:
      case MySqlParser::ST_GEOMETRYTYPE:
      case MySqlParser::ST_GEOMFROMTEXT:
      case MySqlParser::ST_GEOMFROMWKB:
      case MySqlParser::ST_INTERIORRINGN:
      case MySqlParser::ST_INTERSECTION:
      case MySqlParser::ST_INTERSECTS:
      case MySqlParser::ST_ISCLOSED:
      case MySqlParser::ST_ISEMPTY:
      case MySqlParser::ST_ISSIMPLE:
      case MySqlParser::ST_LINEFROMTEXT:
      case MySqlParser::ST_LINEFROMWKB:
      case MySqlParser::ST_LINESTRINGFROMTEXT:
      case MySqlParser::ST_LINESTRINGFROMWKB:
      case MySqlParser::ST_NUMGEOMETRIES:
      case MySqlParser::ST_NUMINTERIORRING:
      case MySqlParser::ST_NUMINTERIORRINGS:
      case MySqlParser::ST_NUMPOINTS:
      case MySqlParser::ST_OVERLAPS:
      case MySqlParser::ST_POINTFROMTEXT:
      case MySqlParser::ST_POINTFROMWKB:
      case MySqlParser::ST_POINTN:
      case MySqlParser::ST_POLYFROMTEXT:
      case MySqlParser::ST_POLYFROMWKB:
      case MySqlParser::ST_POLYGONFROMTEXT:
      case MySqlParser::ST_POLYGONFROMWKB:
      case MySqlParser::ST_SRID:
      case MySqlParser::ST_STARTPOINT:
      case MySqlParser::ST_SYMDIFFERENCE:
      case MySqlParser::ST_TOUCHES:
      case MySqlParser::ST_UNION:
      case MySqlParser::ST_WITHIN:
      case MySqlParser::ST_X:
      case MySqlParser::ST_Y:
      case MySqlParser::SUBDATE:
      case MySqlParser::SUBSTRING_INDEX:
      case MySqlParser::SUBTIME:
      case MySqlParser::SYSTEM_USER:
      case MySqlParser::TAN:
      case MySqlParser::TIMEDIFF:
      case MySqlParser::TIMESTAMPADD:
      case MySqlParser::TIMESTAMPDIFF:
      case MySqlParser::TIME_FORMAT:
      case MySqlParser::TIME_TO_SEC:
      case MySqlParser::TOUCHES:
      case MySqlParser::TO_BASE64:
      case MySqlParser::TO_DAYS:
      case MySqlParser::TO_SECONDS:
      case MySqlParser::TP_CONNECTION_ADMIN:
      case MySqlParser::UCASE:
      case MySqlParser::UNCOMPRESS:
      case MySqlParser::UNCOMPRESSED_LENGTH:
      case MySqlParser::UNHEX:
      case MySqlParser::UNIX_TIMESTAMP:
      case MySqlParser::UPDATEXML:
      case MySqlParser::UPPER:
      case MySqlParser::UUID:
      case MySqlParser::UUID_SHORT:
      case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
      case MySqlParser::VERSION:
      case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
      case MySqlParser::WEEKDAY:
      case MySqlParser::WEEKOFYEAR:
      case MySqlParser::WEIGHT_STRING:
      case MySqlParser::WITHIN:
      case MySqlParser::YEARWEEK:
      case MySqlParser::Y_FUNCTION:
      case MySqlParser::X_FUNCTION:
      case MySqlParser::MOD:
      case MySqlParser::ID: {
        setState(6142);
        simpleId();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithStatementContext ------------------------------------------------------------------

MySqlParser::WithStatementContext::WithStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::WithStatementContext::WITH() {
  return getToken(MySqlParser::WITH, 0);
}

std::vector<MySqlParser::CommonTableExpressionsContext *> MySqlParser::WithStatementContext::commonTableExpressions() {
  return getRuleContexts<MySqlParser::CommonTableExpressionsContext>();
}

MySqlParser::CommonTableExpressionsContext* MySqlParser::WithStatementContext::commonTableExpressions(size_t i) {
  return getRuleContext<MySqlParser::CommonTableExpressionsContext>(i);
}

tree::TerminalNode* MySqlParser::WithStatementContext::RECURSIVE() {
  return getToken(MySqlParser::RECURSIVE, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::WithStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::WithStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::WithStatementContext::getRuleIndex() const {
  return MySqlParser::RuleWithStatement;
}

void MySqlParser::WithStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithStatement(this);
}

void MySqlParser::WithStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithStatement(this);
}


std::any MySqlParser::WithStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitWithStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::WithStatementContext* MySqlParser::withStatement() {
  WithStatementContext *_localctx = _tracker.createInstance<WithStatementContext>(_ctx, getState());
  enterRule(_localctx, 534, MySqlParser::RuleWithStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6145);
    match(MySqlParser::WITH);
    setState(6147);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 898, _ctx)) {
    case 1: {
      setState(6146);
      match(MySqlParser::RECURSIVE);
      break;
    }

    default:
      break;
    }
    setState(6149);
    commonTableExpressions();
    setState(6154);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(6150);
      match(MySqlParser::COMMA);
      setState(6151);
      commonTableExpressions();
      setState(6156);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableStatementContext ------------------------------------------------------------------

MySqlParser::TableStatementContext::TableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::TableStatementContext::TABLE() {
  return getToken(MySqlParser::TABLE, 0);
}

MySqlParser::TableNameContext* MySqlParser::TableStatementContext::tableName() {
  return getRuleContext<MySqlParser::TableNameContext>(0);
}

MySqlParser::OrderByClauseContext* MySqlParser::TableStatementContext::orderByClause() {
  return getRuleContext<MySqlParser::OrderByClauseContext>(0);
}

MySqlParser::LimitClauseContext* MySqlParser::TableStatementContext::limitClause() {
  return getRuleContext<MySqlParser::LimitClauseContext>(0);
}


size_t MySqlParser::TableStatementContext::getRuleIndex() const {
  return MySqlParser::RuleTableStatement;
}

void MySqlParser::TableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableStatement(this);
}

void MySqlParser::TableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableStatement(this);
}


std::any MySqlParser::TableStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TableStatementContext* MySqlParser::tableStatement() {
  TableStatementContext *_localctx = _tracker.createInstance<TableStatementContext>(_ctx, getState());
  enterRule(_localctx, 536, MySqlParser::RuleTableStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6157);
    match(MySqlParser::TABLE);
    setState(6158);
    tableName();
    setState(6160);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ORDER) {
      setState(6159);
      orderByClause();
    }
    setState(6163);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::LIMIT) {
      setState(6162);
      limitClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DiagnosticsStatementContext ------------------------------------------------------------------

MySqlParser::DiagnosticsStatementContext::DiagnosticsStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DiagnosticsStatementContext::GET() {
  return getToken(MySqlParser::GET, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsStatementContext::DIAGNOSTICS() {
  return getToken(MySqlParser::DIAGNOSTICS, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsStatementContext::CURRENT() {
  return getToken(MySqlParser::CURRENT, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsStatementContext::STACKED() {
  return getToken(MySqlParser::STACKED, 0);
}

std::vector<MySqlParser::VariableClauseContext *> MySqlParser::DiagnosticsStatementContext::variableClause() {
  return getRuleContexts<MySqlParser::VariableClauseContext>();
}

MySqlParser::VariableClauseContext* MySqlParser::DiagnosticsStatementContext::variableClause(size_t i) {
  return getRuleContext<MySqlParser::VariableClauseContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::DiagnosticsStatementContext::EQUAL_SYMBOL() {
  return getTokens(MySqlParser::EQUAL_SYMBOL);
}

tree::TerminalNode* MySqlParser::DiagnosticsStatementContext::EQUAL_SYMBOL(size_t i) {
  return getToken(MySqlParser::EQUAL_SYMBOL, i);
}

tree::TerminalNode* MySqlParser::DiagnosticsStatementContext::CONDITION() {
  return getToken(MySqlParser::CONDITION, 0);
}

std::vector<MySqlParser::DiagnosticsConditionInformationNameContext *> MySqlParser::DiagnosticsStatementContext::diagnosticsConditionInformationName() {
  return getRuleContexts<MySqlParser::DiagnosticsConditionInformationNameContext>();
}

MySqlParser::DiagnosticsConditionInformationNameContext* MySqlParser::DiagnosticsStatementContext::diagnosticsConditionInformationName(size_t i) {
  return getRuleContext<MySqlParser::DiagnosticsConditionInformationNameContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::DiagnosticsStatementContext::NUMBER() {
  return getTokens(MySqlParser::NUMBER);
}

tree::TerminalNode* MySqlParser::DiagnosticsStatementContext::NUMBER(size_t i) {
  return getToken(MySqlParser::NUMBER, i);
}

std::vector<tree::TerminalNode *> MySqlParser::DiagnosticsStatementContext::ROW_COUNT() {
  return getTokens(MySqlParser::ROW_COUNT);
}

tree::TerminalNode* MySqlParser::DiagnosticsStatementContext::ROW_COUNT(size_t i) {
  return getToken(MySqlParser::ROW_COUNT, i);
}

MySqlParser::DecimalLiteralContext* MySqlParser::DiagnosticsStatementContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::DiagnosticsStatementContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::DiagnosticsStatementContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::DiagnosticsStatementContext::getRuleIndex() const {
  return MySqlParser::RuleDiagnosticsStatement;
}

void MySqlParser::DiagnosticsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDiagnosticsStatement(this);
}

void MySqlParser::DiagnosticsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDiagnosticsStatement(this);
}


std::any MySqlParser::DiagnosticsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDiagnosticsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DiagnosticsStatementContext* MySqlParser::diagnosticsStatement() {
  DiagnosticsStatementContext *_localctx = _tracker.createInstance<DiagnosticsStatementContext>(_ctx, getState());
  enterRule(_localctx, 538, MySqlParser::RuleDiagnosticsStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6165);
    match(MySqlParser::GET);
    setState(6167);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::CURRENT || _la == MySqlParser::STACKED) {
      setState(6166);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::CURRENT || _la == MySqlParser::STACKED)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(6169);
    match(MySqlParser::DIAGNOSTICS);
    setState(6201);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 906, _ctx)) {
    case 1: {
      setState(6170);
      variableClause();
      setState(6171);
      match(MySqlParser::EQUAL_SYMBOL);
      setState(6172);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::NUMBER || _la == MySqlParser::ROW_COUNT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6180);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(6173);
        match(MySqlParser::COMMA);
        setState(6174);
        variableClause();
        setState(6175);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(6176);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::NUMBER || _la == MySqlParser::ROW_COUNT)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6182);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      setState(6183);
      match(MySqlParser::CONDITION);
      setState(6186);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::ZERO_DECIMAL:
        case MySqlParser::ONE_DECIMAL:
        case MySqlParser::TWO_DECIMAL:
        case MySqlParser::DECIMAL_LITERAL:
        case MySqlParser::REAL_LITERAL: {
          setState(6184);
          decimalLiteral();
          break;
        }

        case MySqlParser::ATTRIBUTE:
        case MySqlParser::BUCKETS:
        case MySqlParser::CONDITION:
        case MySqlParser::CURRENT:
        case MySqlParser::CURRENT_USER:
        case MySqlParser::DATABASE:
        case MySqlParser::DEFAULT:
        case MySqlParser::DIAGNOSTICS:
        case MySqlParser::EMPTY:
        case MySqlParser::ENFORCED:
        case MySqlParser::EXCEPT:
        case MySqlParser::GROUP:
        case MySqlParser::IF:
        case MySqlParser::IGNORED:
        case MySqlParser::INSERT:
        case MySqlParser::LATERAL:
        case MySqlParser::LEFT:
        case MySqlParser::NUMBER:
        case MySqlParser::OPTIONAL:
        case MySqlParser::ORDER:
        case MySqlParser::PRIMARY:
        case MySqlParser::REPLACE:
        case MySqlParser::RIGHT:
        case MySqlParser::SCHEMA:
        case MySqlParser::SKIP_QUERY_REWRITE:
        case MySqlParser::STACKED:
        case MySqlParser::DATE:
        case MySqlParser::TIME:
        case MySqlParser::TIMESTAMP:
        case MySqlParser::DATETIME:
        case MySqlParser::YEAR:
        case MySqlParser::BINARY:
        case MySqlParser::TEXT:
        case MySqlParser::ENUM:
        case MySqlParser::SERIAL:
        case MySqlParser::JSON_ARRAY:
        case MySqlParser::JSON_ARRAYAGG:
        case MySqlParser::JSON_ARRAY_APPEND:
        case MySqlParser::JSON_ARRAY_INSERT:
        case MySqlParser::JSON_CONTAINS:
        case MySqlParser::JSON_CONTAINS_PATH:
        case MySqlParser::JSON_DEPTH:
        case MySqlParser::JSON_EXTRACT:
        case MySqlParser::JSON_INSERT:
        case MySqlParser::JSON_KEYS:
        case MySqlParser::JSON_LENGTH:
        case MySqlParser::JSON_MERGE:
        case MySqlParser::JSON_MERGE_PATCH:
        case MySqlParser::JSON_MERGE_PRESERVE:
        case MySqlParser::JSON_OBJECT:
        case MySqlParser::JSON_OBJECTAGG:
        case MySqlParser::JSON_OVERLAPS:
        case MySqlParser::JSON_PRETTY:
        case MySqlParser::JSON_QUOTE:
        case MySqlParser::JSON_REMOVE:
        case MySqlParser::JSON_REPLACE:
        case MySqlParser::JSON_SCHEMA_VALID:
        case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
        case MySqlParser::JSON_SEARCH:
        case MySqlParser::JSON_SET:
        case MySqlParser::JSON_STORAGE_FREE:
        case MySqlParser::JSON_STORAGE_SIZE:
        case MySqlParser::JSON_TABLE:
        case MySqlParser::JSON_TYPE:
        case MySqlParser::JSON_UNQUOTE:
        case MySqlParser::JSON_VALID:
        case MySqlParser::JSON_VALUE:
        case MySqlParser::NESTED:
        case MySqlParser::ORDINALITY:
        case MySqlParser::PATH:
        case MySqlParser::AVG:
        case MySqlParser::BIT_AND:
        case MySqlParser::BIT_OR:
        case MySqlParser::BIT_XOR:
        case MySqlParser::COUNT:
        case MySqlParser::CUME_DIST:
        case MySqlParser::DENSE_RANK:
        case MySqlParser::FIRST_VALUE:
        case MySqlParser::GROUP_CONCAT:
        case MySqlParser::LAG:
        case MySqlParser::LAST_VALUE:
        case MySqlParser::LEAD:
        case MySqlParser::MAX:
        case MySqlParser::MIN:
        case MySqlParser::NTILE:
        case MySqlParser::NTH_VALUE:
        case MySqlParser::PERCENT_RANK:
        case MySqlParser::RANK:
        case MySqlParser::ROW_NUMBER:
        case MySqlParser::STD:
        case MySqlParser::STDDEV:
        case MySqlParser::STDDEV_POP:
        case MySqlParser::STDDEV_SAMP:
        case MySqlParser::SUM:
        case MySqlParser::VAR_POP:
        case MySqlParser::VAR_SAMP:
        case MySqlParser::VARIANCE:
        case MySqlParser::CURRENT_DATE:
        case MySqlParser::CURRENT_TIME:
        case MySqlParser::CURRENT_TIMESTAMP:
        case MySqlParser::LOCALTIME:
        case MySqlParser::CURDATE:
        case MySqlParser::CURTIME:
        case MySqlParser::DATE_ADD:
        case MySqlParser::DATE_SUB:
        case MySqlParser::LOCALTIMESTAMP:
        case MySqlParser::NOW:
        case MySqlParser::POSITION:
        case MySqlParser::SUBSTR:
        case MySqlParser::SUBSTRING:
        case MySqlParser::SYSDATE:
        case MySqlParser::TRIM:
        case MySqlParser::UTC_DATE:
        case MySqlParser::UTC_TIME:
        case MySqlParser::UTC_TIMESTAMP:
        case MySqlParser::ACCOUNT:
        case MySqlParser::ACTION:
        case MySqlParser::AFTER:
        case MySqlParser::AGGREGATE:
        case MySqlParser::ALGORITHM:
        case MySqlParser::ANY:
        case MySqlParser::AT:
        case MySqlParser::AUTHORS:
        case MySqlParser::AUTOCOMMIT:
        case MySqlParser::AUTOEXTEND_SIZE:
        case MySqlParser::AUTO_INCREMENT:
        case MySqlParser::AVG_ROW_LENGTH:
        case MySqlParser::BEGIN:
        case MySqlParser::BINLOG:
        case MySqlParser::BIT:
        case MySqlParser::BLOCK:
        case MySqlParser::BOOL:
        case MySqlParser::BOOLEAN:
        case MySqlParser::BTREE:
        case MySqlParser::CACHE:
        case MySqlParser::CASCADED:
        case MySqlParser::CHAIN:
        case MySqlParser::CHANGED:
        case MySqlParser::CHANNEL:
        case MySqlParser::CHECKSUM:
        case MySqlParser::PAGE_CHECKSUM:
        case MySqlParser::CIPHER:
        case MySqlParser::CLASS_ORIGIN:
        case MySqlParser::CLIENT:
        case MySqlParser::CLOSE:
        case MySqlParser::CLUSTERING:
        case MySqlParser::COALESCE:
        case MySqlParser::CODE:
        case MySqlParser::COLUMNS:
        case MySqlParser::COLUMN_FORMAT:
        case MySqlParser::COLUMN_NAME:
        case MySqlParser::COMMENT:
        case MySqlParser::COMMIT:
        case MySqlParser::COMPACT:
        case MySqlParser::COMPLETION:
        case MySqlParser::COMPRESSED:
        case MySqlParser::COMPRESSION:
        case MySqlParser::CONCURRENT:
        case MySqlParser::CONNECT:
        case MySqlParser::CONNECTION:
        case MySqlParser::CONSISTENT:
        case MySqlParser::CONSTRAINT_CATALOG:
        case MySqlParser::CONSTRAINT_SCHEMA:
        case MySqlParser::CONSTRAINT_NAME:
        case MySqlParser::CONTAINS:
        case MySqlParser::CONTEXT:
        case MySqlParser::CONTRIBUTORS:
        case MySqlParser::COPY:
        case MySqlParser::CPU:
        case MySqlParser::CURSOR_NAME:
        case MySqlParser::DATA:
        case MySqlParser::DATAFILE:
        case MySqlParser::DEALLOCATE:
        case MySqlParser::DEFAULT_AUTH:
        case MySqlParser::DEFINER:
        case MySqlParser::DELAY_KEY_WRITE:
        case MySqlParser::DES_KEY_FILE:
        case MySqlParser::DIRECTORY:
        case MySqlParser::DISABLE:
        case MySqlParser::DISCARD:
        case MySqlParser::DISK:
        case MySqlParser::DO:
        case MySqlParser::DUMPFILE:
        case MySqlParser::DUPLICATE:
        case MySqlParser::DYNAMIC:
        case MySqlParser::ENABLE:
        case MySqlParser::ENCRYPTION:
        case MySqlParser::END:
        case MySqlParser::ENDS:
        case MySqlParser::ENGINE:
        case MySqlParser::ENGINES:
        case MySqlParser::ERROR:
        case MySqlParser::ERRORS:
        case MySqlParser::ESCAPE:
        case MySqlParser::EVEN:
        case MySqlParser::EVENT:
        case MySqlParser::EVENTS:
        case MySqlParser::EVERY:
        case MySqlParser::EXCHANGE:
        case MySqlParser::EXCLUSIVE:
        case MySqlParser::EXPIRE:
        case MySqlParser::EXPORT:
        case MySqlParser::EXTENDED:
        case MySqlParser::EXTENT_SIZE:
        case MySqlParser::FAILED_LOGIN_ATTEMPTS:
        case MySqlParser::FAST:
        case MySqlParser::FAULTS:
        case MySqlParser::FIELDS:
        case MySqlParser::FILE_BLOCK_SIZE:
        case MySqlParser::FILTER:
        case MySqlParser::FIRST:
        case MySqlParser::FIXED:
        case MySqlParser::FLUSH:
        case MySqlParser::FOLLOWS:
        case MySqlParser::FOUND:
        case MySqlParser::FULL:
        case MySqlParser::FUNCTION:
        case MySqlParser::GENERAL:
        case MySqlParser::GLOBAL:
        case MySqlParser::GRANTS:
        case MySqlParser::GROUP_REPLICATION:
        case MySqlParser::HANDLER:
        case MySqlParser::HASH:
        case MySqlParser::HELP:
        case MySqlParser::HISTORY:
        case MySqlParser::HOST:
        case MySqlParser::HOSTS:
        case MySqlParser::IDENTIFIED:
        case MySqlParser::IGNORE_SERVER_IDS:
        case MySqlParser::IMPORT:
        case MySqlParser::INDEXES:
        case MySqlParser::INITIAL_SIZE:
        case MySqlParser::INPLACE:
        case MySqlParser::INSERT_METHOD:
        case MySqlParser::INSTALL:
        case MySqlParser::INSTANCE:
        case MySqlParser::INSTANT:
        case MySqlParser::INVISIBLE:
        case MySqlParser::INVOKER:
        case MySqlParser::IO:
        case MySqlParser::IO_THREAD:
        case MySqlParser::IPC:
        case MySqlParser::ISOLATION:
        case MySqlParser::ISSUER:
        case MySqlParser::JSON:
        case MySqlParser::KEY_BLOCK_SIZE:
        case MySqlParser::LANGUAGE:
        case MySqlParser::LAST:
        case MySqlParser::LEAVES:
        case MySqlParser::LESS:
        case MySqlParser::LEVEL:
        case MySqlParser::LIST:
        case MySqlParser::LOCAL:
        case MySqlParser::LOGFILE:
        case MySqlParser::LOGS:
        case MySqlParser::MASTER:
        case MySqlParser::MASTER_AUTO_POSITION:
        case MySqlParser::MASTER_CONNECT_RETRY:
        case MySqlParser::MASTER_DELAY:
        case MySqlParser::MASTER_HEARTBEAT_PERIOD:
        case MySqlParser::MASTER_HOST:
        case MySqlParser::MASTER_LOG_FILE:
        case MySqlParser::MASTER_LOG_POS:
        case MySqlParser::MASTER_PASSWORD:
        case MySqlParser::MASTER_PORT:
        case MySqlParser::MASTER_RETRY_COUNT:
        case MySqlParser::MASTER_SSL:
        case MySqlParser::MASTER_SSL_CA:
        case MySqlParser::MASTER_SSL_CAPATH:
        case MySqlParser::MASTER_SSL_CERT:
        case MySqlParser::MASTER_SSL_CIPHER:
        case MySqlParser::MASTER_SSL_CRL:
        case MySqlParser::MASTER_SSL_CRLPATH:
        case MySqlParser::MASTER_SSL_KEY:
        case MySqlParser::MASTER_TLS_VERSION:
        case MySqlParser::MASTER_USER:
        case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
        case MySqlParser::MAX_QUERIES_PER_HOUR:
        case MySqlParser::MAX_ROWS:
        case MySqlParser::MAX_SIZE:
        case MySqlParser::MAX_UPDATES_PER_HOUR:
        case MySqlParser::MAX_USER_CONNECTIONS:
        case MySqlParser::MEDIUM:
        case MySqlParser::MEMBER:
        case MySqlParser::MERGE:
        case MySqlParser::MESSAGE_TEXT:
        case MySqlParser::MID:
        case MySqlParser::MIGRATE:
        case MySqlParser::MIN_ROWS:
        case MySqlParser::MODE:
        case MySqlParser::MODIFY:
        case MySqlParser::MUTEX:
        case MySqlParser::MYSQL:
        case MySqlParser::MYSQL_ERRNO:
        case MySqlParser::NAME:
        case MySqlParser::NAMES:
        case MySqlParser::NCHAR:
        case MySqlParser::NEVER:
        case MySqlParser::NEXT:
        case MySqlParser::NO:
        case MySqlParser::NOCOPY:
        case MySqlParser::NOWAIT:
        case MySqlParser::NODEGROUP:
        case MySqlParser::NONE:
        case MySqlParser::ODBC:
        case MySqlParser::OFFLINE:
        case MySqlParser::OFFSET:
        case MySqlParser::OF:
        case MySqlParser::OJ:
        case MySqlParser::OLD_PASSWORD:
        case MySqlParser::ONE:
        case MySqlParser::ONLINE:
        case MySqlParser::ONLY:
        case MySqlParser::OPEN:
        case MySqlParser::OPTIMIZER_COSTS:
        case MySqlParser::OPTIONS:
        case MySqlParser::OWNER:
        case MySqlParser::PACK_KEYS:
        case MySqlParser::PAGE:
        case MySqlParser::PARSER:
        case MySqlParser::PARTIAL:
        case MySqlParser::PARTITIONING:
        case MySqlParser::PARTITIONS:
        case MySqlParser::PASSWORD:
        case MySqlParser::PASSWORD_LOCK_TIME:
        case MySqlParser::PHASE:
        case MySqlParser::PLUGIN:
        case MySqlParser::PLUGIN_DIR:
        case MySqlParser::PLUGINS:
        case MySqlParser::PORT:
        case MySqlParser::PRECEDES:
        case MySqlParser::PREPARE:
        case MySqlParser::PRESERVE:
        case MySqlParser::PREV:
        case MySqlParser::PROCESSLIST:
        case MySqlParser::PROFILE:
        case MySqlParser::PROFILES:
        case MySqlParser::PROXY:
        case MySqlParser::QUERY:
        case MySqlParser::QUICK:
        case MySqlParser::REBUILD:
        case MySqlParser::RECOVER:
        case MySqlParser::RECURSIVE:
        case MySqlParser::REDO_BUFFER_SIZE:
        case MySqlParser::REDUNDANT:
        case MySqlParser::RELAY:
        case MySqlParser::RELAY_LOG_FILE:
        case MySqlParser::RELAY_LOG_POS:
        case MySqlParser::RELAYLOG:
        case MySqlParser::REMOVE:
        case MySqlParser::REORGANIZE:
        case MySqlParser::REPAIR:
        case MySqlParser::REPLICATE_DO_DB:
        case MySqlParser::REPLICATE_DO_TABLE:
        case MySqlParser::REPLICATE_IGNORE_DB:
        case MySqlParser::REPLICATE_IGNORE_TABLE:
        case MySqlParser::REPLICATE_REWRITE_DB:
        case MySqlParser::REPLICATE_WILD_DO_TABLE:
        case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
        case MySqlParser::REPLICATION:
        case MySqlParser::RESET:
        case MySqlParser::RESUME:
        case MySqlParser::RETURNED_SQLSTATE:
        case MySqlParser::RETURNS:
        case MySqlParser::REUSE:
        case MySqlParser::ROLE:
        case MySqlParser::ROLLBACK:
        case MySqlParser::ROLLUP:
        case MySqlParser::ROTATE:
        case MySqlParser::ROW:
        case MySqlParser::ROWS:
        case MySqlParser::ROW_FORMAT:
        case MySqlParser::RTREE:
        case MySqlParser::SAVEPOINT:
        case MySqlParser::SCHEDULE:
        case MySqlParser::SECURITY:
        case MySqlParser::SERVER:
        case MySqlParser::SESSION:
        case MySqlParser::SHARE:
        case MySqlParser::SHARED:
        case MySqlParser::SIGNED:
        case MySqlParser::SIMPLE:
        case MySqlParser::SLAVE:
        case MySqlParser::SLOW:
        case MySqlParser::SNAPSHOT:
        case MySqlParser::SOCKET:
        case MySqlParser::SOME:
        case MySqlParser::SONAME:
        case MySqlParser::SOUNDS:
        case MySqlParser::SOURCE:
        case MySqlParser::SQL_AFTER_GTIDS:
        case MySqlParser::SQL_AFTER_MTS_GAPS:
        case MySqlParser::SQL_BEFORE_GTIDS:
        case MySqlParser::SQL_BUFFER_RESULT:
        case MySqlParser::SQL_CACHE:
        case MySqlParser::SQL_NO_CACHE:
        case MySqlParser::SQL_THREAD:
        case MySqlParser::START:
        case MySqlParser::STARTS:
        case MySqlParser::STATS_AUTO_RECALC:
        case MySqlParser::STATS_PERSISTENT:
        case MySqlParser::STATS_SAMPLE_PAGES:
        case MySqlParser::STATUS:
        case MySqlParser::STOP:
        case MySqlParser::STORAGE:
        case MySqlParser::STRING:
        case MySqlParser::SUBCLASS_ORIGIN:
        case MySqlParser::SUBJECT:
        case MySqlParser::SUBPARTITION:
        case MySqlParser::SUBPARTITIONS:
        case MySqlParser::SUSPEND:
        case MySqlParser::SWAPS:
        case MySqlParser::SWITCHES:
        case MySqlParser::TABLE_NAME:
        case MySqlParser::TABLESPACE:
        case MySqlParser::TABLE_TYPE:
        case MySqlParser::TEMPORARY:
        case MySqlParser::TEMPTABLE:
        case MySqlParser::THAN:
        case MySqlParser::TRADITIONAL:
        case MySqlParser::TRANSACTION:
        case MySqlParser::TRANSACTIONAL:
        case MySqlParser::TRIGGERS:
        case MySqlParser::TRUNCATE:
        case MySqlParser::UNBOUNDED:
        case MySqlParser::UNDEFINED:
        case MySqlParser::UNDOFILE:
        case MySqlParser::UNDO_BUFFER_SIZE:
        case MySqlParser::UNINSTALL:
        case MySqlParser::UNKNOWN:
        case MySqlParser::UNTIL:
        case MySqlParser::UPGRADE:
        case MySqlParser::USER:
        case MySqlParser::USE_FRM:
        case MySqlParser::USER_RESOURCES:
        case MySqlParser::VALIDATION:
        case MySqlParser::VALUE:
        case MySqlParser::VARIABLES:
        case MySqlParser::VIEW:
        case MySqlParser::VIRTUAL:
        case MySqlParser::VISIBLE:
        case MySqlParser::WAIT:
        case MySqlParser::WARNINGS:
        case MySqlParser::WITHOUT:
        case MySqlParser::WORK:
        case MySqlParser::WRAPPER:
        case MySqlParser::X509:
        case MySqlParser::XA:
        case MySqlParser::XML:
        case MySqlParser::EUR:
        case MySqlParser::USA:
        case MySqlParser::JIS:
        case MySqlParser::ISO:
        case MySqlParser::INTERNAL:
        case MySqlParser::QUARTER:
        case MySqlParser::MONTH:
        case MySqlParser::DAY:
        case MySqlParser::HOUR:
        case MySqlParser::MINUTE:
        case MySqlParser::WEEK:
        case MySqlParser::SECOND:
        case MySqlParser::MICROSECOND:
        case MySqlParser::ADMIN:
        case MySqlParser::AUDIT_ABORT_EXEMPT:
        case MySqlParser::AUDIT_ADMIN:
        case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
        case MySqlParser::BACKUP_ADMIN:
        case MySqlParser::BINLOG_ADMIN:
        case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
        case MySqlParser::CLONE_ADMIN:
        case MySqlParser::CONNECTION_ADMIN:
        case MySqlParser::ENCRYPTION_KEY_ADMIN:
        case MySqlParser::EXECUTE:
        case MySqlParser::FILE:
        case MySqlParser::FIREWALL_ADMIN:
        case MySqlParser::FIREWALL_EXEMPT:
        case MySqlParser::FIREWALL_USER:
        case MySqlParser::GROUP_REPLICATION_ADMIN:
        case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
        case MySqlParser::INVOKE:
        case MySqlParser::LAMBDA:
        case MySqlParser::NDB_STORED_USER:
        case MySqlParser::PASSWORDLESS_USER_ADMIN:
        case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
        case MySqlParser::PRIVILEGES:
        case MySqlParser::PROCESS:
        case MySqlParser::RELOAD:
        case MySqlParser::REPLICATION_APPLIER:
        case MySqlParser::REPLICATION_SLAVE_ADMIN:
        case MySqlParser::RESOURCE_GROUP_ADMIN:
        case MySqlParser::RESOURCE_GROUP_USER:
        case MySqlParser::ROLE_ADMIN:
        case MySqlParser::ROUTINE:
        case MySqlParser::S3:
        case MySqlParser::SESSION_VARIABLES_ADMIN:
        case MySqlParser::SET_USER_ID:
        case MySqlParser::SHOW_ROUTINE:
        case MySqlParser::SHUTDOWN:
        case MySqlParser::SUPER:
        case MySqlParser::SYSTEM_VARIABLES_ADMIN:
        case MySqlParser::TABLES:
        case MySqlParser::TABLE_ENCRYPTION_ADMIN:
        case MySqlParser::VERSION_TOKEN_ADMIN:
        case MySqlParser::XA_RECOVER_ADMIN:
        case MySqlParser::ARMSCII8:
        case MySqlParser::ASCII:
        case MySqlParser::BIG5:
        case MySqlParser::CP1250:
        case MySqlParser::CP1251:
        case MySqlParser::CP1256:
        case MySqlParser::CP1257:
        case MySqlParser::CP850:
        case MySqlParser::CP852:
        case MySqlParser::CP866:
        case MySqlParser::CP932:
        case MySqlParser::DEC8:
        case MySqlParser::EUCJPMS:
        case MySqlParser::EUCKR:
        case MySqlParser::GB18030:
        case MySqlParser::GB2312:
        case MySqlParser::GBK:
        case MySqlParser::GEOSTD8:
        case MySqlParser::GREEK:
        case MySqlParser::HEBREW:
        case MySqlParser::HP8:
        case MySqlParser::KEYBCS2:
        case MySqlParser::KOI8R:
        case MySqlParser::KOI8U:
        case MySqlParser::LATIN1:
        case MySqlParser::LATIN2:
        case MySqlParser::LATIN5:
        case MySqlParser::LATIN7:
        case MySqlParser::MACCE:
        case MySqlParser::MACROMAN:
        case MySqlParser::SJIS:
        case MySqlParser::SWE7:
        case MySqlParser::TIS620:
        case MySqlParser::UCS2:
        case MySqlParser::UJIS:
        case MySqlParser::UTF16:
        case MySqlParser::UTF16LE:
        case MySqlParser::UTF32:
        case MySqlParser::UTF8:
        case MySqlParser::UTF8MB3:
        case MySqlParser::UTF8MB4:
        case MySqlParser::ARCHIVE:
        case MySqlParser::BLACKHOLE:
        case MySqlParser::CSV:
        case MySqlParser::FEDERATED:
        case MySqlParser::INNODB:
        case MySqlParser::MEMORY:
        case MySqlParser::MRG_MYISAM:
        case MySqlParser::MYISAM:
        case MySqlParser::NDB:
        case MySqlParser::NDBCLUSTER:
        case MySqlParser::PERFORMANCE_SCHEMA:
        case MySqlParser::TOKUDB:
        case MySqlParser::REPEATABLE:
        case MySqlParser::COMMITTED:
        case MySqlParser::UNCOMMITTED:
        case MySqlParser::SERIALIZABLE:
        case MySqlParser::GEOMETRYCOLLECTION:
        case MySqlParser::LINESTRING:
        case MySqlParser::MULTILINESTRING:
        case MySqlParser::MULTIPOINT:
        case MySqlParser::MULTIPOLYGON:
        case MySqlParser::POINT:
        case MySqlParser::POLYGON:
        case MySqlParser::ABS:
        case MySqlParser::ACOS:
        case MySqlParser::ADDDATE:
        case MySqlParser::ADDTIME:
        case MySqlParser::AES_DECRYPT:
        case MySqlParser::AES_ENCRYPT:
        case MySqlParser::AREA:
        case MySqlParser::ASBINARY:
        case MySqlParser::ASIN:
        case MySqlParser::ASTEXT:
        case MySqlParser::ASWKB:
        case MySqlParser::ASWKT:
        case MySqlParser::ASYMMETRIC_DECRYPT:
        case MySqlParser::ASYMMETRIC_DERIVE:
        case MySqlParser::ASYMMETRIC_ENCRYPT:
        case MySqlParser::ASYMMETRIC_SIGN:
        case MySqlParser::ASYMMETRIC_VERIFY:
        case MySqlParser::ATAN:
        case MySqlParser::ATAN2:
        case MySqlParser::BENCHMARK:
        case MySqlParser::BIN:
        case MySqlParser::BIT_COUNT:
        case MySqlParser::BIT_LENGTH:
        case MySqlParser::BUFFER:
        case MySqlParser::CATALOG_NAME:
        case MySqlParser::CEIL:
        case MySqlParser::CEILING:
        case MySqlParser::CENTROID:
        case MySqlParser::CHARACTER_LENGTH:
        case MySqlParser::CHARSET:
        case MySqlParser::CHAR_LENGTH:
        case MySqlParser::COERCIBILITY:
        case MySqlParser::COLLATION:
        case MySqlParser::COMPRESS:
        case MySqlParser::CONCAT:
        case MySqlParser::CONCAT_WS:
        case MySqlParser::CONNECTION_ID:
        case MySqlParser::CONV:
        case MySqlParser::CONVERT_TZ:
        case MySqlParser::COS:
        case MySqlParser::COT:
        case MySqlParser::CRC32:
        case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
        case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
        case MySqlParser::CREATE_DH_PARAMETERS:
        case MySqlParser::CREATE_DIGEST:
        case MySqlParser::CROSSES:
        case MySqlParser::DATEDIFF:
        case MySqlParser::DATE_FORMAT:
        case MySqlParser::DAYNAME:
        case MySqlParser::DAYOFMONTH:
        case MySqlParser::DAYOFWEEK:
        case MySqlParser::DAYOFYEAR:
        case MySqlParser::DECODE:
        case MySqlParser::DEGREES:
        case MySqlParser::DES_DECRYPT:
        case MySqlParser::DES_ENCRYPT:
        case MySqlParser::DIMENSION:
        case MySqlParser::DISJOINT:
        case MySqlParser::ELT:
        case MySqlParser::ENCODE:
        case MySqlParser::ENCRYPT:
        case MySqlParser::ENDPOINT:
        case MySqlParser::ENGINE_ATTRIBUTE:
        case MySqlParser::ENVELOPE:
        case MySqlParser::EQUALS:
        case MySqlParser::EXP:
        case MySqlParser::EXPORT_SET:
        case MySqlParser::EXTERIORRING:
        case MySqlParser::EXTRACTVALUE:
        case MySqlParser::FIELD:
        case MySqlParser::FIND_IN_SET:
        case MySqlParser::FLOOR:
        case MySqlParser::FORMAT:
        case MySqlParser::FOUND_ROWS:
        case MySqlParser::FROM_BASE64:
        case MySqlParser::FROM_DAYS:
        case MySqlParser::FROM_UNIXTIME:
        case MySqlParser::GEOMCOLLFROMTEXT:
        case MySqlParser::GEOMCOLLFROMWKB:
        case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
        case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
        case MySqlParser::GEOMETRYFROMTEXT:
        case MySqlParser::GEOMETRYFROMWKB:
        case MySqlParser::GEOMETRYN:
        case MySqlParser::GEOMETRYTYPE:
        case MySqlParser::GEOMFROMTEXT:
        case MySqlParser::GEOMFROMWKB:
        case MySqlParser::GET_FORMAT:
        case MySqlParser::GET_LOCK:
        case MySqlParser::GLENGTH:
        case MySqlParser::GREATEST:
        case MySqlParser::GTID_SUBSET:
        case MySqlParser::GTID_SUBTRACT:
        case MySqlParser::HEX:
        case MySqlParser::IFNULL:
        case MySqlParser::INET6_ATON:
        case MySqlParser::INET6_NTOA:
        case MySqlParser::INET_ATON:
        case MySqlParser::INET_NTOA:
        case MySqlParser::INSTR:
        case MySqlParser::INTERIORRINGN:
        case MySqlParser::INTERSECTS:
        case MySqlParser::ISCLOSED:
        case MySqlParser::ISEMPTY:
        case MySqlParser::ISNULL:
        case MySqlParser::ISSIMPLE:
        case MySqlParser::IS_FREE_LOCK:
        case MySqlParser::IS_IPV4:
        case MySqlParser::IS_IPV4_COMPAT:
        case MySqlParser::IS_IPV4_MAPPED:
        case MySqlParser::IS_IPV6:
        case MySqlParser::IS_USED_LOCK:
        case MySqlParser::LAST_INSERT_ID:
        case MySqlParser::LCASE:
        case MySqlParser::LEAST:
        case MySqlParser::LENGTH:
        case MySqlParser::LINEFROMTEXT:
        case MySqlParser::LINEFROMWKB:
        case MySqlParser::LINESTRINGFROMTEXT:
        case MySqlParser::LINESTRINGFROMWKB:
        case MySqlParser::LN:
        case MySqlParser::LOAD_FILE:
        case MySqlParser::LOCATE:
        case MySqlParser::LOG:
        case MySqlParser::LOG10:
        case MySqlParser::LOG2:
        case MySqlParser::LOWER:
        case MySqlParser::LPAD:
        case MySqlParser::LTRIM:
        case MySqlParser::MAKEDATE:
        case MySqlParser::MAKETIME:
        case MySqlParser::MAKE_SET:
        case MySqlParser::MASTER_POS_WAIT:
        case MySqlParser::MBRCONTAINS:
        case MySqlParser::MBRDISJOINT:
        case MySqlParser::MBREQUAL:
        case MySqlParser::MBRINTERSECTS:
        case MySqlParser::MBROVERLAPS:
        case MySqlParser::MBRTOUCHES:
        case MySqlParser::MBRWITHIN:
        case MySqlParser::MD5:
        case MySqlParser::MLINEFROMTEXT:
        case MySqlParser::MLINEFROMWKB:
        case MySqlParser::MONTHNAME:
        case MySqlParser::MPOINTFROMTEXT:
        case MySqlParser::MPOINTFROMWKB:
        case MySqlParser::MPOLYFROMTEXT:
        case MySqlParser::MPOLYFROMWKB:
        case MySqlParser::MULTILINESTRINGFROMTEXT:
        case MySqlParser::MULTILINESTRINGFROMWKB:
        case MySqlParser::MULTIPOINTFROMTEXT:
        case MySqlParser::MULTIPOINTFROMWKB:
        case MySqlParser::MULTIPOLYGONFROMTEXT:
        case MySqlParser::MULTIPOLYGONFROMWKB:
        case MySqlParser::NAME_CONST:
        case MySqlParser::NULLIF:
        case MySqlParser::NUMGEOMETRIES:
        case MySqlParser::NUMINTERIORRINGS:
        case MySqlParser::NUMPOINTS:
        case MySqlParser::OCT:
        case MySqlParser::OCTET_LENGTH:
        case MySqlParser::ORD:
        case MySqlParser::OVERLAPS:
        case MySqlParser::PERIOD_ADD:
        case MySqlParser::PERIOD_DIFF:
        case MySqlParser::PI:
        case MySqlParser::POINTFROMTEXT:
        case MySqlParser::POINTFROMWKB:
        case MySqlParser::POINTN:
        case MySqlParser::POLYFROMTEXT:
        case MySqlParser::POLYFROMWKB:
        case MySqlParser::POLYGONFROMTEXT:
        case MySqlParser::POLYGONFROMWKB:
        case MySqlParser::POW:
        case MySqlParser::POWER:
        case MySqlParser::QUOTE:
        case MySqlParser::RADIANS:
        case MySqlParser::RAND:
        case MySqlParser::RANDOM_BYTES:
        case MySqlParser::RELEASE_LOCK:
        case MySqlParser::REVERSE:
        case MySqlParser::ROUND:
        case MySqlParser::ROW_COUNT:
        case MySqlParser::RPAD:
        case MySqlParser::RTRIM:
        case MySqlParser::SEC_TO_TIME:
        case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
        case MySqlParser::SESSION_USER:
        case MySqlParser::SHA:
        case MySqlParser::SHA1:
        case MySqlParser::SHA2:
        case MySqlParser::SCHEMA_NAME:
        case MySqlParser::SIGN:
        case MySqlParser::SIN:
        case MySqlParser::SLEEP:
        case MySqlParser::SOUNDEX:
        case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
        case MySqlParser::SQRT:
        case MySqlParser::SRID:
        case MySqlParser::STARTPOINT:
        case MySqlParser::STRCMP:
        case MySqlParser::STR_TO_DATE:
        case MySqlParser::ST_AREA:
        case MySqlParser::ST_ASBINARY:
        case MySqlParser::ST_ASTEXT:
        case MySqlParser::ST_ASWKB:
        case MySqlParser::ST_ASWKT:
        case MySqlParser::ST_BUFFER:
        case MySqlParser::ST_CENTROID:
        case MySqlParser::ST_CONTAINS:
        case MySqlParser::ST_CROSSES:
        case MySqlParser::ST_DIFFERENCE:
        case MySqlParser::ST_DIMENSION:
        case MySqlParser::ST_DISJOINT:
        case MySqlParser::ST_DISTANCE:
        case MySqlParser::ST_ENDPOINT:
        case MySqlParser::ST_ENVELOPE:
        case MySqlParser::ST_EQUALS:
        case MySqlParser::ST_EXTERIORRING:
        case MySqlParser::ST_GEOMCOLLFROMTEXT:
        case MySqlParser::ST_GEOMCOLLFROMTXT:
        case MySqlParser::ST_GEOMCOLLFROMWKB:
        case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
        case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
        case MySqlParser::ST_GEOMETRYFROMTEXT:
        case MySqlParser::ST_GEOMETRYFROMWKB:
        case MySqlParser::ST_GEOMETRYN:
        case MySqlParser::ST_GEOMETRYTYPE:
        case MySqlParser::ST_GEOMFROMTEXT:
        case MySqlParser::ST_GEOMFROMWKB:
        case MySqlParser::ST_INTERIORRINGN:
        case MySqlParser::ST_INTERSECTION:
        case MySqlParser::ST_INTERSECTS:
        case MySqlParser::ST_ISCLOSED:
        case MySqlParser::ST_ISEMPTY:
        case MySqlParser::ST_ISSIMPLE:
        case MySqlParser::ST_LINEFROMTEXT:
        case MySqlParser::ST_LINEFROMWKB:
        case MySqlParser::ST_LINESTRINGFROMTEXT:
        case MySqlParser::ST_LINESTRINGFROMWKB:
        case MySqlParser::ST_NUMGEOMETRIES:
        case MySqlParser::ST_NUMINTERIORRING:
        case MySqlParser::ST_NUMINTERIORRINGS:
        case MySqlParser::ST_NUMPOINTS:
        case MySqlParser::ST_OVERLAPS:
        case MySqlParser::ST_POINTFROMTEXT:
        case MySqlParser::ST_POINTFROMWKB:
        case MySqlParser::ST_POINTN:
        case MySqlParser::ST_POLYFROMTEXT:
        case MySqlParser::ST_POLYFROMWKB:
        case MySqlParser::ST_POLYGONFROMTEXT:
        case MySqlParser::ST_POLYGONFROMWKB:
        case MySqlParser::ST_SRID:
        case MySqlParser::ST_STARTPOINT:
        case MySqlParser::ST_SYMDIFFERENCE:
        case MySqlParser::ST_TOUCHES:
        case MySqlParser::ST_UNION:
        case MySqlParser::ST_WITHIN:
        case MySqlParser::ST_X:
        case MySqlParser::ST_Y:
        case MySqlParser::SUBDATE:
        case MySqlParser::SUBSTRING_INDEX:
        case MySqlParser::SUBTIME:
        case MySqlParser::SYSTEM_USER:
        case MySqlParser::TAN:
        case MySqlParser::TIMEDIFF:
        case MySqlParser::TIMESTAMPADD:
        case MySqlParser::TIMESTAMPDIFF:
        case MySqlParser::TIME_FORMAT:
        case MySqlParser::TIME_TO_SEC:
        case MySqlParser::TOUCHES:
        case MySqlParser::TO_BASE64:
        case MySqlParser::TO_DAYS:
        case MySqlParser::TO_SECONDS:
        case MySqlParser::TP_CONNECTION_ADMIN:
        case MySqlParser::UCASE:
        case MySqlParser::UNCOMPRESS:
        case MySqlParser::UNCOMPRESSED_LENGTH:
        case MySqlParser::UNHEX:
        case MySqlParser::UNIX_TIMESTAMP:
        case MySqlParser::UPDATEXML:
        case MySqlParser::UPPER:
        case MySqlParser::UUID:
        case MySqlParser::UUID_SHORT:
        case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
        case MySqlParser::VERSION:
        case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
        case MySqlParser::WEEKDAY:
        case MySqlParser::WEEKOFYEAR:
        case MySqlParser::WEIGHT_STRING:
        case MySqlParser::WITHIN:
        case MySqlParser::YEARWEEK:
        case MySqlParser::Y_FUNCTION:
        case MySqlParser::X_FUNCTION:
        case MySqlParser::MOD:
        case MySqlParser::AT_SIGN:
        case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
        case MySqlParser::STRING_LITERAL:
        case MySqlParser::ID:
        case MySqlParser::LOCAL_ID:
        case MySqlParser::GLOBAL_ID: {
          setState(6185);
          variableClause();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(6188);
      variableClause();
      setState(6189);
      match(MySqlParser::EQUAL_SYMBOL);
      setState(6190);
      diagnosticsConditionInformationName();
      setState(6198);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(6191);
        match(MySqlParser::COMMA);
        setState(6192);
        variableClause();
        setState(6193);
        match(MySqlParser::EQUAL_SYMBOL);
        setState(6194);
        diagnosticsConditionInformationName();
        setState(6200);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DiagnosticsConditionInformationNameContext ------------------------------------------------------------------

MySqlParser::DiagnosticsConditionInformationNameContext::DiagnosticsConditionInformationNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DiagnosticsConditionInformationNameContext::CLASS_ORIGIN() {
  return getToken(MySqlParser::CLASS_ORIGIN, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsConditionInformationNameContext::SUBCLASS_ORIGIN() {
  return getToken(MySqlParser::SUBCLASS_ORIGIN, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsConditionInformationNameContext::RETURNED_SQLSTATE() {
  return getToken(MySqlParser::RETURNED_SQLSTATE, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsConditionInformationNameContext::MESSAGE_TEXT() {
  return getToken(MySqlParser::MESSAGE_TEXT, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsConditionInformationNameContext::MYSQL_ERRNO() {
  return getToken(MySqlParser::MYSQL_ERRNO, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsConditionInformationNameContext::CONSTRAINT_CATALOG() {
  return getToken(MySqlParser::CONSTRAINT_CATALOG, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsConditionInformationNameContext::CONSTRAINT_SCHEMA() {
  return getToken(MySqlParser::CONSTRAINT_SCHEMA, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsConditionInformationNameContext::CONSTRAINT_NAME() {
  return getToken(MySqlParser::CONSTRAINT_NAME, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsConditionInformationNameContext::CATALOG_NAME() {
  return getToken(MySqlParser::CATALOG_NAME, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsConditionInformationNameContext::SCHEMA_NAME() {
  return getToken(MySqlParser::SCHEMA_NAME, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsConditionInformationNameContext::TABLE_NAME() {
  return getToken(MySqlParser::TABLE_NAME, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsConditionInformationNameContext::COLUMN_NAME() {
  return getToken(MySqlParser::COLUMN_NAME, 0);
}

tree::TerminalNode* MySqlParser::DiagnosticsConditionInformationNameContext::CURSOR_NAME() {
  return getToken(MySqlParser::CURSOR_NAME, 0);
}


size_t MySqlParser::DiagnosticsConditionInformationNameContext::getRuleIndex() const {
  return MySqlParser::RuleDiagnosticsConditionInformationName;
}

void MySqlParser::DiagnosticsConditionInformationNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDiagnosticsConditionInformationName(this);
}

void MySqlParser::DiagnosticsConditionInformationNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDiagnosticsConditionInformationName(this);
}


std::any MySqlParser::DiagnosticsConditionInformationNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDiagnosticsConditionInformationName(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DiagnosticsConditionInformationNameContext* MySqlParser::diagnosticsConditionInformationName() {
  DiagnosticsConditionInformationNameContext *_localctx = _tracker.createInstance<DiagnosticsConditionInformationNameContext>(_ctx, getState());
  enterRule(_localctx, 540, MySqlParser::RuleDiagnosticsConditionInformationName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6203);
    _la = _input->LA(1);
    if (!(((((_la - 359) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 359)) & 272105729) != 0) || _la == MySqlParser::MESSAGE_TEXT

    || _la == MySqlParser::MYSQL_ERRNO || ((((_la - 592) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 592)) & 18155135997837313) != 0) || _la == MySqlParser::CATALOG_NAME || _la == MySqlParser::SCHEMA_NAME)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DescribeObjectClauseContext ------------------------------------------------------------------

MySqlParser::DescribeObjectClauseContext::DescribeObjectClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::DescribeObjectClauseContext::getRuleIndex() const {
  return MySqlParser::RuleDescribeObjectClause;
}

void MySqlParser::DescribeObjectClauseContext::copyFrom(DescribeObjectClauseContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- DescribeStatementsContext ------------------------------------------------------------------

MySqlParser::SelectStatementContext* MySqlParser::DescribeStatementsContext::selectStatement() {
  return getRuleContext<MySqlParser::SelectStatementContext>(0);
}

MySqlParser::DeleteStatementContext* MySqlParser::DescribeStatementsContext::deleteStatement() {
  return getRuleContext<MySqlParser::DeleteStatementContext>(0);
}

MySqlParser::InsertStatementContext* MySqlParser::DescribeStatementsContext::insertStatement() {
  return getRuleContext<MySqlParser::InsertStatementContext>(0);
}

MySqlParser::ReplaceStatementContext* MySqlParser::DescribeStatementsContext::replaceStatement() {
  return getRuleContext<MySqlParser::ReplaceStatementContext>(0);
}

MySqlParser::UpdateStatementContext* MySqlParser::DescribeStatementsContext::updateStatement() {
  return getRuleContext<MySqlParser::UpdateStatementContext>(0);
}

MySqlParser::DescribeStatementsContext::DescribeStatementsContext(DescribeObjectClauseContext *ctx) { copyFrom(ctx); }

void MySqlParser::DescribeStatementsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDescribeStatements(this);
}
void MySqlParser::DescribeStatementsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDescribeStatements(this);
}

std::any MySqlParser::DescribeStatementsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDescribeStatements(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DescribeConnectionContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::DescribeConnectionContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

tree::TerminalNode* MySqlParser::DescribeConnectionContext::CONNECTION() {
  return getToken(MySqlParser::CONNECTION, 0);
}

MySqlParser::UidContext* MySqlParser::DescribeConnectionContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

MySqlParser::DescribeConnectionContext::DescribeConnectionContext(DescribeObjectClauseContext *ctx) { copyFrom(ctx); }

void MySqlParser::DescribeConnectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDescribeConnection(this);
}
void MySqlParser::DescribeConnectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDescribeConnection(this);
}

std::any MySqlParser::DescribeConnectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDescribeConnection(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::DescribeObjectClauseContext* MySqlParser::describeObjectClause() {
  DescribeObjectClauseContext *_localctx = _tracker.createInstance<DescribeObjectClauseContext>(_ctx, getState());
  enterRule(_localctx, 542, MySqlParser::RuleDescribeObjectClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6215);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::DELETE:
      case MySqlParser::INSERT:
      case MySqlParser::REPLACE:
      case MySqlParser::SELECT:
      case MySqlParser::UPDATE:
      case MySqlParser::LR_BRACKET: {
        _localctx = _tracker.createInstance<MySqlParser::DescribeStatementsContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(6210);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySqlParser::SELECT:
          case MySqlParser::LR_BRACKET: {
            setState(6205);
            selectStatement();
            break;
          }

          case MySqlParser::DELETE: {
            setState(6206);
            deleteStatement();
            break;
          }

          case MySqlParser::INSERT: {
            setState(6207);
            insertStatement();
            break;
          }

          case MySqlParser::REPLACE: {
            setState(6208);
            replaceStatement();
            break;
          }

          case MySqlParser::UPDATE: {
            setState(6209);
            updateStatement();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySqlParser::FOR: {
        _localctx = _tracker.createInstance<MySqlParser::DescribeConnectionContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(6212);
        match(MySqlParser::FOR);
        setState(6213);
        match(MySqlParser::CONNECTION);
        setState(6214);
        uid();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FullIdContext ------------------------------------------------------------------

MySqlParser::FullIdContext::FullIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::UidContext *> MySqlParser::FullIdContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::FullIdContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

tree::TerminalNode* MySqlParser::FullIdContext::DOT_ID() {
  return getToken(MySqlParser::DOT_ID, 0);
}

tree::TerminalNode* MySqlParser::FullIdContext::DOT() {
  return getToken(MySqlParser::DOT, 0);
}


size_t MySqlParser::FullIdContext::getRuleIndex() const {
  return MySqlParser::RuleFullId;
}

void MySqlParser::FullIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFullId(this);
}

void MySqlParser::FullIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFullId(this);
}


std::any MySqlParser::FullIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFullId(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FullIdContext* MySqlParser::fullId() {
  FullIdContext *_localctx = _tracker.createInstance<FullIdContext>(_ctx, getState());
  enterRule(_localctx, 544, MySqlParser::RuleFullId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6217);
    uid();
    setState(6221);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 909, _ctx)) {
    case 1: {
      setState(6218);
      match(MySqlParser::DOT_ID);
      break;
    }

    case 2: {
      setState(6219);
      match(MySqlParser::DOT);
      setState(6220);
      uid();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableNameContext ------------------------------------------------------------------

MySqlParser::TableNameContext::TableNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::FullIdContext* MySqlParser::TableNameContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}


size_t MySqlParser::TableNameContext::getRuleIndex() const {
  return MySqlParser::RuleTableName;
}

void MySqlParser::TableNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableName(this);
}

void MySqlParser::TableNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableName(this);
}


std::any MySqlParser::TableNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTableName(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TableNameContext* MySqlParser::tableName() {
  TableNameContext *_localctx = _tracker.createInstance<TableNameContext>(_ctx, getState());
  enterRule(_localctx, 546, MySqlParser::RuleTableName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6223);
    fullId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleNameContext ------------------------------------------------------------------

MySqlParser::RoleNameContext::RoleNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::UserNameContext* MySqlParser::RoleNameContext::userName() {
  return getRuleContext<MySqlParser::UserNameContext>(0);
}

MySqlParser::UidContext* MySqlParser::RoleNameContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}


size_t MySqlParser::RoleNameContext::getRuleIndex() const {
  return MySqlParser::RuleRoleName;
}

void MySqlParser::RoleNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleName(this);
}

void MySqlParser::RoleNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleName(this);
}


std::any MySqlParser::RoleNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRoleName(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::RoleNameContext* MySqlParser::roleName() {
  RoleNameContext *_localctx = _tracker.createInstance<RoleNameContext>(_ctx, getState());
  enterRule(_localctx, 548, MySqlParser::RuleRoleName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6227);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 910, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6225);
      userName();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6226);
      uid();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FullColumnNameContext ------------------------------------------------------------------

MySqlParser::FullColumnNameContext::FullColumnNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::UidContext* MySqlParser::FullColumnNameContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

std::vector<MySqlParser::DottedIdContext *> MySqlParser::FullColumnNameContext::dottedId() {
  return getRuleContexts<MySqlParser::DottedIdContext>();
}

MySqlParser::DottedIdContext* MySqlParser::FullColumnNameContext::dottedId(size_t i) {
  return getRuleContext<MySqlParser::DottedIdContext>(i);
}


size_t MySqlParser::FullColumnNameContext::getRuleIndex() const {
  return MySqlParser::RuleFullColumnName;
}

void MySqlParser::FullColumnNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFullColumnName(this);
}

void MySqlParser::FullColumnNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFullColumnName(this);
}


std::any MySqlParser::FullColumnNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFullColumnName(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FullColumnNameContext* MySqlParser::fullColumnName() {
  FullColumnNameContext *_localctx = _tracker.createInstance<FullColumnNameContext>(_ctx, getState());
  enterRule(_localctx, 550, MySqlParser::RuleFullColumnName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6243);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 915, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6229);
      uid();
      setState(6234);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 912, _ctx)) {
      case 1: {
        setState(6230);
        dottedId();
        setState(6232);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 911, _ctx)) {
        case 1: {
          setState(6231);
          dottedId();
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6237);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 913, _ctx)) {
      case 1: {
        setState(6236);
        matchWildcard();
        break;
      }

      default:
        break;
      }
      setState(6239);
      dottedId();
      setState(6241);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 914, _ctx)) {
      case 1: {
        setState(6240);
        dottedId();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexColumnNameContext ------------------------------------------------------------------

MySqlParser::IndexColumnNameContext::IndexColumnNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::ExpressionContext* MySqlParser::IndexColumnNameContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

MySqlParser::UidContext* MySqlParser::IndexColumnNameContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::IndexColumnNameContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::IndexColumnNameContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::IndexColumnNameContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::IndexColumnNameContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::IndexColumnNameContext::ASC() {
  return getToken(MySqlParser::ASC, 0);
}

tree::TerminalNode* MySqlParser::IndexColumnNameContext::DESC() {
  return getToken(MySqlParser::DESC, 0);
}


size_t MySqlParser::IndexColumnNameContext::getRuleIndex() const {
  return MySqlParser::RuleIndexColumnName;
}

void MySqlParser::IndexColumnNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexColumnName(this);
}

void MySqlParser::IndexColumnNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexColumnName(this);
}


std::any MySqlParser::IndexColumnNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIndexColumnName(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::IndexColumnNameContext* MySqlParser::indexColumnName() {
  IndexColumnNameContext *_localctx = _tracker.createInstance<IndexColumnNameContext>(_ctx, getState());
  enterRule(_localctx, 552, MySqlParser::RuleIndexColumnName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6256);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 918, _ctx)) {
    case 1: {
      setState(6247);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 916, _ctx)) {
      case 1: {
        setState(6245);
        uid();
        break;
      }

      case 2: {
        setState(6246);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      default:
        break;
      }
      setState(6253);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LR_BRACKET) {
        setState(6249);
        match(MySqlParser::LR_BRACKET);
        setState(6250);
        decimalLiteral();
        setState(6251);
        match(MySqlParser::RR_BRACKET);
      }
      break;
    }

    case 2: {
      setState(6255);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(6259);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ASC

    || _la == MySqlParser::DESC) {
      setState(6258);
      antlrcpp::downCast<IndexColumnNameContext *>(_localctx)->sortType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::ASC

      || _la == MySqlParser::DESC)) {
        antlrcpp::downCast<IndexColumnNameContext *>(_localctx)->sortType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserNameContext ------------------------------------------------------------------

MySqlParser::UserNameContext::UserNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::UserNameContext::STRING_USER_NAME() {
  return getToken(MySqlParser::STRING_USER_NAME, 0);
}

tree::TerminalNode* MySqlParser::UserNameContext::ID() {
  return getToken(MySqlParser::ID, 0);
}

tree::TerminalNode* MySqlParser::UserNameContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::UserNameContext::ADMIN() {
  return getToken(MySqlParser::ADMIN, 0);
}

MySqlParser::KeywordsCanBeIdContext* MySqlParser::UserNameContext::keywordsCanBeId() {
  return getRuleContext<MySqlParser::KeywordsCanBeIdContext>(0);
}


size_t MySqlParser::UserNameContext::getRuleIndex() const {
  return MySqlParser::RuleUserName;
}

void MySqlParser::UserNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserName(this);
}

void MySqlParser::UserNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserName(this);
}


std::any MySqlParser::UserNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUserName(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UserNameContext* MySqlParser::userName() {
  UserNameContext *_localctx = _tracker.createInstance<UserNameContext>(_ctx, getState());
  enterRule(_localctx, 554, MySqlParser::RuleUserName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6266);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 920, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6261);
      match(MySqlParser::STRING_USER_NAME);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6262);
      match(MySqlParser::ID);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6263);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6264);
      match(MySqlParser::ADMIN);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6265);
      keywordsCanBeId();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MysqlVariableContext ------------------------------------------------------------------

MySqlParser::MysqlVariableContext::MysqlVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::MysqlVariableContext::LOCAL_ID() {
  return getToken(MySqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* MySqlParser::MysqlVariableContext::GLOBAL_ID() {
  return getToken(MySqlParser::GLOBAL_ID, 0);
}


size_t MySqlParser::MysqlVariableContext::getRuleIndex() const {
  return MySqlParser::RuleMysqlVariable;
}

void MySqlParser::MysqlVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMysqlVariable(this);
}

void MySqlParser::MysqlVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMysqlVariable(this);
}


std::any MySqlParser::MysqlVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitMysqlVariable(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::MysqlVariableContext* MySqlParser::mysqlVariable() {
  MysqlVariableContext *_localctx = _tracker.createInstance<MysqlVariableContext>(_ctx, getState());
  enterRule(_localctx, 556, MySqlParser::RuleMysqlVariable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6268);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::LOCAL_ID

    || _la == MySqlParser::GLOBAL_ID)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetNameContext ------------------------------------------------------------------

MySqlParser::CharsetNameContext::CharsetNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CharsetNameContext::BINARY() {
  return getToken(MySqlParser::BINARY, 0);
}

MySqlParser::CharsetNameBaseContext* MySqlParser::CharsetNameContext::charsetNameBase() {
  return getRuleContext<MySqlParser::CharsetNameBaseContext>(0);
}

tree::TerminalNode* MySqlParser::CharsetNameContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameContext::CHARSET_REVERSE_QOUTE_STRING() {
  return getToken(MySqlParser::CHARSET_REVERSE_QOUTE_STRING, 0);
}


size_t MySqlParser::CharsetNameContext::getRuleIndex() const {
  return MySqlParser::RuleCharsetName;
}

void MySqlParser::CharsetNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharsetName(this);
}

void MySqlParser::CharsetNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharsetName(this);
}


std::any MySqlParser::CharsetNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCharsetName(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CharsetNameContext* MySqlParser::charsetName() {
  CharsetNameContext *_localctx = _tracker.createInstance<CharsetNameContext>(_ctx, getState());
  enterRule(_localctx, 558, MySqlParser::RuleCharsetName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6274);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 921, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6270);
      match(MySqlParser::BINARY);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6271);
      charsetNameBase();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6272);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6273);
      match(MySqlParser::CHARSET_REVERSE_QOUTE_STRING);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollationNameContext ------------------------------------------------------------------

MySqlParser::CollationNameContext::CollationNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::UidContext* MySqlParser::CollationNameContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::CollationNameContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}


size_t MySqlParser::CollationNameContext::getRuleIndex() const {
  return MySqlParser::RuleCollationName;
}

void MySqlParser::CollationNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollationName(this);
}

void MySqlParser::CollationNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollationName(this);
}


std::any MySqlParser::CollationNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCollationName(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CollationNameContext* MySqlParser::collationName() {
  CollationNameContext *_localctx = _tracker.createInstance<CollationNameContext>(_ctx, getState());
  enterRule(_localctx, 560, MySqlParser::RuleCollationName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6278);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 922, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6276);
      uid();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6277);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EngineNameContext ------------------------------------------------------------------

MySqlParser::EngineNameContext::EngineNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::EngineNameBaseContext* MySqlParser::EngineNameContext::engineNameBase() {
  return getRuleContext<MySqlParser::EngineNameBaseContext>(0);
}

tree::TerminalNode* MySqlParser::EngineNameContext::ID() {
  return getToken(MySqlParser::ID, 0);
}

tree::TerminalNode* MySqlParser::EngineNameContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}


size_t MySqlParser::EngineNameContext::getRuleIndex() const {
  return MySqlParser::RuleEngineName;
}

void MySqlParser::EngineNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEngineName(this);
}

void MySqlParser::EngineNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEngineName(this);
}


std::any MySqlParser::EngineNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitEngineName(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::EngineNameContext* MySqlParser::engineName() {
  EngineNameContext *_localctx = _tracker.createInstance<EngineNameContext>(_ctx, getState());
  enterRule(_localctx, 562, MySqlParser::RuleEngineName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6283);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::CONNECT:
      case MySqlParser::ARCHIVE:
      case MySqlParser::BLACKHOLE:
      case MySqlParser::CSV:
      case MySqlParser::FEDERATED:
      case MySqlParser::INNODB:
      case MySqlParser::MEMORY:
      case MySqlParser::MRG_MYISAM:
      case MySqlParser::MYISAM:
      case MySqlParser::NDB:
      case MySqlParser::NDBCLUSTER:
      case MySqlParser::PERFORMANCE_SCHEMA:
      case MySqlParser::TOKUDB: {
        enterOuterAlt(_localctx, 1);
        setState(6280);
        engineNameBase();
        break;
      }

      case MySqlParser::ID: {
        enterOuterAlt(_localctx, 2);
        setState(6281);
        match(MySqlParser::ID);
        break;
      }

      case MySqlParser::STRING_LITERAL: {
        enterOuterAlt(_localctx, 3);
        setState(6282);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EngineNameBaseContext ------------------------------------------------------------------

MySqlParser::EngineNameBaseContext::EngineNameBaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::EngineNameBaseContext::ARCHIVE() {
  return getToken(MySqlParser::ARCHIVE, 0);
}

tree::TerminalNode* MySqlParser::EngineNameBaseContext::BLACKHOLE() {
  return getToken(MySqlParser::BLACKHOLE, 0);
}

tree::TerminalNode* MySqlParser::EngineNameBaseContext::CONNECT() {
  return getToken(MySqlParser::CONNECT, 0);
}

tree::TerminalNode* MySqlParser::EngineNameBaseContext::CSV() {
  return getToken(MySqlParser::CSV, 0);
}

tree::TerminalNode* MySqlParser::EngineNameBaseContext::FEDERATED() {
  return getToken(MySqlParser::FEDERATED, 0);
}

tree::TerminalNode* MySqlParser::EngineNameBaseContext::INNODB() {
  return getToken(MySqlParser::INNODB, 0);
}

tree::TerminalNode* MySqlParser::EngineNameBaseContext::MEMORY() {
  return getToken(MySqlParser::MEMORY, 0);
}

tree::TerminalNode* MySqlParser::EngineNameBaseContext::MRG_MYISAM() {
  return getToken(MySqlParser::MRG_MYISAM, 0);
}

tree::TerminalNode* MySqlParser::EngineNameBaseContext::MYISAM() {
  return getToken(MySqlParser::MYISAM, 0);
}

tree::TerminalNode* MySqlParser::EngineNameBaseContext::NDB() {
  return getToken(MySqlParser::NDB, 0);
}

tree::TerminalNode* MySqlParser::EngineNameBaseContext::NDBCLUSTER() {
  return getToken(MySqlParser::NDBCLUSTER, 0);
}

tree::TerminalNode* MySqlParser::EngineNameBaseContext::PERFORMANCE_SCHEMA() {
  return getToken(MySqlParser::PERFORMANCE_SCHEMA, 0);
}

tree::TerminalNode* MySqlParser::EngineNameBaseContext::TOKUDB() {
  return getToken(MySqlParser::TOKUDB, 0);
}


size_t MySqlParser::EngineNameBaseContext::getRuleIndex() const {
  return MySqlParser::RuleEngineNameBase;
}

void MySqlParser::EngineNameBaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEngineNameBase(this);
}

void MySqlParser::EngineNameBaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEngineNameBase(this);
}


std::any MySqlParser::EngineNameBaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitEngineNameBase(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::EngineNameBaseContext* MySqlParser::engineNameBase() {
  EngineNameBaseContext *_localctx = _tracker.createInstance<EngineNameBaseContext>(_ctx, getState());
  enterRule(_localctx, 564, MySqlParser::RuleEngineNameBase);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6285);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::CONNECT || ((((_la - 787) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 787)) & 4095) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UuidSetContext ------------------------------------------------------------------

MySqlParser::UuidSetContext::UuidSetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::DecimalLiteralContext *> MySqlParser::UuidSetContext::decimalLiteral() {
  return getRuleContexts<MySqlParser::DecimalLiteralContext>();
}

MySqlParser::DecimalLiteralContext* MySqlParser::UuidSetContext::decimalLiteral(size_t i) {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::UuidSetContext::MINUS() {
  return getTokens(MySqlParser::MINUS);
}

tree::TerminalNode* MySqlParser::UuidSetContext::MINUS(size_t i) {
  return getToken(MySqlParser::MINUS, i);
}

std::vector<tree::TerminalNode *> MySqlParser::UuidSetContext::COLON_SYMB() {
  return getTokens(MySqlParser::COLON_SYMB);
}

tree::TerminalNode* MySqlParser::UuidSetContext::COLON_SYMB(size_t i) {
  return getToken(MySqlParser::COLON_SYMB, i);
}


size_t MySqlParser::UuidSetContext::getRuleIndex() const {
  return MySqlParser::RuleUuidSet;
}

void MySqlParser::UuidSetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUuidSet(this);
}

void MySqlParser::UuidSetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUuidSet(this);
}


std::any MySqlParser::UuidSetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUuidSet(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UuidSetContext* MySqlParser::uuidSet() {
  UuidSetContext *_localctx = _tracker.createInstance<UuidSetContext>(_ctx, getState());
  enterRule(_localctx, 566, MySqlParser::RuleUuidSet);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6287);
    decimalLiteral();
    setState(6288);
    match(MySqlParser::MINUS);
    setState(6289);
    decimalLiteral();
    setState(6290);
    match(MySqlParser::MINUS);
    setState(6291);
    decimalLiteral();
    setState(6292);
    match(MySqlParser::MINUS);
    setState(6293);
    decimalLiteral();
    setState(6294);
    match(MySqlParser::MINUS);
    setState(6295);
    decimalLiteral();
    setState(6301); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(6296);
      match(MySqlParser::COLON_SYMB);
      setState(6297);
      decimalLiteral();
      setState(6298);
      match(MySqlParser::MINUS);
      setState(6299);
      decimalLiteral();
      setState(6303); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MySqlParser::COLON_SYMB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XidContext ------------------------------------------------------------------

MySqlParser::XidContext::XidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::XuidStringIdContext *> MySqlParser::XidContext::xuidStringId() {
  return getRuleContexts<MySqlParser::XuidStringIdContext>();
}

MySqlParser::XuidStringIdContext* MySqlParser::XidContext::xuidStringId(size_t i) {
  return getRuleContext<MySqlParser::XuidStringIdContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::XidContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::XidContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::DecimalLiteralContext* MySqlParser::XidContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}


size_t MySqlParser::XidContext::getRuleIndex() const {
  return MySqlParser::RuleXid;
}

void MySqlParser::XidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXid(this);
}

void MySqlParser::XidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXid(this);
}


std::any MySqlParser::XidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitXid(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::XidContext* MySqlParser::xid() {
  XidContext *_localctx = _tracker.createInstance<XidContext>(_ctx, getState());
  enterRule(_localctx, 568, MySqlParser::RuleXid);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6305);
    antlrcpp::downCast<XidContext *>(_localctx)->globalTableUid = xuidStringId();
    setState(6312);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::COMMA) {
      setState(6306);
      match(MySqlParser::COMMA);
      setState(6307);
      antlrcpp::downCast<XidContext *>(_localctx)->qualifier = xuidStringId();
      setState(6310);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::COMMA) {
        setState(6308);
        match(MySqlParser::COMMA);
        setState(6309);
        antlrcpp::downCast<XidContext *>(_localctx)->idFormat = decimalLiteral();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XuidStringIdContext ------------------------------------------------------------------

MySqlParser::XuidStringIdContext::XuidStringIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::XuidStringIdContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::XuidStringIdContext::BIT_STRING() {
  return getToken(MySqlParser::BIT_STRING, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::XuidStringIdContext::HEXADECIMAL_LITERAL() {
  return getTokens(MySqlParser::HEXADECIMAL_LITERAL);
}

tree::TerminalNode* MySqlParser::XuidStringIdContext::HEXADECIMAL_LITERAL(size_t i) {
  return getToken(MySqlParser::HEXADECIMAL_LITERAL, i);
}


size_t MySqlParser::XuidStringIdContext::getRuleIndex() const {
  return MySqlParser::RuleXuidStringId;
}

void MySqlParser::XuidStringIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXuidStringId(this);
}

void MySqlParser::XuidStringIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXuidStringId(this);
}


std::any MySqlParser::XuidStringIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitXuidStringId(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::XuidStringIdContext* MySqlParser::xuidStringId() {
  XuidStringIdContext *_localctx = _tracker.createInstance<XuidStringIdContext>(_ctx, getState());
  enterRule(_localctx, 570, MySqlParser::RuleXuidStringId);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6321);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::STRING_LITERAL: {
        enterOuterAlt(_localctx, 1);
        setState(6314);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

      case MySqlParser::BIT_STRING: {
        enterOuterAlt(_localctx, 2);
        setState(6315);
        match(MySqlParser::BIT_STRING);
        break;
      }

      case MySqlParser::HEXADECIMAL_LITERAL: {
        enterOuterAlt(_localctx, 3);
        setState(6317); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(6316);
          match(MySqlParser::HEXADECIMAL_LITERAL);
          setState(6319); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == MySqlParser::HEXADECIMAL_LITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AuthPluginContext ------------------------------------------------------------------

MySqlParser::AuthPluginContext::AuthPluginContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::UidContext* MySqlParser::AuthPluginContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}

tree::TerminalNode* MySqlParser::AuthPluginContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}


size_t MySqlParser::AuthPluginContext::getRuleIndex() const {
  return MySqlParser::RuleAuthPlugin;
}

void MySqlParser::AuthPluginContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAuthPlugin(this);
}

void MySqlParser::AuthPluginContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAuthPlugin(this);
}


std::any MySqlParser::AuthPluginContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAuthPlugin(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AuthPluginContext* MySqlParser::authPlugin() {
  AuthPluginContext *_localctx = _tracker.createInstance<AuthPluginContext>(_ctx, getState());
  enterRule(_localctx, 572, MySqlParser::RuleAuthPlugin);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6325);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 929, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6323);
      uid();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6324);
      match(MySqlParser::STRING_LITERAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UidContext ------------------------------------------------------------------

MySqlParser::UidContext::UidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::SimpleIdContext* MySqlParser::UidContext::simpleId() {
  return getRuleContext<MySqlParser::SimpleIdContext>(0);
}

tree::TerminalNode* MySqlParser::UidContext::CHARSET_REVERSE_QOUTE_STRING() {
  return getToken(MySqlParser::CHARSET_REVERSE_QOUTE_STRING, 0);
}

tree::TerminalNode* MySqlParser::UidContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}


size_t MySqlParser::UidContext::getRuleIndex() const {
  return MySqlParser::RuleUid;
}

void MySqlParser::UidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUid(this);
}

void MySqlParser::UidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUid(this);
}


std::any MySqlParser::UidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUid(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UidContext* MySqlParser::uid() {
  UidContext *_localctx = _tracker.createInstance<UidContext>(_ctx, getState());
  enterRule(_localctx, 574, MySqlParser::RuleUid);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6330);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::ATTRIBUTE:
      case MySqlParser::BUCKETS:
      case MySqlParser::CONDITION:
      case MySqlParser::CURRENT:
      case MySqlParser::CURRENT_USER:
      case MySqlParser::DATABASE:
      case MySqlParser::DEFAULT:
      case MySqlParser::DIAGNOSTICS:
      case MySqlParser::EMPTY:
      case MySqlParser::ENFORCED:
      case MySqlParser::EXCEPT:
      case MySqlParser::GROUP:
      case MySqlParser::IF:
      case MySqlParser::IGNORED:
      case MySqlParser::INSERT:
      case MySqlParser::LATERAL:
      case MySqlParser::LEFT:
      case MySqlParser::NUMBER:
      case MySqlParser::OPTIONAL:
      case MySqlParser::ORDER:
      case MySqlParser::PRIMARY:
      case MySqlParser::REPLACE:
      case MySqlParser::RIGHT:
      case MySqlParser::SCHEMA:
      case MySqlParser::SKIP_QUERY_REWRITE:
      case MySqlParser::STACKED:
      case MySqlParser::DATE:
      case MySqlParser::TIME:
      case MySqlParser::TIMESTAMP:
      case MySqlParser::DATETIME:
      case MySqlParser::YEAR:
      case MySqlParser::BINARY:
      case MySqlParser::TEXT:
      case MySqlParser::ENUM:
      case MySqlParser::SERIAL:
      case MySqlParser::JSON_ARRAY:
      case MySqlParser::JSON_ARRAYAGG:
      case MySqlParser::JSON_ARRAY_APPEND:
      case MySqlParser::JSON_ARRAY_INSERT:
      case MySqlParser::JSON_CONTAINS:
      case MySqlParser::JSON_CONTAINS_PATH:
      case MySqlParser::JSON_DEPTH:
      case MySqlParser::JSON_EXTRACT:
      case MySqlParser::JSON_INSERT:
      case MySqlParser::JSON_KEYS:
      case MySqlParser::JSON_LENGTH:
      case MySqlParser::JSON_MERGE:
      case MySqlParser::JSON_MERGE_PATCH:
      case MySqlParser::JSON_MERGE_PRESERVE:
      case MySqlParser::JSON_OBJECT:
      case MySqlParser::JSON_OBJECTAGG:
      case MySqlParser::JSON_OVERLAPS:
      case MySqlParser::JSON_PRETTY:
      case MySqlParser::JSON_QUOTE:
      case MySqlParser::JSON_REMOVE:
      case MySqlParser::JSON_REPLACE:
      case MySqlParser::JSON_SCHEMA_VALID:
      case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
      case MySqlParser::JSON_SEARCH:
      case MySqlParser::JSON_SET:
      case MySqlParser::JSON_STORAGE_FREE:
      case MySqlParser::JSON_STORAGE_SIZE:
      case MySqlParser::JSON_TABLE:
      case MySqlParser::JSON_TYPE:
      case MySqlParser::JSON_UNQUOTE:
      case MySqlParser::JSON_VALID:
      case MySqlParser::JSON_VALUE:
      case MySqlParser::NESTED:
      case MySqlParser::ORDINALITY:
      case MySqlParser::PATH:
      case MySqlParser::AVG:
      case MySqlParser::BIT_AND:
      case MySqlParser::BIT_OR:
      case MySqlParser::BIT_XOR:
      case MySqlParser::COUNT:
      case MySqlParser::CUME_DIST:
      case MySqlParser::DENSE_RANK:
      case MySqlParser::FIRST_VALUE:
      case MySqlParser::GROUP_CONCAT:
      case MySqlParser::LAG:
      case MySqlParser::LAST_VALUE:
      case MySqlParser::LEAD:
      case MySqlParser::MAX:
      case MySqlParser::MIN:
      case MySqlParser::NTILE:
      case MySqlParser::NTH_VALUE:
      case MySqlParser::PERCENT_RANK:
      case MySqlParser::RANK:
      case MySqlParser::ROW_NUMBER:
      case MySqlParser::STD:
      case MySqlParser::STDDEV:
      case MySqlParser::STDDEV_POP:
      case MySqlParser::STDDEV_SAMP:
      case MySqlParser::SUM:
      case MySqlParser::VAR_POP:
      case MySqlParser::VAR_SAMP:
      case MySqlParser::VARIANCE:
      case MySqlParser::CURRENT_DATE:
      case MySqlParser::CURRENT_TIME:
      case MySqlParser::CURRENT_TIMESTAMP:
      case MySqlParser::LOCALTIME:
      case MySqlParser::CURDATE:
      case MySqlParser::CURTIME:
      case MySqlParser::DATE_ADD:
      case MySqlParser::DATE_SUB:
      case MySqlParser::LOCALTIMESTAMP:
      case MySqlParser::NOW:
      case MySqlParser::POSITION:
      case MySqlParser::SUBSTR:
      case MySqlParser::SUBSTRING:
      case MySqlParser::SYSDATE:
      case MySqlParser::TRIM:
      case MySqlParser::UTC_DATE:
      case MySqlParser::UTC_TIME:
      case MySqlParser::UTC_TIMESTAMP:
      case MySqlParser::ACCOUNT:
      case MySqlParser::ACTION:
      case MySqlParser::AFTER:
      case MySqlParser::AGGREGATE:
      case MySqlParser::ALGORITHM:
      case MySqlParser::ANY:
      case MySqlParser::AT:
      case MySqlParser::AUTHORS:
      case MySqlParser::AUTOCOMMIT:
      case MySqlParser::AUTOEXTEND_SIZE:
      case MySqlParser::AUTO_INCREMENT:
      case MySqlParser::AVG_ROW_LENGTH:
      case MySqlParser::BEGIN:
      case MySqlParser::BINLOG:
      case MySqlParser::BIT:
      case MySqlParser::BLOCK:
      case MySqlParser::BOOL:
      case MySqlParser::BOOLEAN:
      case MySqlParser::BTREE:
      case MySqlParser::CACHE:
      case MySqlParser::CASCADED:
      case MySqlParser::CHAIN:
      case MySqlParser::CHANGED:
      case MySqlParser::CHANNEL:
      case MySqlParser::CHECKSUM:
      case MySqlParser::PAGE_CHECKSUM:
      case MySqlParser::CIPHER:
      case MySqlParser::CLASS_ORIGIN:
      case MySqlParser::CLIENT:
      case MySqlParser::CLOSE:
      case MySqlParser::CLUSTERING:
      case MySqlParser::COALESCE:
      case MySqlParser::CODE:
      case MySqlParser::COLUMNS:
      case MySqlParser::COLUMN_FORMAT:
      case MySqlParser::COLUMN_NAME:
      case MySqlParser::COMMENT:
      case MySqlParser::COMMIT:
      case MySqlParser::COMPACT:
      case MySqlParser::COMPLETION:
      case MySqlParser::COMPRESSED:
      case MySqlParser::COMPRESSION:
      case MySqlParser::CONCURRENT:
      case MySqlParser::CONNECT:
      case MySqlParser::CONNECTION:
      case MySqlParser::CONSISTENT:
      case MySqlParser::CONSTRAINT_CATALOG:
      case MySqlParser::CONSTRAINT_SCHEMA:
      case MySqlParser::CONSTRAINT_NAME:
      case MySqlParser::CONTAINS:
      case MySqlParser::CONTEXT:
      case MySqlParser::CONTRIBUTORS:
      case MySqlParser::COPY:
      case MySqlParser::CPU:
      case MySqlParser::CURSOR_NAME:
      case MySqlParser::DATA:
      case MySqlParser::DATAFILE:
      case MySqlParser::DEALLOCATE:
      case MySqlParser::DEFAULT_AUTH:
      case MySqlParser::DEFINER:
      case MySqlParser::DELAY_KEY_WRITE:
      case MySqlParser::DES_KEY_FILE:
      case MySqlParser::DIRECTORY:
      case MySqlParser::DISABLE:
      case MySqlParser::DISCARD:
      case MySqlParser::DISK:
      case MySqlParser::DO:
      case MySqlParser::DUMPFILE:
      case MySqlParser::DUPLICATE:
      case MySqlParser::DYNAMIC:
      case MySqlParser::ENABLE:
      case MySqlParser::ENCRYPTION:
      case MySqlParser::END:
      case MySqlParser::ENDS:
      case MySqlParser::ENGINE:
      case MySqlParser::ENGINES:
      case MySqlParser::ERROR:
      case MySqlParser::ERRORS:
      case MySqlParser::ESCAPE:
      case MySqlParser::EVEN:
      case MySqlParser::EVENT:
      case MySqlParser::EVENTS:
      case MySqlParser::EVERY:
      case MySqlParser::EXCHANGE:
      case MySqlParser::EXCLUSIVE:
      case MySqlParser::EXPIRE:
      case MySqlParser::EXPORT:
      case MySqlParser::EXTENDED:
      case MySqlParser::EXTENT_SIZE:
      case MySqlParser::FAILED_LOGIN_ATTEMPTS:
      case MySqlParser::FAST:
      case MySqlParser::FAULTS:
      case MySqlParser::FIELDS:
      case MySqlParser::FILE_BLOCK_SIZE:
      case MySqlParser::FILTER:
      case MySqlParser::FIRST:
      case MySqlParser::FIXED:
      case MySqlParser::FLUSH:
      case MySqlParser::FOLLOWS:
      case MySqlParser::FOUND:
      case MySqlParser::FULL:
      case MySqlParser::FUNCTION:
      case MySqlParser::GENERAL:
      case MySqlParser::GLOBAL:
      case MySqlParser::GRANTS:
      case MySqlParser::GROUP_REPLICATION:
      case MySqlParser::HANDLER:
      case MySqlParser::HASH:
      case MySqlParser::HELP:
      case MySqlParser::HISTORY:
      case MySqlParser::HOST:
      case MySqlParser::HOSTS:
      case MySqlParser::IDENTIFIED:
      case MySqlParser::IGNORE_SERVER_IDS:
      case MySqlParser::IMPORT:
      case MySqlParser::INDEXES:
      case MySqlParser::INITIAL_SIZE:
      case MySqlParser::INPLACE:
      case MySqlParser::INSERT_METHOD:
      case MySqlParser::INSTALL:
      case MySqlParser::INSTANCE:
      case MySqlParser::INSTANT:
      case MySqlParser::INVISIBLE:
      case MySqlParser::INVOKER:
      case MySqlParser::IO:
      case MySqlParser::IO_THREAD:
      case MySqlParser::IPC:
      case MySqlParser::ISOLATION:
      case MySqlParser::ISSUER:
      case MySqlParser::JSON:
      case MySqlParser::KEY_BLOCK_SIZE:
      case MySqlParser::LANGUAGE:
      case MySqlParser::LAST:
      case MySqlParser::LEAVES:
      case MySqlParser::LESS:
      case MySqlParser::LEVEL:
      case MySqlParser::LIST:
      case MySqlParser::LOCAL:
      case MySqlParser::LOGFILE:
      case MySqlParser::LOGS:
      case MySqlParser::MASTER:
      case MySqlParser::MASTER_AUTO_POSITION:
      case MySqlParser::MASTER_CONNECT_RETRY:
      case MySqlParser::MASTER_DELAY:
      case MySqlParser::MASTER_HEARTBEAT_PERIOD:
      case MySqlParser::MASTER_HOST:
      case MySqlParser::MASTER_LOG_FILE:
      case MySqlParser::MASTER_LOG_POS:
      case MySqlParser::MASTER_PASSWORD:
      case MySqlParser::MASTER_PORT:
      case MySqlParser::MASTER_RETRY_COUNT:
      case MySqlParser::MASTER_SSL:
      case MySqlParser::MASTER_SSL_CA:
      case MySqlParser::MASTER_SSL_CAPATH:
      case MySqlParser::MASTER_SSL_CERT:
      case MySqlParser::MASTER_SSL_CIPHER:
      case MySqlParser::MASTER_SSL_CRL:
      case MySqlParser::MASTER_SSL_CRLPATH:
      case MySqlParser::MASTER_SSL_KEY:
      case MySqlParser::MASTER_TLS_VERSION:
      case MySqlParser::MASTER_USER:
      case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
      case MySqlParser::MAX_QUERIES_PER_HOUR:
      case MySqlParser::MAX_ROWS:
      case MySqlParser::MAX_SIZE:
      case MySqlParser::MAX_UPDATES_PER_HOUR:
      case MySqlParser::MAX_USER_CONNECTIONS:
      case MySqlParser::MEDIUM:
      case MySqlParser::MEMBER:
      case MySqlParser::MERGE:
      case MySqlParser::MESSAGE_TEXT:
      case MySqlParser::MID:
      case MySqlParser::MIGRATE:
      case MySqlParser::MIN_ROWS:
      case MySqlParser::MODE:
      case MySqlParser::MODIFY:
      case MySqlParser::MUTEX:
      case MySqlParser::MYSQL:
      case MySqlParser::MYSQL_ERRNO:
      case MySqlParser::NAME:
      case MySqlParser::NAMES:
      case MySqlParser::NCHAR:
      case MySqlParser::NEVER:
      case MySqlParser::NEXT:
      case MySqlParser::NO:
      case MySqlParser::NOCOPY:
      case MySqlParser::NOWAIT:
      case MySqlParser::NODEGROUP:
      case MySqlParser::NONE:
      case MySqlParser::ODBC:
      case MySqlParser::OFFLINE:
      case MySqlParser::OFFSET:
      case MySqlParser::OF:
      case MySqlParser::OJ:
      case MySqlParser::OLD_PASSWORD:
      case MySqlParser::ONE:
      case MySqlParser::ONLINE:
      case MySqlParser::ONLY:
      case MySqlParser::OPEN:
      case MySqlParser::OPTIMIZER_COSTS:
      case MySqlParser::OPTIONS:
      case MySqlParser::OWNER:
      case MySqlParser::PACK_KEYS:
      case MySqlParser::PAGE:
      case MySqlParser::PARSER:
      case MySqlParser::PARTIAL:
      case MySqlParser::PARTITIONING:
      case MySqlParser::PARTITIONS:
      case MySqlParser::PASSWORD:
      case MySqlParser::PASSWORD_LOCK_TIME:
      case MySqlParser::PHASE:
      case MySqlParser::PLUGIN:
      case MySqlParser::PLUGIN_DIR:
      case MySqlParser::PLUGINS:
      case MySqlParser::PORT:
      case MySqlParser::PRECEDES:
      case MySqlParser::PREPARE:
      case MySqlParser::PRESERVE:
      case MySqlParser::PREV:
      case MySqlParser::PROCESSLIST:
      case MySqlParser::PROFILE:
      case MySqlParser::PROFILES:
      case MySqlParser::PROXY:
      case MySqlParser::QUERY:
      case MySqlParser::QUICK:
      case MySqlParser::REBUILD:
      case MySqlParser::RECOVER:
      case MySqlParser::RECURSIVE:
      case MySqlParser::REDO_BUFFER_SIZE:
      case MySqlParser::REDUNDANT:
      case MySqlParser::RELAY:
      case MySqlParser::RELAY_LOG_FILE:
      case MySqlParser::RELAY_LOG_POS:
      case MySqlParser::RELAYLOG:
      case MySqlParser::REMOVE:
      case MySqlParser::REORGANIZE:
      case MySqlParser::REPAIR:
      case MySqlParser::REPLICATE_DO_DB:
      case MySqlParser::REPLICATE_DO_TABLE:
      case MySqlParser::REPLICATE_IGNORE_DB:
      case MySqlParser::REPLICATE_IGNORE_TABLE:
      case MySqlParser::REPLICATE_REWRITE_DB:
      case MySqlParser::REPLICATE_WILD_DO_TABLE:
      case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySqlParser::REPLICATION:
      case MySqlParser::RESET:
      case MySqlParser::RESUME:
      case MySqlParser::RETURNED_SQLSTATE:
      case MySqlParser::RETURNS:
      case MySqlParser::REUSE:
      case MySqlParser::ROLE:
      case MySqlParser::ROLLBACK:
      case MySqlParser::ROLLUP:
      case MySqlParser::ROTATE:
      case MySqlParser::ROW:
      case MySqlParser::ROWS:
      case MySqlParser::ROW_FORMAT:
      case MySqlParser::RTREE:
      case MySqlParser::SAVEPOINT:
      case MySqlParser::SCHEDULE:
      case MySqlParser::SECURITY:
      case MySqlParser::SERVER:
      case MySqlParser::SESSION:
      case MySqlParser::SHARE:
      case MySqlParser::SHARED:
      case MySqlParser::SIGNED:
      case MySqlParser::SIMPLE:
      case MySqlParser::SLAVE:
      case MySqlParser::SLOW:
      case MySqlParser::SNAPSHOT:
      case MySqlParser::SOCKET:
      case MySqlParser::SOME:
      case MySqlParser::SONAME:
      case MySqlParser::SOUNDS:
      case MySqlParser::SOURCE:
      case MySqlParser::SQL_AFTER_GTIDS:
      case MySqlParser::SQL_AFTER_MTS_GAPS:
      case MySqlParser::SQL_BEFORE_GTIDS:
      case MySqlParser::SQL_BUFFER_RESULT:
      case MySqlParser::SQL_CACHE:
      case MySqlParser::SQL_NO_CACHE:
      case MySqlParser::SQL_THREAD:
      case MySqlParser::START:
      case MySqlParser::STARTS:
      case MySqlParser::STATS_AUTO_RECALC:
      case MySqlParser::STATS_PERSISTENT:
      case MySqlParser::STATS_SAMPLE_PAGES:
      case MySqlParser::STATUS:
      case MySqlParser::STOP:
      case MySqlParser::STORAGE:
      case MySqlParser::STRING:
      case MySqlParser::SUBCLASS_ORIGIN:
      case MySqlParser::SUBJECT:
      case MySqlParser::SUBPARTITION:
      case MySqlParser::SUBPARTITIONS:
      case MySqlParser::SUSPEND:
      case MySqlParser::SWAPS:
      case MySqlParser::SWITCHES:
      case MySqlParser::TABLE_NAME:
      case MySqlParser::TABLESPACE:
      case MySqlParser::TABLE_TYPE:
      case MySqlParser::TEMPORARY:
      case MySqlParser::TEMPTABLE:
      case MySqlParser::THAN:
      case MySqlParser::TRADITIONAL:
      case MySqlParser::TRANSACTION:
      case MySqlParser::TRANSACTIONAL:
      case MySqlParser::TRIGGERS:
      case MySqlParser::TRUNCATE:
      case MySqlParser::UNBOUNDED:
      case MySqlParser::UNDEFINED:
      case MySqlParser::UNDOFILE:
      case MySqlParser::UNDO_BUFFER_SIZE:
      case MySqlParser::UNINSTALL:
      case MySqlParser::UNKNOWN:
      case MySqlParser::UNTIL:
      case MySqlParser::UPGRADE:
      case MySqlParser::USER:
      case MySqlParser::USE_FRM:
      case MySqlParser::USER_RESOURCES:
      case MySqlParser::VALIDATION:
      case MySqlParser::VALUE:
      case MySqlParser::VARIABLES:
      case MySqlParser::VIEW:
      case MySqlParser::VIRTUAL:
      case MySqlParser::VISIBLE:
      case MySqlParser::WAIT:
      case MySqlParser::WARNINGS:
      case MySqlParser::WITHOUT:
      case MySqlParser::WORK:
      case MySqlParser::WRAPPER:
      case MySqlParser::X509:
      case MySqlParser::XA:
      case MySqlParser::XML:
      case MySqlParser::EUR:
      case MySqlParser::USA:
      case MySqlParser::JIS:
      case MySqlParser::ISO:
      case MySqlParser::INTERNAL:
      case MySqlParser::QUARTER:
      case MySqlParser::MONTH:
      case MySqlParser::DAY:
      case MySqlParser::HOUR:
      case MySqlParser::MINUTE:
      case MySqlParser::WEEK:
      case MySqlParser::SECOND:
      case MySqlParser::MICROSECOND:
      case MySqlParser::ADMIN:
      case MySqlParser::AUDIT_ABORT_EXEMPT:
      case MySqlParser::AUDIT_ADMIN:
      case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
      case MySqlParser::BACKUP_ADMIN:
      case MySqlParser::BINLOG_ADMIN:
      case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
      case MySqlParser::CLONE_ADMIN:
      case MySqlParser::CONNECTION_ADMIN:
      case MySqlParser::ENCRYPTION_KEY_ADMIN:
      case MySqlParser::EXECUTE:
      case MySqlParser::FILE:
      case MySqlParser::FIREWALL_ADMIN:
      case MySqlParser::FIREWALL_EXEMPT:
      case MySqlParser::FIREWALL_USER:
      case MySqlParser::GROUP_REPLICATION_ADMIN:
      case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
      case MySqlParser::INVOKE:
      case MySqlParser::LAMBDA:
      case MySqlParser::NDB_STORED_USER:
      case MySqlParser::PASSWORDLESS_USER_ADMIN:
      case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
      case MySqlParser::PRIVILEGES:
      case MySqlParser::PROCESS:
      case MySqlParser::RELOAD:
      case MySqlParser::REPLICATION_APPLIER:
      case MySqlParser::REPLICATION_SLAVE_ADMIN:
      case MySqlParser::RESOURCE_GROUP_ADMIN:
      case MySqlParser::RESOURCE_GROUP_USER:
      case MySqlParser::ROLE_ADMIN:
      case MySqlParser::ROUTINE:
      case MySqlParser::S3:
      case MySqlParser::SESSION_VARIABLES_ADMIN:
      case MySqlParser::SET_USER_ID:
      case MySqlParser::SHOW_ROUTINE:
      case MySqlParser::SHUTDOWN:
      case MySqlParser::SUPER:
      case MySqlParser::SYSTEM_VARIABLES_ADMIN:
      case MySqlParser::TABLES:
      case MySqlParser::TABLE_ENCRYPTION_ADMIN:
      case MySqlParser::VERSION_TOKEN_ADMIN:
      case MySqlParser::XA_RECOVER_ADMIN:
      case MySqlParser::ARMSCII8:
      case MySqlParser::ASCII:
      case MySqlParser::BIG5:
      case MySqlParser::CP1250:
      case MySqlParser::CP1251:
      case MySqlParser::CP1256:
      case MySqlParser::CP1257:
      case MySqlParser::CP850:
      case MySqlParser::CP852:
      case MySqlParser::CP866:
      case MySqlParser::CP932:
      case MySqlParser::DEC8:
      case MySqlParser::EUCJPMS:
      case MySqlParser::EUCKR:
      case MySqlParser::GB18030:
      case MySqlParser::GB2312:
      case MySqlParser::GBK:
      case MySqlParser::GEOSTD8:
      case MySqlParser::GREEK:
      case MySqlParser::HEBREW:
      case MySqlParser::HP8:
      case MySqlParser::KEYBCS2:
      case MySqlParser::KOI8R:
      case MySqlParser::KOI8U:
      case MySqlParser::LATIN1:
      case MySqlParser::LATIN2:
      case MySqlParser::LATIN5:
      case MySqlParser::LATIN7:
      case MySqlParser::MACCE:
      case MySqlParser::MACROMAN:
      case MySqlParser::SJIS:
      case MySqlParser::SWE7:
      case MySqlParser::TIS620:
      case MySqlParser::UCS2:
      case MySqlParser::UJIS:
      case MySqlParser::UTF16:
      case MySqlParser::UTF16LE:
      case MySqlParser::UTF32:
      case MySqlParser::UTF8:
      case MySqlParser::UTF8MB3:
      case MySqlParser::UTF8MB4:
      case MySqlParser::ARCHIVE:
      case MySqlParser::BLACKHOLE:
      case MySqlParser::CSV:
      case MySqlParser::FEDERATED:
      case MySqlParser::INNODB:
      case MySqlParser::MEMORY:
      case MySqlParser::MRG_MYISAM:
      case MySqlParser::MYISAM:
      case MySqlParser::NDB:
      case MySqlParser::NDBCLUSTER:
      case MySqlParser::PERFORMANCE_SCHEMA:
      case MySqlParser::TOKUDB:
      case MySqlParser::REPEATABLE:
      case MySqlParser::COMMITTED:
      case MySqlParser::UNCOMMITTED:
      case MySqlParser::SERIALIZABLE:
      case MySqlParser::GEOMETRYCOLLECTION:
      case MySqlParser::LINESTRING:
      case MySqlParser::MULTILINESTRING:
      case MySqlParser::MULTIPOINT:
      case MySqlParser::MULTIPOLYGON:
      case MySqlParser::POINT:
      case MySqlParser::POLYGON:
      case MySqlParser::ABS:
      case MySqlParser::ACOS:
      case MySqlParser::ADDDATE:
      case MySqlParser::ADDTIME:
      case MySqlParser::AES_DECRYPT:
      case MySqlParser::AES_ENCRYPT:
      case MySqlParser::AREA:
      case MySqlParser::ASBINARY:
      case MySqlParser::ASIN:
      case MySqlParser::ASTEXT:
      case MySqlParser::ASWKB:
      case MySqlParser::ASWKT:
      case MySqlParser::ASYMMETRIC_DECRYPT:
      case MySqlParser::ASYMMETRIC_DERIVE:
      case MySqlParser::ASYMMETRIC_ENCRYPT:
      case MySqlParser::ASYMMETRIC_SIGN:
      case MySqlParser::ASYMMETRIC_VERIFY:
      case MySqlParser::ATAN:
      case MySqlParser::ATAN2:
      case MySqlParser::BENCHMARK:
      case MySqlParser::BIN:
      case MySqlParser::BIT_COUNT:
      case MySqlParser::BIT_LENGTH:
      case MySqlParser::BUFFER:
      case MySqlParser::CATALOG_NAME:
      case MySqlParser::CEIL:
      case MySqlParser::CEILING:
      case MySqlParser::CENTROID:
      case MySqlParser::CHARACTER_LENGTH:
      case MySqlParser::CHARSET:
      case MySqlParser::CHAR_LENGTH:
      case MySqlParser::COERCIBILITY:
      case MySqlParser::COLLATION:
      case MySqlParser::COMPRESS:
      case MySqlParser::CONCAT:
      case MySqlParser::CONCAT_WS:
      case MySqlParser::CONNECTION_ID:
      case MySqlParser::CONV:
      case MySqlParser::CONVERT_TZ:
      case MySqlParser::COS:
      case MySqlParser::COT:
      case MySqlParser::CRC32:
      case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
      case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
      case MySqlParser::CREATE_DH_PARAMETERS:
      case MySqlParser::CREATE_DIGEST:
      case MySqlParser::CROSSES:
      case MySqlParser::DATEDIFF:
      case MySqlParser::DATE_FORMAT:
      case MySqlParser::DAYNAME:
      case MySqlParser::DAYOFMONTH:
      case MySqlParser::DAYOFWEEK:
      case MySqlParser::DAYOFYEAR:
      case MySqlParser::DECODE:
      case MySqlParser::DEGREES:
      case MySqlParser::DES_DECRYPT:
      case MySqlParser::DES_ENCRYPT:
      case MySqlParser::DIMENSION:
      case MySqlParser::DISJOINT:
      case MySqlParser::ELT:
      case MySqlParser::ENCODE:
      case MySqlParser::ENCRYPT:
      case MySqlParser::ENDPOINT:
      case MySqlParser::ENGINE_ATTRIBUTE:
      case MySqlParser::ENVELOPE:
      case MySqlParser::EQUALS:
      case MySqlParser::EXP:
      case MySqlParser::EXPORT_SET:
      case MySqlParser::EXTERIORRING:
      case MySqlParser::EXTRACTVALUE:
      case MySqlParser::FIELD:
      case MySqlParser::FIND_IN_SET:
      case MySqlParser::FLOOR:
      case MySqlParser::FORMAT:
      case MySqlParser::FOUND_ROWS:
      case MySqlParser::FROM_BASE64:
      case MySqlParser::FROM_DAYS:
      case MySqlParser::FROM_UNIXTIME:
      case MySqlParser::GEOMCOLLFROMTEXT:
      case MySqlParser::GEOMCOLLFROMWKB:
      case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::GEOMETRYFROMTEXT:
      case MySqlParser::GEOMETRYFROMWKB:
      case MySqlParser::GEOMETRYN:
      case MySqlParser::GEOMETRYTYPE:
      case MySqlParser::GEOMFROMTEXT:
      case MySqlParser::GEOMFROMWKB:
      case MySqlParser::GET_FORMAT:
      case MySqlParser::GET_LOCK:
      case MySqlParser::GLENGTH:
      case MySqlParser::GREATEST:
      case MySqlParser::GTID_SUBSET:
      case MySqlParser::GTID_SUBTRACT:
      case MySqlParser::HEX:
      case MySqlParser::IFNULL:
      case MySqlParser::INET6_ATON:
      case MySqlParser::INET6_NTOA:
      case MySqlParser::INET_ATON:
      case MySqlParser::INET_NTOA:
      case MySqlParser::INSTR:
      case MySqlParser::INTERIORRINGN:
      case MySqlParser::INTERSECTS:
      case MySqlParser::ISCLOSED:
      case MySqlParser::ISEMPTY:
      case MySqlParser::ISNULL:
      case MySqlParser::ISSIMPLE:
      case MySqlParser::IS_FREE_LOCK:
      case MySqlParser::IS_IPV4:
      case MySqlParser::IS_IPV4_COMPAT:
      case MySqlParser::IS_IPV4_MAPPED:
      case MySqlParser::IS_IPV6:
      case MySqlParser::IS_USED_LOCK:
      case MySqlParser::LAST_INSERT_ID:
      case MySqlParser::LCASE:
      case MySqlParser::LEAST:
      case MySqlParser::LENGTH:
      case MySqlParser::LINEFROMTEXT:
      case MySqlParser::LINEFROMWKB:
      case MySqlParser::LINESTRINGFROMTEXT:
      case MySqlParser::LINESTRINGFROMWKB:
      case MySqlParser::LN:
      case MySqlParser::LOAD_FILE:
      case MySqlParser::LOCATE:
      case MySqlParser::LOG:
      case MySqlParser::LOG10:
      case MySqlParser::LOG2:
      case MySqlParser::LOWER:
      case MySqlParser::LPAD:
      case MySqlParser::LTRIM:
      case MySqlParser::MAKEDATE:
      case MySqlParser::MAKETIME:
      case MySqlParser::MAKE_SET:
      case MySqlParser::MASTER_POS_WAIT:
      case MySqlParser::MBRCONTAINS:
      case MySqlParser::MBRDISJOINT:
      case MySqlParser::MBREQUAL:
      case MySqlParser::MBRINTERSECTS:
      case MySqlParser::MBROVERLAPS:
      case MySqlParser::MBRTOUCHES:
      case MySqlParser::MBRWITHIN:
      case MySqlParser::MD5:
      case MySqlParser::MLINEFROMTEXT:
      case MySqlParser::MLINEFROMWKB:
      case MySqlParser::MONTHNAME:
      case MySqlParser::MPOINTFROMTEXT:
      case MySqlParser::MPOINTFROMWKB:
      case MySqlParser::MPOLYFROMTEXT:
      case MySqlParser::MPOLYFROMWKB:
      case MySqlParser::MULTILINESTRINGFROMTEXT:
      case MySqlParser::MULTILINESTRINGFROMWKB:
      case MySqlParser::MULTIPOINTFROMTEXT:
      case MySqlParser::MULTIPOINTFROMWKB:
      case MySqlParser::MULTIPOLYGONFROMTEXT:
      case MySqlParser::MULTIPOLYGONFROMWKB:
      case MySqlParser::NAME_CONST:
      case MySqlParser::NULLIF:
      case MySqlParser::NUMGEOMETRIES:
      case MySqlParser::NUMINTERIORRINGS:
      case MySqlParser::NUMPOINTS:
      case MySqlParser::OCT:
      case MySqlParser::OCTET_LENGTH:
      case MySqlParser::ORD:
      case MySqlParser::OVERLAPS:
      case MySqlParser::PERIOD_ADD:
      case MySqlParser::PERIOD_DIFF:
      case MySqlParser::PI:
      case MySqlParser::POINTFROMTEXT:
      case MySqlParser::POINTFROMWKB:
      case MySqlParser::POINTN:
      case MySqlParser::POLYFROMTEXT:
      case MySqlParser::POLYFROMWKB:
      case MySqlParser::POLYGONFROMTEXT:
      case MySqlParser::POLYGONFROMWKB:
      case MySqlParser::POW:
      case MySqlParser::POWER:
      case MySqlParser::QUOTE:
      case MySqlParser::RADIANS:
      case MySqlParser::RAND:
      case MySqlParser::RANDOM_BYTES:
      case MySqlParser::RELEASE_LOCK:
      case MySqlParser::REVERSE:
      case MySqlParser::ROUND:
      case MySqlParser::ROW_COUNT:
      case MySqlParser::RPAD:
      case MySqlParser::RTRIM:
      case MySqlParser::SEC_TO_TIME:
      case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySqlParser::SESSION_USER:
      case MySqlParser::SHA:
      case MySqlParser::SHA1:
      case MySqlParser::SHA2:
      case MySqlParser::SCHEMA_NAME:
      case MySqlParser::SIGN:
      case MySqlParser::SIN:
      case MySqlParser::SLEEP:
      case MySqlParser::SOUNDEX:
      case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
      case MySqlParser::SQRT:
      case MySqlParser::SRID:
      case MySqlParser::STARTPOINT:
      case MySqlParser::STRCMP:
      case MySqlParser::STR_TO_DATE:
      case MySqlParser::ST_AREA:
      case MySqlParser::ST_ASBINARY:
      case MySqlParser::ST_ASTEXT:
      case MySqlParser::ST_ASWKB:
      case MySqlParser::ST_ASWKT:
      case MySqlParser::ST_BUFFER:
      case MySqlParser::ST_CENTROID:
      case MySqlParser::ST_CONTAINS:
      case MySqlParser::ST_CROSSES:
      case MySqlParser::ST_DIFFERENCE:
      case MySqlParser::ST_DIMENSION:
      case MySqlParser::ST_DISJOINT:
      case MySqlParser::ST_DISTANCE:
      case MySqlParser::ST_ENDPOINT:
      case MySqlParser::ST_ENVELOPE:
      case MySqlParser::ST_EQUALS:
      case MySqlParser::ST_EXTERIORRING:
      case MySqlParser::ST_GEOMCOLLFROMTEXT:
      case MySqlParser::ST_GEOMCOLLFROMTXT:
      case MySqlParser::ST_GEOMCOLLFROMWKB:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::ST_GEOMETRYFROMTEXT:
      case MySqlParser::ST_GEOMETRYFROMWKB:
      case MySqlParser::ST_GEOMETRYN:
      case MySqlParser::ST_GEOMETRYTYPE:
      case MySqlParser::ST_GEOMFROMTEXT:
      case MySqlParser::ST_GEOMFROMWKB:
      case MySqlParser::ST_INTERIORRINGN:
      case MySqlParser::ST_INTERSECTION:
      case MySqlParser::ST_INTERSECTS:
      case MySqlParser::ST_ISCLOSED:
      case MySqlParser::ST_ISEMPTY:
      case MySqlParser::ST_ISSIMPLE:
      case MySqlParser::ST_LINEFROMTEXT:
      case MySqlParser::ST_LINEFROMWKB:
      case MySqlParser::ST_LINESTRINGFROMTEXT:
      case MySqlParser::ST_LINESTRINGFROMWKB:
      case MySqlParser::ST_NUMGEOMETRIES:
      case MySqlParser::ST_NUMINTERIORRING:
      case MySqlParser::ST_NUMINTERIORRINGS:
      case MySqlParser::ST_NUMPOINTS:
      case MySqlParser::ST_OVERLAPS:
      case MySqlParser::ST_POINTFROMTEXT:
      case MySqlParser::ST_POINTFROMWKB:
      case MySqlParser::ST_POINTN:
      case MySqlParser::ST_POLYFROMTEXT:
      case MySqlParser::ST_POLYFROMWKB:
      case MySqlParser::ST_POLYGONFROMTEXT:
      case MySqlParser::ST_POLYGONFROMWKB:
      case MySqlParser::ST_SRID:
      case MySqlParser::ST_STARTPOINT:
      case MySqlParser::ST_SYMDIFFERENCE:
      case MySqlParser::ST_TOUCHES:
      case MySqlParser::ST_UNION:
      case MySqlParser::ST_WITHIN:
      case MySqlParser::ST_X:
      case MySqlParser::ST_Y:
      case MySqlParser::SUBDATE:
      case MySqlParser::SUBSTRING_INDEX:
      case MySqlParser::SUBTIME:
      case MySqlParser::SYSTEM_USER:
      case MySqlParser::TAN:
      case MySqlParser::TIMEDIFF:
      case MySqlParser::TIMESTAMPADD:
      case MySqlParser::TIMESTAMPDIFF:
      case MySqlParser::TIME_FORMAT:
      case MySqlParser::TIME_TO_SEC:
      case MySqlParser::TOUCHES:
      case MySqlParser::TO_BASE64:
      case MySqlParser::TO_DAYS:
      case MySqlParser::TO_SECONDS:
      case MySqlParser::TP_CONNECTION_ADMIN:
      case MySqlParser::UCASE:
      case MySqlParser::UNCOMPRESS:
      case MySqlParser::UNCOMPRESSED_LENGTH:
      case MySqlParser::UNHEX:
      case MySqlParser::UNIX_TIMESTAMP:
      case MySqlParser::UPDATEXML:
      case MySqlParser::UPPER:
      case MySqlParser::UUID:
      case MySqlParser::UUID_SHORT:
      case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
      case MySqlParser::VERSION:
      case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
      case MySqlParser::WEEKDAY:
      case MySqlParser::WEEKOFYEAR:
      case MySqlParser::WEIGHT_STRING:
      case MySqlParser::WITHIN:
      case MySqlParser::YEARWEEK:
      case MySqlParser::Y_FUNCTION:
      case MySqlParser::X_FUNCTION:
      case MySqlParser::MOD:
      case MySqlParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(6327);
        simpleId();
        break;
      }

      case MySqlParser::CHARSET_REVERSE_QOUTE_STRING: {
        enterOuterAlt(_localctx, 2);
        setState(6328);
        match(MySqlParser::CHARSET_REVERSE_QOUTE_STRING);
        break;
      }

      case MySqlParser::STRING_LITERAL: {
        enterOuterAlt(_localctx, 3);
        setState(6329);
        match(MySqlParser::STRING_LITERAL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleIdContext ------------------------------------------------------------------

MySqlParser::SimpleIdContext::SimpleIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::SimpleIdContext::ID() {
  return getToken(MySqlParser::ID, 0);
}

MySqlParser::CharsetNameBaseContext* MySqlParser::SimpleIdContext::charsetNameBase() {
  return getRuleContext<MySqlParser::CharsetNameBaseContext>(0);
}

MySqlParser::TransactionLevelBaseContext* MySqlParser::SimpleIdContext::transactionLevelBase() {
  return getRuleContext<MySqlParser::TransactionLevelBaseContext>(0);
}

MySqlParser::EngineNameBaseContext* MySqlParser::SimpleIdContext::engineNameBase() {
  return getRuleContext<MySqlParser::EngineNameBaseContext>(0);
}

MySqlParser::PrivilegesBaseContext* MySqlParser::SimpleIdContext::privilegesBase() {
  return getRuleContext<MySqlParser::PrivilegesBaseContext>(0);
}

MySqlParser::IntervalTypeBaseContext* MySqlParser::SimpleIdContext::intervalTypeBase() {
  return getRuleContext<MySqlParser::IntervalTypeBaseContext>(0);
}

MySqlParser::DataTypeBaseContext* MySqlParser::SimpleIdContext::dataTypeBase() {
  return getRuleContext<MySqlParser::DataTypeBaseContext>(0);
}

MySqlParser::KeywordsCanBeIdContext* MySqlParser::SimpleIdContext::keywordsCanBeId() {
  return getRuleContext<MySqlParser::KeywordsCanBeIdContext>(0);
}

MySqlParser::ScalarFunctionNameContext* MySqlParser::SimpleIdContext::scalarFunctionName() {
  return getRuleContext<MySqlParser::ScalarFunctionNameContext>(0);
}


size_t MySqlParser::SimpleIdContext::getRuleIndex() const {
  return MySqlParser::RuleSimpleId;
}

void MySqlParser::SimpleIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleId(this);
}

void MySqlParser::SimpleIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleId(this);
}


std::any MySqlParser::SimpleIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSimpleId(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SimpleIdContext* MySqlParser::simpleId() {
  SimpleIdContext *_localctx = _tracker.createInstance<SimpleIdContext>(_ctx, getState());
  enterRule(_localctx, 576, MySqlParser::RuleSimpleId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6341);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 931, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6332);
      match(MySqlParser::ID);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6333);
      charsetNameBase();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6334);
      transactionLevelBase();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6335);
      engineNameBase();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6336);
      privilegesBase();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6337);
      intervalTypeBase();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6338);
      dataTypeBase();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6339);
      keywordsCanBeId();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6340);
      scalarFunctionName();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DottedIdContext ------------------------------------------------------------------

MySqlParser::DottedIdContext::DottedIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DottedIdContext::DOT_ID() {
  return getToken(MySqlParser::DOT_ID, 0);
}

tree::TerminalNode* MySqlParser::DottedIdContext::DOT() {
  return getToken(MySqlParser::DOT, 0);
}

MySqlParser::UidContext* MySqlParser::DottedIdContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}


size_t MySqlParser::DottedIdContext::getRuleIndex() const {
  return MySqlParser::RuleDottedId;
}

void MySqlParser::DottedIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDottedId(this);
}

void MySqlParser::DottedIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDottedId(this);
}


std::any MySqlParser::DottedIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDottedId(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DottedIdContext* MySqlParser::dottedId() {
  DottedIdContext *_localctx = _tracker.createInstance<DottedIdContext>(_ctx, getState());
  enterRule(_localctx, 578, MySqlParser::RuleDottedId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6346);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::DOT_ID: {
        enterOuterAlt(_localctx, 1);
        setState(6343);
        match(MySqlParser::DOT_ID);
        break;
      }

      case MySqlParser::DOT: {
        enterOuterAlt(_localctx, 2);
        setState(6344);
        match(MySqlParser::DOT);
        setState(6345);
        uid();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecimalLiteralContext ------------------------------------------------------------------

MySqlParser::DecimalLiteralContext::DecimalLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DecimalLiteralContext::DECIMAL_LITERAL() {
  return getToken(MySqlParser::DECIMAL_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::DecimalLiteralContext::ZERO_DECIMAL() {
  return getToken(MySqlParser::ZERO_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::DecimalLiteralContext::ONE_DECIMAL() {
  return getToken(MySqlParser::ONE_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::DecimalLiteralContext::TWO_DECIMAL() {
  return getToken(MySqlParser::TWO_DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::DecimalLiteralContext::REAL_LITERAL() {
  return getToken(MySqlParser::REAL_LITERAL, 0);
}


size_t MySqlParser::DecimalLiteralContext::getRuleIndex() const {
  return MySqlParser::RuleDecimalLiteral;
}

void MySqlParser::DecimalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecimalLiteral(this);
}

void MySqlParser::DecimalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecimalLiteral(this);
}


std::any MySqlParser::DecimalLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDecimalLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DecimalLiteralContext* MySqlParser::decimalLiteral() {
  DecimalLiteralContext *_localctx = _tracker.createInstance<DecimalLiteralContext>(_ctx, getState());
  enterRule(_localctx, 580, MySqlParser::RuleDecimalLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6348);
    _la = _input->LA(1);
    if (!(((((_la - 1137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1137)) & 10247) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FileSizeLiteralContext ------------------------------------------------------------------

MySqlParser::FileSizeLiteralContext::FileSizeLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::FileSizeLiteralContext::FILESIZE_LITERAL() {
  return getToken(MySqlParser::FILESIZE_LITERAL, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::FileSizeLiteralContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}


size_t MySqlParser::FileSizeLiteralContext::getRuleIndex() const {
  return MySqlParser::RuleFileSizeLiteral;
}

void MySqlParser::FileSizeLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFileSizeLiteral(this);
}

void MySqlParser::FileSizeLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFileSizeLiteral(this);
}


std::any MySqlParser::FileSizeLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFileSizeLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FileSizeLiteralContext* MySqlParser::fileSizeLiteral() {
  FileSizeLiteralContext *_localctx = _tracker.createInstance<FileSizeLiteralContext>(_ctx, getState());
  enterRule(_localctx, 582, MySqlParser::RuleFileSizeLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6352);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::FILESIZE_LITERAL: {
        enterOuterAlt(_localctx, 1);
        setState(6350);
        match(MySqlParser::FILESIZE_LITERAL);
        break;
      }

      case MySqlParser::ZERO_DECIMAL:
      case MySqlParser::ONE_DECIMAL:
      case MySqlParser::TWO_DECIMAL:
      case MySqlParser::DECIMAL_LITERAL:
      case MySqlParser::REAL_LITERAL: {
        enterOuterAlt(_localctx, 2);
        setState(6351);
        decimalLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringLiteralContext ------------------------------------------------------------------

MySqlParser::StringLiteralContext::StringLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySqlParser::StringLiteralContext::STRING_LITERAL() {
  return getTokens(MySqlParser::STRING_LITERAL);
}

tree::TerminalNode* MySqlParser::StringLiteralContext::STRING_LITERAL(size_t i) {
  return getToken(MySqlParser::STRING_LITERAL, i);
}

tree::TerminalNode* MySqlParser::StringLiteralContext::START_NATIONAL_STRING_LITERAL() {
  return getToken(MySqlParser::START_NATIONAL_STRING_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::StringLiteralContext::STRING_CHARSET_NAME() {
  return getToken(MySqlParser::STRING_CHARSET_NAME, 0);
}

tree::TerminalNode* MySqlParser::StringLiteralContext::COLLATE() {
  return getToken(MySqlParser::COLLATE, 0);
}

MySqlParser::CollationNameContext* MySqlParser::StringLiteralContext::collationName() {
  return getRuleContext<MySqlParser::CollationNameContext>(0);
}


size_t MySqlParser::StringLiteralContext::getRuleIndex() const {
  return MySqlParser::RuleStringLiteral;
}

void MySqlParser::StringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringLiteral(this);
}

void MySqlParser::StringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringLiteral(this);
}


std::any MySqlParser::StringLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitStringLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::StringLiteralContext* MySqlParser::stringLiteral() {
  StringLiteralContext *_localctx = _tracker.createInstance<StringLiteralContext>(_ctx, getState());
  enterRule(_localctx, 584, MySqlParser::RuleStringLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(6377);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 940, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6359);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::STRING_LITERAL:
        case MySqlParser::STRING_CHARSET_NAME: {
          setState(6355);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::STRING_CHARSET_NAME) {
            setState(6354);
            match(MySqlParser::STRING_CHARSET_NAME);
          }
          setState(6357);
          match(MySqlParser::STRING_LITERAL);
          break;
        }

        case MySqlParser::START_NATIONAL_STRING_LITERAL: {
          setState(6358);
          match(MySqlParser::START_NATIONAL_STRING_LITERAL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(6362); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(6361);
                match(MySqlParser::STRING_LITERAL);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(6364); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 936, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6371);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySqlParser::STRING_LITERAL:
        case MySqlParser::STRING_CHARSET_NAME: {
          setState(6367);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::STRING_CHARSET_NAME) {
            setState(6366);
            match(MySqlParser::STRING_CHARSET_NAME);
          }
          setState(6369);
          match(MySqlParser::STRING_LITERAL);
          break;
        }

        case MySqlParser::START_NATIONAL_STRING_LITERAL: {
          setState(6370);
          match(MySqlParser::START_NATIONAL_STRING_LITERAL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(6375);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 939, _ctx)) {
      case 1: {
        setState(6373);
        match(MySqlParser::COLLATE);
        setState(6374);
        collationName();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanLiteralContext ------------------------------------------------------------------

MySqlParser::BooleanLiteralContext::BooleanLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::BooleanLiteralContext::TRUE() {
  return getToken(MySqlParser::TRUE, 0);
}

tree::TerminalNode* MySqlParser::BooleanLiteralContext::FALSE() {
  return getToken(MySqlParser::FALSE, 0);
}


size_t MySqlParser::BooleanLiteralContext::getRuleIndex() const {
  return MySqlParser::RuleBooleanLiteral;
}

void MySqlParser::BooleanLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanLiteral(this);
}

void MySqlParser::BooleanLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanLiteral(this);
}


std::any MySqlParser::BooleanLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitBooleanLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::BooleanLiteralContext* MySqlParser::booleanLiteral() {
  BooleanLiteralContext *_localctx = _tracker.createInstance<BooleanLiteralContext>(_ctx, getState());
  enterRule(_localctx, 586, MySqlParser::RuleBooleanLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6379);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::FALSE || _la == MySqlParser::TRUE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HexadecimalLiteralContext ------------------------------------------------------------------

MySqlParser::HexadecimalLiteralContext::HexadecimalLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::HexadecimalLiteralContext::HEXADECIMAL_LITERAL() {
  return getToken(MySqlParser::HEXADECIMAL_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::HexadecimalLiteralContext::STRING_CHARSET_NAME() {
  return getToken(MySqlParser::STRING_CHARSET_NAME, 0);
}


size_t MySqlParser::HexadecimalLiteralContext::getRuleIndex() const {
  return MySqlParser::RuleHexadecimalLiteral;
}

void MySqlParser::HexadecimalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHexadecimalLiteral(this);
}

void MySqlParser::HexadecimalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHexadecimalLiteral(this);
}


std::any MySqlParser::HexadecimalLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitHexadecimalLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::HexadecimalLiteralContext* MySqlParser::hexadecimalLiteral() {
  HexadecimalLiteralContext *_localctx = _tracker.createInstance<HexadecimalLiteralContext>(_ctx, getState());
  enterRule(_localctx, 588, MySqlParser::RuleHexadecimalLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6382);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::STRING_CHARSET_NAME) {
      setState(6381);
      match(MySqlParser::STRING_CHARSET_NAME);
    }
    setState(6384);
    match(MySqlParser::HEXADECIMAL_LITERAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullNotnullContext ------------------------------------------------------------------

MySqlParser::NullNotnullContext::NullNotnullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::NullNotnullContext::NULL_LITERAL() {
  return getToken(MySqlParser::NULL_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::NullNotnullContext::NULL_SPEC_LITERAL() {
  return getToken(MySqlParser::NULL_SPEC_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::NullNotnullContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}


size_t MySqlParser::NullNotnullContext::getRuleIndex() const {
  return MySqlParser::RuleNullNotnull;
}

void MySqlParser::NullNotnullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullNotnull(this);
}

void MySqlParser::NullNotnullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullNotnull(this);
}


std::any MySqlParser::NullNotnullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitNullNotnull(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::NullNotnullContext* MySqlParser::nullNotnull() {
  NullNotnullContext *_localctx = _tracker.createInstance<NullNotnullContext>(_ctx, getState());
  enterRule(_localctx, 590, MySqlParser::RuleNullNotnull);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6387);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::NOT) {
      setState(6386);
      match(MySqlParser::NOT);
    }
    setState(6389);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::NULL_LITERAL || _la == MySqlParser::NULL_SPEC_LITERAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

MySqlParser::ConstantContext::ConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::StringLiteralContext* MySqlParser::ConstantContext::stringLiteral() {
  return getRuleContext<MySqlParser::StringLiteralContext>(0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::ConstantContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::ConstantContext::MINUS() {
  return getToken(MySqlParser::MINUS, 0);
}

MySqlParser::HexadecimalLiteralContext* MySqlParser::ConstantContext::hexadecimalLiteral() {
  return getRuleContext<MySqlParser::HexadecimalLiteralContext>(0);
}

MySqlParser::BooleanLiteralContext* MySqlParser::ConstantContext::booleanLiteral() {
  return getRuleContext<MySqlParser::BooleanLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::ConstantContext::REAL_LITERAL() {
  return getToken(MySqlParser::REAL_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::ConstantContext::BIT_STRING() {
  return getToken(MySqlParser::BIT_STRING, 0);
}

tree::TerminalNode* MySqlParser::ConstantContext::NULL_LITERAL() {
  return getToken(MySqlParser::NULL_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::ConstantContext::NULL_SPEC_LITERAL() {
  return getToken(MySqlParser::NULL_SPEC_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::ConstantContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}


size_t MySqlParser::ConstantContext::getRuleIndex() const {
  return MySqlParser::RuleConstant;
}

void MySqlParser::ConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant(this);
}

void MySqlParser::ConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant(this);
}


std::any MySqlParser::ConstantContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitConstant(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ConstantContext* MySqlParser::constant() {
  ConstantContext *_localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
  enterRule(_localctx, 592, MySqlParser::RuleConstant);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6403);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 944, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6391);
      stringLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6392);
      decimalLiteral();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6393);
      match(MySqlParser::MINUS);
      setState(6394);
      decimalLiteral();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6395);
      hexadecimalLiteral();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6396);
      booleanLiteral();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6397);
      match(MySqlParser::REAL_LITERAL);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6398);
      match(MySqlParser::BIT_STRING);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6400);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::NOT) {
        setState(6399);
        match(MySqlParser::NOT);
      }
      setState(6402);
      antlrcpp::downCast<ConstantContext *>(_localctx)->nullLiteral = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::NULL_LITERAL || _la == MySqlParser::NULL_SPEC_LITERAL)) {
        antlrcpp::downCast<ConstantContext *>(_localctx)->nullLiteral = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataTypeContext ------------------------------------------------------------------

MySqlParser::DataTypeContext::DataTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::DataTypeContext::getRuleIndex() const {
  return MySqlParser::RuleDataType;
}

void MySqlParser::DataTypeContext::copyFrom(DataTypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SpatialDataTypeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SpatialDataTypeContext::GEOMETRYCOLLECTION() {
  return getToken(MySqlParser::GEOMETRYCOLLECTION, 0);
}

tree::TerminalNode* MySqlParser::SpatialDataTypeContext::GEOMCOLLECTION() {
  return getToken(MySqlParser::GEOMCOLLECTION, 0);
}

tree::TerminalNode* MySqlParser::SpatialDataTypeContext::LINESTRING() {
  return getToken(MySqlParser::LINESTRING, 0);
}

tree::TerminalNode* MySqlParser::SpatialDataTypeContext::MULTILINESTRING() {
  return getToken(MySqlParser::MULTILINESTRING, 0);
}

tree::TerminalNode* MySqlParser::SpatialDataTypeContext::MULTIPOINT() {
  return getToken(MySqlParser::MULTIPOINT, 0);
}

tree::TerminalNode* MySqlParser::SpatialDataTypeContext::MULTIPOLYGON() {
  return getToken(MySqlParser::MULTIPOLYGON, 0);
}

tree::TerminalNode* MySqlParser::SpatialDataTypeContext::POINT() {
  return getToken(MySqlParser::POINT, 0);
}

tree::TerminalNode* MySqlParser::SpatialDataTypeContext::POLYGON() {
  return getToken(MySqlParser::POLYGON, 0);
}

tree::TerminalNode* MySqlParser::SpatialDataTypeContext::JSON() {
  return getToken(MySqlParser::JSON, 0);
}

tree::TerminalNode* MySqlParser::SpatialDataTypeContext::GEOMETRY() {
  return getToken(MySqlParser::GEOMETRY, 0);
}

tree::TerminalNode* MySqlParser::SpatialDataTypeContext::SRID() {
  return getToken(MySqlParser::SRID, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::SpatialDataTypeContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

MySqlParser::SpatialDataTypeContext::SpatialDataTypeContext(DataTypeContext *ctx) { copyFrom(ctx); }

void MySqlParser::SpatialDataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpatialDataType(this);
}
void MySqlParser::SpatialDataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpatialDataType(this);
}

std::any MySqlParser::SpatialDataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSpatialDataType(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LongVarbinaryDataTypeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::LongVarbinaryDataTypeContext::LONG() {
  return getToken(MySqlParser::LONG, 0);
}

tree::TerminalNode* MySqlParser::LongVarbinaryDataTypeContext::VARBINARY() {
  return getToken(MySqlParser::VARBINARY, 0);
}

MySqlParser::LongVarbinaryDataTypeContext::LongVarbinaryDataTypeContext(DataTypeContext *ctx) { copyFrom(ctx); }

void MySqlParser::LongVarbinaryDataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLongVarbinaryDataType(this);
}
void MySqlParser::LongVarbinaryDataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLongVarbinaryDataType(this);
}

std::any MySqlParser::LongVarbinaryDataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLongVarbinaryDataType(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CollectionDataTypeContext ------------------------------------------------------------------

MySqlParser::CollectionOptionsContext* MySqlParser::CollectionDataTypeContext::collectionOptions() {
  return getRuleContext<MySqlParser::CollectionOptionsContext>(0);
}

tree::TerminalNode* MySqlParser::CollectionDataTypeContext::ENUM() {
  return getToken(MySqlParser::ENUM, 0);
}

tree::TerminalNode* MySqlParser::CollectionDataTypeContext::SET() {
  return getToken(MySqlParser::SET, 0);
}

tree::TerminalNode* MySqlParser::CollectionDataTypeContext::BINARY() {
  return getToken(MySqlParser::BINARY, 0);
}

MySqlParser::CharSetContext* MySqlParser::CollectionDataTypeContext::charSet() {
  return getRuleContext<MySqlParser::CharSetContext>(0);
}

MySqlParser::CharsetNameContext* MySqlParser::CollectionDataTypeContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

MySqlParser::CollectionDataTypeContext::CollectionDataTypeContext(DataTypeContext *ctx) { copyFrom(ctx); }

void MySqlParser::CollectionDataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollectionDataType(this);
}
void MySqlParser::CollectionDataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollectionDataType(this);
}

std::any MySqlParser::CollectionDataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCollectionDataType(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NationalVaryingStringDataTypeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::NationalVaryingStringDataTypeContext::NATIONAL() {
  return getToken(MySqlParser::NATIONAL, 0);
}

tree::TerminalNode* MySqlParser::NationalVaryingStringDataTypeContext::VARYING() {
  return getToken(MySqlParser::VARYING, 0);
}

tree::TerminalNode* MySqlParser::NationalVaryingStringDataTypeContext::CHAR() {
  return getToken(MySqlParser::CHAR, 0);
}

tree::TerminalNode* MySqlParser::NationalVaryingStringDataTypeContext::CHARACTER() {
  return getToken(MySqlParser::CHARACTER, 0);
}

MySqlParser::LengthOneDimensionContext* MySqlParser::NationalVaryingStringDataTypeContext::lengthOneDimension() {
  return getRuleContext<MySqlParser::LengthOneDimensionContext>(0);
}

tree::TerminalNode* MySqlParser::NationalVaryingStringDataTypeContext::BINARY() {
  return getToken(MySqlParser::BINARY, 0);
}

MySqlParser::NationalVaryingStringDataTypeContext::NationalVaryingStringDataTypeContext(DataTypeContext *ctx) { copyFrom(ctx); }

void MySqlParser::NationalVaryingStringDataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNationalVaryingStringDataType(this);
}
void MySqlParser::NationalVaryingStringDataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNationalVaryingStringDataType(this);
}

std::any MySqlParser::NationalVaryingStringDataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitNationalVaryingStringDataType(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DimensionDataTypeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::TINYINT() {
  return getToken(MySqlParser::TINYINT, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::SMALLINT() {
  return getToken(MySqlParser::SMALLINT, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::MEDIUMINT() {
  return getToken(MySqlParser::MEDIUMINT, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::INT() {
  return getToken(MySqlParser::INT, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::INTEGER() {
  return getToken(MySqlParser::INTEGER, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::BIGINT() {
  return getToken(MySqlParser::BIGINT, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::MIDDLEINT() {
  return getToken(MySqlParser::MIDDLEINT, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::INT1() {
  return getToken(MySqlParser::INT1, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::INT2() {
  return getToken(MySqlParser::INT2, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::INT3() {
  return getToken(MySqlParser::INT3, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::INT4() {
  return getToken(MySqlParser::INT4, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::INT8() {
  return getToken(MySqlParser::INT8, 0);
}

MySqlParser::LengthOneDimensionContext* MySqlParser::DimensionDataTypeContext::lengthOneDimension() {
  return getRuleContext<MySqlParser::LengthOneDimensionContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::DimensionDataTypeContext::SIGNED() {
  return getTokens(MySqlParser::SIGNED);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::SIGNED(size_t i) {
  return getToken(MySqlParser::SIGNED, i);
}

std::vector<tree::TerminalNode *> MySqlParser::DimensionDataTypeContext::UNSIGNED() {
  return getTokens(MySqlParser::UNSIGNED);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::UNSIGNED(size_t i) {
  return getToken(MySqlParser::UNSIGNED, i);
}

std::vector<tree::TerminalNode *> MySqlParser::DimensionDataTypeContext::ZEROFILL() {
  return getTokens(MySqlParser::ZEROFILL);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::ZEROFILL(size_t i) {
  return getToken(MySqlParser::ZEROFILL, i);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::REAL() {
  return getToken(MySqlParser::REAL, 0);
}

MySqlParser::LengthTwoDimensionContext* MySqlParser::DimensionDataTypeContext::lengthTwoDimension() {
  return getRuleContext<MySqlParser::LengthTwoDimensionContext>(0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::DOUBLE() {
  return getToken(MySqlParser::DOUBLE, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::PRECISION() {
  return getToken(MySqlParser::PRECISION, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::DECIMAL() {
  return getToken(MySqlParser::DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::DEC() {
  return getToken(MySqlParser::DEC, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::FIXED() {
  return getToken(MySqlParser::FIXED, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::NUMERIC() {
  return getToken(MySqlParser::NUMERIC, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::FLOAT() {
  return getToken(MySqlParser::FLOAT, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::FLOAT4() {
  return getToken(MySqlParser::FLOAT4, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::FLOAT8() {
  return getToken(MySqlParser::FLOAT8, 0);
}

MySqlParser::LengthTwoOptionalDimensionContext* MySqlParser::DimensionDataTypeContext::lengthTwoOptionalDimension() {
  return getRuleContext<MySqlParser::LengthTwoOptionalDimensionContext>(0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::BIT() {
  return getToken(MySqlParser::BIT, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::TIME() {
  return getToken(MySqlParser::TIME, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::TIMESTAMP() {
  return getToken(MySqlParser::TIMESTAMP, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::DATETIME() {
  return getToken(MySqlParser::DATETIME, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::BINARY() {
  return getToken(MySqlParser::BINARY, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::VARBINARY() {
  return getToken(MySqlParser::VARBINARY, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::BLOB() {
  return getToken(MySqlParser::BLOB, 0);
}

tree::TerminalNode* MySqlParser::DimensionDataTypeContext::YEAR() {
  return getToken(MySqlParser::YEAR, 0);
}

MySqlParser::DimensionDataTypeContext::DimensionDataTypeContext(DataTypeContext *ctx) { copyFrom(ctx); }

void MySqlParser::DimensionDataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDimensionDataType(this);
}
void MySqlParser::DimensionDataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDimensionDataType(this);
}

std::any MySqlParser::DimensionDataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDimensionDataType(this);
  else
    return visitor->visitChildren(this);
}
//----------------- StringDataTypeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::StringDataTypeContext::CHAR() {
  return getToken(MySqlParser::CHAR, 0);
}

tree::TerminalNode* MySqlParser::StringDataTypeContext::CHARACTER() {
  return getToken(MySqlParser::CHARACTER, 0);
}

tree::TerminalNode* MySqlParser::StringDataTypeContext::VARCHAR() {
  return getToken(MySqlParser::VARCHAR, 0);
}

tree::TerminalNode* MySqlParser::StringDataTypeContext::TINYTEXT() {
  return getToken(MySqlParser::TINYTEXT, 0);
}

tree::TerminalNode* MySqlParser::StringDataTypeContext::TEXT() {
  return getToken(MySqlParser::TEXT, 0);
}

tree::TerminalNode* MySqlParser::StringDataTypeContext::MEDIUMTEXT() {
  return getToken(MySqlParser::MEDIUMTEXT, 0);
}

tree::TerminalNode* MySqlParser::StringDataTypeContext::LONGTEXT() {
  return getToken(MySqlParser::LONGTEXT, 0);
}

tree::TerminalNode* MySqlParser::StringDataTypeContext::NCHAR() {
  return getToken(MySqlParser::NCHAR, 0);
}

tree::TerminalNode* MySqlParser::StringDataTypeContext::NVARCHAR() {
  return getToken(MySqlParser::NVARCHAR, 0);
}

tree::TerminalNode* MySqlParser::StringDataTypeContext::LONG() {
  return getToken(MySqlParser::LONG, 0);
}

tree::TerminalNode* MySqlParser::StringDataTypeContext::VARYING() {
  return getToken(MySqlParser::VARYING, 0);
}

MySqlParser::LengthOneDimensionContext* MySqlParser::StringDataTypeContext::lengthOneDimension() {
  return getRuleContext<MySqlParser::LengthOneDimensionContext>(0);
}

std::vector<tree::TerminalNode *> MySqlParser::StringDataTypeContext::BINARY() {
  return getTokens(MySqlParser::BINARY);
}

tree::TerminalNode* MySqlParser::StringDataTypeContext::BINARY(size_t i) {
  return getToken(MySqlParser::BINARY, i);
}

MySqlParser::CharSetContext* MySqlParser::StringDataTypeContext::charSet() {
  return getRuleContext<MySqlParser::CharSetContext>(0);
}

MySqlParser::CharsetNameContext* MySqlParser::StringDataTypeContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySqlParser::StringDataTypeContext::COLLATE() {
  return getToken(MySqlParser::COLLATE, 0);
}

MySqlParser::CollationNameContext* MySqlParser::StringDataTypeContext::collationName() {
  return getRuleContext<MySqlParser::CollationNameContext>(0);
}

MySqlParser::StringDataTypeContext::StringDataTypeContext(DataTypeContext *ctx) { copyFrom(ctx); }

void MySqlParser::StringDataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringDataType(this);
}
void MySqlParser::StringDataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringDataType(this);
}

std::any MySqlParser::StringDataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitStringDataType(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LongVarcharDataTypeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::LongVarcharDataTypeContext::LONG() {
  return getToken(MySqlParser::LONG, 0);
}

tree::TerminalNode* MySqlParser::LongVarcharDataTypeContext::VARCHAR() {
  return getToken(MySqlParser::VARCHAR, 0);
}

tree::TerminalNode* MySqlParser::LongVarcharDataTypeContext::BINARY() {
  return getToken(MySqlParser::BINARY, 0);
}

MySqlParser::CharSetContext* MySqlParser::LongVarcharDataTypeContext::charSet() {
  return getRuleContext<MySqlParser::CharSetContext>(0);
}

MySqlParser::CharsetNameContext* MySqlParser::LongVarcharDataTypeContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySqlParser::LongVarcharDataTypeContext::COLLATE() {
  return getToken(MySqlParser::COLLATE, 0);
}

MySqlParser::CollationNameContext* MySqlParser::LongVarcharDataTypeContext::collationName() {
  return getRuleContext<MySqlParser::CollationNameContext>(0);
}

MySqlParser::LongVarcharDataTypeContext::LongVarcharDataTypeContext(DataTypeContext *ctx) { copyFrom(ctx); }

void MySqlParser::LongVarcharDataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLongVarcharDataType(this);
}
void MySqlParser::LongVarcharDataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLongVarcharDataType(this);
}

std::any MySqlParser::LongVarcharDataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLongVarcharDataType(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NationalStringDataTypeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::NationalStringDataTypeContext::NATIONAL() {
  return getToken(MySqlParser::NATIONAL, 0);
}

tree::TerminalNode* MySqlParser::NationalStringDataTypeContext::VARCHAR() {
  return getToken(MySqlParser::VARCHAR, 0);
}

tree::TerminalNode* MySqlParser::NationalStringDataTypeContext::CHARACTER() {
  return getToken(MySqlParser::CHARACTER, 0);
}

tree::TerminalNode* MySqlParser::NationalStringDataTypeContext::CHAR() {
  return getToken(MySqlParser::CHAR, 0);
}

MySqlParser::LengthOneDimensionContext* MySqlParser::NationalStringDataTypeContext::lengthOneDimension() {
  return getRuleContext<MySqlParser::LengthOneDimensionContext>(0);
}

tree::TerminalNode* MySqlParser::NationalStringDataTypeContext::BINARY() {
  return getToken(MySqlParser::BINARY, 0);
}

tree::TerminalNode* MySqlParser::NationalStringDataTypeContext::NCHAR() {
  return getToken(MySqlParser::NCHAR, 0);
}

MySqlParser::NationalStringDataTypeContext::NationalStringDataTypeContext(DataTypeContext *ctx) { copyFrom(ctx); }

void MySqlParser::NationalStringDataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNationalStringDataType(this);
}
void MySqlParser::NationalStringDataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNationalStringDataType(this);
}

std::any MySqlParser::NationalStringDataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitNationalStringDataType(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleDataTypeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SimpleDataTypeContext::DATE() {
  return getToken(MySqlParser::DATE, 0);
}

tree::TerminalNode* MySqlParser::SimpleDataTypeContext::TINYBLOB() {
  return getToken(MySqlParser::TINYBLOB, 0);
}

tree::TerminalNode* MySqlParser::SimpleDataTypeContext::MEDIUMBLOB() {
  return getToken(MySqlParser::MEDIUMBLOB, 0);
}

tree::TerminalNode* MySqlParser::SimpleDataTypeContext::LONGBLOB() {
  return getToken(MySqlParser::LONGBLOB, 0);
}

tree::TerminalNode* MySqlParser::SimpleDataTypeContext::BOOL() {
  return getToken(MySqlParser::BOOL, 0);
}

tree::TerminalNode* MySqlParser::SimpleDataTypeContext::BOOLEAN() {
  return getToken(MySqlParser::BOOLEAN, 0);
}

tree::TerminalNode* MySqlParser::SimpleDataTypeContext::SERIAL() {
  return getToken(MySqlParser::SERIAL, 0);
}

MySqlParser::SimpleDataTypeContext::SimpleDataTypeContext(DataTypeContext *ctx) { copyFrom(ctx); }

void MySqlParser::SimpleDataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleDataType(this);
}
void MySqlParser::SimpleDataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleDataType(this);
}

std::any MySqlParser::SimpleDataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSimpleDataType(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::DataTypeContext* MySqlParser::dataType() {
  DataTypeContext *_localctx = _tracker.createInstance<DataTypeContext>(_ctx, getState());
  enterRule(_localctx, 594, MySqlParser::RuleDataType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(6531);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 973, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::StringDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(6405);
      antlrcpp::downCast<StringDataTypeContext *>(_localctx)->typeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::CHARACTER || ((((_la - 222) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 222)) & 31239) != 0) || _la == MySqlParser::NCHAR)) {
        antlrcpp::downCast<StringDataTypeContext *>(_localctx)->typeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6407);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::VARYING) {
        setState(6406);
        match(MySqlParser::VARYING);
      }
      setState(6410);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 946, _ctx)) {
      case 1: {
        setState(6409);
        lengthOneDimension();
        break;
      }

      default:
        break;
      }
      setState(6413);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 947, _ctx)) {
      case 1: {
        setState(6412);
        match(MySqlParser::BINARY);
        break;
      }

      default:
        break;
      }
      setState(6418);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 948, _ctx)) {
      case 1: {
        setState(6415);
        charSet();
        setState(6416);
        charsetName();
        break;
      }

      default:
        break;
      }
      setState(6423);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 949, _ctx)) {
      case 1: {
        setState(6420);
        match(MySqlParser::COLLATE);
        setState(6421);
        collationName();
        break;
      }

      case 2: {
        setState(6422);
        match(MySqlParser::BINARY);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::NationalVaryingStringDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(6425);
      match(MySqlParser::NATIONAL);
      setState(6426);
      antlrcpp::downCast<NationalVaryingStringDataTypeContext *>(_localctx)->typeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::CHARACTER || _la == MySqlParser::CHAR)) {
        antlrcpp::downCast<NationalVaryingStringDataTypeContext *>(_localctx)->typeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6427);
      match(MySqlParser::VARYING);
      setState(6429);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 950, _ctx)) {
      case 1: {
        setState(6428);
        lengthOneDimension();
        break;
      }

      default:
        break;
      }
      setState(6432);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 951, _ctx)) {
      case 1: {
        setState(6431);
        match(MySqlParser::BINARY);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::NationalStringDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(6434);
      match(MySqlParser::NATIONAL);
      setState(6435);
      antlrcpp::downCast<NationalStringDataTypeContext *>(_localctx)->typeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::CHARACTER || _la == MySqlParser::CHAR

      || _la == MySqlParser::VARCHAR)) {
        antlrcpp::downCast<NationalStringDataTypeContext *>(_localctx)->typeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6437);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 952, _ctx)) {
      case 1: {
        setState(6436);
        lengthOneDimension();
        break;
      }

      default:
        break;
      }
      setState(6440);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 953, _ctx)) {
      case 1: {
        setState(6439);
        match(MySqlParser::BINARY);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::NationalStringDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(6442);
      match(MySqlParser::NCHAR);
      setState(6443);
      antlrcpp::downCast<NationalStringDataTypeContext *>(_localctx)->typeName = match(MySqlParser::VARCHAR);
      setState(6445);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 954, _ctx)) {
      case 1: {
        setState(6444);
        lengthOneDimension();
        break;
      }

      default:
        break;
      }
      setState(6448);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 955, _ctx)) {
      case 1: {
        setState(6447);
        match(MySqlParser::BINARY);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<MySqlParser::DimensionDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(6450);
      antlrcpp::downCast<DimensionDataTypeContext *>(_localctx)->typeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 196) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 196)) & 4095) != 0))) {
        antlrcpp::downCast<DimensionDataTypeContext *>(_localctx)->typeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6452);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 956, _ctx)) {
      case 1: {
        setState(6451);
        lengthOneDimension();
        break;
      }

      default:
        break;
      }
      setState(6457);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 957, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(6454);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::UNSIGNED

          || _la == MySqlParser::ZEROFILL || _la == MySqlParser::SIGNED)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          } 
        }
        setState(6459);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 957, _ctx);
      }
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<MySqlParser::DimensionDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(6460);
      antlrcpp::downCast<DimensionDataTypeContext *>(_localctx)->typeName = match(MySqlParser::REAL);
      setState(6462);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 958, _ctx)) {
      case 1: {
        setState(6461);
        lengthTwoDimension();
        break;
      }

      default:
        break;
      }
      setState(6467);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 959, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(6464);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::UNSIGNED

          || _la == MySqlParser::ZEROFILL || _la == MySqlParser::SIGNED)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          } 
        }
        setState(6469);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 959, _ctx);
      }
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<MySqlParser::DimensionDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(6470);
      antlrcpp::downCast<DimensionDataTypeContext *>(_localctx)->typeName = match(MySqlParser::DOUBLE);
      setState(6472);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::PRECISION) {
        setState(6471);
        match(MySqlParser::PRECISION);
      }
      setState(6475);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 961, _ctx)) {
      case 1: {
        setState(6474);
        lengthTwoDimension();
        break;
      }

      default:
        break;
      }
      setState(6480);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 962, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(6477);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::UNSIGNED

          || _la == MySqlParser::ZEROFILL || _la == MySqlParser::SIGNED)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          } 
        }
        setState(6482);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 962, _ctx);
      }
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<MySqlParser::DimensionDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(6483);
      antlrcpp::downCast<DimensionDataTypeContext *>(_localctx)->typeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 211) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 211)) & 63) != 0) || _la == MySqlParser::FIXED)) {
        antlrcpp::downCast<DimensionDataTypeContext *>(_localctx)->typeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6485);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 963, _ctx)) {
      case 1: {
        setState(6484);
        lengthTwoOptionalDimension();
        break;
      }

      default:
        break;
      }
      setState(6490);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 964, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(6487);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::UNSIGNED

          || _la == MySqlParser::ZEROFILL || _la == MySqlParser::SIGNED)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          } 
        }
        setState(6492);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 964, _ctx);
      }
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<MySqlParser::SimpleDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(6493);
      antlrcpp::downCast<SimpleDataTypeContext *>(_localctx)->typeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 217) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 217)) & 4237313) != 0) || _la == MySqlParser::BOOL

      || _la == MySqlParser::BOOLEAN)) {
        antlrcpp::downCast<SimpleDataTypeContext *>(_localctx)->typeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<MySqlParser::DimensionDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(6494);
      antlrcpp::downCast<DimensionDataTypeContext *>(_localctx)->typeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 218) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 218)) & 2831) != 0) || _la == MySqlParser::BIT)) {
        antlrcpp::downCast<DimensionDataTypeContext *>(_localctx)->typeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6496);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 965, _ctx)) {
      case 1: {
        setState(6495);
        lengthOneDimension();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<MySqlParser::CollectionDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 11);
      setState(6498);
      antlrcpp::downCast<CollectionDataTypeContext *>(_localctx)->typeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::SET || _la == MySqlParser::ENUM)) {
        antlrcpp::downCast<CollectionDataTypeContext *>(_localctx)->typeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6499);
      collectionOptions();
      setState(6501);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 966, _ctx)) {
      case 1: {
        setState(6500);
        match(MySqlParser::BINARY);
        break;
      }

      default:
        break;
      }
      setState(6506);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 967, _ctx)) {
      case 1: {
        setState(6503);
        charSet();
        setState(6504);
        charsetName();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<MySqlParser::SpatialDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 12);
      setState(6508);
      antlrcpp::downCast<SpatialDataTypeContext *>(_localctx)->typeName = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::JSON || ((((_la - 803) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 803)) & 511) != 0))) {
        antlrcpp::downCast<SpatialDataTypeContext *>(_localctx)->typeName = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6511);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 968, _ctx)) {
      case 1: {
        setState(6509);
        match(MySqlParser::SRID);
        setState(6510);
        decimalLiteral();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<MySqlParser::LongVarcharDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 13);
      setState(6513);
      antlrcpp::downCast<LongVarcharDataTypeContext *>(_localctx)->typeName = match(MySqlParser::LONG);
      setState(6515);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::VARCHAR) {
        setState(6514);
        match(MySqlParser::VARCHAR);
      }
      setState(6518);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 970, _ctx)) {
      case 1: {
        setState(6517);
        match(MySqlParser::BINARY);
        break;
      }

      default:
        break;
      }
      setState(6523);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 971, _ctx)) {
      case 1: {
        setState(6520);
        charSet();
        setState(6521);
        charsetName();
        break;
      }

      default:
        break;
      }
      setState(6527);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 972, _ctx)) {
      case 1: {
        setState(6525);
        match(MySqlParser::COLLATE);
        setState(6526);
        collationName();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<MySqlParser::LongVarbinaryDataTypeContext>(_localctx);
      enterOuterAlt(_localctx, 14);
      setState(6529);
      match(MySqlParser::LONG);
      setState(6530);
      match(MySqlParser::VARBINARY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollectionOptionsContext ------------------------------------------------------------------

MySqlParser::CollectionOptionsContext::CollectionOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CollectionOptionsContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::CollectionOptionsContext::STRING_LITERAL() {
  return getTokens(MySqlParser::STRING_LITERAL);
}

tree::TerminalNode* MySqlParser::CollectionOptionsContext::STRING_LITERAL(size_t i) {
  return getToken(MySqlParser::STRING_LITERAL, i);
}

tree::TerminalNode* MySqlParser::CollectionOptionsContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::CollectionOptionsContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::CollectionOptionsContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::CollectionOptionsContext::getRuleIndex() const {
  return MySqlParser::RuleCollectionOptions;
}

void MySqlParser::CollectionOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollectionOptions(this);
}

void MySqlParser::CollectionOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollectionOptions(this);
}


std::any MySqlParser::CollectionOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCollectionOptions(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CollectionOptionsContext* MySqlParser::collectionOptions() {
  CollectionOptionsContext *_localctx = _tracker.createInstance<CollectionOptionsContext>(_ctx, getState());
  enterRule(_localctx, 596, MySqlParser::RuleCollectionOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6533);
    match(MySqlParser::LR_BRACKET);
    setState(6534);
    match(MySqlParser::STRING_LITERAL);
    setState(6539);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(6535);
      match(MySqlParser::COMMA);
      setState(6536);
      match(MySqlParser::STRING_LITERAL);
      setState(6541);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6542);
    match(MySqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConvertedDataTypeContext ------------------------------------------------------------------

MySqlParser::ConvertedDataTypeContext::ConvertedDataTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ConvertedDataTypeContext::CHAR() {
  return getToken(MySqlParser::CHAR, 0);
}

tree::TerminalNode* MySqlParser::ConvertedDataTypeContext::DECIMAL() {
  return getToken(MySqlParser::DECIMAL, 0);
}

tree::TerminalNode* MySqlParser::ConvertedDataTypeContext::SIGNED() {
  return getToken(MySqlParser::SIGNED, 0);
}

tree::TerminalNode* MySqlParser::ConvertedDataTypeContext::UNSIGNED() {
  return getToken(MySqlParser::UNSIGNED, 0);
}

tree::TerminalNode* MySqlParser::ConvertedDataTypeContext::ARRAY() {
  return getToken(MySqlParser::ARRAY, 0);
}

tree::TerminalNode* MySqlParser::ConvertedDataTypeContext::BINARY() {
  return getToken(MySqlParser::BINARY, 0);
}

tree::TerminalNode* MySqlParser::ConvertedDataTypeContext::NCHAR() {
  return getToken(MySqlParser::NCHAR, 0);
}

tree::TerminalNode* MySqlParser::ConvertedDataTypeContext::DATE() {
  return getToken(MySqlParser::DATE, 0);
}

tree::TerminalNode* MySqlParser::ConvertedDataTypeContext::DATETIME() {
  return getToken(MySqlParser::DATETIME, 0);
}

tree::TerminalNode* MySqlParser::ConvertedDataTypeContext::TIME() {
  return getToken(MySqlParser::TIME, 0);
}

tree::TerminalNode* MySqlParser::ConvertedDataTypeContext::JSON() {
  return getToken(MySqlParser::JSON, 0);
}

tree::TerminalNode* MySqlParser::ConvertedDataTypeContext::INT() {
  return getToken(MySqlParser::INT, 0);
}

tree::TerminalNode* MySqlParser::ConvertedDataTypeContext::INTEGER() {
  return getToken(MySqlParser::INTEGER, 0);
}

MySqlParser::LengthOneDimensionContext* MySqlParser::ConvertedDataTypeContext::lengthOneDimension() {
  return getRuleContext<MySqlParser::LengthOneDimensionContext>(0);
}

MySqlParser::CharSetContext* MySqlParser::ConvertedDataTypeContext::charSet() {
  return getRuleContext<MySqlParser::CharSetContext>(0);
}

MySqlParser::CharsetNameContext* MySqlParser::ConvertedDataTypeContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

MySqlParser::LengthTwoOptionalDimensionContext* MySqlParser::ConvertedDataTypeContext::lengthTwoOptionalDimension() {
  return getRuleContext<MySqlParser::LengthTwoOptionalDimensionContext>(0);
}


size_t MySqlParser::ConvertedDataTypeContext::getRuleIndex() const {
  return MySqlParser::RuleConvertedDataType;
}

void MySqlParser::ConvertedDataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConvertedDataType(this);
}

void MySqlParser::ConvertedDataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConvertedDataType(this);
}


std::any MySqlParser::ConvertedDataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitConvertedDataType(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ConvertedDataTypeContext* MySqlParser::convertedDataType() {
  ConvertedDataTypeContext *_localctx = _tracker.createInstance<ConvertedDataTypeContext>(_ctx, getState());
  enterRule(_localctx, 598, MySqlParser::RuleConvertedDataType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6566);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::BINARY:
      case MySqlParser::NCHAR: {
        setState(6544);
        antlrcpp::downCast<ConvertedDataTypeContext *>(_localctx)->typeName = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::BINARY || _la == MySqlParser::NCHAR)) {
          antlrcpp::downCast<ConvertedDataTypeContext *>(_localctx)->typeName = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6546);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::LR_BRACKET) {
          setState(6545);
          lengthOneDimension();
        }
        break;
      }

      case MySqlParser::CHAR: {
        setState(6548);
        antlrcpp::downCast<ConvertedDataTypeContext *>(_localctx)->typeName = match(MySqlParser::CHAR);
        setState(6550);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::LR_BRACKET) {
          setState(6549);
          lengthOneDimension();
        }
        setState(6555);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::CHARACTER || _la == MySqlParser::CHAR || _la == MySqlParser::CHARSET) {
          setState(6552);
          charSet();
          setState(6553);
          charsetName();
        }
        break;
      }

      case MySqlParser::INT:
      case MySqlParser::INTEGER:
      case MySqlParser::DATE:
      case MySqlParser::TIME:
      case MySqlParser::DATETIME:
      case MySqlParser::JSON: {
        setState(6557);
        antlrcpp::downCast<ConvertedDataTypeContext *>(_localctx)->typeName = _input->LT(1);
        _la = _input->LA(1);
        if (!(((((_la - 200) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 200)) & 1441857) != 0) || _la == MySqlParser::JSON)) {
          antlrcpp::downCast<ConvertedDataTypeContext *>(_localctx)->typeName = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySqlParser::DECIMAL: {
        setState(6558);
        antlrcpp::downCast<ConvertedDataTypeContext *>(_localctx)->typeName = match(MySqlParser::DECIMAL);
        setState(6560);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::LR_BRACKET) {
          setState(6559);
          lengthTwoOptionalDimension();
        }
        break;
      }

      case MySqlParser::UNSIGNED:
      case MySqlParser::SIGNED: {
        setState(6562);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::UNSIGNED || _la == MySqlParser::SIGNED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6564);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::INTEGER) {
          setState(6563);
          match(MySqlParser::INTEGER);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(6569);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ARRAY) {
      setState(6568);
      match(MySqlParser::ARRAY);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LengthOneDimensionContext ------------------------------------------------------------------

MySqlParser::LengthOneDimensionContext::LengthOneDimensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::LengthOneDimensionContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::LengthOneDimensionContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::LengthOneDimensionContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}


size_t MySqlParser::LengthOneDimensionContext::getRuleIndex() const {
  return MySqlParser::RuleLengthOneDimension;
}

void MySqlParser::LengthOneDimensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLengthOneDimension(this);
}

void MySqlParser::LengthOneDimensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLengthOneDimension(this);
}


std::any MySqlParser::LengthOneDimensionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLengthOneDimension(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LengthOneDimensionContext* MySqlParser::lengthOneDimension() {
  LengthOneDimensionContext *_localctx = _tracker.createInstance<LengthOneDimensionContext>(_ctx, getState());
  enterRule(_localctx, 600, MySqlParser::RuleLengthOneDimension);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6571);
    match(MySqlParser::LR_BRACKET);
    setState(6572);
    decimalLiteral();
    setState(6573);
    match(MySqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LengthTwoDimensionContext ------------------------------------------------------------------

MySqlParser::LengthTwoDimensionContext::LengthTwoDimensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::LengthTwoDimensionContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::DecimalLiteralContext *> MySqlParser::LengthTwoDimensionContext::decimalLiteral() {
  return getRuleContexts<MySqlParser::DecimalLiteralContext>();
}

MySqlParser::DecimalLiteralContext* MySqlParser::LengthTwoDimensionContext::decimalLiteral(size_t i) {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(i);
}

tree::TerminalNode* MySqlParser::LengthTwoDimensionContext::COMMA() {
  return getToken(MySqlParser::COMMA, 0);
}

tree::TerminalNode* MySqlParser::LengthTwoDimensionContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}


size_t MySqlParser::LengthTwoDimensionContext::getRuleIndex() const {
  return MySqlParser::RuleLengthTwoDimension;
}

void MySqlParser::LengthTwoDimensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLengthTwoDimension(this);
}

void MySqlParser::LengthTwoDimensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLengthTwoDimension(this);
}


std::any MySqlParser::LengthTwoDimensionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLengthTwoDimension(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LengthTwoDimensionContext* MySqlParser::lengthTwoDimension() {
  LengthTwoDimensionContext *_localctx = _tracker.createInstance<LengthTwoDimensionContext>(_ctx, getState());
  enterRule(_localctx, 602, MySqlParser::RuleLengthTwoDimension);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6575);
    match(MySqlParser::LR_BRACKET);
    setState(6576);
    decimalLiteral();
    setState(6577);
    match(MySqlParser::COMMA);
    setState(6578);
    decimalLiteral();
    setState(6579);
    match(MySqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LengthTwoOptionalDimensionContext ------------------------------------------------------------------

MySqlParser::LengthTwoOptionalDimensionContext::LengthTwoOptionalDimensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::LengthTwoOptionalDimensionContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::DecimalLiteralContext *> MySqlParser::LengthTwoOptionalDimensionContext::decimalLiteral() {
  return getRuleContexts<MySqlParser::DecimalLiteralContext>();
}

MySqlParser::DecimalLiteralContext* MySqlParser::LengthTwoOptionalDimensionContext::decimalLiteral(size_t i) {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(i);
}

tree::TerminalNode* MySqlParser::LengthTwoOptionalDimensionContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::LengthTwoOptionalDimensionContext::COMMA() {
  return getToken(MySqlParser::COMMA, 0);
}


size_t MySqlParser::LengthTwoOptionalDimensionContext::getRuleIndex() const {
  return MySqlParser::RuleLengthTwoOptionalDimension;
}

void MySqlParser::LengthTwoOptionalDimensionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLengthTwoOptionalDimension(this);
}

void MySqlParser::LengthTwoOptionalDimensionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLengthTwoOptionalDimension(this);
}


std::any MySqlParser::LengthTwoOptionalDimensionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLengthTwoOptionalDimension(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LengthTwoOptionalDimensionContext* MySqlParser::lengthTwoOptionalDimension() {
  LengthTwoOptionalDimensionContext *_localctx = _tracker.createInstance<LengthTwoOptionalDimensionContext>(_ctx, getState());
  enterRule(_localctx, 604, MySqlParser::RuleLengthTwoOptionalDimension);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6581);
    match(MySqlParser::LR_BRACKET);
    setState(6582);
    decimalLiteral();
    setState(6585);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::COMMA) {
      setState(6583);
      match(MySqlParser::COMMA);
      setState(6584);
      decimalLiteral();
    }
    setState(6587);
    match(MySqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UidListContext ------------------------------------------------------------------

MySqlParser::UidListContext::UidListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::UidContext *> MySqlParser::UidListContext::uid() {
  return getRuleContexts<MySqlParser::UidContext>();
}

MySqlParser::UidContext* MySqlParser::UidListContext::uid(size_t i) {
  return getRuleContext<MySqlParser::UidContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::UidListContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::UidListContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::UidListContext::getRuleIndex() const {
  return MySqlParser::RuleUidList;
}

void MySqlParser::UidListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUidList(this);
}

void MySqlParser::UidListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUidList(this);
}


std::any MySqlParser::UidListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUidList(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UidListContext* MySqlParser::uidList() {
  UidListContext *_localctx = _tracker.createInstance<UidListContext>(_ctx, getState());
  enterRule(_localctx, 606, MySqlParser::RuleUidList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6589);
    uid();
    setState(6594);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 983, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(6590);
        match(MySqlParser::COMMA);
        setState(6591);
        uid(); 
      }
      setState(6596);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 983, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FullColumnNameListContext ------------------------------------------------------------------

MySqlParser::FullColumnNameListContext::FullColumnNameListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::FullColumnNameContext *> MySqlParser::FullColumnNameListContext::fullColumnName() {
  return getRuleContexts<MySqlParser::FullColumnNameContext>();
}

MySqlParser::FullColumnNameContext* MySqlParser::FullColumnNameListContext::fullColumnName(size_t i) {
  return getRuleContext<MySqlParser::FullColumnNameContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::FullColumnNameListContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::FullColumnNameListContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::FullColumnNameListContext::getRuleIndex() const {
  return MySqlParser::RuleFullColumnNameList;
}

void MySqlParser::FullColumnNameListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFullColumnNameList(this);
}

void MySqlParser::FullColumnNameListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFullColumnNameList(this);
}


std::any MySqlParser::FullColumnNameListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFullColumnNameList(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FullColumnNameListContext* MySqlParser::fullColumnNameList() {
  FullColumnNameListContext *_localctx = _tracker.createInstance<FullColumnNameListContext>(_ctx, getState());
  enterRule(_localctx, 608, MySqlParser::RuleFullColumnNameList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6597);
    fullColumnName();
    setState(6602);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(6598);
      match(MySqlParser::COMMA);
      setState(6599);
      fullColumnName();
      setState(6604);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablesContext ------------------------------------------------------------------

MySqlParser::TablesContext::TablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::TableNameContext *> MySqlParser::TablesContext::tableName() {
  return getRuleContexts<MySqlParser::TableNameContext>();
}

MySqlParser::TableNameContext* MySqlParser::TablesContext::tableName(size_t i) {
  return getRuleContext<MySqlParser::TableNameContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::TablesContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::TablesContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::TablesContext::getRuleIndex() const {
  return MySqlParser::RuleTables;
}

void MySqlParser::TablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTables(this);
}

void MySqlParser::TablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTables(this);
}


std::any MySqlParser::TablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTables(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TablesContext* MySqlParser::tables() {
  TablesContext *_localctx = _tracker.createInstance<TablesContext>(_ctx, getState());
  enterRule(_localctx, 610, MySqlParser::RuleTables);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6605);
    tableName();
    setState(6610);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 985, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(6606);
        match(MySqlParser::COMMA);
        setState(6607);
        tableName(); 
      }
      setState(6612);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 985, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexColumnNamesContext ------------------------------------------------------------------

MySqlParser::IndexColumnNamesContext::IndexColumnNamesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::IndexColumnNamesContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::IndexColumnNameContext *> MySqlParser::IndexColumnNamesContext::indexColumnName() {
  return getRuleContexts<MySqlParser::IndexColumnNameContext>();
}

MySqlParser::IndexColumnNameContext* MySqlParser::IndexColumnNamesContext::indexColumnName(size_t i) {
  return getRuleContext<MySqlParser::IndexColumnNameContext>(i);
}

tree::TerminalNode* MySqlParser::IndexColumnNamesContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::IndexColumnNamesContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::IndexColumnNamesContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::IndexColumnNamesContext::getRuleIndex() const {
  return MySqlParser::RuleIndexColumnNames;
}

void MySqlParser::IndexColumnNamesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexColumnNames(this);
}

void MySqlParser::IndexColumnNamesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexColumnNames(this);
}


std::any MySqlParser::IndexColumnNamesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIndexColumnNames(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::IndexColumnNamesContext* MySqlParser::indexColumnNames() {
  IndexColumnNamesContext *_localctx = _tracker.createInstance<IndexColumnNamesContext>(_ctx, getState());
  enterRule(_localctx, 612, MySqlParser::RuleIndexColumnNames);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6613);
    match(MySqlParser::LR_BRACKET);
    setState(6614);
    indexColumnName();
    setState(6619);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(6615);
      match(MySqlParser::COMMA);
      setState(6616);
      indexColumnName();
      setState(6621);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(6622);
    match(MySqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionsContext ------------------------------------------------------------------

MySqlParser::ExpressionsContext::ExpressionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::ExpressionContext *> MySqlParser::ExpressionsContext::expression() {
  return getRuleContexts<MySqlParser::ExpressionContext>();
}

MySqlParser::ExpressionContext* MySqlParser::ExpressionsContext::expression(size_t i) {
  return getRuleContext<MySqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::ExpressionsContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::ExpressionsContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::ExpressionsContext::getRuleIndex() const {
  return MySqlParser::RuleExpressions;
}

void MySqlParser::ExpressionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressions(this);
}

void MySqlParser::ExpressionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressions(this);
}


std::any MySqlParser::ExpressionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitExpressions(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ExpressionsContext* MySqlParser::expressions() {
  ExpressionsContext *_localctx = _tracker.createInstance<ExpressionsContext>(_ctx, getState());
  enterRule(_localctx, 614, MySqlParser::RuleExpressions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6624);
    expression(0);
    setState(6629);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(6625);
      match(MySqlParser::COMMA);
      setState(6626);
      expression(0);
      setState(6631);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionsWithDefaultsContext ------------------------------------------------------------------

MySqlParser::ExpressionsWithDefaultsContext::ExpressionsWithDefaultsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::ExpressionOrDefaultContext *> MySqlParser::ExpressionsWithDefaultsContext::expressionOrDefault() {
  return getRuleContexts<MySqlParser::ExpressionOrDefaultContext>();
}

MySqlParser::ExpressionOrDefaultContext* MySqlParser::ExpressionsWithDefaultsContext::expressionOrDefault(size_t i) {
  return getRuleContext<MySqlParser::ExpressionOrDefaultContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::ExpressionsWithDefaultsContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::ExpressionsWithDefaultsContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::ExpressionsWithDefaultsContext::getRuleIndex() const {
  return MySqlParser::RuleExpressionsWithDefaults;
}

void MySqlParser::ExpressionsWithDefaultsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionsWithDefaults(this);
}

void MySqlParser::ExpressionsWithDefaultsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionsWithDefaults(this);
}


std::any MySqlParser::ExpressionsWithDefaultsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitExpressionsWithDefaults(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ExpressionsWithDefaultsContext* MySqlParser::expressionsWithDefaults() {
  ExpressionsWithDefaultsContext *_localctx = _tracker.createInstance<ExpressionsWithDefaultsContext>(_ctx, getState());
  enterRule(_localctx, 616, MySqlParser::RuleExpressionsWithDefaults);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6632);
    expressionOrDefault();
    setState(6637);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(6633);
      match(MySqlParser::COMMA);
      setState(6634);
      expressionOrDefault();
      setState(6639);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantsContext ------------------------------------------------------------------

MySqlParser::ConstantsContext::ConstantsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::ConstantContext *> MySqlParser::ConstantsContext::constant() {
  return getRuleContexts<MySqlParser::ConstantContext>();
}

MySqlParser::ConstantContext* MySqlParser::ConstantsContext::constant(size_t i) {
  return getRuleContext<MySqlParser::ConstantContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::ConstantsContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::ConstantsContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::ConstantsContext::getRuleIndex() const {
  return MySqlParser::RuleConstants;
}

void MySqlParser::ConstantsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstants(this);
}

void MySqlParser::ConstantsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstants(this);
}


std::any MySqlParser::ConstantsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitConstants(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ConstantsContext* MySqlParser::constants() {
  ConstantsContext *_localctx = _tracker.createInstance<ConstantsContext>(_ctx, getState());
  enterRule(_localctx, 618, MySqlParser::RuleConstants);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6640);
    constant();
    setState(6645);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(6641);
      match(MySqlParser::COMMA);
      setState(6642);
      constant();
      setState(6647);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleStringsContext ------------------------------------------------------------------

MySqlParser::SimpleStringsContext::SimpleStringsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySqlParser::SimpleStringsContext::STRING_LITERAL() {
  return getTokens(MySqlParser::STRING_LITERAL);
}

tree::TerminalNode* MySqlParser::SimpleStringsContext::STRING_LITERAL(size_t i) {
  return getToken(MySqlParser::STRING_LITERAL, i);
}

std::vector<tree::TerminalNode *> MySqlParser::SimpleStringsContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::SimpleStringsContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::SimpleStringsContext::getRuleIndex() const {
  return MySqlParser::RuleSimpleStrings;
}

void MySqlParser::SimpleStringsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleStrings(this);
}

void MySqlParser::SimpleStringsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleStrings(this);
}


std::any MySqlParser::SimpleStringsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSimpleStrings(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::SimpleStringsContext* MySqlParser::simpleStrings() {
  SimpleStringsContext *_localctx = _tracker.createInstance<SimpleStringsContext>(_ctx, getState());
  enterRule(_localctx, 620, MySqlParser::RuleSimpleStrings);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6648);
    match(MySqlParser::STRING_LITERAL);
    setState(6653);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(6649);
      match(MySqlParser::COMMA);
      setState(6650);
      match(MySqlParser::STRING_LITERAL);
      setState(6655);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserVariablesContext ------------------------------------------------------------------

MySqlParser::UserVariablesContext::UserVariablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySqlParser::UserVariablesContext::LOCAL_ID() {
  return getTokens(MySqlParser::LOCAL_ID);
}

tree::TerminalNode* MySqlParser::UserVariablesContext::LOCAL_ID(size_t i) {
  return getToken(MySqlParser::LOCAL_ID, i);
}

std::vector<tree::TerminalNode *> MySqlParser::UserVariablesContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::UserVariablesContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::UserVariablesContext::getRuleIndex() const {
  return MySqlParser::RuleUserVariables;
}

void MySqlParser::UserVariablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserVariables(this);
}

void MySqlParser::UserVariablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserVariables(this);
}


std::any MySqlParser::UserVariablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUserVariables(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UserVariablesContext* MySqlParser::userVariables() {
  UserVariablesContext *_localctx = _tracker.createInstance<UserVariablesContext>(_ctx, getState());
  enterRule(_localctx, 622, MySqlParser::RuleUserVariables);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6656);
    match(MySqlParser::LOCAL_ID);
    setState(6661);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(6657);
      match(MySqlParser::COMMA);
      setState(6658);
      match(MySqlParser::LOCAL_ID);
      setState(6663);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultValueContext ------------------------------------------------------------------

MySqlParser::DefaultValueContext::DefaultValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DefaultValueContext::NULL_LITERAL() {
  return getToken(MySqlParser::NULL_LITERAL, 0);
}

tree::TerminalNode* MySqlParser::DefaultValueContext::CAST() {
  return getToken(MySqlParser::CAST, 0);
}

tree::TerminalNode* MySqlParser::DefaultValueContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ExpressionContext* MySqlParser::DefaultValueContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::DefaultValueContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

MySqlParser::ConvertedDataTypeContext* MySqlParser::DefaultValueContext::convertedDataType() {
  return getRuleContext<MySqlParser::ConvertedDataTypeContext>(0);
}

tree::TerminalNode* MySqlParser::DefaultValueContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::ConstantContext* MySqlParser::DefaultValueContext::constant() {
  return getRuleContext<MySqlParser::ConstantContext>(0);
}

MySqlParser::UnaryOperatorContext* MySqlParser::DefaultValueContext::unaryOperator() {
  return getRuleContext<MySqlParser::UnaryOperatorContext>(0);
}

std::vector<MySqlParser::CurrentTimestampContext *> MySqlParser::DefaultValueContext::currentTimestamp() {
  return getRuleContexts<MySqlParser::CurrentTimestampContext>();
}

MySqlParser::CurrentTimestampContext* MySqlParser::DefaultValueContext::currentTimestamp(size_t i) {
  return getRuleContext<MySqlParser::CurrentTimestampContext>(i);
}

tree::TerminalNode* MySqlParser::DefaultValueContext::ON() {
  return getToken(MySqlParser::ON, 0);
}

tree::TerminalNode* MySqlParser::DefaultValueContext::UPDATE() {
  return getToken(MySqlParser::UPDATE, 0);
}

MySqlParser::FullIdContext* MySqlParser::DefaultValueContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}


size_t MySqlParser::DefaultValueContext::getRuleIndex() const {
  return MySqlParser::RuleDefaultValue;
}

void MySqlParser::DefaultValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultValue(this);
}

void MySqlParser::DefaultValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultValue(this);
}


std::any MySqlParser::DefaultValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDefaultValue(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DefaultValueContext* MySqlParser::defaultValue() {
  DefaultValueContext *_localctx = _tracker.createInstance<DefaultValueContext>(_ctx, getState());
  enterRule(_localctx, 624, MySqlParser::RuleDefaultValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6690);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 994, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6664);
      match(MySqlParser::NULL_LITERAL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6665);
      match(MySqlParser::CAST);
      setState(6666);
      match(MySqlParser::LR_BRACKET);
      setState(6667);
      expression(0);
      setState(6668);
      match(MySqlParser::AS);
      setState(6669);
      convertedDataType();
      setState(6670);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6673);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 992, _ctx)) {
      case 1: {
        setState(6672);
        unaryOperator();
        break;
      }

      default:
        break;
      }
      setState(6675);
      constant();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6676);
      currentTimestamp();
      setState(6680);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 993, _ctx)) {
      case 1: {
        setState(6677);
        match(MySqlParser::ON);
        setState(6678);
        match(MySqlParser::UPDATE);
        setState(6679);
        currentTimestamp();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6682);
      match(MySqlParser::LR_BRACKET);
      setState(6683);
      expression(0);
      setState(6684);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6686);
      match(MySqlParser::LR_BRACKET);
      setState(6687);
      fullId();
      setState(6688);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CurrentTimestampContext ------------------------------------------------------------------

MySqlParser::CurrentTimestampContext::CurrentTimestampContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CurrentTimestampContext::NOW() {
  return getToken(MySqlParser::NOW, 0);
}

tree::TerminalNode* MySqlParser::CurrentTimestampContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::CurrentTimestampContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::CurrentTimestampContext::CURRENT_TIMESTAMP() {
  return getToken(MySqlParser::CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* MySqlParser::CurrentTimestampContext::LOCALTIME() {
  return getToken(MySqlParser::LOCALTIME, 0);
}

tree::TerminalNode* MySqlParser::CurrentTimestampContext::LOCALTIMESTAMP() {
  return getToken(MySqlParser::LOCALTIMESTAMP, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::CurrentTimestampContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}


size_t MySqlParser::CurrentTimestampContext::getRuleIndex() const {
  return MySqlParser::RuleCurrentTimestamp;
}

void MySqlParser::CurrentTimestampContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCurrentTimestamp(this);
}

void MySqlParser::CurrentTimestampContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCurrentTimestamp(this);
}


std::any MySqlParser::CurrentTimestampContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCurrentTimestamp(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CurrentTimestampContext* MySqlParser::currentTimestamp() {
  CurrentTimestampContext *_localctx = _tracker.createInstance<CurrentTimestampContext>(_ctx, getState());
  enterRule(_localctx, 626, MySqlParser::RuleCurrentTimestamp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6706);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::CURRENT_TIMESTAMP:
      case MySqlParser::LOCALTIME:
      case MySqlParser::LOCALTIMESTAMP: {
        setState(6692);
        _la = _input->LA(1);
        if (!(((((_la - 315) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 315)) & 131) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6698);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 996, _ctx)) {
        case 1: {
          setState(6693);
          match(MySqlParser::LR_BRACKET);
          setState(6695);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((((_la - 1137) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 1137)) & 10247) != 0)) {
            setState(6694);
            decimalLiteral();
          }
          setState(6697);
          match(MySqlParser::RR_BRACKET);
          break;
        }

        default:
          break;
        }
        break;
      }

      case MySqlParser::NOW: {
        setState(6700);
        match(MySqlParser::NOW);
        setState(6701);
        match(MySqlParser::LR_BRACKET);
        setState(6703);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 1137) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 1137)) & 10247) != 0)) {
          setState(6702);
          decimalLiteral();
        }
        setState(6705);
        match(MySqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionOrDefaultContext ------------------------------------------------------------------

MySqlParser::ExpressionOrDefaultContext::ExpressionOrDefaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::ExpressionContext* MySqlParser::ExpressionOrDefaultContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::ExpressionOrDefaultContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}


size_t MySqlParser::ExpressionOrDefaultContext::getRuleIndex() const {
  return MySqlParser::RuleExpressionOrDefault;
}

void MySqlParser::ExpressionOrDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionOrDefault(this);
}

void MySqlParser::ExpressionOrDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionOrDefault(this);
}


std::any MySqlParser::ExpressionOrDefaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitExpressionOrDefault(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ExpressionOrDefaultContext* MySqlParser::expressionOrDefault() {
  ExpressionOrDefaultContext *_localctx = _tracker.createInstance<ExpressionOrDefaultContext>(_ctx, getState());
  enterRule(_localctx, 628, MySqlParser::RuleExpressionOrDefault);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6710);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 999, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6708);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6709);
      match(MySqlParser::DEFAULT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfExistsContext ------------------------------------------------------------------

MySqlParser::IfExistsContext::IfExistsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::IfExistsContext::IF() {
  return getToken(MySqlParser::IF, 0);
}

tree::TerminalNode* MySqlParser::IfExistsContext::EXISTS() {
  return getToken(MySqlParser::EXISTS, 0);
}


size_t MySqlParser::IfExistsContext::getRuleIndex() const {
  return MySqlParser::RuleIfExists;
}

void MySqlParser::IfExistsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfExists(this);
}

void MySqlParser::IfExistsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfExists(this);
}


std::any MySqlParser::IfExistsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIfExists(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::IfExistsContext* MySqlParser::ifExists() {
  IfExistsContext *_localctx = _tracker.createInstance<IfExistsContext>(_ctx, getState());
  enterRule(_localctx, 630, MySqlParser::RuleIfExists);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6712);
    match(MySqlParser::IF);
    setState(6713);
    match(MySqlParser::EXISTS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfNotExistsContext ------------------------------------------------------------------

MySqlParser::IfNotExistsContext::IfNotExistsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::IfNotExistsContext::IF() {
  return getToken(MySqlParser::IF, 0);
}

tree::TerminalNode* MySqlParser::IfNotExistsContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}

tree::TerminalNode* MySqlParser::IfNotExistsContext::EXISTS() {
  return getToken(MySqlParser::EXISTS, 0);
}


size_t MySqlParser::IfNotExistsContext::getRuleIndex() const {
  return MySqlParser::RuleIfNotExists;
}

void MySqlParser::IfNotExistsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfNotExists(this);
}

void MySqlParser::IfNotExistsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfNotExists(this);
}


std::any MySqlParser::IfNotExistsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIfNotExists(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::IfNotExistsContext* MySqlParser::ifNotExists() {
  IfNotExistsContext *_localctx = _tracker.createInstance<IfNotExistsContext>(_ctx, getState());
  enterRule(_localctx, 632, MySqlParser::RuleIfNotExists);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6715);
    match(MySqlParser::IF);
    setState(6716);
    match(MySqlParser::NOT);
    setState(6717);
    match(MySqlParser::EXISTS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrReplaceContext ------------------------------------------------------------------

MySqlParser::OrReplaceContext::OrReplaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::OrReplaceContext::OR() {
  return getToken(MySqlParser::OR, 0);
}

tree::TerminalNode* MySqlParser::OrReplaceContext::REPLACE() {
  return getToken(MySqlParser::REPLACE, 0);
}


size_t MySqlParser::OrReplaceContext::getRuleIndex() const {
  return MySqlParser::RuleOrReplace;
}

void MySqlParser::OrReplaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrReplace(this);
}

void MySqlParser::OrReplaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrReplace(this);
}


std::any MySqlParser::OrReplaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitOrReplace(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::OrReplaceContext* MySqlParser::orReplace() {
  OrReplaceContext *_localctx = _tracker.createInstance<OrReplaceContext>(_ctx, getState());
  enterRule(_localctx, 634, MySqlParser::RuleOrReplace);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6719);
    match(MySqlParser::OR);
    setState(6720);
    match(MySqlParser::REPLACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WaitNowaitClauseContext ------------------------------------------------------------------

MySqlParser::WaitNowaitClauseContext::WaitNowaitClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::WaitNowaitClauseContext::WAIT() {
  return getToken(MySqlParser::WAIT, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::WaitNowaitClauseContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::WaitNowaitClauseContext::NOWAIT() {
  return getToken(MySqlParser::NOWAIT, 0);
}


size_t MySqlParser::WaitNowaitClauseContext::getRuleIndex() const {
  return MySqlParser::RuleWaitNowaitClause;
}

void MySqlParser::WaitNowaitClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWaitNowaitClause(this);
}

void MySqlParser::WaitNowaitClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWaitNowaitClause(this);
}


std::any MySqlParser::WaitNowaitClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitWaitNowaitClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::WaitNowaitClauseContext* MySqlParser::waitNowaitClause() {
  WaitNowaitClauseContext *_localctx = _tracker.createInstance<WaitNowaitClauseContext>(_ctx, getState());
  enterRule(_localctx, 636, MySqlParser::RuleWaitNowaitClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6725);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::WAIT: {
        enterOuterAlt(_localctx, 1);
        setState(6722);
        match(MySqlParser::WAIT);
        setState(6723);
        decimalLiteral();
        break;
      }

      case MySqlParser::NOWAIT: {
        enterOuterAlt(_localctx, 2);
        setState(6724);
        match(MySqlParser::NOWAIT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionCallContext ------------------------------------------------------------------

MySqlParser::FunctionCallContext::FunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::FunctionCallContext::getRuleIndex() const {
  return MySqlParser::RuleFunctionCall;
}

void MySqlParser::FunctionCallContext::copyFrom(FunctionCallContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SpecificFunctionCallContext ------------------------------------------------------------------

MySqlParser::SpecificFunctionContext* MySqlParser::SpecificFunctionCallContext::specificFunction() {
  return getRuleContext<MySqlParser::SpecificFunctionContext>(0);
}

MySqlParser::SpecificFunctionCallContext::SpecificFunctionCallContext(FunctionCallContext *ctx) { copyFrom(ctx); }

void MySqlParser::SpecificFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecificFunctionCall(this);
}
void MySqlParser::SpecificFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecificFunctionCall(this);
}

std::any MySqlParser::SpecificFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSpecificFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PasswordFunctionCallContext ------------------------------------------------------------------

MySqlParser::PasswordFunctionClauseContext* MySqlParser::PasswordFunctionCallContext::passwordFunctionClause() {
  return getRuleContext<MySqlParser::PasswordFunctionClauseContext>(0);
}

MySqlParser::PasswordFunctionCallContext::PasswordFunctionCallContext(FunctionCallContext *ctx) { copyFrom(ctx); }

void MySqlParser::PasswordFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPasswordFunctionCall(this);
}
void MySqlParser::PasswordFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPasswordFunctionCall(this);
}

std::any MySqlParser::PasswordFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPasswordFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- UdfFunctionCallContext ------------------------------------------------------------------

MySqlParser::FullIdContext* MySqlParser::UdfFunctionCallContext::fullId() {
  return getRuleContext<MySqlParser::FullIdContext>(0);
}

tree::TerminalNode* MySqlParser::UdfFunctionCallContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::UdfFunctionCallContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::FunctionArgsContext* MySqlParser::UdfFunctionCallContext::functionArgs() {
  return getRuleContext<MySqlParser::FunctionArgsContext>(0);
}

MySqlParser::UdfFunctionCallContext::UdfFunctionCallContext(FunctionCallContext *ctx) { copyFrom(ctx); }

void MySqlParser::UdfFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdfFunctionCall(this);
}
void MySqlParser::UdfFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdfFunctionCall(this);
}

std::any MySqlParser::UdfFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUdfFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NonAggregateFunctionCallContext ------------------------------------------------------------------

MySqlParser::NonAggregateWindowedFunctionContext* MySqlParser::NonAggregateFunctionCallContext::nonAggregateWindowedFunction() {
  return getRuleContext<MySqlParser::NonAggregateWindowedFunctionContext>(0);
}

MySqlParser::NonAggregateFunctionCallContext::NonAggregateFunctionCallContext(FunctionCallContext *ctx) { copyFrom(ctx); }

void MySqlParser::NonAggregateFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNonAggregateFunctionCall(this);
}
void MySqlParser::NonAggregateFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNonAggregateFunctionCall(this);
}

std::any MySqlParser::NonAggregateFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitNonAggregateFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AggregateFunctionCallContext ------------------------------------------------------------------

MySqlParser::AggregateWindowedFunctionContext* MySqlParser::AggregateFunctionCallContext::aggregateWindowedFunction() {
  return getRuleContext<MySqlParser::AggregateWindowedFunctionContext>(0);
}

MySqlParser::AggregateFunctionCallContext::AggregateFunctionCallContext(FunctionCallContext *ctx) { copyFrom(ctx); }

void MySqlParser::AggregateFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregateFunctionCall(this);
}
void MySqlParser::AggregateFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregateFunctionCall(this);
}

std::any MySqlParser::AggregateFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAggregateFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ScalarFunctionCallContext ------------------------------------------------------------------

MySqlParser::ScalarFunctionNameContext* MySqlParser::ScalarFunctionCallContext::scalarFunctionName() {
  return getRuleContext<MySqlParser::ScalarFunctionNameContext>(0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionCallContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionCallContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::FunctionArgsContext* MySqlParser::ScalarFunctionCallContext::functionArgs() {
  return getRuleContext<MySqlParser::FunctionArgsContext>(0);
}

MySqlParser::ScalarFunctionCallContext::ScalarFunctionCallContext(FunctionCallContext *ctx) { copyFrom(ctx); }

void MySqlParser::ScalarFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalarFunctionCall(this);
}
void MySqlParser::ScalarFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalarFunctionCall(this);
}

std::any MySqlParser::ScalarFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitScalarFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::FunctionCallContext* MySqlParser::functionCall() {
  FunctionCallContext *_localctx = _tracker.createInstance<FunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 638, MySqlParser::RuleFunctionCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6745);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1003, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::SpecificFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(6727);
      specificFunction();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::AggregateFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(6728);
      aggregateWindowedFunction();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::NonAggregateFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(6729);
      nonAggregateWindowedFunction();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::ScalarFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(6730);
      scalarFunctionName();
      setState(6731);
      match(MySqlParser::LR_BRACKET);
      setState(6733);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1001, _ctx)) {
      case 1: {
        setState(6732);
        functionArgs();
        break;
      }

      default:
        break;
      }
      setState(6735);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<MySqlParser::UdfFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(6737);
      fullId();
      setState(6738);
      match(MySqlParser::LR_BRACKET);
      setState(6740);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1002, _ctx)) {
      case 1: {
        setState(6739);
        functionArgs();
        break;
      }

      default:
        break;
      }
      setState(6742);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<MySqlParser::PasswordFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(6744);
      passwordFunctionClause();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpecificFunctionContext ------------------------------------------------------------------

MySqlParser::SpecificFunctionContext::SpecificFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::SpecificFunctionContext::getRuleIndex() const {
  return MySqlParser::RuleSpecificFunction;
}

void MySqlParser::SpecificFunctionContext::copyFrom(SpecificFunctionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PositionFunctionCallContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::PositionFunctionCallContext::POSITION() {
  return getToken(MySqlParser::POSITION, 0);
}

tree::TerminalNode* MySqlParser::PositionFunctionCallContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::PositionFunctionCallContext::IN() {
  return getToken(MySqlParser::IN, 0);
}

tree::TerminalNode* MySqlParser::PositionFunctionCallContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<MySqlParser::StringLiteralContext *> MySqlParser::PositionFunctionCallContext::stringLiteral() {
  return getRuleContexts<MySqlParser::StringLiteralContext>();
}

MySqlParser::StringLiteralContext* MySqlParser::PositionFunctionCallContext::stringLiteral(size_t i) {
  return getRuleContext<MySqlParser::StringLiteralContext>(i);
}

std::vector<MySqlParser::ExpressionContext *> MySqlParser::PositionFunctionCallContext::expression() {
  return getRuleContexts<MySqlParser::ExpressionContext>();
}

MySqlParser::ExpressionContext* MySqlParser::PositionFunctionCallContext::expression(size_t i) {
  return getRuleContext<MySqlParser::ExpressionContext>(i);
}

MySqlParser::PositionFunctionCallContext::PositionFunctionCallContext(SpecificFunctionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PositionFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPositionFunctionCall(this);
}
void MySqlParser::PositionFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPositionFunctionCall(this);
}

std::any MySqlParser::PositionFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPositionFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TrimFunctionCallContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::TrimFunctionCallContext::TRIM() {
  return getToken(MySqlParser::TRIM, 0);
}

tree::TerminalNode* MySqlParser::TrimFunctionCallContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::TrimFunctionCallContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

tree::TerminalNode* MySqlParser::TrimFunctionCallContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::TrimFunctionCallContext::BOTH() {
  return getToken(MySqlParser::BOTH, 0);
}

tree::TerminalNode* MySqlParser::TrimFunctionCallContext::LEADING() {
  return getToken(MySqlParser::LEADING, 0);
}

tree::TerminalNode* MySqlParser::TrimFunctionCallContext::TRAILING() {
  return getToken(MySqlParser::TRAILING, 0);
}

std::vector<MySqlParser::StringLiteralContext *> MySqlParser::TrimFunctionCallContext::stringLiteral() {
  return getRuleContexts<MySqlParser::StringLiteralContext>();
}

MySqlParser::StringLiteralContext* MySqlParser::TrimFunctionCallContext::stringLiteral(size_t i) {
  return getRuleContext<MySqlParser::StringLiteralContext>(i);
}

std::vector<MySqlParser::ExpressionContext *> MySqlParser::TrimFunctionCallContext::expression() {
  return getRuleContexts<MySqlParser::ExpressionContext>();
}

MySqlParser::ExpressionContext* MySqlParser::TrimFunctionCallContext::expression(size_t i) {
  return getRuleContext<MySqlParser::ExpressionContext>(i);
}

MySqlParser::TrimFunctionCallContext::TrimFunctionCallContext(SpecificFunctionContext *ctx) { copyFrom(ctx); }

void MySqlParser::TrimFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrimFunctionCall(this);
}
void MySqlParser::TrimFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrimFunctionCall(this);
}

std::any MySqlParser::TrimFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTrimFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- JsonValueFunctionCallContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::JsonValueFunctionCallContext::JSON_VALUE() {
  return getToken(MySqlParser::JSON_VALUE, 0);
}

tree::TerminalNode* MySqlParser::JsonValueFunctionCallContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::ExpressionContext *> MySqlParser::JsonValueFunctionCallContext::expression() {
  return getRuleContexts<MySqlParser::ExpressionContext>();
}

MySqlParser::ExpressionContext* MySqlParser::JsonValueFunctionCallContext::expression(size_t i) {
  return getRuleContext<MySqlParser::ExpressionContext>(i);
}

tree::TerminalNode* MySqlParser::JsonValueFunctionCallContext::COMMA() {
  return getToken(MySqlParser::COMMA, 0);
}

tree::TerminalNode* MySqlParser::JsonValueFunctionCallContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::JsonValueFunctionCallContext::RETURNING() {
  return getToken(MySqlParser::RETURNING, 0);
}

MySqlParser::ConvertedDataTypeContext* MySqlParser::JsonValueFunctionCallContext::convertedDataType() {
  return getRuleContext<MySqlParser::ConvertedDataTypeContext>(0);
}

MySqlParser::JsonOnEmptyContext* MySqlParser::JsonValueFunctionCallContext::jsonOnEmpty() {
  return getRuleContext<MySqlParser::JsonOnEmptyContext>(0);
}

MySqlParser::JsonOnErrorContext* MySqlParser::JsonValueFunctionCallContext::jsonOnError() {
  return getRuleContext<MySqlParser::JsonOnErrorContext>(0);
}

MySqlParser::JsonValueFunctionCallContext::JsonValueFunctionCallContext(SpecificFunctionContext *ctx) { copyFrom(ctx); }

void MySqlParser::JsonValueFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonValueFunctionCall(this);
}
void MySqlParser::JsonValueFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonValueFunctionCall(this);
}

std::any MySqlParser::JsonValueFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitJsonValueFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CaseFunctionCallContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::CaseFunctionCallContext::CASE() {
  return getToken(MySqlParser::CASE, 0);
}

tree::TerminalNode* MySqlParser::CaseFunctionCallContext::END() {
  return getToken(MySqlParser::END, 0);
}

std::vector<MySqlParser::CaseFuncAlternativeContext *> MySqlParser::CaseFunctionCallContext::caseFuncAlternative() {
  return getRuleContexts<MySqlParser::CaseFuncAlternativeContext>();
}

MySqlParser::CaseFuncAlternativeContext* MySqlParser::CaseFunctionCallContext::caseFuncAlternative(size_t i) {
  return getRuleContext<MySqlParser::CaseFuncAlternativeContext>(i);
}

tree::TerminalNode* MySqlParser::CaseFunctionCallContext::ELSE() {
  return getToken(MySqlParser::ELSE, 0);
}

MySqlParser::FunctionArgContext* MySqlParser::CaseFunctionCallContext::functionArg() {
  return getRuleContext<MySqlParser::FunctionArgContext>(0);
}

MySqlParser::CaseFunctionCallContext::CaseFunctionCallContext(SpecificFunctionContext *ctx) { copyFrom(ctx); }

void MySqlParser::CaseFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseFunctionCall(this);
}
void MySqlParser::CaseFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseFunctionCall(this);
}

std::any MySqlParser::CaseFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCaseFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ExtractFunctionCallContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ExtractFunctionCallContext::EXTRACT() {
  return getToken(MySqlParser::EXTRACT, 0);
}

tree::TerminalNode* MySqlParser::ExtractFunctionCallContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::IntervalTypeContext* MySqlParser::ExtractFunctionCallContext::intervalType() {
  return getRuleContext<MySqlParser::IntervalTypeContext>(0);
}

tree::TerminalNode* MySqlParser::ExtractFunctionCallContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

tree::TerminalNode* MySqlParser::ExtractFunctionCallContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::StringLiteralContext* MySqlParser::ExtractFunctionCallContext::stringLiteral() {
  return getRuleContext<MySqlParser::StringLiteralContext>(0);
}

MySqlParser::ExpressionContext* MySqlParser::ExtractFunctionCallContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

MySqlParser::ExtractFunctionCallContext::ExtractFunctionCallContext(SpecificFunctionContext *ctx) { copyFrom(ctx); }

void MySqlParser::ExtractFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExtractFunctionCall(this);
}
void MySqlParser::ExtractFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExtractFunctionCall(this);
}

std::any MySqlParser::ExtractFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitExtractFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DataTypeFunctionCallContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::DataTypeFunctionCallContext::CONVERT() {
  return getToken(MySqlParser::CONVERT, 0);
}

tree::TerminalNode* MySqlParser::DataTypeFunctionCallContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ExpressionContext* MySqlParser::DataTypeFunctionCallContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

MySqlParser::ConvertedDataTypeContext* MySqlParser::DataTypeFunctionCallContext::convertedDataType() {
  return getRuleContext<MySqlParser::ConvertedDataTypeContext>(0);
}

tree::TerminalNode* MySqlParser::DataTypeFunctionCallContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::DataTypeFunctionCallContext::COMMA() {
  return getToken(MySqlParser::COMMA, 0);
}

tree::TerminalNode* MySqlParser::DataTypeFunctionCallContext::USING() {
  return getToken(MySqlParser::USING, 0);
}

MySqlParser::CharsetNameContext* MySqlParser::DataTypeFunctionCallContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySqlParser::DataTypeFunctionCallContext::CAST() {
  return getToken(MySqlParser::CAST, 0);
}

tree::TerminalNode* MySqlParser::DataTypeFunctionCallContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

MySqlParser::DataTypeFunctionCallContext::DataTypeFunctionCallContext(SpecificFunctionContext *ctx) { copyFrom(ctx); }

void MySqlParser::DataTypeFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataTypeFunctionCall(this);
}
void MySqlParser::DataTypeFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataTypeFunctionCall(this);
}

std::any MySqlParser::DataTypeFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDataTypeFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ValuesFunctionCallContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ValuesFunctionCallContext::VALUES() {
  return getToken(MySqlParser::VALUES, 0);
}

tree::TerminalNode* MySqlParser::ValuesFunctionCallContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::FullColumnNameContext* MySqlParser::ValuesFunctionCallContext::fullColumnName() {
  return getRuleContext<MySqlParser::FullColumnNameContext>(0);
}

tree::TerminalNode* MySqlParser::ValuesFunctionCallContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::ValuesFunctionCallContext::ValuesFunctionCallContext(SpecificFunctionContext *ctx) { copyFrom(ctx); }

void MySqlParser::ValuesFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValuesFunctionCall(this);
}
void MySqlParser::ValuesFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValuesFunctionCall(this);
}

std::any MySqlParser::ValuesFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitValuesFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CaseExpressionFunctionCallContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::CaseExpressionFunctionCallContext::CASE() {
  return getToken(MySqlParser::CASE, 0);
}

MySqlParser::ExpressionContext* MySqlParser::CaseExpressionFunctionCallContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::CaseExpressionFunctionCallContext::END() {
  return getToken(MySqlParser::END, 0);
}

std::vector<MySqlParser::CaseFuncAlternativeContext *> MySqlParser::CaseExpressionFunctionCallContext::caseFuncAlternative() {
  return getRuleContexts<MySqlParser::CaseFuncAlternativeContext>();
}

MySqlParser::CaseFuncAlternativeContext* MySqlParser::CaseExpressionFunctionCallContext::caseFuncAlternative(size_t i) {
  return getRuleContext<MySqlParser::CaseFuncAlternativeContext>(i);
}

tree::TerminalNode* MySqlParser::CaseExpressionFunctionCallContext::ELSE() {
  return getToken(MySqlParser::ELSE, 0);
}

MySqlParser::FunctionArgContext* MySqlParser::CaseExpressionFunctionCallContext::functionArg() {
  return getRuleContext<MySqlParser::FunctionArgContext>(0);
}

MySqlParser::CaseExpressionFunctionCallContext::CaseExpressionFunctionCallContext(SpecificFunctionContext *ctx) { copyFrom(ctx); }

void MySqlParser::CaseExpressionFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseExpressionFunctionCall(this);
}
void MySqlParser::CaseExpressionFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseExpressionFunctionCall(this);
}

std::any MySqlParser::CaseExpressionFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCaseExpressionFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleFunctionCallContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SimpleFunctionCallContext::CURRENT_DATE() {
  return getToken(MySqlParser::CURRENT_DATE, 0);
}

tree::TerminalNode* MySqlParser::SimpleFunctionCallContext::CURRENT_TIME() {
  return getToken(MySqlParser::CURRENT_TIME, 0);
}

tree::TerminalNode* MySqlParser::SimpleFunctionCallContext::CURRENT_TIMESTAMP() {
  return getToken(MySqlParser::CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* MySqlParser::SimpleFunctionCallContext::CURRENT_USER() {
  return getToken(MySqlParser::CURRENT_USER, 0);
}

tree::TerminalNode* MySqlParser::SimpleFunctionCallContext::LOCALTIME() {
  return getToken(MySqlParser::LOCALTIME, 0);
}

tree::TerminalNode* MySqlParser::SimpleFunctionCallContext::UTC_TIMESTAMP() {
  return getToken(MySqlParser::UTC_TIMESTAMP, 0);
}

tree::TerminalNode* MySqlParser::SimpleFunctionCallContext::SCHEMA() {
  return getToken(MySqlParser::SCHEMA, 0);
}

tree::TerminalNode* MySqlParser::SimpleFunctionCallContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::SimpleFunctionCallContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::SimpleFunctionCallContext::SimpleFunctionCallContext(SpecificFunctionContext *ctx) { copyFrom(ctx); }

void MySqlParser::SimpleFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleFunctionCall(this);
}
void MySqlParser::SimpleFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleFunctionCall(this);
}

std::any MySqlParser::SimpleFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSimpleFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CharFunctionCallContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::CharFunctionCallContext::CHAR() {
  return getToken(MySqlParser::CHAR, 0);
}

tree::TerminalNode* MySqlParser::CharFunctionCallContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::FunctionArgsContext* MySqlParser::CharFunctionCallContext::functionArgs() {
  return getRuleContext<MySqlParser::FunctionArgsContext>(0);
}

tree::TerminalNode* MySqlParser::CharFunctionCallContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::CharFunctionCallContext::USING() {
  return getToken(MySqlParser::USING, 0);
}

MySqlParser::CharsetNameContext* MySqlParser::CharFunctionCallContext::charsetName() {
  return getRuleContext<MySqlParser::CharsetNameContext>(0);
}

MySqlParser::CharFunctionCallContext::CharFunctionCallContext(SpecificFunctionContext *ctx) { copyFrom(ctx); }

void MySqlParser::CharFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharFunctionCall(this);
}
void MySqlParser::CharFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharFunctionCall(this);
}

std::any MySqlParser::CharFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCharFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- WeightFunctionCallContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::WeightFunctionCallContext::WEIGHT_STRING() {
  return getToken(MySqlParser::WEIGHT_STRING, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::WeightFunctionCallContext::LR_BRACKET() {
  return getTokens(MySqlParser::LR_BRACKET);
}

tree::TerminalNode* MySqlParser::WeightFunctionCallContext::LR_BRACKET(size_t i) {
  return getToken(MySqlParser::LR_BRACKET, i);
}

std::vector<tree::TerminalNode *> MySqlParser::WeightFunctionCallContext::RR_BRACKET() {
  return getTokens(MySqlParser::RR_BRACKET);
}

tree::TerminalNode* MySqlParser::WeightFunctionCallContext::RR_BRACKET(size_t i) {
  return getToken(MySqlParser::RR_BRACKET, i);
}

MySqlParser::StringLiteralContext* MySqlParser::WeightFunctionCallContext::stringLiteral() {
  return getRuleContext<MySqlParser::StringLiteralContext>(0);
}

MySqlParser::ExpressionContext* MySqlParser::WeightFunctionCallContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::WeightFunctionCallContext::AS() {
  return getToken(MySqlParser::AS, 0);
}

MySqlParser::DecimalLiteralContext* MySqlParser::WeightFunctionCallContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

MySqlParser::LevelsInWeightStringContext* MySqlParser::WeightFunctionCallContext::levelsInWeightString() {
  return getRuleContext<MySqlParser::LevelsInWeightStringContext>(0);
}

tree::TerminalNode* MySqlParser::WeightFunctionCallContext::CHAR() {
  return getToken(MySqlParser::CHAR, 0);
}

tree::TerminalNode* MySqlParser::WeightFunctionCallContext::BINARY() {
  return getToken(MySqlParser::BINARY, 0);
}

MySqlParser::WeightFunctionCallContext::WeightFunctionCallContext(SpecificFunctionContext *ctx) { copyFrom(ctx); }

void MySqlParser::WeightFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWeightFunctionCall(this);
}
void MySqlParser::WeightFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWeightFunctionCall(this);
}

std::any MySqlParser::WeightFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitWeightFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- GetFormatFunctionCallContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::GetFormatFunctionCallContext::GET_FORMAT() {
  return getToken(MySqlParser::GET_FORMAT, 0);
}

tree::TerminalNode* MySqlParser::GetFormatFunctionCallContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::GetFormatFunctionCallContext::COMMA() {
  return getToken(MySqlParser::COMMA, 0);
}

MySqlParser::StringLiteralContext* MySqlParser::GetFormatFunctionCallContext::stringLiteral() {
  return getRuleContext<MySqlParser::StringLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::GetFormatFunctionCallContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::GetFormatFunctionCallContext::DATE() {
  return getToken(MySqlParser::DATE, 0);
}

tree::TerminalNode* MySqlParser::GetFormatFunctionCallContext::TIME() {
  return getToken(MySqlParser::TIME, 0);
}

tree::TerminalNode* MySqlParser::GetFormatFunctionCallContext::DATETIME() {
  return getToken(MySqlParser::DATETIME, 0);
}

MySqlParser::GetFormatFunctionCallContext::GetFormatFunctionCallContext(SpecificFunctionContext *ctx) { copyFrom(ctx); }

void MySqlParser::GetFormatFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetFormatFunctionCall(this);
}
void MySqlParser::GetFormatFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetFormatFunctionCall(this);
}

std::any MySqlParser::GetFormatFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitGetFormatFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SubstrFunctionCallContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SubstrFunctionCallContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::SubstrFunctionCallContext::FROM() {
  return getToken(MySqlParser::FROM, 0);
}

tree::TerminalNode* MySqlParser::SubstrFunctionCallContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::SubstrFunctionCallContext::SUBSTR() {
  return getToken(MySqlParser::SUBSTR, 0);
}

tree::TerminalNode* MySqlParser::SubstrFunctionCallContext::SUBSTRING() {
  return getToken(MySqlParser::SUBSTRING, 0);
}

MySqlParser::StringLiteralContext* MySqlParser::SubstrFunctionCallContext::stringLiteral() {
  return getRuleContext<MySqlParser::StringLiteralContext>(0);
}

std::vector<MySqlParser::ExpressionContext *> MySqlParser::SubstrFunctionCallContext::expression() {
  return getRuleContexts<MySqlParser::ExpressionContext>();
}

MySqlParser::ExpressionContext* MySqlParser::SubstrFunctionCallContext::expression(size_t i) {
  return getRuleContext<MySqlParser::ExpressionContext>(i);
}

std::vector<MySqlParser::DecimalLiteralContext *> MySqlParser::SubstrFunctionCallContext::decimalLiteral() {
  return getRuleContexts<MySqlParser::DecimalLiteralContext>();
}

MySqlParser::DecimalLiteralContext* MySqlParser::SubstrFunctionCallContext::decimalLiteral(size_t i) {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(i);
}

tree::TerminalNode* MySqlParser::SubstrFunctionCallContext::FOR() {
  return getToken(MySqlParser::FOR, 0);
}

MySqlParser::SubstrFunctionCallContext::SubstrFunctionCallContext(SpecificFunctionContext *ctx) { copyFrom(ctx); }

void MySqlParser::SubstrFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubstrFunctionCall(this);
}
void MySqlParser::SubstrFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubstrFunctionCall(this);
}

std::any MySqlParser::SubstrFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSubstrFunctionCall(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::SpecificFunctionContext* MySqlParser::specificFunction() {
  SpecificFunctionContext *_localctx = _tracker.createInstance<SpecificFunctionContext>(_ctx, getState());
  enterRule(_localctx, 640, MySqlParser::RuleSpecificFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6925);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1027, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::SimpleFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(6747);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::CURRENT_USER || _la == MySqlParser::SCHEMA || ((((_la - 313) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 313)) & 262159) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6750);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1004, _ctx)) {
      case 1: {
        setState(6748);
        match(MySqlParser::LR_BRACKET);
        setState(6749);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::DataTypeFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(6752);
      match(MySqlParser::CONVERT);
      setState(6753);
      match(MySqlParser::LR_BRACKET);
      setState(6754);
      expression(0);
      setState(6755);
      antlrcpp::downCast<DataTypeFunctionCallContext *>(_localctx)->separator = match(MySqlParser::COMMA);
      setState(6756);
      convertedDataType();
      setState(6757);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<MySqlParser::DataTypeFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(6759);
      match(MySqlParser::CONVERT);
      setState(6760);
      match(MySqlParser::LR_BRACKET);
      setState(6761);
      expression(0);
      setState(6762);
      match(MySqlParser::USING);
      setState(6763);
      charsetName();
      setState(6764);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MySqlParser::DataTypeFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(6766);
      match(MySqlParser::CAST);
      setState(6767);
      match(MySqlParser::LR_BRACKET);
      setState(6768);
      expression(0);
      setState(6769);
      match(MySqlParser::AS);
      setState(6770);
      convertedDataType();
      setState(6771);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<MySqlParser::ValuesFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(6773);
      match(MySqlParser::VALUES);
      setState(6774);
      match(MySqlParser::LR_BRACKET);
      setState(6775);
      fullColumnName();
      setState(6776);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<MySqlParser::CaseExpressionFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(6778);
      match(MySqlParser::CASE);
      setState(6779);
      expression(0);
      setState(6781); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(6780);
        caseFuncAlternative();
        setState(6783); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MySqlParser::WHEN);
      setState(6787);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::ELSE) {
        setState(6785);
        match(MySqlParser::ELSE);
        setState(6786);
        antlrcpp::downCast<CaseExpressionFunctionCallContext *>(_localctx)->elseArg = functionArg();
      }
      setState(6789);
      match(MySqlParser::END);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<MySqlParser::CaseFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(6791);
      match(MySqlParser::CASE);
      setState(6793); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(6792);
        caseFuncAlternative();
        setState(6795); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MySqlParser::WHEN);
      setState(6799);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::ELSE) {
        setState(6797);
        match(MySqlParser::ELSE);
        setState(6798);
        antlrcpp::downCast<CaseFunctionCallContext *>(_localctx)->elseArg = functionArg();
      }
      setState(6801);
      match(MySqlParser::END);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<MySqlParser::CharFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(6803);
      match(MySqlParser::CHAR);
      setState(6804);
      match(MySqlParser::LR_BRACKET);
      setState(6805);
      functionArgs();
      setState(6808);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::USING) {
        setState(6806);
        match(MySqlParser::USING);
        setState(6807);
        charsetName();
      }
      setState(6810);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<MySqlParser::PositionFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(6812);
      match(MySqlParser::POSITION);
      setState(6813);
      match(MySqlParser::LR_BRACKET);
      setState(6816);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1010, _ctx)) {
      case 1: {
        setState(6814);
        antlrcpp::downCast<PositionFunctionCallContext *>(_localctx)->positionString = stringLiteral();
        break;
      }

      case 2: {
        setState(6815);
        antlrcpp::downCast<PositionFunctionCallContext *>(_localctx)->positionExpression = expression(0);
        break;
      }

      default:
        break;
      }
      setState(6818);
      match(MySqlParser::IN);
      setState(6821);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1011, _ctx)) {
      case 1: {
        setState(6819);
        antlrcpp::downCast<PositionFunctionCallContext *>(_localctx)->inString = stringLiteral();
        break;
      }

      case 2: {
        setState(6820);
        antlrcpp::downCast<PositionFunctionCallContext *>(_localctx)->inExpression = expression(0);
        break;
      }

      default:
        break;
      }
      setState(6823);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<MySqlParser::SubstrFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(6825);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::SUBSTR

      || _la == MySqlParser::SUBSTRING)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6826);
      match(MySqlParser::LR_BRACKET);
      setState(6829);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1012, _ctx)) {
      case 1: {
        setState(6827);
        antlrcpp::downCast<SubstrFunctionCallContext *>(_localctx)->sourceString = stringLiteral();
        break;
      }

      case 2: {
        setState(6828);
        antlrcpp::downCast<SubstrFunctionCallContext *>(_localctx)->sourceExpression = expression(0);
        break;
      }

      default:
        break;
      }
      setState(6831);
      match(MySqlParser::FROM);
      setState(6834);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1013, _ctx)) {
      case 1: {
        setState(6832);
        antlrcpp::downCast<SubstrFunctionCallContext *>(_localctx)->fromDecimal = decimalLiteral();
        break;
      }

      case 2: {
        setState(6833);
        antlrcpp::downCast<SubstrFunctionCallContext *>(_localctx)->fromExpression = expression(0);
        break;
      }

      default:
        break;
      }
      setState(6841);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::FOR) {
        setState(6836);
        match(MySqlParser::FOR);
        setState(6839);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1014, _ctx)) {
        case 1: {
          setState(6837);
          antlrcpp::downCast<SubstrFunctionCallContext *>(_localctx)->forDecimal = decimalLiteral();
          break;
        }

        case 2: {
          setState(6838);
          antlrcpp::downCast<SubstrFunctionCallContext *>(_localctx)->forExpression = expression(0);
          break;
        }

        default:
          break;
        }
      }
      setState(6843);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<MySqlParser::TrimFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 11);
      setState(6845);
      match(MySqlParser::TRIM);
      setState(6846);
      match(MySqlParser::LR_BRACKET);
      setState(6847);
      antlrcpp::downCast<TrimFunctionCallContext *>(_localctx)->positioinForm = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::BOTH || _la == MySqlParser::LEADING || _la == MySqlParser::TRAILING)) {
        antlrcpp::downCast<TrimFunctionCallContext *>(_localctx)->positioinForm = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6850);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1016, _ctx)) {
      case 1: {
        setState(6848);
        antlrcpp::downCast<TrimFunctionCallContext *>(_localctx)->sourceString = stringLiteral();
        break;
      }

      case 2: {
        setState(6849);
        antlrcpp::downCast<TrimFunctionCallContext *>(_localctx)->sourceExpression = expression(0);
        break;
      }

      default:
        break;
      }
      setState(6852);
      match(MySqlParser::FROM);
      setState(6855);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1017, _ctx)) {
      case 1: {
        setState(6853);
        antlrcpp::downCast<TrimFunctionCallContext *>(_localctx)->fromString = stringLiteral();
        break;
      }

      case 2: {
        setState(6854);
        antlrcpp::downCast<TrimFunctionCallContext *>(_localctx)->fromExpression = expression(0);
        break;
      }

      default:
        break;
      }
      setState(6857);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<MySqlParser::TrimFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 12);
      setState(6859);
      match(MySqlParser::TRIM);
      setState(6860);
      match(MySqlParser::LR_BRACKET);
      setState(6863);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1018, _ctx)) {
      case 1: {
        setState(6861);
        antlrcpp::downCast<TrimFunctionCallContext *>(_localctx)->sourceString = stringLiteral();
        break;
      }

      case 2: {
        setState(6862);
        antlrcpp::downCast<TrimFunctionCallContext *>(_localctx)->sourceExpression = expression(0);
        break;
      }

      default:
        break;
      }
      setState(6865);
      match(MySqlParser::FROM);
      setState(6868);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1019, _ctx)) {
      case 1: {
        setState(6866);
        antlrcpp::downCast<TrimFunctionCallContext *>(_localctx)->fromString = stringLiteral();
        break;
      }

      case 2: {
        setState(6867);
        antlrcpp::downCast<TrimFunctionCallContext *>(_localctx)->fromExpression = expression(0);
        break;
      }

      default:
        break;
      }
      setState(6870);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<MySqlParser::WeightFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 13);
      setState(6872);
      match(MySqlParser::WEIGHT_STRING);
      setState(6873);
      match(MySqlParser::LR_BRACKET);
      setState(6876);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1020, _ctx)) {
      case 1: {
        setState(6874);
        stringLiteral();
        break;
      }

      case 2: {
        setState(6875);
        expression(0);
        break;
      }

      default:
        break;
      }
      setState(6884);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::AS) {
        setState(6878);
        match(MySqlParser::AS);
        setState(6879);
        antlrcpp::downCast<WeightFunctionCallContext *>(_localctx)->stringFormat = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::CHAR

        || _la == MySqlParser::BINARY)) {
          antlrcpp::downCast<WeightFunctionCallContext *>(_localctx)->stringFormat = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6880);
        match(MySqlParser::LR_BRACKET);
        setState(6881);
        decimalLiteral();
        setState(6882);
        match(MySqlParser::RR_BRACKET);
      }
      setState(6887);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::LEVEL) {
        setState(6886);
        levelsInWeightString();
      }
      setState(6889);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<MySqlParser::ExtractFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 14);
      setState(6891);
      match(MySqlParser::EXTRACT);
      setState(6892);
      match(MySqlParser::LR_BRACKET);
      setState(6893);
      intervalType();
      setState(6894);
      match(MySqlParser::FROM);
      setState(6897);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1023, _ctx)) {
      case 1: {
        setState(6895);
        antlrcpp::downCast<ExtractFunctionCallContext *>(_localctx)->sourceString = stringLiteral();
        break;
      }

      case 2: {
        setState(6896);
        antlrcpp::downCast<ExtractFunctionCallContext *>(_localctx)->sourceExpression = expression(0);
        break;
      }

      default:
        break;
      }
      setState(6899);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 15: {
      _localctx = _tracker.createInstance<MySqlParser::GetFormatFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 15);
      setState(6901);
      match(MySqlParser::GET_FORMAT);
      setState(6902);
      match(MySqlParser::LR_BRACKET);
      setState(6903);
      antlrcpp::downCast<GetFormatFunctionCallContext *>(_localctx)->datetimeFormat = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 217) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 217)) & 11) != 0))) {
        antlrcpp::downCast<GetFormatFunctionCallContext *>(_localctx)->datetimeFormat = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6904);
      match(MySqlParser::COMMA);
      setState(6905);
      stringLiteral();
      setState(6906);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 16: {
      _localctx = _tracker.createInstance<MySqlParser::JsonValueFunctionCallContext>(_localctx);
      enterOuterAlt(_localctx, 16);
      setState(6908);
      match(MySqlParser::JSON_VALUE);
      setState(6909);
      match(MySqlParser::LR_BRACKET);
      setState(6910);
      expression(0);
      setState(6911);
      match(MySqlParser::COMMA);
      setState(6912);
      expression(0);
      setState(6915);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::RETURNING) {
        setState(6913);
        match(MySqlParser::RETURNING);
        setState(6914);
        convertedDataType();
      }
      setState(6918);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1025, _ctx)) {
      case 1: {
        setState(6917);
        jsonOnEmpty();
        break;
      }

      default:
        break;
      }
      setState(6921);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::DEFAULT || _la == MySqlParser::NULL_LITERAL || _la == MySqlParser::ERROR) {
        setState(6920);
        jsonOnError();
      }
      setState(6923);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseFuncAlternativeContext ------------------------------------------------------------------

MySqlParser::CaseFuncAlternativeContext::CaseFuncAlternativeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CaseFuncAlternativeContext::WHEN() {
  return getToken(MySqlParser::WHEN, 0);
}

tree::TerminalNode* MySqlParser::CaseFuncAlternativeContext::THEN() {
  return getToken(MySqlParser::THEN, 0);
}

std::vector<MySqlParser::FunctionArgContext *> MySqlParser::CaseFuncAlternativeContext::functionArg() {
  return getRuleContexts<MySqlParser::FunctionArgContext>();
}

MySqlParser::FunctionArgContext* MySqlParser::CaseFuncAlternativeContext::functionArg(size_t i) {
  return getRuleContext<MySqlParser::FunctionArgContext>(i);
}


size_t MySqlParser::CaseFuncAlternativeContext::getRuleIndex() const {
  return MySqlParser::RuleCaseFuncAlternative;
}

void MySqlParser::CaseFuncAlternativeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseFuncAlternative(this);
}

void MySqlParser::CaseFuncAlternativeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseFuncAlternative(this);
}


std::any MySqlParser::CaseFuncAlternativeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCaseFuncAlternative(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CaseFuncAlternativeContext* MySqlParser::caseFuncAlternative() {
  CaseFuncAlternativeContext *_localctx = _tracker.createInstance<CaseFuncAlternativeContext>(_ctx, getState());
  enterRule(_localctx, 642, MySqlParser::RuleCaseFuncAlternative);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6927);
    match(MySqlParser::WHEN);
    setState(6928);
    antlrcpp::downCast<CaseFuncAlternativeContext *>(_localctx)->condition = functionArg();
    setState(6929);
    match(MySqlParser::THEN);
    setState(6930);
    antlrcpp::downCast<CaseFuncAlternativeContext *>(_localctx)->consequent = functionArg();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LevelsInWeightStringContext ------------------------------------------------------------------

MySqlParser::LevelsInWeightStringContext::LevelsInWeightStringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::LevelsInWeightStringContext::getRuleIndex() const {
  return MySqlParser::RuleLevelsInWeightString;
}

void MySqlParser::LevelsInWeightStringContext::copyFrom(LevelsInWeightStringContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- LevelWeightRangeContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::LevelWeightRangeContext::LEVEL() {
  return getToken(MySqlParser::LEVEL, 0);
}

tree::TerminalNode* MySqlParser::LevelWeightRangeContext::MINUS() {
  return getToken(MySqlParser::MINUS, 0);
}

std::vector<MySqlParser::DecimalLiteralContext *> MySqlParser::LevelWeightRangeContext::decimalLiteral() {
  return getRuleContexts<MySqlParser::DecimalLiteralContext>();
}

MySqlParser::DecimalLiteralContext* MySqlParser::LevelWeightRangeContext::decimalLiteral(size_t i) {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(i);
}

MySqlParser::LevelWeightRangeContext::LevelWeightRangeContext(LevelsInWeightStringContext *ctx) { copyFrom(ctx); }

void MySqlParser::LevelWeightRangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLevelWeightRange(this);
}
void MySqlParser::LevelWeightRangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLevelWeightRange(this);
}

std::any MySqlParser::LevelWeightRangeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLevelWeightRange(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LevelWeightListContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::LevelWeightListContext::LEVEL() {
  return getToken(MySqlParser::LEVEL, 0);
}

std::vector<MySqlParser::LevelInWeightListElementContext *> MySqlParser::LevelWeightListContext::levelInWeightListElement() {
  return getRuleContexts<MySqlParser::LevelInWeightListElementContext>();
}

MySqlParser::LevelInWeightListElementContext* MySqlParser::LevelWeightListContext::levelInWeightListElement(size_t i) {
  return getRuleContext<MySqlParser::LevelInWeightListElementContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::LevelWeightListContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::LevelWeightListContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::LevelWeightListContext::LevelWeightListContext(LevelsInWeightStringContext *ctx) { copyFrom(ctx); }

void MySqlParser::LevelWeightListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLevelWeightList(this);
}
void MySqlParser::LevelWeightListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLevelWeightList(this);
}

std::any MySqlParser::LevelWeightListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLevelWeightList(this);
  else
    return visitor->visitChildren(this);
}
MySqlParser::LevelsInWeightStringContext* MySqlParser::levelsInWeightString() {
  LevelsInWeightStringContext *_localctx = _tracker.createInstance<LevelsInWeightStringContext>(_ctx, getState());
  enterRule(_localctx, 644, MySqlParser::RuleLevelsInWeightString);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6946);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1029, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<MySqlParser::LevelWeightListContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(6932);
      match(MySqlParser::LEVEL);
      setState(6933);
      levelInWeightListElement();
      setState(6938);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(6934);
        match(MySqlParser::COMMA);
        setState(6935);
        levelInWeightListElement();
        setState(6940);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<MySqlParser::LevelWeightRangeContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(6941);
      match(MySqlParser::LEVEL);
      setState(6942);
      antlrcpp::downCast<LevelWeightRangeContext *>(_localctx)->firstLevel = decimalLiteral();
      setState(6943);
      match(MySqlParser::MINUS);
      setState(6944);
      antlrcpp::downCast<LevelWeightRangeContext *>(_localctx)->lastLevel = decimalLiteral();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LevelInWeightListElementContext ------------------------------------------------------------------

MySqlParser::LevelInWeightListElementContext::LevelInWeightListElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::DecimalLiteralContext* MySqlParser::LevelInWeightListElementContext::decimalLiteral() {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(0);
}

tree::TerminalNode* MySqlParser::LevelInWeightListElementContext::ASC() {
  return getToken(MySqlParser::ASC, 0);
}

tree::TerminalNode* MySqlParser::LevelInWeightListElementContext::DESC() {
  return getToken(MySqlParser::DESC, 0);
}

tree::TerminalNode* MySqlParser::LevelInWeightListElementContext::REVERSE() {
  return getToken(MySqlParser::REVERSE, 0);
}


size_t MySqlParser::LevelInWeightListElementContext::getRuleIndex() const {
  return MySqlParser::RuleLevelInWeightListElement;
}

void MySqlParser::LevelInWeightListElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLevelInWeightListElement(this);
}

void MySqlParser::LevelInWeightListElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLevelInWeightListElement(this);
}


std::any MySqlParser::LevelInWeightListElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLevelInWeightListElement(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LevelInWeightListElementContext* MySqlParser::levelInWeightListElement() {
  LevelInWeightListElementContext *_localctx = _tracker.createInstance<LevelInWeightListElementContext>(_ctx, getState());
  enterRule(_localctx, 646, MySqlParser::RuleLevelInWeightListElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6948);
    decimalLiteral();
    setState(6950);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ASC

    || _la == MySqlParser::DESC || _la == MySqlParser::REVERSE) {
      setState(6949);
      antlrcpp::downCast<LevelInWeightListElementContext *>(_localctx)->orderType = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::ASC

      || _la == MySqlParser::DESC || _la == MySqlParser::REVERSE)) {
        antlrcpp::downCast<LevelInWeightListElementContext *>(_localctx)->orderType = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AggregateWindowedFunctionContext ------------------------------------------------------------------

MySqlParser::AggregateWindowedFunctionContext::AggregateWindowedFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::FunctionArgContext* MySqlParser::AggregateWindowedFunctionContext::functionArg() {
  return getRuleContext<MySqlParser::FunctionArgContext>(0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::AVG() {
  return getToken(MySqlParser::AVG, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::MAX() {
  return getToken(MySqlParser::MAX, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::MIN() {
  return getToken(MySqlParser::MIN, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::SUM() {
  return getToken(MySqlParser::SUM, 0);
}

MySqlParser::OverClauseContext* MySqlParser::AggregateWindowedFunctionContext::overClause() {
  return getRuleContext<MySqlParser::OverClauseContext>(0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::DISTINCT() {
  return getToken(MySqlParser::DISTINCT, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::COUNT() {
  return getToken(MySqlParser::COUNT, 0);
}

MySqlParser::FunctionArgsContext* MySqlParser::AggregateWindowedFunctionContext::functionArgs() {
  return getRuleContext<MySqlParser::FunctionArgsContext>(0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::STAR() {
  return getToken(MySqlParser::STAR, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::BIT_AND() {
  return getToken(MySqlParser::BIT_AND, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::BIT_OR() {
  return getToken(MySqlParser::BIT_OR, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::BIT_XOR() {
  return getToken(MySqlParser::BIT_XOR, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::STD() {
  return getToken(MySqlParser::STD, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::STDDEV() {
  return getToken(MySqlParser::STDDEV, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::STDDEV_POP() {
  return getToken(MySqlParser::STDDEV_POP, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::STDDEV_SAMP() {
  return getToken(MySqlParser::STDDEV_SAMP, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::VAR_POP() {
  return getToken(MySqlParser::VAR_POP, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::VAR_SAMP() {
  return getToken(MySqlParser::VAR_SAMP, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::VARIANCE() {
  return getToken(MySqlParser::VARIANCE, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::GROUP_CONCAT() {
  return getToken(MySqlParser::GROUP_CONCAT, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::ORDER() {
  return getToken(MySqlParser::ORDER, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::BY() {
  return getToken(MySqlParser::BY, 0);
}

std::vector<MySqlParser::OrderByExpressionContext *> MySqlParser::AggregateWindowedFunctionContext::orderByExpression() {
  return getRuleContexts<MySqlParser::OrderByExpressionContext>();
}

MySqlParser::OrderByExpressionContext* MySqlParser::AggregateWindowedFunctionContext::orderByExpression(size_t i) {
  return getRuleContext<MySqlParser::OrderByExpressionContext>(i);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::SEPARATOR() {
  return getToken(MySqlParser::SEPARATOR, 0);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::AggregateWindowedFunctionContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::AggregateWindowedFunctionContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::AggregateWindowedFunctionContext::getRuleIndex() const {
  return MySqlParser::RuleAggregateWindowedFunction;
}

void MySqlParser::AggregateWindowedFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregateWindowedFunction(this);
}

void MySqlParser::AggregateWindowedFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregateWindowedFunction(this);
}


std::any MySqlParser::AggregateWindowedFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitAggregateWindowedFunction(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::AggregateWindowedFunctionContext* MySqlParser::aggregateWindowedFunction() {
  AggregateWindowedFunctionContext *_localctx = _tracker.createInstance<AggregateWindowedFunctionContext>(_ctx, getState());
  enterRule(_localctx, 648, MySqlParser::RuleAggregateWindowedFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7011);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::AVG:
      case MySqlParser::MAX:
      case MySqlParser::MIN:
      case MySqlParser::SUM: {
        enterOuterAlt(_localctx, 1);
        setState(6952);
        _la = _input->LA(1);
        if (!(((((_la - 286) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 286)) & 8400897) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6953);
        match(MySqlParser::LR_BRACKET);
        setState(6955);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1031, _ctx)) {
        case 1: {
          setState(6954);
          antlrcpp::downCast<AggregateWindowedFunctionContext *>(_localctx)->aggregator = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::ALL

          || _la == MySqlParser::DISTINCT)) {
            antlrcpp::downCast<AggregateWindowedFunctionContext *>(_localctx)->aggregator = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        }
        setState(6957);
        functionArg();
        setState(6958);
        match(MySqlParser::RR_BRACKET);
        setState(6960);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1032, _ctx)) {
        case 1: {
          setState(6959);
          overClause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case MySqlParser::COUNT: {
        enterOuterAlt(_localctx, 2);
        setState(6962);
        match(MySqlParser::COUNT);
        setState(6963);
        match(MySqlParser::LR_BRACKET);
        setState(6971);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1034, _ctx)) {
        case 1: {
          setState(6964);
          antlrcpp::downCast<AggregateWindowedFunctionContext *>(_localctx)->starArg = match(MySqlParser::STAR);
          break;
        }

        case 2: {
          setState(6966);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1033, _ctx)) {
          case 1: {
            setState(6965);
            antlrcpp::downCast<AggregateWindowedFunctionContext *>(_localctx)->aggregator = match(MySqlParser::ALL);
            break;
          }

          default:
            break;
          }
          setState(6968);
          functionArg();
          break;
        }

        case 3: {
          setState(6969);
          antlrcpp::downCast<AggregateWindowedFunctionContext *>(_localctx)->aggregator = match(MySqlParser::DISTINCT);
          setState(6970);
          functionArgs();
          break;
        }

        default:
          break;
        }
        setState(6973);
        match(MySqlParser::RR_BRACKET);
        setState(6975);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1035, _ctx)) {
        case 1: {
          setState(6974);
          overClause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case MySqlParser::BIT_AND:
      case MySqlParser::BIT_OR:
      case MySqlParser::BIT_XOR:
      case MySqlParser::STD:
      case MySqlParser::STDDEV:
      case MySqlParser::STDDEV_POP:
      case MySqlParser::STDDEV_SAMP:
      case MySqlParser::VAR_POP:
      case MySqlParser::VAR_SAMP:
      case MySqlParser::VARIANCE: {
        enterOuterAlt(_localctx, 3);
        setState(6977);
        _la = _input->LA(1);
        if (!(((((_la - 287) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 287)) & 62652423) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6978);
        match(MySqlParser::LR_BRACKET);
        setState(6980);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1036, _ctx)) {
        case 1: {
          setState(6979);
          antlrcpp::downCast<AggregateWindowedFunctionContext *>(_localctx)->aggregator = match(MySqlParser::ALL);
          break;
        }

        default:
          break;
        }
        setState(6982);
        functionArg();
        setState(6983);
        match(MySqlParser::RR_BRACKET);
        setState(6985);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1037, _ctx)) {
        case 1: {
          setState(6984);
          overClause();
          break;
        }

        default:
          break;
        }
        break;
      }

      case MySqlParser::GROUP_CONCAT: {
        enterOuterAlt(_localctx, 4);
        setState(6987);
        match(MySqlParser::GROUP_CONCAT);
        setState(6988);
        match(MySqlParser::LR_BRACKET);
        setState(6990);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1038, _ctx)) {
        case 1: {
          setState(6989);
          antlrcpp::downCast<AggregateWindowedFunctionContext *>(_localctx)->aggregator = match(MySqlParser::DISTINCT);
          break;
        }

        default:
          break;
        }
        setState(6992);
        functionArgs();
        setState(7003);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::ORDER) {
          setState(6993);
          match(MySqlParser::ORDER);
          setState(6994);
          match(MySqlParser::BY);
          setState(6995);
          orderByExpression();
          setState(7000);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == MySqlParser::COMMA) {
            setState(6996);
            match(MySqlParser::COMMA);
            setState(6997);
            orderByExpression();
            setState(7002);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        setState(7007);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::SEPARATOR) {
          setState(7005);
          match(MySqlParser::SEPARATOR);
          setState(7006);
          antlrcpp::downCast<AggregateWindowedFunctionContext *>(_localctx)->separator = match(MySqlParser::STRING_LITERAL);
        }
        setState(7009);
        match(MySqlParser::RR_BRACKET);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NonAggregateWindowedFunctionContext ------------------------------------------------------------------

MySqlParser::NonAggregateWindowedFunctionContext::NonAggregateWindowedFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::ExpressionContext* MySqlParser::NonAggregateWindowedFunctionContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::OverClauseContext* MySqlParser::NonAggregateWindowedFunctionContext::overClause() {
  return getRuleContext<MySqlParser::OverClauseContext>(0);
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::LAG() {
  return getToken(MySqlParser::LAG, 0);
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::LEAD() {
  return getToken(MySqlParser::LEAD, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::NonAggregateWindowedFunctionContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

std::vector<MySqlParser::DecimalLiteralContext *> MySqlParser::NonAggregateWindowedFunctionContext::decimalLiteral() {
  return getRuleContexts<MySqlParser::DecimalLiteralContext>();
}

MySqlParser::DecimalLiteralContext* MySqlParser::NonAggregateWindowedFunctionContext::decimalLiteral(size_t i) {
  return getRuleContext<MySqlParser::DecimalLiteralContext>(i);
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::FIRST_VALUE() {
  return getToken(MySqlParser::FIRST_VALUE, 0);
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::LAST_VALUE() {
  return getToken(MySqlParser::LAST_VALUE, 0);
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::CUME_DIST() {
  return getToken(MySqlParser::CUME_DIST, 0);
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::DENSE_RANK() {
  return getToken(MySqlParser::DENSE_RANK, 0);
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::PERCENT_RANK() {
  return getToken(MySqlParser::PERCENT_RANK, 0);
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::RANK() {
  return getToken(MySqlParser::RANK, 0);
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::ROW_NUMBER() {
  return getToken(MySqlParser::ROW_NUMBER, 0);
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::NTH_VALUE() {
  return getToken(MySqlParser::NTH_VALUE, 0);
}

tree::TerminalNode* MySqlParser::NonAggregateWindowedFunctionContext::NTILE() {
  return getToken(MySqlParser::NTILE, 0);
}


size_t MySqlParser::NonAggregateWindowedFunctionContext::getRuleIndex() const {
  return MySqlParser::RuleNonAggregateWindowedFunction;
}

void MySqlParser::NonAggregateWindowedFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNonAggregateWindowedFunction(this);
}

void MySqlParser::NonAggregateWindowedFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNonAggregateWindowedFunction(this);
}


std::any MySqlParser::NonAggregateWindowedFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitNonAggregateWindowedFunction(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::NonAggregateWindowedFunctionContext* MySqlParser::nonAggregateWindowedFunction() {
  NonAggregateWindowedFunctionContext *_localctx = _tracker.createInstance<NonAggregateWindowedFunctionContext>(_ctx, getState());
  enterRule(_localctx, 650, MySqlParser::RuleNonAggregateWindowedFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7051);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::LAG:
      case MySqlParser::LEAD: {
        enterOuterAlt(_localctx, 1);
        setState(7013);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::LAG

        || _la == MySqlParser::LEAD)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7014);
        match(MySqlParser::LR_BRACKET);
        setState(7015);
        expression(0);
        setState(7018);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1043, _ctx)) {
        case 1: {
          setState(7016);
          match(MySqlParser::COMMA);
          setState(7017);
          decimalLiteral();
          break;
        }

        default:
          break;
        }
        setState(7022);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySqlParser::COMMA) {
          setState(7020);
          match(MySqlParser::COMMA);
          setState(7021);
          decimalLiteral();
        }
        setState(7024);
        match(MySqlParser::RR_BRACKET);
        setState(7025);
        overClause();
        break;
      }

      case MySqlParser::FIRST_VALUE:
      case MySqlParser::LAST_VALUE: {
        enterOuterAlt(_localctx, 2);
        setState(7027);
        _la = _input->LA(1);
        if (!(_la == MySqlParser::FIRST_VALUE

        || _la == MySqlParser::LAST_VALUE)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7028);
        match(MySqlParser::LR_BRACKET);
        setState(7029);
        expression(0);
        setState(7030);
        match(MySqlParser::RR_BRACKET);
        setState(7031);
        overClause();
        break;
      }

      case MySqlParser::CUME_DIST:
      case MySqlParser::DENSE_RANK:
      case MySqlParser::PERCENT_RANK:
      case MySqlParser::RANK:
      case MySqlParser::ROW_NUMBER: {
        enterOuterAlt(_localctx, 3);
        setState(7033);
        _la = _input->LA(1);
        if (!(((((_la - 291) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 291)) & 14339) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7034);
        match(MySqlParser::LR_BRACKET);
        setState(7035);
        match(MySqlParser::RR_BRACKET);
        setState(7036);
        overClause();
        break;
      }

      case MySqlParser::NTH_VALUE: {
        enterOuterAlt(_localctx, 4);
        setState(7037);
        match(MySqlParser::NTH_VALUE);
        setState(7038);
        match(MySqlParser::LR_BRACKET);
        setState(7039);
        expression(0);
        setState(7040);
        match(MySqlParser::COMMA);
        setState(7041);
        decimalLiteral();
        setState(7042);
        match(MySqlParser::RR_BRACKET);
        setState(7043);
        overClause();
        break;
      }

      case MySqlParser::NTILE: {
        enterOuterAlt(_localctx, 5);
        setState(7045);
        match(MySqlParser::NTILE);
        setState(7046);
        match(MySqlParser::LR_BRACKET);
        setState(7047);
        decimalLiteral();
        setState(7048);
        match(MySqlParser::RR_BRACKET);
        setState(7049);
        overClause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OverClauseContext ------------------------------------------------------------------

MySqlParser::OverClauseContext::OverClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::OverClauseContext::OVER() {
  return getToken(MySqlParser::OVER, 0);
}

tree::TerminalNode* MySqlParser::OverClauseContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::WindowSpecContext* MySqlParser::OverClauseContext::windowSpec() {
  return getRuleContext<MySqlParser::WindowSpecContext>(0);
}

tree::TerminalNode* MySqlParser::OverClauseContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::WindowNameContext* MySqlParser::OverClauseContext::windowName() {
  return getRuleContext<MySqlParser::WindowNameContext>(0);
}


size_t MySqlParser::OverClauseContext::getRuleIndex() const {
  return MySqlParser::RuleOverClause;
}

void MySqlParser::OverClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOverClause(this);
}

void MySqlParser::OverClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOverClause(this);
}


std::any MySqlParser::OverClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitOverClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::OverClauseContext* MySqlParser::overClause() {
  OverClauseContext *_localctx = _tracker.createInstance<OverClauseContext>(_ctx, getState());
  enterRule(_localctx, 652, MySqlParser::RuleOverClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7053);
    match(MySqlParser::OVER);
    setState(7059);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::LR_BRACKET: {
        setState(7054);
        match(MySqlParser::LR_BRACKET);
        setState(7055);
        windowSpec();
        setState(7056);
        match(MySqlParser::RR_BRACKET);
        break;
      }

      case MySqlParser::ATTRIBUTE:
      case MySqlParser::BUCKETS:
      case MySqlParser::CONDITION:
      case MySqlParser::CURRENT:
      case MySqlParser::CURRENT_USER:
      case MySqlParser::DATABASE:
      case MySqlParser::DEFAULT:
      case MySqlParser::DIAGNOSTICS:
      case MySqlParser::EMPTY:
      case MySqlParser::ENFORCED:
      case MySqlParser::EXCEPT:
      case MySqlParser::GROUP:
      case MySqlParser::IF:
      case MySqlParser::IGNORED:
      case MySqlParser::INSERT:
      case MySqlParser::LATERAL:
      case MySqlParser::LEFT:
      case MySqlParser::NUMBER:
      case MySqlParser::OPTIONAL:
      case MySqlParser::ORDER:
      case MySqlParser::PRIMARY:
      case MySqlParser::REPLACE:
      case MySqlParser::RIGHT:
      case MySqlParser::SCHEMA:
      case MySqlParser::SKIP_QUERY_REWRITE:
      case MySqlParser::STACKED:
      case MySqlParser::DATE:
      case MySqlParser::TIME:
      case MySqlParser::TIMESTAMP:
      case MySqlParser::DATETIME:
      case MySqlParser::YEAR:
      case MySqlParser::BINARY:
      case MySqlParser::TEXT:
      case MySqlParser::ENUM:
      case MySqlParser::SERIAL:
      case MySqlParser::JSON_ARRAY:
      case MySqlParser::JSON_ARRAYAGG:
      case MySqlParser::JSON_ARRAY_APPEND:
      case MySqlParser::JSON_ARRAY_INSERT:
      case MySqlParser::JSON_CONTAINS:
      case MySqlParser::JSON_CONTAINS_PATH:
      case MySqlParser::JSON_DEPTH:
      case MySqlParser::JSON_EXTRACT:
      case MySqlParser::JSON_INSERT:
      case MySqlParser::JSON_KEYS:
      case MySqlParser::JSON_LENGTH:
      case MySqlParser::JSON_MERGE:
      case MySqlParser::JSON_MERGE_PATCH:
      case MySqlParser::JSON_MERGE_PRESERVE:
      case MySqlParser::JSON_OBJECT:
      case MySqlParser::JSON_OBJECTAGG:
      case MySqlParser::JSON_OVERLAPS:
      case MySqlParser::JSON_PRETTY:
      case MySqlParser::JSON_QUOTE:
      case MySqlParser::JSON_REMOVE:
      case MySqlParser::JSON_REPLACE:
      case MySqlParser::JSON_SCHEMA_VALID:
      case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
      case MySqlParser::JSON_SEARCH:
      case MySqlParser::JSON_SET:
      case MySqlParser::JSON_STORAGE_FREE:
      case MySqlParser::JSON_STORAGE_SIZE:
      case MySqlParser::JSON_TABLE:
      case MySqlParser::JSON_TYPE:
      case MySqlParser::JSON_UNQUOTE:
      case MySqlParser::JSON_VALID:
      case MySqlParser::JSON_VALUE:
      case MySqlParser::NESTED:
      case MySqlParser::ORDINALITY:
      case MySqlParser::PATH:
      case MySqlParser::AVG:
      case MySqlParser::BIT_AND:
      case MySqlParser::BIT_OR:
      case MySqlParser::BIT_XOR:
      case MySqlParser::COUNT:
      case MySqlParser::CUME_DIST:
      case MySqlParser::DENSE_RANK:
      case MySqlParser::FIRST_VALUE:
      case MySqlParser::GROUP_CONCAT:
      case MySqlParser::LAG:
      case MySqlParser::LAST_VALUE:
      case MySqlParser::LEAD:
      case MySqlParser::MAX:
      case MySqlParser::MIN:
      case MySqlParser::NTILE:
      case MySqlParser::NTH_VALUE:
      case MySqlParser::PERCENT_RANK:
      case MySqlParser::RANK:
      case MySqlParser::ROW_NUMBER:
      case MySqlParser::STD:
      case MySqlParser::STDDEV:
      case MySqlParser::STDDEV_POP:
      case MySqlParser::STDDEV_SAMP:
      case MySqlParser::SUM:
      case MySqlParser::VAR_POP:
      case MySqlParser::VAR_SAMP:
      case MySqlParser::VARIANCE:
      case MySqlParser::CURRENT_DATE:
      case MySqlParser::CURRENT_TIME:
      case MySqlParser::CURRENT_TIMESTAMP:
      case MySqlParser::LOCALTIME:
      case MySqlParser::CURDATE:
      case MySqlParser::CURTIME:
      case MySqlParser::DATE_ADD:
      case MySqlParser::DATE_SUB:
      case MySqlParser::LOCALTIMESTAMP:
      case MySqlParser::NOW:
      case MySqlParser::POSITION:
      case MySqlParser::SUBSTR:
      case MySqlParser::SUBSTRING:
      case MySqlParser::SYSDATE:
      case MySqlParser::TRIM:
      case MySqlParser::UTC_DATE:
      case MySqlParser::UTC_TIME:
      case MySqlParser::UTC_TIMESTAMP:
      case MySqlParser::ACCOUNT:
      case MySqlParser::ACTION:
      case MySqlParser::AFTER:
      case MySqlParser::AGGREGATE:
      case MySqlParser::ALGORITHM:
      case MySqlParser::ANY:
      case MySqlParser::AT:
      case MySqlParser::AUTHORS:
      case MySqlParser::AUTOCOMMIT:
      case MySqlParser::AUTOEXTEND_SIZE:
      case MySqlParser::AUTO_INCREMENT:
      case MySqlParser::AVG_ROW_LENGTH:
      case MySqlParser::BEGIN:
      case MySqlParser::BINLOG:
      case MySqlParser::BIT:
      case MySqlParser::BLOCK:
      case MySqlParser::BOOL:
      case MySqlParser::BOOLEAN:
      case MySqlParser::BTREE:
      case MySqlParser::CACHE:
      case MySqlParser::CASCADED:
      case MySqlParser::CHAIN:
      case MySqlParser::CHANGED:
      case MySqlParser::CHANNEL:
      case MySqlParser::CHECKSUM:
      case MySqlParser::PAGE_CHECKSUM:
      case MySqlParser::CIPHER:
      case MySqlParser::CLASS_ORIGIN:
      case MySqlParser::CLIENT:
      case MySqlParser::CLOSE:
      case MySqlParser::CLUSTERING:
      case MySqlParser::COALESCE:
      case MySqlParser::CODE:
      case MySqlParser::COLUMNS:
      case MySqlParser::COLUMN_FORMAT:
      case MySqlParser::COLUMN_NAME:
      case MySqlParser::COMMENT:
      case MySqlParser::COMMIT:
      case MySqlParser::COMPACT:
      case MySqlParser::COMPLETION:
      case MySqlParser::COMPRESSED:
      case MySqlParser::COMPRESSION:
      case MySqlParser::CONCURRENT:
      case MySqlParser::CONNECT:
      case MySqlParser::CONNECTION:
      case MySqlParser::CONSISTENT:
      case MySqlParser::CONSTRAINT_CATALOG:
      case MySqlParser::CONSTRAINT_SCHEMA:
      case MySqlParser::CONSTRAINT_NAME:
      case MySqlParser::CONTAINS:
      case MySqlParser::CONTEXT:
      case MySqlParser::CONTRIBUTORS:
      case MySqlParser::COPY:
      case MySqlParser::CPU:
      case MySqlParser::CURSOR_NAME:
      case MySqlParser::DATA:
      case MySqlParser::DATAFILE:
      case MySqlParser::DEALLOCATE:
      case MySqlParser::DEFAULT_AUTH:
      case MySqlParser::DEFINER:
      case MySqlParser::DELAY_KEY_WRITE:
      case MySqlParser::DES_KEY_FILE:
      case MySqlParser::DIRECTORY:
      case MySqlParser::DISABLE:
      case MySqlParser::DISCARD:
      case MySqlParser::DISK:
      case MySqlParser::DO:
      case MySqlParser::DUMPFILE:
      case MySqlParser::DUPLICATE:
      case MySqlParser::DYNAMIC:
      case MySqlParser::ENABLE:
      case MySqlParser::ENCRYPTION:
      case MySqlParser::END:
      case MySqlParser::ENDS:
      case MySqlParser::ENGINE:
      case MySqlParser::ENGINES:
      case MySqlParser::ERROR:
      case MySqlParser::ERRORS:
      case MySqlParser::ESCAPE:
      case MySqlParser::EVEN:
      case MySqlParser::EVENT:
      case MySqlParser::EVENTS:
      case MySqlParser::EVERY:
      case MySqlParser::EXCHANGE:
      case MySqlParser::EXCLUSIVE:
      case MySqlParser::EXPIRE:
      case MySqlParser::EXPORT:
      case MySqlParser::EXTENDED:
      case MySqlParser::EXTENT_SIZE:
      case MySqlParser::FAILED_LOGIN_ATTEMPTS:
      case MySqlParser::FAST:
      case MySqlParser::FAULTS:
      case MySqlParser::FIELDS:
      case MySqlParser::FILE_BLOCK_SIZE:
      case MySqlParser::FILTER:
      case MySqlParser::FIRST:
      case MySqlParser::FIXED:
      case MySqlParser::FLUSH:
      case MySqlParser::FOLLOWS:
      case MySqlParser::FOUND:
      case MySqlParser::FULL:
      case MySqlParser::FUNCTION:
      case MySqlParser::GENERAL:
      case MySqlParser::GLOBAL:
      case MySqlParser::GRANTS:
      case MySqlParser::GROUP_REPLICATION:
      case MySqlParser::HANDLER:
      case MySqlParser::HASH:
      case MySqlParser::HELP:
      case MySqlParser::HISTORY:
      case MySqlParser::HOST:
      case MySqlParser::HOSTS:
      case MySqlParser::IDENTIFIED:
      case MySqlParser::IGNORE_SERVER_IDS:
      case MySqlParser::IMPORT:
      case MySqlParser::INDEXES:
      case MySqlParser::INITIAL_SIZE:
      case MySqlParser::INPLACE:
      case MySqlParser::INSERT_METHOD:
      case MySqlParser::INSTALL:
      case MySqlParser::INSTANCE:
      case MySqlParser::INSTANT:
      case MySqlParser::INVISIBLE:
      case MySqlParser::INVOKER:
      case MySqlParser::IO:
      case MySqlParser::IO_THREAD:
      case MySqlParser::IPC:
      case MySqlParser::ISOLATION:
      case MySqlParser::ISSUER:
      case MySqlParser::JSON:
      case MySqlParser::KEY_BLOCK_SIZE:
      case MySqlParser::LANGUAGE:
      case MySqlParser::LAST:
      case MySqlParser::LEAVES:
      case MySqlParser::LESS:
      case MySqlParser::LEVEL:
      case MySqlParser::LIST:
      case MySqlParser::LOCAL:
      case MySqlParser::LOGFILE:
      case MySqlParser::LOGS:
      case MySqlParser::MASTER:
      case MySqlParser::MASTER_AUTO_POSITION:
      case MySqlParser::MASTER_CONNECT_RETRY:
      case MySqlParser::MASTER_DELAY:
      case MySqlParser::MASTER_HEARTBEAT_PERIOD:
      case MySqlParser::MASTER_HOST:
      case MySqlParser::MASTER_LOG_FILE:
      case MySqlParser::MASTER_LOG_POS:
      case MySqlParser::MASTER_PASSWORD:
      case MySqlParser::MASTER_PORT:
      case MySqlParser::MASTER_RETRY_COUNT:
      case MySqlParser::MASTER_SSL:
      case MySqlParser::MASTER_SSL_CA:
      case MySqlParser::MASTER_SSL_CAPATH:
      case MySqlParser::MASTER_SSL_CERT:
      case MySqlParser::MASTER_SSL_CIPHER:
      case MySqlParser::MASTER_SSL_CRL:
      case MySqlParser::MASTER_SSL_CRLPATH:
      case MySqlParser::MASTER_SSL_KEY:
      case MySqlParser::MASTER_TLS_VERSION:
      case MySqlParser::MASTER_USER:
      case MySqlParser::MAX_CONNECTIONS_PER_HOUR:
      case MySqlParser::MAX_QUERIES_PER_HOUR:
      case MySqlParser::MAX_ROWS:
      case MySqlParser::MAX_SIZE:
      case MySqlParser::MAX_UPDATES_PER_HOUR:
      case MySqlParser::MAX_USER_CONNECTIONS:
      case MySqlParser::MEDIUM:
      case MySqlParser::MEMBER:
      case MySqlParser::MERGE:
      case MySqlParser::MESSAGE_TEXT:
      case MySqlParser::MID:
      case MySqlParser::MIGRATE:
      case MySqlParser::MIN_ROWS:
      case MySqlParser::MODE:
      case MySqlParser::MODIFY:
      case MySqlParser::MUTEX:
      case MySqlParser::MYSQL:
      case MySqlParser::MYSQL_ERRNO:
      case MySqlParser::NAME:
      case MySqlParser::NAMES:
      case MySqlParser::NCHAR:
      case MySqlParser::NEVER:
      case MySqlParser::NEXT:
      case MySqlParser::NO:
      case MySqlParser::NOCOPY:
      case MySqlParser::NOWAIT:
      case MySqlParser::NODEGROUP:
      case MySqlParser::NONE:
      case MySqlParser::ODBC:
      case MySqlParser::OFFLINE:
      case MySqlParser::OFFSET:
      case MySqlParser::OF:
      case MySqlParser::OJ:
      case MySqlParser::OLD_PASSWORD:
      case MySqlParser::ONE:
      case MySqlParser::ONLINE:
      case MySqlParser::ONLY:
      case MySqlParser::OPEN:
      case MySqlParser::OPTIMIZER_COSTS:
      case MySqlParser::OPTIONS:
      case MySqlParser::OWNER:
      case MySqlParser::PACK_KEYS:
      case MySqlParser::PAGE:
      case MySqlParser::PARSER:
      case MySqlParser::PARTIAL:
      case MySqlParser::PARTITIONING:
      case MySqlParser::PARTITIONS:
      case MySqlParser::PASSWORD:
      case MySqlParser::PASSWORD_LOCK_TIME:
      case MySqlParser::PHASE:
      case MySqlParser::PLUGIN:
      case MySqlParser::PLUGIN_DIR:
      case MySqlParser::PLUGINS:
      case MySqlParser::PORT:
      case MySqlParser::PRECEDES:
      case MySqlParser::PREPARE:
      case MySqlParser::PRESERVE:
      case MySqlParser::PREV:
      case MySqlParser::PROCESSLIST:
      case MySqlParser::PROFILE:
      case MySqlParser::PROFILES:
      case MySqlParser::PROXY:
      case MySqlParser::QUERY:
      case MySqlParser::QUICK:
      case MySqlParser::REBUILD:
      case MySqlParser::RECOVER:
      case MySqlParser::RECURSIVE:
      case MySqlParser::REDO_BUFFER_SIZE:
      case MySqlParser::REDUNDANT:
      case MySqlParser::RELAY:
      case MySqlParser::RELAY_LOG_FILE:
      case MySqlParser::RELAY_LOG_POS:
      case MySqlParser::RELAYLOG:
      case MySqlParser::REMOVE:
      case MySqlParser::REORGANIZE:
      case MySqlParser::REPAIR:
      case MySqlParser::REPLICATE_DO_DB:
      case MySqlParser::REPLICATE_DO_TABLE:
      case MySqlParser::REPLICATE_IGNORE_DB:
      case MySqlParser::REPLICATE_IGNORE_TABLE:
      case MySqlParser::REPLICATE_REWRITE_DB:
      case MySqlParser::REPLICATE_WILD_DO_TABLE:
      case MySqlParser::REPLICATE_WILD_IGNORE_TABLE:
      case MySqlParser::REPLICATION:
      case MySqlParser::RESET:
      case MySqlParser::RESUME:
      case MySqlParser::RETURNED_SQLSTATE:
      case MySqlParser::RETURNS:
      case MySqlParser::REUSE:
      case MySqlParser::ROLE:
      case MySqlParser::ROLLBACK:
      case MySqlParser::ROLLUP:
      case MySqlParser::ROTATE:
      case MySqlParser::ROW:
      case MySqlParser::ROWS:
      case MySqlParser::ROW_FORMAT:
      case MySqlParser::RTREE:
      case MySqlParser::SAVEPOINT:
      case MySqlParser::SCHEDULE:
      case MySqlParser::SECURITY:
      case MySqlParser::SERVER:
      case MySqlParser::SESSION:
      case MySqlParser::SHARE:
      case MySqlParser::SHARED:
      case MySqlParser::SIGNED:
      case MySqlParser::SIMPLE:
      case MySqlParser::SLAVE:
      case MySqlParser::SLOW:
      case MySqlParser::SNAPSHOT:
      case MySqlParser::SOCKET:
      case MySqlParser::SOME:
      case MySqlParser::SONAME:
      case MySqlParser::SOUNDS:
      case MySqlParser::SOURCE:
      case MySqlParser::SQL_AFTER_GTIDS:
      case MySqlParser::SQL_AFTER_MTS_GAPS:
      case MySqlParser::SQL_BEFORE_GTIDS:
      case MySqlParser::SQL_BUFFER_RESULT:
      case MySqlParser::SQL_CACHE:
      case MySqlParser::SQL_NO_CACHE:
      case MySqlParser::SQL_THREAD:
      case MySqlParser::START:
      case MySqlParser::STARTS:
      case MySqlParser::STATS_AUTO_RECALC:
      case MySqlParser::STATS_PERSISTENT:
      case MySqlParser::STATS_SAMPLE_PAGES:
      case MySqlParser::STATUS:
      case MySqlParser::STOP:
      case MySqlParser::STORAGE:
      case MySqlParser::STRING:
      case MySqlParser::SUBCLASS_ORIGIN:
      case MySqlParser::SUBJECT:
      case MySqlParser::SUBPARTITION:
      case MySqlParser::SUBPARTITIONS:
      case MySqlParser::SUSPEND:
      case MySqlParser::SWAPS:
      case MySqlParser::SWITCHES:
      case MySqlParser::TABLE_NAME:
      case MySqlParser::TABLESPACE:
      case MySqlParser::TABLE_TYPE:
      case MySqlParser::TEMPORARY:
      case MySqlParser::TEMPTABLE:
      case MySqlParser::THAN:
      case MySqlParser::TRADITIONAL:
      case MySqlParser::TRANSACTION:
      case MySqlParser::TRANSACTIONAL:
      case MySqlParser::TRIGGERS:
      case MySqlParser::TRUNCATE:
      case MySqlParser::UNBOUNDED:
      case MySqlParser::UNDEFINED:
      case MySqlParser::UNDOFILE:
      case MySqlParser::UNDO_BUFFER_SIZE:
      case MySqlParser::UNINSTALL:
      case MySqlParser::UNKNOWN:
      case MySqlParser::UNTIL:
      case MySqlParser::UPGRADE:
      case MySqlParser::USER:
      case MySqlParser::USE_FRM:
      case MySqlParser::USER_RESOURCES:
      case MySqlParser::VALIDATION:
      case MySqlParser::VALUE:
      case MySqlParser::VARIABLES:
      case MySqlParser::VIEW:
      case MySqlParser::VIRTUAL:
      case MySqlParser::VISIBLE:
      case MySqlParser::WAIT:
      case MySqlParser::WARNINGS:
      case MySqlParser::WITHOUT:
      case MySqlParser::WORK:
      case MySqlParser::WRAPPER:
      case MySqlParser::X509:
      case MySqlParser::XA:
      case MySqlParser::XML:
      case MySqlParser::EUR:
      case MySqlParser::USA:
      case MySqlParser::JIS:
      case MySqlParser::ISO:
      case MySqlParser::INTERNAL:
      case MySqlParser::QUARTER:
      case MySqlParser::MONTH:
      case MySqlParser::DAY:
      case MySqlParser::HOUR:
      case MySqlParser::MINUTE:
      case MySqlParser::WEEK:
      case MySqlParser::SECOND:
      case MySqlParser::MICROSECOND:
      case MySqlParser::ADMIN:
      case MySqlParser::AUDIT_ABORT_EXEMPT:
      case MySqlParser::AUDIT_ADMIN:
      case MySqlParser::AUTHENTICATION_POLICY_ADMIN:
      case MySqlParser::BACKUP_ADMIN:
      case MySqlParser::BINLOG_ADMIN:
      case MySqlParser::BINLOG_ENCRYPTION_ADMIN:
      case MySqlParser::CLONE_ADMIN:
      case MySqlParser::CONNECTION_ADMIN:
      case MySqlParser::ENCRYPTION_KEY_ADMIN:
      case MySqlParser::EXECUTE:
      case MySqlParser::FILE:
      case MySqlParser::FIREWALL_ADMIN:
      case MySqlParser::FIREWALL_EXEMPT:
      case MySqlParser::FIREWALL_USER:
      case MySqlParser::GROUP_REPLICATION_ADMIN:
      case MySqlParser::INNODB_REDO_LOG_ARCHIVE:
      case MySqlParser::INVOKE:
      case MySqlParser::LAMBDA:
      case MySqlParser::NDB_STORED_USER:
      case MySqlParser::PASSWORDLESS_USER_ADMIN:
      case MySqlParser::PERSIST_RO_VARIABLES_ADMIN:
      case MySqlParser::PRIVILEGES:
      case MySqlParser::PROCESS:
      case MySqlParser::RELOAD:
      case MySqlParser::REPLICATION_APPLIER:
      case MySqlParser::REPLICATION_SLAVE_ADMIN:
      case MySqlParser::RESOURCE_GROUP_ADMIN:
      case MySqlParser::RESOURCE_GROUP_USER:
      case MySqlParser::ROLE_ADMIN:
      case MySqlParser::ROUTINE:
      case MySqlParser::S3:
      case MySqlParser::SESSION_VARIABLES_ADMIN:
      case MySqlParser::SET_USER_ID:
      case MySqlParser::SHOW_ROUTINE:
      case MySqlParser::SHUTDOWN:
      case MySqlParser::SUPER:
      case MySqlParser::SYSTEM_VARIABLES_ADMIN:
      case MySqlParser::TABLES:
      case MySqlParser::TABLE_ENCRYPTION_ADMIN:
      case MySqlParser::VERSION_TOKEN_ADMIN:
      case MySqlParser::XA_RECOVER_ADMIN:
      case MySqlParser::ARMSCII8:
      case MySqlParser::ASCII:
      case MySqlParser::BIG5:
      case MySqlParser::CP1250:
      case MySqlParser::CP1251:
      case MySqlParser::CP1256:
      case MySqlParser::CP1257:
      case MySqlParser::CP850:
      case MySqlParser::CP852:
      case MySqlParser::CP866:
      case MySqlParser::CP932:
      case MySqlParser::DEC8:
      case MySqlParser::EUCJPMS:
      case MySqlParser::EUCKR:
      case MySqlParser::GB18030:
      case MySqlParser::GB2312:
      case MySqlParser::GBK:
      case MySqlParser::GEOSTD8:
      case MySqlParser::GREEK:
      case MySqlParser::HEBREW:
      case MySqlParser::HP8:
      case MySqlParser::KEYBCS2:
      case MySqlParser::KOI8R:
      case MySqlParser::KOI8U:
      case MySqlParser::LATIN1:
      case MySqlParser::LATIN2:
      case MySqlParser::LATIN5:
      case MySqlParser::LATIN7:
      case MySqlParser::MACCE:
      case MySqlParser::MACROMAN:
      case MySqlParser::SJIS:
      case MySqlParser::SWE7:
      case MySqlParser::TIS620:
      case MySqlParser::UCS2:
      case MySqlParser::UJIS:
      case MySqlParser::UTF16:
      case MySqlParser::UTF16LE:
      case MySqlParser::UTF32:
      case MySqlParser::UTF8:
      case MySqlParser::UTF8MB3:
      case MySqlParser::UTF8MB4:
      case MySqlParser::ARCHIVE:
      case MySqlParser::BLACKHOLE:
      case MySqlParser::CSV:
      case MySqlParser::FEDERATED:
      case MySqlParser::INNODB:
      case MySqlParser::MEMORY:
      case MySqlParser::MRG_MYISAM:
      case MySqlParser::MYISAM:
      case MySqlParser::NDB:
      case MySqlParser::NDBCLUSTER:
      case MySqlParser::PERFORMANCE_SCHEMA:
      case MySqlParser::TOKUDB:
      case MySqlParser::REPEATABLE:
      case MySqlParser::COMMITTED:
      case MySqlParser::UNCOMMITTED:
      case MySqlParser::SERIALIZABLE:
      case MySqlParser::GEOMETRYCOLLECTION:
      case MySqlParser::LINESTRING:
      case MySqlParser::MULTILINESTRING:
      case MySqlParser::MULTIPOINT:
      case MySqlParser::MULTIPOLYGON:
      case MySqlParser::POINT:
      case MySqlParser::POLYGON:
      case MySqlParser::ABS:
      case MySqlParser::ACOS:
      case MySqlParser::ADDDATE:
      case MySqlParser::ADDTIME:
      case MySqlParser::AES_DECRYPT:
      case MySqlParser::AES_ENCRYPT:
      case MySqlParser::AREA:
      case MySqlParser::ASBINARY:
      case MySqlParser::ASIN:
      case MySqlParser::ASTEXT:
      case MySqlParser::ASWKB:
      case MySqlParser::ASWKT:
      case MySqlParser::ASYMMETRIC_DECRYPT:
      case MySqlParser::ASYMMETRIC_DERIVE:
      case MySqlParser::ASYMMETRIC_ENCRYPT:
      case MySqlParser::ASYMMETRIC_SIGN:
      case MySqlParser::ASYMMETRIC_VERIFY:
      case MySqlParser::ATAN:
      case MySqlParser::ATAN2:
      case MySqlParser::BENCHMARK:
      case MySqlParser::BIN:
      case MySqlParser::BIT_COUNT:
      case MySqlParser::BIT_LENGTH:
      case MySqlParser::BUFFER:
      case MySqlParser::CATALOG_NAME:
      case MySqlParser::CEIL:
      case MySqlParser::CEILING:
      case MySqlParser::CENTROID:
      case MySqlParser::CHARACTER_LENGTH:
      case MySqlParser::CHARSET:
      case MySqlParser::CHAR_LENGTH:
      case MySqlParser::COERCIBILITY:
      case MySqlParser::COLLATION:
      case MySqlParser::COMPRESS:
      case MySqlParser::CONCAT:
      case MySqlParser::CONCAT_WS:
      case MySqlParser::CONNECTION_ID:
      case MySqlParser::CONV:
      case MySqlParser::CONVERT_TZ:
      case MySqlParser::COS:
      case MySqlParser::COT:
      case MySqlParser::CRC32:
      case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
      case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
      case MySqlParser::CREATE_DH_PARAMETERS:
      case MySqlParser::CREATE_DIGEST:
      case MySqlParser::CROSSES:
      case MySqlParser::DATEDIFF:
      case MySqlParser::DATE_FORMAT:
      case MySqlParser::DAYNAME:
      case MySqlParser::DAYOFMONTH:
      case MySqlParser::DAYOFWEEK:
      case MySqlParser::DAYOFYEAR:
      case MySqlParser::DECODE:
      case MySqlParser::DEGREES:
      case MySqlParser::DES_DECRYPT:
      case MySqlParser::DES_ENCRYPT:
      case MySqlParser::DIMENSION:
      case MySqlParser::DISJOINT:
      case MySqlParser::ELT:
      case MySqlParser::ENCODE:
      case MySqlParser::ENCRYPT:
      case MySqlParser::ENDPOINT:
      case MySqlParser::ENGINE_ATTRIBUTE:
      case MySqlParser::ENVELOPE:
      case MySqlParser::EQUALS:
      case MySqlParser::EXP:
      case MySqlParser::EXPORT_SET:
      case MySqlParser::EXTERIORRING:
      case MySqlParser::EXTRACTVALUE:
      case MySqlParser::FIELD:
      case MySqlParser::FIND_IN_SET:
      case MySqlParser::FLOOR:
      case MySqlParser::FORMAT:
      case MySqlParser::FOUND_ROWS:
      case MySqlParser::FROM_BASE64:
      case MySqlParser::FROM_DAYS:
      case MySqlParser::FROM_UNIXTIME:
      case MySqlParser::GEOMCOLLFROMTEXT:
      case MySqlParser::GEOMCOLLFROMWKB:
      case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::GEOMETRYFROMTEXT:
      case MySqlParser::GEOMETRYFROMWKB:
      case MySqlParser::GEOMETRYN:
      case MySqlParser::GEOMETRYTYPE:
      case MySqlParser::GEOMFROMTEXT:
      case MySqlParser::GEOMFROMWKB:
      case MySqlParser::GET_FORMAT:
      case MySqlParser::GET_LOCK:
      case MySqlParser::GLENGTH:
      case MySqlParser::GREATEST:
      case MySqlParser::GTID_SUBSET:
      case MySqlParser::GTID_SUBTRACT:
      case MySqlParser::HEX:
      case MySqlParser::IFNULL:
      case MySqlParser::INET6_ATON:
      case MySqlParser::INET6_NTOA:
      case MySqlParser::INET_ATON:
      case MySqlParser::INET_NTOA:
      case MySqlParser::INSTR:
      case MySqlParser::INTERIORRINGN:
      case MySqlParser::INTERSECTS:
      case MySqlParser::ISCLOSED:
      case MySqlParser::ISEMPTY:
      case MySqlParser::ISNULL:
      case MySqlParser::ISSIMPLE:
      case MySqlParser::IS_FREE_LOCK:
      case MySqlParser::IS_IPV4:
      case MySqlParser::IS_IPV4_COMPAT:
      case MySqlParser::IS_IPV4_MAPPED:
      case MySqlParser::IS_IPV6:
      case MySqlParser::IS_USED_LOCK:
      case MySqlParser::LAST_INSERT_ID:
      case MySqlParser::LCASE:
      case MySqlParser::LEAST:
      case MySqlParser::LENGTH:
      case MySqlParser::LINEFROMTEXT:
      case MySqlParser::LINEFROMWKB:
      case MySqlParser::LINESTRINGFROMTEXT:
      case MySqlParser::LINESTRINGFROMWKB:
      case MySqlParser::LN:
      case MySqlParser::LOAD_FILE:
      case MySqlParser::LOCATE:
      case MySqlParser::LOG:
      case MySqlParser::LOG10:
      case MySqlParser::LOG2:
      case MySqlParser::LOWER:
      case MySqlParser::LPAD:
      case MySqlParser::LTRIM:
      case MySqlParser::MAKEDATE:
      case MySqlParser::MAKETIME:
      case MySqlParser::MAKE_SET:
      case MySqlParser::MASTER_POS_WAIT:
      case MySqlParser::MBRCONTAINS:
      case MySqlParser::MBRDISJOINT:
      case MySqlParser::MBREQUAL:
      case MySqlParser::MBRINTERSECTS:
      case MySqlParser::MBROVERLAPS:
      case MySqlParser::MBRTOUCHES:
      case MySqlParser::MBRWITHIN:
      case MySqlParser::MD5:
      case MySqlParser::MLINEFROMTEXT:
      case MySqlParser::MLINEFROMWKB:
      case MySqlParser::MONTHNAME:
      case MySqlParser::MPOINTFROMTEXT:
      case MySqlParser::MPOINTFROMWKB:
      case MySqlParser::MPOLYFROMTEXT:
      case MySqlParser::MPOLYFROMWKB:
      case MySqlParser::MULTILINESTRINGFROMTEXT:
      case MySqlParser::MULTILINESTRINGFROMWKB:
      case MySqlParser::MULTIPOINTFROMTEXT:
      case MySqlParser::MULTIPOINTFROMWKB:
      case MySqlParser::MULTIPOLYGONFROMTEXT:
      case MySqlParser::MULTIPOLYGONFROMWKB:
      case MySqlParser::NAME_CONST:
      case MySqlParser::NULLIF:
      case MySqlParser::NUMGEOMETRIES:
      case MySqlParser::NUMINTERIORRINGS:
      case MySqlParser::NUMPOINTS:
      case MySqlParser::OCT:
      case MySqlParser::OCTET_LENGTH:
      case MySqlParser::ORD:
      case MySqlParser::OVERLAPS:
      case MySqlParser::PERIOD_ADD:
      case MySqlParser::PERIOD_DIFF:
      case MySqlParser::PI:
      case MySqlParser::POINTFROMTEXT:
      case MySqlParser::POINTFROMWKB:
      case MySqlParser::POINTN:
      case MySqlParser::POLYFROMTEXT:
      case MySqlParser::POLYFROMWKB:
      case MySqlParser::POLYGONFROMTEXT:
      case MySqlParser::POLYGONFROMWKB:
      case MySqlParser::POW:
      case MySqlParser::POWER:
      case MySqlParser::QUOTE:
      case MySqlParser::RADIANS:
      case MySqlParser::RAND:
      case MySqlParser::RANDOM_BYTES:
      case MySqlParser::RELEASE_LOCK:
      case MySqlParser::REVERSE:
      case MySqlParser::ROUND:
      case MySqlParser::ROW_COUNT:
      case MySqlParser::RPAD:
      case MySqlParser::RTRIM:
      case MySqlParser::SEC_TO_TIME:
      case MySqlParser::SECONDARY_ENGINE_ATTRIBUTE:
      case MySqlParser::SESSION_USER:
      case MySqlParser::SHA:
      case MySqlParser::SHA1:
      case MySqlParser::SHA2:
      case MySqlParser::SCHEMA_NAME:
      case MySqlParser::SIGN:
      case MySqlParser::SIN:
      case MySqlParser::SLEEP:
      case MySqlParser::SOUNDEX:
      case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
      case MySqlParser::SQRT:
      case MySqlParser::SRID:
      case MySqlParser::STARTPOINT:
      case MySqlParser::STRCMP:
      case MySqlParser::STR_TO_DATE:
      case MySqlParser::ST_AREA:
      case MySqlParser::ST_ASBINARY:
      case MySqlParser::ST_ASTEXT:
      case MySqlParser::ST_ASWKB:
      case MySqlParser::ST_ASWKT:
      case MySqlParser::ST_BUFFER:
      case MySqlParser::ST_CENTROID:
      case MySqlParser::ST_CONTAINS:
      case MySqlParser::ST_CROSSES:
      case MySqlParser::ST_DIFFERENCE:
      case MySqlParser::ST_DIMENSION:
      case MySqlParser::ST_DISJOINT:
      case MySqlParser::ST_DISTANCE:
      case MySqlParser::ST_ENDPOINT:
      case MySqlParser::ST_ENVELOPE:
      case MySqlParser::ST_EQUALS:
      case MySqlParser::ST_EXTERIORRING:
      case MySqlParser::ST_GEOMCOLLFROMTEXT:
      case MySqlParser::ST_GEOMCOLLFROMTXT:
      case MySqlParser::ST_GEOMCOLLFROMWKB:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::ST_GEOMETRYFROMTEXT:
      case MySqlParser::ST_GEOMETRYFROMWKB:
      case MySqlParser::ST_GEOMETRYN:
      case MySqlParser::ST_GEOMETRYTYPE:
      case MySqlParser::ST_GEOMFROMTEXT:
      case MySqlParser::ST_GEOMFROMWKB:
      case MySqlParser::ST_INTERIORRINGN:
      case MySqlParser::ST_INTERSECTION:
      case MySqlParser::ST_INTERSECTS:
      case MySqlParser::ST_ISCLOSED:
      case MySqlParser::ST_ISEMPTY:
      case MySqlParser::ST_ISSIMPLE:
      case MySqlParser::ST_LINEFROMTEXT:
      case MySqlParser::ST_LINEFROMWKB:
      case MySqlParser::ST_LINESTRINGFROMTEXT:
      case MySqlParser::ST_LINESTRINGFROMWKB:
      case MySqlParser::ST_NUMGEOMETRIES:
      case MySqlParser::ST_NUMINTERIORRING:
      case MySqlParser::ST_NUMINTERIORRINGS:
      case MySqlParser::ST_NUMPOINTS:
      case MySqlParser::ST_OVERLAPS:
      case MySqlParser::ST_POINTFROMTEXT:
      case MySqlParser::ST_POINTFROMWKB:
      case MySqlParser::ST_POINTN:
      case MySqlParser::ST_POLYFROMTEXT:
      case MySqlParser::ST_POLYFROMWKB:
      case MySqlParser::ST_POLYGONFROMTEXT:
      case MySqlParser::ST_POLYGONFROMWKB:
      case MySqlParser::ST_SRID:
      case MySqlParser::ST_STARTPOINT:
      case MySqlParser::ST_SYMDIFFERENCE:
      case MySqlParser::ST_TOUCHES:
      case MySqlParser::ST_UNION:
      case MySqlParser::ST_WITHIN:
      case MySqlParser::ST_X:
      case MySqlParser::ST_Y:
      case MySqlParser::SUBDATE:
      case MySqlParser::SUBSTRING_INDEX:
      case MySqlParser::SUBTIME:
      case MySqlParser::SYSTEM_USER:
      case MySqlParser::TAN:
      case MySqlParser::TIMEDIFF:
      case MySqlParser::TIMESTAMPADD:
      case MySqlParser::TIMESTAMPDIFF:
      case MySqlParser::TIME_FORMAT:
      case MySqlParser::TIME_TO_SEC:
      case MySqlParser::TOUCHES:
      case MySqlParser::TO_BASE64:
      case MySqlParser::TO_DAYS:
      case MySqlParser::TO_SECONDS:
      case MySqlParser::TP_CONNECTION_ADMIN:
      case MySqlParser::UCASE:
      case MySqlParser::UNCOMPRESS:
      case MySqlParser::UNCOMPRESSED_LENGTH:
      case MySqlParser::UNHEX:
      case MySqlParser::UNIX_TIMESTAMP:
      case MySqlParser::UPDATEXML:
      case MySqlParser::UPPER:
      case MySqlParser::UUID:
      case MySqlParser::UUID_SHORT:
      case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
      case MySqlParser::VERSION:
      case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
      case MySqlParser::WEEKDAY:
      case MySqlParser::WEEKOFYEAR:
      case MySqlParser::WEIGHT_STRING:
      case MySqlParser::WITHIN:
      case MySqlParser::YEARWEEK:
      case MySqlParser::Y_FUNCTION:
      case MySqlParser::X_FUNCTION:
      case MySqlParser::MOD:
      case MySqlParser::CHARSET_REVERSE_QOUTE_STRING:
      case MySqlParser::STRING_LITERAL:
      case MySqlParser::ID: {
        setState(7058);
        windowName();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowSpecContext ------------------------------------------------------------------

MySqlParser::WindowSpecContext::WindowSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::WindowNameContext* MySqlParser::WindowSpecContext::windowName() {
  return getRuleContext<MySqlParser::WindowNameContext>(0);
}

MySqlParser::PartitionClauseContext* MySqlParser::WindowSpecContext::partitionClause() {
  return getRuleContext<MySqlParser::PartitionClauseContext>(0);
}

MySqlParser::OrderByClauseContext* MySqlParser::WindowSpecContext::orderByClause() {
  return getRuleContext<MySqlParser::OrderByClauseContext>(0);
}

MySqlParser::FrameClauseContext* MySqlParser::WindowSpecContext::frameClause() {
  return getRuleContext<MySqlParser::FrameClauseContext>(0);
}


size_t MySqlParser::WindowSpecContext::getRuleIndex() const {
  return MySqlParser::RuleWindowSpec;
}

void MySqlParser::WindowSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowSpec(this);
}

void MySqlParser::WindowSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowSpec(this);
}


std::any MySqlParser::WindowSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitWindowSpec(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::WindowSpecContext* MySqlParser::windowSpec() {
  WindowSpecContext *_localctx = _tracker.createInstance<WindowSpecContext>(_ctx, getState());
  enterRule(_localctx, 654, MySqlParser::RuleWindowSpec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7062);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1047, _ctx)) {
    case 1: {
      setState(7061);
      windowName();
      break;
    }

    default:
      break;
    }
    setState(7065);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::PARTITION) {
      setState(7064);
      partitionClause();
    }
    setState(7068);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::ORDER) {
      setState(7067);
      orderByClause();
    }
    setState(7071);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySqlParser::RANGE || _la == MySqlParser::ROWS) {
      setState(7070);
      frameClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowNameContext ------------------------------------------------------------------

MySqlParser::WindowNameContext::WindowNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::UidContext* MySqlParser::WindowNameContext::uid() {
  return getRuleContext<MySqlParser::UidContext>(0);
}


size_t MySqlParser::WindowNameContext::getRuleIndex() const {
  return MySqlParser::RuleWindowName;
}

void MySqlParser::WindowNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowName(this);
}

void MySqlParser::WindowNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowName(this);
}


std::any MySqlParser::WindowNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitWindowName(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::WindowNameContext* MySqlParser::windowName() {
  WindowNameContext *_localctx = _tracker.createInstance<WindowNameContext>(_ctx, getState());
  enterRule(_localctx, 656, MySqlParser::RuleWindowName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7073);
    uid();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FrameClauseContext ------------------------------------------------------------------

MySqlParser::FrameClauseContext::FrameClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::FrameUnitsContext* MySqlParser::FrameClauseContext::frameUnits() {
  return getRuleContext<MySqlParser::FrameUnitsContext>(0);
}

MySqlParser::FrameExtentContext* MySqlParser::FrameClauseContext::frameExtent() {
  return getRuleContext<MySqlParser::FrameExtentContext>(0);
}


size_t MySqlParser::FrameClauseContext::getRuleIndex() const {
  return MySqlParser::RuleFrameClause;
}

void MySqlParser::FrameClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrameClause(this);
}

void MySqlParser::FrameClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrameClause(this);
}


std::any MySqlParser::FrameClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFrameClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FrameClauseContext* MySqlParser::frameClause() {
  FrameClauseContext *_localctx = _tracker.createInstance<FrameClauseContext>(_ctx, getState());
  enterRule(_localctx, 658, MySqlParser::RuleFrameClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7075);
    frameUnits();
    setState(7076);
    frameExtent();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FrameUnitsContext ------------------------------------------------------------------

MySqlParser::FrameUnitsContext::FrameUnitsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::FrameUnitsContext::ROWS() {
  return getToken(MySqlParser::ROWS, 0);
}

tree::TerminalNode* MySqlParser::FrameUnitsContext::RANGE() {
  return getToken(MySqlParser::RANGE, 0);
}


size_t MySqlParser::FrameUnitsContext::getRuleIndex() const {
  return MySqlParser::RuleFrameUnits;
}

void MySqlParser::FrameUnitsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrameUnits(this);
}

void MySqlParser::FrameUnitsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrameUnits(this);
}


std::any MySqlParser::FrameUnitsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFrameUnits(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FrameUnitsContext* MySqlParser::frameUnits() {
  FrameUnitsContext *_localctx = _tracker.createInstance<FrameUnitsContext>(_ctx, getState());
  enterRule(_localctx, 660, MySqlParser::RuleFrameUnits);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7078);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::RANGE || _la == MySqlParser::ROWS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FrameExtentContext ------------------------------------------------------------------

MySqlParser::FrameExtentContext::FrameExtentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::FrameRangeContext* MySqlParser::FrameExtentContext::frameRange() {
  return getRuleContext<MySqlParser::FrameRangeContext>(0);
}

MySqlParser::FrameBetweenContext* MySqlParser::FrameExtentContext::frameBetween() {
  return getRuleContext<MySqlParser::FrameBetweenContext>(0);
}


size_t MySqlParser::FrameExtentContext::getRuleIndex() const {
  return MySqlParser::RuleFrameExtent;
}

void MySqlParser::FrameExtentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrameExtent(this);
}

void MySqlParser::FrameExtentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrameExtent(this);
}


std::any MySqlParser::FrameExtentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFrameExtent(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FrameExtentContext* MySqlParser::frameExtent() {
  FrameExtentContext *_localctx = _tracker.createInstance<FrameExtentContext>(_ctx, getState());
  enterRule(_localctx, 662, MySqlParser::RuleFrameExtent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7082);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1051, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7080);
      frameRange();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7081);
      frameBetween();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FrameBetweenContext ------------------------------------------------------------------

MySqlParser::FrameBetweenContext::FrameBetweenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::FrameBetweenContext::BETWEEN() {
  return getToken(MySqlParser::BETWEEN, 0);
}

std::vector<MySqlParser::FrameRangeContext *> MySqlParser::FrameBetweenContext::frameRange() {
  return getRuleContexts<MySqlParser::FrameRangeContext>();
}

MySqlParser::FrameRangeContext* MySqlParser::FrameBetweenContext::frameRange(size_t i) {
  return getRuleContext<MySqlParser::FrameRangeContext>(i);
}

tree::TerminalNode* MySqlParser::FrameBetweenContext::AND() {
  return getToken(MySqlParser::AND, 0);
}


size_t MySqlParser::FrameBetweenContext::getRuleIndex() const {
  return MySqlParser::RuleFrameBetween;
}

void MySqlParser::FrameBetweenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrameBetween(this);
}

void MySqlParser::FrameBetweenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrameBetween(this);
}


std::any MySqlParser::FrameBetweenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFrameBetween(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FrameBetweenContext* MySqlParser::frameBetween() {
  FrameBetweenContext *_localctx = _tracker.createInstance<FrameBetweenContext>(_ctx, getState());
  enterRule(_localctx, 664, MySqlParser::RuleFrameBetween);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7084);
    match(MySqlParser::BETWEEN);
    setState(7085);
    frameRange();
    setState(7086);
    match(MySqlParser::AND);
    setState(7087);
    frameRange();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FrameRangeContext ------------------------------------------------------------------

MySqlParser::FrameRangeContext::FrameRangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::FrameRangeContext::CURRENT() {
  return getToken(MySqlParser::CURRENT, 0);
}

tree::TerminalNode* MySqlParser::FrameRangeContext::ROW() {
  return getToken(MySqlParser::ROW, 0);
}

tree::TerminalNode* MySqlParser::FrameRangeContext::UNBOUNDED() {
  return getToken(MySqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* MySqlParser::FrameRangeContext::PRECEDING() {
  return getToken(MySqlParser::PRECEDING, 0);
}

tree::TerminalNode* MySqlParser::FrameRangeContext::FOLLOWING() {
  return getToken(MySqlParser::FOLLOWING, 0);
}

MySqlParser::ExpressionContext* MySqlParser::FrameRangeContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}


size_t MySqlParser::FrameRangeContext::getRuleIndex() const {
  return MySqlParser::RuleFrameRange;
}

void MySqlParser::FrameRangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrameRange(this);
}

void MySqlParser::FrameRangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrameRange(this);
}


std::any MySqlParser::FrameRangeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFrameRange(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FrameRangeContext* MySqlParser::frameRange() {
  FrameRangeContext *_localctx = _tracker.createInstance<FrameRangeContext>(_ctx, getState());
  enterRule(_localctx, 666, MySqlParser::RuleFrameRange);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7096);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1052, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7089);
      match(MySqlParser::CURRENT);
      setState(7090);
      match(MySqlParser::ROW);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7091);
      match(MySqlParser::UNBOUNDED);
      setState(7092);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::FOLLOWING || _la == MySqlParser::PRECEDING)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7093);
      expression(0);
      setState(7094);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::FOLLOWING || _la == MySqlParser::PRECEDING)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionClauseContext ------------------------------------------------------------------

MySqlParser::PartitionClauseContext::PartitionClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::PartitionClauseContext::PARTITION() {
  return getToken(MySqlParser::PARTITION, 0);
}

tree::TerminalNode* MySqlParser::PartitionClauseContext::BY() {
  return getToken(MySqlParser::BY, 0);
}

std::vector<MySqlParser::ExpressionContext *> MySqlParser::PartitionClauseContext::expression() {
  return getRuleContexts<MySqlParser::ExpressionContext>();
}

MySqlParser::ExpressionContext* MySqlParser::PartitionClauseContext::expression(size_t i) {
  return getRuleContext<MySqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::PartitionClauseContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::PartitionClauseContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::PartitionClauseContext::getRuleIndex() const {
  return MySqlParser::RulePartitionClause;
}

void MySqlParser::PartitionClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionClause(this);
}

void MySqlParser::PartitionClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionClause(this);
}


std::any MySqlParser::PartitionClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPartitionClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::PartitionClauseContext* MySqlParser::partitionClause() {
  PartitionClauseContext *_localctx = _tracker.createInstance<PartitionClauseContext>(_ctx, getState());
  enterRule(_localctx, 668, MySqlParser::RulePartitionClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7098);
    match(MySqlParser::PARTITION);
    setState(7099);
    match(MySqlParser::BY);
    setState(7100);
    expression(0);
    setState(7105);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(7101);
      match(MySqlParser::COMMA);
      setState(7102);
      expression(0);
      setState(7107);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScalarFunctionNameContext ------------------------------------------------------------------

MySqlParser::ScalarFunctionNameContext::ScalarFunctionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::FunctionNameBaseContext* MySqlParser::ScalarFunctionNameContext::functionNameBase() {
  return getRuleContext<MySqlParser::FunctionNameBaseContext>(0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::ASCII() {
  return getToken(MySqlParser::ASCII, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::CURDATE() {
  return getToken(MySqlParser::CURDATE, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::CURRENT_DATE() {
  return getToken(MySqlParser::CURRENT_DATE, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::CURRENT_TIME() {
  return getToken(MySqlParser::CURRENT_TIME, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::CURRENT_TIMESTAMP() {
  return getToken(MySqlParser::CURRENT_TIMESTAMP, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::CURTIME() {
  return getToken(MySqlParser::CURTIME, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::DATE_ADD() {
  return getToken(MySqlParser::DATE_ADD, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::DATE_SUB() {
  return getToken(MySqlParser::DATE_SUB, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::IF() {
  return getToken(MySqlParser::IF, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::INSERT() {
  return getToken(MySqlParser::INSERT, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::LOCALTIME() {
  return getToken(MySqlParser::LOCALTIME, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::LOCALTIMESTAMP() {
  return getToken(MySqlParser::LOCALTIMESTAMP, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::MID() {
  return getToken(MySqlParser::MID, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::NOW() {
  return getToken(MySqlParser::NOW, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::REPLACE() {
  return getToken(MySqlParser::REPLACE, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::SUBSTR() {
  return getToken(MySqlParser::SUBSTR, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::SUBSTRING() {
  return getToken(MySqlParser::SUBSTRING, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::SYSDATE() {
  return getToken(MySqlParser::SYSDATE, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::TRIM() {
  return getToken(MySqlParser::TRIM, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::UTC_DATE() {
  return getToken(MySqlParser::UTC_DATE, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::UTC_TIME() {
  return getToken(MySqlParser::UTC_TIME, 0);
}

tree::TerminalNode* MySqlParser::ScalarFunctionNameContext::UTC_TIMESTAMP() {
  return getToken(MySqlParser::UTC_TIMESTAMP, 0);
}


size_t MySqlParser::ScalarFunctionNameContext::getRuleIndex() const {
  return MySqlParser::RuleScalarFunctionName;
}

void MySqlParser::ScalarFunctionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScalarFunctionName(this);
}

void MySqlParser::ScalarFunctionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScalarFunctionName(this);
}


std::any MySqlParser::ScalarFunctionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitScalarFunctionName(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ScalarFunctionNameContext* MySqlParser::scalarFunctionName() {
  ScalarFunctionNameContext *_localctx = _tracker.createInstance<ScalarFunctionNameContext>(_ctx, getState());
  enterRule(_localctx, 670, MySqlParser::RuleScalarFunctionName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7131);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::DATABASE:
      case MySqlParser::LEFT:
      case MySqlParser::RIGHT:
      case MySqlParser::SCHEMA:
      case MySqlParser::DATE:
      case MySqlParser::TIME:
      case MySqlParser::TIMESTAMP:
      case MySqlParser::YEAR:
      case MySqlParser::JSON_ARRAY:
      case MySqlParser::JSON_ARRAYAGG:
      case MySqlParser::JSON_ARRAY_APPEND:
      case MySqlParser::JSON_ARRAY_INSERT:
      case MySqlParser::JSON_CONTAINS:
      case MySqlParser::JSON_CONTAINS_PATH:
      case MySqlParser::JSON_DEPTH:
      case MySqlParser::JSON_EXTRACT:
      case MySqlParser::JSON_INSERT:
      case MySqlParser::JSON_KEYS:
      case MySqlParser::JSON_LENGTH:
      case MySqlParser::JSON_MERGE:
      case MySqlParser::JSON_MERGE_PATCH:
      case MySqlParser::JSON_MERGE_PRESERVE:
      case MySqlParser::JSON_OBJECT:
      case MySqlParser::JSON_OBJECTAGG:
      case MySqlParser::JSON_OVERLAPS:
      case MySqlParser::JSON_PRETTY:
      case MySqlParser::JSON_QUOTE:
      case MySqlParser::JSON_REMOVE:
      case MySqlParser::JSON_REPLACE:
      case MySqlParser::JSON_SCHEMA_VALID:
      case MySqlParser::JSON_SCHEMA_VALIDATION_REPORT:
      case MySqlParser::JSON_SEARCH:
      case MySqlParser::JSON_SET:
      case MySqlParser::JSON_STORAGE_FREE:
      case MySqlParser::JSON_STORAGE_SIZE:
      case MySqlParser::JSON_TABLE:
      case MySqlParser::JSON_TYPE:
      case MySqlParser::JSON_UNQUOTE:
      case MySqlParser::JSON_VALID:
      case MySqlParser::JSON_VALUE:
      case MySqlParser::COUNT:
      case MySqlParser::CUME_DIST:
      case MySqlParser::DENSE_RANK:
      case MySqlParser::FIRST_VALUE:
      case MySqlParser::LAG:
      case MySqlParser::LAST_VALUE:
      case MySqlParser::LEAD:
      case MySqlParser::NTILE:
      case MySqlParser::NTH_VALUE:
      case MySqlParser::PERCENT_RANK:
      case MySqlParser::RANK:
      case MySqlParser::ROW_NUMBER:
      case MySqlParser::POSITION:
      case MySqlParser::INVISIBLE:
      case MySqlParser::VISIBLE:
      case MySqlParser::QUARTER:
      case MySqlParser::MONTH:
      case MySqlParser::DAY:
      case MySqlParser::HOUR:
      case MySqlParser::MINUTE:
      case MySqlParser::WEEK:
      case MySqlParser::SECOND:
      case MySqlParser::MICROSECOND:
      case MySqlParser::SESSION_VARIABLES_ADMIN:
      case MySqlParser::GEOMETRYCOLLECTION:
      case MySqlParser::LINESTRING:
      case MySqlParser::MULTILINESTRING:
      case MySqlParser::MULTIPOINT:
      case MySqlParser::MULTIPOLYGON:
      case MySqlParser::POINT:
      case MySqlParser::POLYGON:
      case MySqlParser::ABS:
      case MySqlParser::ACOS:
      case MySqlParser::ADDDATE:
      case MySqlParser::ADDTIME:
      case MySqlParser::AES_DECRYPT:
      case MySqlParser::AES_ENCRYPT:
      case MySqlParser::AREA:
      case MySqlParser::ASBINARY:
      case MySqlParser::ASIN:
      case MySqlParser::ASTEXT:
      case MySqlParser::ASWKB:
      case MySqlParser::ASWKT:
      case MySqlParser::ASYMMETRIC_DECRYPT:
      case MySqlParser::ASYMMETRIC_DERIVE:
      case MySqlParser::ASYMMETRIC_ENCRYPT:
      case MySqlParser::ASYMMETRIC_SIGN:
      case MySqlParser::ASYMMETRIC_VERIFY:
      case MySqlParser::ATAN:
      case MySqlParser::ATAN2:
      case MySqlParser::BENCHMARK:
      case MySqlParser::BIN:
      case MySqlParser::BIT_COUNT:
      case MySqlParser::BIT_LENGTH:
      case MySqlParser::BUFFER:
      case MySqlParser::CEIL:
      case MySqlParser::CEILING:
      case MySqlParser::CENTROID:
      case MySqlParser::CHARACTER_LENGTH:
      case MySqlParser::CHARSET:
      case MySqlParser::CHAR_LENGTH:
      case MySqlParser::COERCIBILITY:
      case MySqlParser::COLLATION:
      case MySqlParser::COMPRESS:
      case MySqlParser::CONCAT:
      case MySqlParser::CONCAT_WS:
      case MySqlParser::CONNECTION_ID:
      case MySqlParser::CONV:
      case MySqlParser::CONVERT_TZ:
      case MySqlParser::COS:
      case MySqlParser::COT:
      case MySqlParser::CRC32:
      case MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY:
      case MySqlParser::CREATE_ASYMMETRIC_PUB_KEY:
      case MySqlParser::CREATE_DH_PARAMETERS:
      case MySqlParser::CREATE_DIGEST:
      case MySqlParser::CROSSES:
      case MySqlParser::DATEDIFF:
      case MySqlParser::DATE_FORMAT:
      case MySqlParser::DAYNAME:
      case MySqlParser::DAYOFMONTH:
      case MySqlParser::DAYOFWEEK:
      case MySqlParser::DAYOFYEAR:
      case MySqlParser::DECODE:
      case MySqlParser::DEGREES:
      case MySqlParser::DES_DECRYPT:
      case MySqlParser::DES_ENCRYPT:
      case MySqlParser::DIMENSION:
      case MySqlParser::DISJOINT:
      case MySqlParser::ELT:
      case MySqlParser::ENCODE:
      case MySqlParser::ENCRYPT:
      case MySqlParser::ENDPOINT:
      case MySqlParser::ENVELOPE:
      case MySqlParser::EQUALS:
      case MySqlParser::EXP:
      case MySqlParser::EXPORT_SET:
      case MySqlParser::EXTERIORRING:
      case MySqlParser::EXTRACTVALUE:
      case MySqlParser::FIELD:
      case MySqlParser::FIND_IN_SET:
      case MySqlParser::FLOOR:
      case MySqlParser::FORMAT:
      case MySqlParser::FOUND_ROWS:
      case MySqlParser::FROM_BASE64:
      case MySqlParser::FROM_DAYS:
      case MySqlParser::FROM_UNIXTIME:
      case MySqlParser::GEOMCOLLFROMTEXT:
      case MySqlParser::GEOMCOLLFROMWKB:
      case MySqlParser::GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::GEOMETRYFROMTEXT:
      case MySqlParser::GEOMETRYFROMWKB:
      case MySqlParser::GEOMETRYN:
      case MySqlParser::GEOMETRYTYPE:
      case MySqlParser::GEOMFROMTEXT:
      case MySqlParser::GEOMFROMWKB:
      case MySqlParser::GET_FORMAT:
      case MySqlParser::GET_LOCK:
      case MySqlParser::GLENGTH:
      case MySqlParser::GREATEST:
      case MySqlParser::GTID_SUBSET:
      case MySqlParser::GTID_SUBTRACT:
      case MySqlParser::HEX:
      case MySqlParser::IFNULL:
      case MySqlParser::INET6_ATON:
      case MySqlParser::INET6_NTOA:
      case MySqlParser::INET_ATON:
      case MySqlParser::INET_NTOA:
      case MySqlParser::INSTR:
      case MySqlParser::INTERIORRINGN:
      case MySqlParser::INTERSECTS:
      case MySqlParser::ISCLOSED:
      case MySqlParser::ISEMPTY:
      case MySqlParser::ISNULL:
      case MySqlParser::ISSIMPLE:
      case MySqlParser::IS_FREE_LOCK:
      case MySqlParser::IS_IPV4:
      case MySqlParser::IS_IPV4_COMPAT:
      case MySqlParser::IS_IPV4_MAPPED:
      case MySqlParser::IS_IPV6:
      case MySqlParser::IS_USED_LOCK:
      case MySqlParser::LAST_INSERT_ID:
      case MySqlParser::LCASE:
      case MySqlParser::LEAST:
      case MySqlParser::LENGTH:
      case MySqlParser::LINEFROMTEXT:
      case MySqlParser::LINEFROMWKB:
      case MySqlParser::LINESTRINGFROMTEXT:
      case MySqlParser::LINESTRINGFROMWKB:
      case MySqlParser::LN:
      case MySqlParser::LOAD_FILE:
      case MySqlParser::LOCATE:
      case MySqlParser::LOG:
      case MySqlParser::LOG10:
      case MySqlParser::LOG2:
      case MySqlParser::LOWER:
      case MySqlParser::LPAD:
      case MySqlParser::LTRIM:
      case MySqlParser::MAKEDATE:
      case MySqlParser::MAKETIME:
      case MySqlParser::MAKE_SET:
      case MySqlParser::MASTER_POS_WAIT:
      case MySqlParser::MBRCONTAINS:
      case MySqlParser::MBRDISJOINT:
      case MySqlParser::MBREQUAL:
      case MySqlParser::MBRINTERSECTS:
      case MySqlParser::MBROVERLAPS:
      case MySqlParser::MBRTOUCHES:
      case MySqlParser::MBRWITHIN:
      case MySqlParser::MD5:
      case MySqlParser::MLINEFROMTEXT:
      case MySqlParser::MLINEFROMWKB:
      case MySqlParser::MONTHNAME:
      case MySqlParser::MPOINTFROMTEXT:
      case MySqlParser::MPOINTFROMWKB:
      case MySqlParser::MPOLYFROMTEXT:
      case MySqlParser::MPOLYFROMWKB:
      case MySqlParser::MULTILINESTRINGFROMTEXT:
      case MySqlParser::MULTILINESTRINGFROMWKB:
      case MySqlParser::MULTIPOINTFROMTEXT:
      case MySqlParser::MULTIPOINTFROMWKB:
      case MySqlParser::MULTIPOLYGONFROMTEXT:
      case MySqlParser::MULTIPOLYGONFROMWKB:
      case MySqlParser::NAME_CONST:
      case MySqlParser::NULLIF:
      case MySqlParser::NUMGEOMETRIES:
      case MySqlParser::NUMINTERIORRINGS:
      case MySqlParser::NUMPOINTS:
      case MySqlParser::OCT:
      case MySqlParser::OCTET_LENGTH:
      case MySqlParser::ORD:
      case MySqlParser::OVERLAPS:
      case MySqlParser::PERIOD_ADD:
      case MySqlParser::PERIOD_DIFF:
      case MySqlParser::PI:
      case MySqlParser::POINTFROMTEXT:
      case MySqlParser::POINTFROMWKB:
      case MySqlParser::POINTN:
      case MySqlParser::POLYFROMTEXT:
      case MySqlParser::POLYFROMWKB:
      case MySqlParser::POLYGONFROMTEXT:
      case MySqlParser::POLYGONFROMWKB:
      case MySqlParser::POW:
      case MySqlParser::POWER:
      case MySqlParser::QUOTE:
      case MySqlParser::RADIANS:
      case MySqlParser::RAND:
      case MySqlParser::RANDOM_BYTES:
      case MySqlParser::RELEASE_LOCK:
      case MySqlParser::REVERSE:
      case MySqlParser::ROUND:
      case MySqlParser::ROW_COUNT:
      case MySqlParser::RPAD:
      case MySqlParser::RTRIM:
      case MySqlParser::SEC_TO_TIME:
      case MySqlParser::SESSION_USER:
      case MySqlParser::SHA:
      case MySqlParser::SHA1:
      case MySqlParser::SHA2:
      case MySqlParser::SIGN:
      case MySqlParser::SIN:
      case MySqlParser::SLEEP:
      case MySqlParser::SOUNDEX:
      case MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS:
      case MySqlParser::SQRT:
      case MySqlParser::SRID:
      case MySqlParser::STARTPOINT:
      case MySqlParser::STRCMP:
      case MySqlParser::STR_TO_DATE:
      case MySqlParser::ST_AREA:
      case MySqlParser::ST_ASBINARY:
      case MySqlParser::ST_ASTEXT:
      case MySqlParser::ST_ASWKB:
      case MySqlParser::ST_ASWKT:
      case MySqlParser::ST_BUFFER:
      case MySqlParser::ST_CENTROID:
      case MySqlParser::ST_CONTAINS:
      case MySqlParser::ST_CROSSES:
      case MySqlParser::ST_DIFFERENCE:
      case MySqlParser::ST_DIMENSION:
      case MySqlParser::ST_DISJOINT:
      case MySqlParser::ST_DISTANCE:
      case MySqlParser::ST_ENDPOINT:
      case MySqlParser::ST_ENVELOPE:
      case MySqlParser::ST_EQUALS:
      case MySqlParser::ST_EXTERIORRING:
      case MySqlParser::ST_GEOMCOLLFROMTEXT:
      case MySqlParser::ST_GEOMCOLLFROMTXT:
      case MySqlParser::ST_GEOMCOLLFROMWKB:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT:
      case MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB:
      case MySqlParser::ST_GEOMETRYFROMTEXT:
      case MySqlParser::ST_GEOMETRYFROMWKB:
      case MySqlParser::ST_GEOMETRYN:
      case MySqlParser::ST_GEOMETRYTYPE:
      case MySqlParser::ST_GEOMFROMTEXT:
      case MySqlParser::ST_GEOMFROMWKB:
      case MySqlParser::ST_INTERIORRINGN:
      case MySqlParser::ST_INTERSECTION:
      case MySqlParser::ST_INTERSECTS:
      case MySqlParser::ST_ISCLOSED:
      case MySqlParser::ST_ISEMPTY:
      case MySqlParser::ST_ISSIMPLE:
      case MySqlParser::ST_LINEFROMTEXT:
      case MySqlParser::ST_LINEFROMWKB:
      case MySqlParser::ST_LINESTRINGFROMTEXT:
      case MySqlParser::ST_LINESTRINGFROMWKB:
      case MySqlParser::ST_NUMGEOMETRIES:
      case MySqlParser::ST_NUMINTERIORRING:
      case MySqlParser::ST_NUMINTERIORRINGS:
      case MySqlParser::ST_NUMPOINTS:
      case MySqlParser::ST_OVERLAPS:
      case MySqlParser::ST_POINTFROMTEXT:
      case MySqlParser::ST_POINTFROMWKB:
      case MySqlParser::ST_POINTN:
      case MySqlParser::ST_POLYFROMTEXT:
      case MySqlParser::ST_POLYFROMWKB:
      case MySqlParser::ST_POLYGONFROMTEXT:
      case MySqlParser::ST_POLYGONFROMWKB:
      case MySqlParser::ST_SRID:
      case MySqlParser::ST_STARTPOINT:
      case MySqlParser::ST_SYMDIFFERENCE:
      case MySqlParser::ST_TOUCHES:
      case MySqlParser::ST_UNION:
      case MySqlParser::ST_WITHIN:
      case MySqlParser::ST_X:
      case MySqlParser::ST_Y:
      case MySqlParser::SUBDATE:
      case MySqlParser::SUBSTRING_INDEX:
      case MySqlParser::SUBTIME:
      case MySqlParser::SYSTEM_USER:
      case MySqlParser::TAN:
      case MySqlParser::TIMEDIFF:
      case MySqlParser::TIMESTAMPADD:
      case MySqlParser::TIMESTAMPDIFF:
      case MySqlParser::TIME_FORMAT:
      case MySqlParser::TIME_TO_SEC:
      case MySqlParser::TOUCHES:
      case MySqlParser::TO_BASE64:
      case MySqlParser::TO_DAYS:
      case MySqlParser::TO_SECONDS:
      case MySqlParser::UCASE:
      case MySqlParser::UNCOMPRESS:
      case MySqlParser::UNCOMPRESSED_LENGTH:
      case MySqlParser::UNHEX:
      case MySqlParser::UNIX_TIMESTAMP:
      case MySqlParser::UPDATEXML:
      case MySqlParser::UPPER:
      case MySqlParser::UUID:
      case MySqlParser::UUID_SHORT:
      case MySqlParser::VALIDATE_PASSWORD_STRENGTH:
      case MySqlParser::VERSION:
      case MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:
      case MySqlParser::WEEKDAY:
      case MySqlParser::WEEKOFYEAR:
      case MySqlParser::WEIGHT_STRING:
      case MySqlParser::WITHIN:
      case MySqlParser::YEARWEEK:
      case MySqlParser::Y_FUNCTION:
      case MySqlParser::X_FUNCTION:
      case MySqlParser::MOD: {
        enterOuterAlt(_localctx, 1);
        setState(7108);
        functionNameBase();
        break;
      }

      case MySqlParser::ASCII: {
        enterOuterAlt(_localctx, 2);
        setState(7109);
        match(MySqlParser::ASCII);
        break;
      }

      case MySqlParser::CURDATE: {
        enterOuterAlt(_localctx, 3);
        setState(7110);
        match(MySqlParser::CURDATE);
        break;
      }

      case MySqlParser::CURRENT_DATE: {
        enterOuterAlt(_localctx, 4);
        setState(7111);
        match(MySqlParser::CURRENT_DATE);
        break;
      }

      case MySqlParser::CURRENT_TIME: {
        enterOuterAlt(_localctx, 5);
        setState(7112);
        match(MySqlParser::CURRENT_TIME);
        break;
      }

      case MySqlParser::CURRENT_TIMESTAMP: {
        enterOuterAlt(_localctx, 6);
        setState(7113);
        match(MySqlParser::CURRENT_TIMESTAMP);
        break;
      }

      case MySqlParser::CURTIME: {
        enterOuterAlt(_localctx, 7);
        setState(7114);
        match(MySqlParser::CURTIME);
        break;
      }

      case MySqlParser::DATE_ADD: {
        enterOuterAlt(_localctx, 8);
        setState(7115);
        match(MySqlParser::DATE_ADD);
        break;
      }

      case MySqlParser::DATE_SUB: {
        enterOuterAlt(_localctx, 9);
        setState(7116);
        match(MySqlParser::DATE_SUB);
        break;
      }

      case MySqlParser::IF: {
        enterOuterAlt(_localctx, 10);
        setState(7117);
        match(MySqlParser::IF);
        break;
      }

      case MySqlParser::INSERT: {
        enterOuterAlt(_localctx, 11);
        setState(7118);
        match(MySqlParser::INSERT);
        break;
      }

      case MySqlParser::LOCALTIME: {
        enterOuterAlt(_localctx, 12);
        setState(7119);
        match(MySqlParser::LOCALTIME);
        break;
      }

      case MySqlParser::LOCALTIMESTAMP: {
        enterOuterAlt(_localctx, 13);
        setState(7120);
        match(MySqlParser::LOCALTIMESTAMP);
        break;
      }

      case MySqlParser::MID: {
        enterOuterAlt(_localctx, 14);
        setState(7121);
        match(MySqlParser::MID);
        break;
      }

      case MySqlParser::NOW: {
        enterOuterAlt(_localctx, 15);
        setState(7122);
        match(MySqlParser::NOW);
        break;
      }

      case MySqlParser::REPLACE: {
        enterOuterAlt(_localctx, 16);
        setState(7123);
        match(MySqlParser::REPLACE);
        break;
      }

      case MySqlParser::SUBSTR: {
        enterOuterAlt(_localctx, 17);
        setState(7124);
        match(MySqlParser::SUBSTR);
        break;
      }

      case MySqlParser::SUBSTRING: {
        enterOuterAlt(_localctx, 18);
        setState(7125);
        match(MySqlParser::SUBSTRING);
        break;
      }

      case MySqlParser::SYSDATE: {
        enterOuterAlt(_localctx, 19);
        setState(7126);
        match(MySqlParser::SYSDATE);
        break;
      }

      case MySqlParser::TRIM: {
        enterOuterAlt(_localctx, 20);
        setState(7127);
        match(MySqlParser::TRIM);
        break;
      }

      case MySqlParser::UTC_DATE: {
        enterOuterAlt(_localctx, 21);
        setState(7128);
        match(MySqlParser::UTC_DATE);
        break;
      }

      case MySqlParser::UTC_TIME: {
        enterOuterAlt(_localctx, 22);
        setState(7129);
        match(MySqlParser::UTC_TIME);
        break;
      }

      case MySqlParser::UTC_TIMESTAMP: {
        enterOuterAlt(_localctx, 23);
        setState(7130);
        match(MySqlParser::UTC_TIMESTAMP);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PasswordFunctionClauseContext ------------------------------------------------------------------

MySqlParser::PasswordFunctionClauseContext::PasswordFunctionClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::PasswordFunctionClauseContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::FunctionArgContext* MySqlParser::PasswordFunctionClauseContext::functionArg() {
  return getRuleContext<MySqlParser::FunctionArgContext>(0);
}

tree::TerminalNode* MySqlParser::PasswordFunctionClauseContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::PasswordFunctionClauseContext::PASSWORD() {
  return getToken(MySqlParser::PASSWORD, 0);
}

tree::TerminalNode* MySqlParser::PasswordFunctionClauseContext::OLD_PASSWORD() {
  return getToken(MySqlParser::OLD_PASSWORD, 0);
}


size_t MySqlParser::PasswordFunctionClauseContext::getRuleIndex() const {
  return MySqlParser::RulePasswordFunctionClause;
}

void MySqlParser::PasswordFunctionClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPasswordFunctionClause(this);
}

void MySqlParser::PasswordFunctionClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPasswordFunctionClause(this);
}


std::any MySqlParser::PasswordFunctionClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPasswordFunctionClause(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::PasswordFunctionClauseContext* MySqlParser::passwordFunctionClause() {
  PasswordFunctionClauseContext *_localctx = _tracker.createInstance<PasswordFunctionClauseContext>(_ctx, getState());
  enterRule(_localctx, 672, MySqlParser::RulePasswordFunctionClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7133);
    antlrcpp::downCast<PasswordFunctionClauseContext *>(_localctx)->functionName = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::OLD_PASSWORD

    || _la == MySqlParser::PASSWORD)) {
      antlrcpp::downCast<PasswordFunctionClauseContext *>(_localctx)->functionName = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(7134);
    match(MySqlParser::LR_BRACKET);
    setState(7135);
    functionArg();
    setState(7136);
    match(MySqlParser::RR_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionArgsContext ------------------------------------------------------------------

MySqlParser::FunctionArgsContext::FunctionArgsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySqlParser::ConstantContext *> MySqlParser::FunctionArgsContext::constant() {
  return getRuleContexts<MySqlParser::ConstantContext>();
}

MySqlParser::ConstantContext* MySqlParser::FunctionArgsContext::constant(size_t i) {
  return getRuleContext<MySqlParser::ConstantContext>(i);
}

std::vector<MySqlParser::FullColumnNameContext *> MySqlParser::FunctionArgsContext::fullColumnName() {
  return getRuleContexts<MySqlParser::FullColumnNameContext>();
}

MySqlParser::FullColumnNameContext* MySqlParser::FunctionArgsContext::fullColumnName(size_t i) {
  return getRuleContext<MySqlParser::FullColumnNameContext>(i);
}

std::vector<MySqlParser::FunctionCallContext *> MySqlParser::FunctionArgsContext::functionCall() {
  return getRuleContexts<MySqlParser::FunctionCallContext>();
}

MySqlParser::FunctionCallContext* MySqlParser::FunctionArgsContext::functionCall(size_t i) {
  return getRuleContext<MySqlParser::FunctionCallContext>(i);
}

std::vector<MySqlParser::ExpressionContext *> MySqlParser::FunctionArgsContext::expression() {
  return getRuleContexts<MySqlParser::ExpressionContext>();
}

MySqlParser::ExpressionContext* MySqlParser::FunctionArgsContext::expression(size_t i) {
  return getRuleContext<MySqlParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MySqlParser::FunctionArgsContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::FunctionArgsContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}


size_t MySqlParser::FunctionArgsContext::getRuleIndex() const {
  return MySqlParser::RuleFunctionArgs;
}

void MySqlParser::FunctionArgsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionArgs(this);
}

void MySqlParser::FunctionArgsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionArgs(this);
}


std::any MySqlParser::FunctionArgsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFunctionArgs(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FunctionArgsContext* MySqlParser::functionArgs() {
  FunctionArgsContext *_localctx = _tracker.createInstance<FunctionArgsContext>(_ctx, getState());
  enterRule(_localctx, 674, MySqlParser::RuleFunctionArgs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7142);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1055, _ctx)) {
    case 1: {
      setState(7138);
      constant();
      break;
    }

    case 2: {
      setState(7139);
      fullColumnName();
      break;
    }

    case 3: {
      setState(7140);
      functionCall();
      break;
    }

    case 4: {
      setState(7141);
      expression(0);
      break;
    }

    default:
      break;
    }
    setState(7153);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySqlParser::COMMA) {
      setState(7144);
      match(MySqlParser::COMMA);
      setState(7149);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1056, _ctx)) {
      case 1: {
        setState(7145);
        constant();
        break;
      }

      case 2: {
        setState(7146);
        fullColumnName();
        break;
      }

      case 3: {
        setState(7147);
        functionCall();
        break;
      }

      case 4: {
        setState(7148);
        expression(0);
        break;
      }

      default:
        break;
      }
      setState(7155);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionArgContext ------------------------------------------------------------------

MySqlParser::FunctionArgContext::FunctionArgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySqlParser::ConstantContext* MySqlParser::FunctionArgContext::constant() {
  return getRuleContext<MySqlParser::ConstantContext>(0);
}

MySqlParser::FullColumnNameContext* MySqlParser::FunctionArgContext::fullColumnName() {
  return getRuleContext<MySqlParser::FullColumnNameContext>(0);
}

MySqlParser::FunctionCallContext* MySqlParser::FunctionArgContext::functionCall() {
  return getRuleContext<MySqlParser::FunctionCallContext>(0);
}

MySqlParser::ExpressionContext* MySqlParser::FunctionArgContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}


size_t MySqlParser::FunctionArgContext::getRuleIndex() const {
  return MySqlParser::RuleFunctionArg;
}

void MySqlParser::FunctionArgContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionArg(this);
}

void MySqlParser::FunctionArgContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionArg(this);
}


std::any MySqlParser::FunctionArgContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFunctionArg(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FunctionArgContext* MySqlParser::functionArg() {
  FunctionArgContext *_localctx = _tracker.createInstance<FunctionArgContext>(_ctx, getState());
  enterRule(_localctx, 676, MySqlParser::RuleFunctionArg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7160);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1058, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7156);
      constant();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7157);
      fullColumnName();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7158);
      functionCall();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7159);
      expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

MySqlParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::ExpressionContext::getRuleIndex() const {
  return MySqlParser::RuleExpression;
}

void MySqlParser::ExpressionContext::copyFrom(ExpressionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- IsExpressionContext ------------------------------------------------------------------

MySqlParser::PredicateContext* MySqlParser::IsExpressionContext::predicate() {
  return getRuleContext<MySqlParser::PredicateContext>(0);
}

tree::TerminalNode* MySqlParser::IsExpressionContext::IS() {
  return getToken(MySqlParser::IS, 0);
}

tree::TerminalNode* MySqlParser::IsExpressionContext::TRUE() {
  return getToken(MySqlParser::TRUE, 0);
}

tree::TerminalNode* MySqlParser::IsExpressionContext::FALSE() {
  return getToken(MySqlParser::FALSE, 0);
}

tree::TerminalNode* MySqlParser::IsExpressionContext::UNKNOWN() {
  return getToken(MySqlParser::UNKNOWN, 0);
}

tree::TerminalNode* MySqlParser::IsExpressionContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}

MySqlParser::IsExpressionContext::IsExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void MySqlParser::IsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIsExpression(this);
}
void MySqlParser::IsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIsExpression(this);
}

std::any MySqlParser::IsExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIsExpression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NotExpressionContext ------------------------------------------------------------------

MySqlParser::ExpressionContext* MySqlParser::NotExpressionContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

tree::TerminalNode* MySqlParser::NotExpressionContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}

tree::TerminalNode* MySqlParser::NotExpressionContext::EXCLAMATION_SYMBOL() {
  return getToken(MySqlParser::EXCLAMATION_SYMBOL, 0);
}

MySqlParser::NotExpressionContext::NotExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void MySqlParser::NotExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNotExpression(this);
}
void MySqlParser::NotExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNotExpression(this);
}

std::any MySqlParser::NotExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitNotExpression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LogicalExpressionContext ------------------------------------------------------------------

std::vector<MySqlParser::ExpressionContext *> MySqlParser::LogicalExpressionContext::expression() {
  return getRuleContexts<MySqlParser::ExpressionContext>();
}

MySqlParser::ExpressionContext* MySqlParser::LogicalExpressionContext::expression(size_t i) {
  return getRuleContext<MySqlParser::ExpressionContext>(i);
}

MySqlParser::LogicalOperatorContext* MySqlParser::LogicalExpressionContext::logicalOperator() {
  return getRuleContext<MySqlParser::LogicalOperatorContext>(0);
}

MySqlParser::LogicalExpressionContext::LogicalExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void MySqlParser::LogicalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalExpression(this);
}
void MySqlParser::LogicalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalExpression(this);
}

std::any MySqlParser::LogicalExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLogicalExpression(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PredicateExpressionContext ------------------------------------------------------------------

MySqlParser::PredicateContext* MySqlParser::PredicateExpressionContext::predicate() {
  return getRuleContext<MySqlParser::PredicateContext>(0);
}

MySqlParser::PredicateExpressionContext::PredicateExpressionContext(ExpressionContext *ctx) { copyFrom(ctx); }

void MySqlParser::PredicateExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicateExpression(this);
}
void MySqlParser::PredicateExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicateExpression(this);
}

std::any MySqlParser::PredicateExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPredicateExpression(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ExpressionContext* MySqlParser::expression() {
   return expression(0);
}

MySqlParser::ExpressionContext* MySqlParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySqlParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  MySqlParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 678;
  enterRecursionRule(_localctx, 678, MySqlParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7173);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1060, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<NotExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(7163);
      antlrcpp::downCast<NotExpressionContext *>(_localctx)->notOperator = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::NOT || _la == MySqlParser::EXCLAMATION_SYMBOL)) {
        antlrcpp::downCast<NotExpressionContext *>(_localctx)->notOperator = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7164);
      expression(4);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<IsExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(7165);
      predicate(0);
      setState(7166);
      match(MySqlParser::IS);
      setState(7168);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySqlParser::NOT) {
        setState(7167);
        match(MySqlParser::NOT);
      }
      setState(7170);
      antlrcpp::downCast<IsExpressionContext *>(_localctx)->testValue = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySqlParser::FALSE || _la == MySqlParser::TRUE || _la == MySqlParser::UNKNOWN)) {
        antlrcpp::downCast<IsExpressionContext *>(_localctx)->testValue = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<PredicateExpressionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(7172);
      predicate(0);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(7181);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1061, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<LogicalExpressionContext>(_tracker.createInstance<ExpressionContext>(parentContext, parentState));
        _localctx = newContext;
        pushNewRecursionContext(newContext, startState, RuleExpression);
        setState(7175);

        if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
        setState(7176);
        logicalOperator();
        setState(7177);
        expression(4); 
      }
      setState(7183);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1061, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

MySqlParser::PredicateContext::PredicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::PredicateContext::getRuleIndex() const {
  return MySqlParser::RulePredicate;
}

void MySqlParser::PredicateContext::copyFrom(PredicateContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SoundsLikePredicateContext ------------------------------------------------------------------

std::vector<MySqlParser::PredicateContext *> MySqlParser::SoundsLikePredicateContext::predicate() {
  return getRuleContexts<MySqlParser::PredicateContext>();
}

MySqlParser::PredicateContext* MySqlParser::SoundsLikePredicateContext::predicate(size_t i) {
  return getRuleContext<MySqlParser::PredicateContext>(i);
}

tree::TerminalNode* MySqlParser::SoundsLikePredicateContext::SOUNDS() {
  return getToken(MySqlParser::SOUNDS, 0);
}

tree::TerminalNode* MySqlParser::SoundsLikePredicateContext::LIKE() {
  return getToken(MySqlParser::LIKE, 0);
}

MySqlParser::SoundsLikePredicateContext::SoundsLikePredicateContext(PredicateContext *ctx) { copyFrom(ctx); }

void MySqlParser::SoundsLikePredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSoundsLikePredicate(this);
}
void MySqlParser::SoundsLikePredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSoundsLikePredicate(this);
}

std::any MySqlParser::SoundsLikePredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSoundsLikePredicate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ExpressionAtomPredicateContext ------------------------------------------------------------------

MySqlParser::ExpressionAtomContext* MySqlParser::ExpressionAtomPredicateContext::expressionAtom() {
  return getRuleContext<MySqlParser::ExpressionAtomContext>(0);
}

tree::TerminalNode* MySqlParser::ExpressionAtomPredicateContext::LOCAL_ID() {
  return getToken(MySqlParser::LOCAL_ID, 0);
}

tree::TerminalNode* MySqlParser::ExpressionAtomPredicateContext::VAR_ASSIGN() {
  return getToken(MySqlParser::VAR_ASSIGN, 0);
}

MySqlParser::ExpressionAtomPredicateContext::ExpressionAtomPredicateContext(PredicateContext *ctx) { copyFrom(ctx); }

void MySqlParser::ExpressionAtomPredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionAtomPredicate(this);
}
void MySqlParser::ExpressionAtomPredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionAtomPredicate(this);
}

std::any MySqlParser::ExpressionAtomPredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitExpressionAtomPredicate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SubqueryComparisonPredicateContext ------------------------------------------------------------------

MySqlParser::PredicateContext* MySqlParser::SubqueryComparisonPredicateContext::predicate() {
  return getRuleContext<MySqlParser::PredicateContext>(0);
}

MySqlParser::ComparisonOperatorContext* MySqlParser::SubqueryComparisonPredicateContext::comparisonOperator() {
  return getRuleContext<MySqlParser::ComparisonOperatorContext>(0);
}

tree::TerminalNode* MySqlParser::SubqueryComparisonPredicateContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::SelectStatementContext* MySqlParser::SubqueryComparisonPredicateContext::selectStatement() {
  return getRuleContext<MySqlParser::SelectStatementContext>(0);
}

tree::TerminalNode* MySqlParser::SubqueryComparisonPredicateContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::SubqueryComparisonPredicateContext::ALL() {
  return getToken(MySqlParser::ALL, 0);
}

tree::TerminalNode* MySqlParser::SubqueryComparisonPredicateContext::ANY() {
  return getToken(MySqlParser::ANY, 0);
}

tree::TerminalNode* MySqlParser::SubqueryComparisonPredicateContext::SOME() {
  return getToken(MySqlParser::SOME, 0);
}

MySqlParser::SubqueryComparisonPredicateContext::SubqueryComparisonPredicateContext(PredicateContext *ctx) { copyFrom(ctx); }

void MySqlParser::SubqueryComparisonPredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubqueryComparisonPredicate(this);
}
void MySqlParser::SubqueryComparisonPredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubqueryComparisonPredicate(this);
}

std::any MySqlParser::SubqueryComparisonPredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSubqueryComparisonPredicate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- JsonMemberOfPredicateContext ------------------------------------------------------------------

std::vector<MySqlParser::PredicateContext *> MySqlParser::JsonMemberOfPredicateContext::predicate() {
  return getRuleContexts<MySqlParser::PredicateContext>();
}

MySqlParser::PredicateContext* MySqlParser::JsonMemberOfPredicateContext::predicate(size_t i) {
  return getRuleContext<MySqlParser::PredicateContext>(i);
}

tree::TerminalNode* MySqlParser::JsonMemberOfPredicateContext::MEMBER() {
  return getToken(MySqlParser::MEMBER, 0);
}

tree::TerminalNode* MySqlParser::JsonMemberOfPredicateContext::OF() {
  return getToken(MySqlParser::OF, 0);
}

tree::TerminalNode* MySqlParser::JsonMemberOfPredicateContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::JsonMemberOfPredicateContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::JsonMemberOfPredicateContext::JsonMemberOfPredicateContext(PredicateContext *ctx) { copyFrom(ctx); }

void MySqlParser::JsonMemberOfPredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonMemberOfPredicate(this);
}
void MySqlParser::JsonMemberOfPredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonMemberOfPredicate(this);
}

std::any MySqlParser::JsonMemberOfPredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitJsonMemberOfPredicate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- BinaryComparisonPredicateContext ------------------------------------------------------------------

MySqlParser::ComparisonOperatorContext* MySqlParser::BinaryComparisonPredicateContext::comparisonOperator() {
  return getRuleContext<MySqlParser::ComparisonOperatorContext>(0);
}

std::vector<MySqlParser::PredicateContext *> MySqlParser::BinaryComparisonPredicateContext::predicate() {
  return getRuleContexts<MySqlParser::PredicateContext>();
}

MySqlParser::PredicateContext* MySqlParser::BinaryComparisonPredicateContext::predicate(size_t i) {
  return getRuleContext<MySqlParser::PredicateContext>(i);
}

MySqlParser::BinaryComparisonPredicateContext::BinaryComparisonPredicateContext(PredicateContext *ctx) { copyFrom(ctx); }

void MySqlParser::BinaryComparisonPredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryComparisonPredicate(this);
}
void MySqlParser::BinaryComparisonPredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryComparisonPredicate(this);
}

std::any MySqlParser::BinaryComparisonPredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitBinaryComparisonPredicate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- InPredicateContext ------------------------------------------------------------------

MySqlParser::PredicateContext* MySqlParser::InPredicateContext::predicate() {
  return getRuleContext<MySqlParser::PredicateContext>(0);
}

tree::TerminalNode* MySqlParser::InPredicateContext::IN() {
  return getToken(MySqlParser::IN, 0);
}

tree::TerminalNode* MySqlParser::InPredicateContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

tree::TerminalNode* MySqlParser::InPredicateContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::SelectStatementContext* MySqlParser::InPredicateContext::selectStatement() {
  return getRuleContext<MySqlParser::SelectStatementContext>(0);
}

MySqlParser::ExpressionsContext* MySqlParser::InPredicateContext::expressions() {
  return getRuleContext<MySqlParser::ExpressionsContext>(0);
}

tree::TerminalNode* MySqlParser::InPredicateContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}

MySqlParser::InPredicateContext::InPredicateContext(PredicateContext *ctx) { copyFrom(ctx); }

void MySqlParser::InPredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInPredicate(this);
}
void MySqlParser::InPredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInPredicate(this);
}

std::any MySqlParser::InPredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitInPredicate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- BetweenPredicateContext ------------------------------------------------------------------

std::vector<MySqlParser::PredicateContext *> MySqlParser::BetweenPredicateContext::predicate() {
  return getRuleContexts<MySqlParser::PredicateContext>();
}

MySqlParser::PredicateContext* MySqlParser::BetweenPredicateContext::predicate(size_t i) {
  return getRuleContext<MySqlParser::PredicateContext>(i);
}

tree::TerminalNode* MySqlParser::BetweenPredicateContext::BETWEEN() {
  return getToken(MySqlParser::BETWEEN, 0);
}

tree::TerminalNode* MySqlParser::BetweenPredicateContext::AND() {
  return getToken(MySqlParser::AND, 0);
}

tree::TerminalNode* MySqlParser::BetweenPredicateContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}

MySqlParser::BetweenPredicateContext::BetweenPredicateContext(PredicateContext *ctx) { copyFrom(ctx); }

void MySqlParser::BetweenPredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBetweenPredicate(this);
}
void MySqlParser::BetweenPredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBetweenPredicate(this);
}

std::any MySqlParser::BetweenPredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitBetweenPredicate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- IsNullPredicateContext ------------------------------------------------------------------

MySqlParser::PredicateContext* MySqlParser::IsNullPredicateContext::predicate() {
  return getRuleContext<MySqlParser::PredicateContext>(0);
}

tree::TerminalNode* MySqlParser::IsNullPredicateContext::IS() {
  return getToken(MySqlParser::IS, 0);
}

MySqlParser::NullNotnullContext* MySqlParser::IsNullPredicateContext::nullNotnull() {
  return getRuleContext<MySqlParser::NullNotnullContext>(0);
}

MySqlParser::IsNullPredicateContext::IsNullPredicateContext(PredicateContext *ctx) { copyFrom(ctx); }

void MySqlParser::IsNullPredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIsNullPredicate(this);
}
void MySqlParser::IsNullPredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIsNullPredicate(this);
}

std::any MySqlParser::IsNullPredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIsNullPredicate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LikePredicateContext ------------------------------------------------------------------

std::vector<MySqlParser::PredicateContext *> MySqlParser::LikePredicateContext::predicate() {
  return getRuleContexts<MySqlParser::PredicateContext>();
}

MySqlParser::PredicateContext* MySqlParser::LikePredicateContext::predicate(size_t i) {
  return getRuleContext<MySqlParser::PredicateContext>(i);
}

tree::TerminalNode* MySqlParser::LikePredicateContext::LIKE() {
  return getToken(MySqlParser::LIKE, 0);
}

tree::TerminalNode* MySqlParser::LikePredicateContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}

tree::TerminalNode* MySqlParser::LikePredicateContext::ESCAPE() {
  return getToken(MySqlParser::ESCAPE, 0);
}

tree::TerminalNode* MySqlParser::LikePredicateContext::STRING_LITERAL() {
  return getToken(MySqlParser::STRING_LITERAL, 0);
}

MySqlParser::LikePredicateContext::LikePredicateContext(PredicateContext *ctx) { copyFrom(ctx); }

void MySqlParser::LikePredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLikePredicate(this);
}
void MySqlParser::LikePredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLikePredicate(this);
}

std::any MySqlParser::LikePredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLikePredicate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RegexpPredicateContext ------------------------------------------------------------------

std::vector<MySqlParser::PredicateContext *> MySqlParser::RegexpPredicateContext::predicate() {
  return getRuleContexts<MySqlParser::PredicateContext>();
}

MySqlParser::PredicateContext* MySqlParser::RegexpPredicateContext::predicate(size_t i) {
  return getRuleContext<MySqlParser::PredicateContext>(i);
}

tree::TerminalNode* MySqlParser::RegexpPredicateContext::REGEXP() {
  return getToken(MySqlParser::REGEXP, 0);
}

tree::TerminalNode* MySqlParser::RegexpPredicateContext::RLIKE() {
  return getToken(MySqlParser::RLIKE, 0);
}

tree::TerminalNode* MySqlParser::RegexpPredicateContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}

MySqlParser::RegexpPredicateContext::RegexpPredicateContext(PredicateContext *ctx) { copyFrom(ctx); }

void MySqlParser::RegexpPredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRegexpPredicate(this);
}
void MySqlParser::RegexpPredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRegexpPredicate(this);
}

std::any MySqlParser::RegexpPredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitRegexpPredicate(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::PredicateContext* MySqlParser::predicate() {
   return predicate(0);
}

MySqlParser::PredicateContext* MySqlParser::predicate(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySqlParser::PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, parentState);
  MySqlParser::PredicateContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 680;
  enterRecursionRule(_localctx, 680, MySqlParser::RulePredicate, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    _localctx = _tracker.createInstance<ExpressionAtomPredicateContext>(_localctx);
    _ctx = _localctx;
    previousContext = _localctx;

    setState(7187);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1062, _ctx)) {
    case 1: {
      setState(7185);
      match(MySqlParser::LOCAL_ID);
      setState(7186);
      match(MySqlParser::VAR_ASSIGN);
      break;
    }

    default:
      break;
    }
    setState(7189);
    expressionAtom(0);
    _ctx->stop = _input->LT(-1);
    setState(7255);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1070, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(7253);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1069, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<BinaryComparisonPredicateContext>(_tracker.createInstance<PredicateContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RulePredicate);
          setState(7191);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(7192);
          comparisonOperator();
          setState(7193);
          antlrcpp::downCast<BinaryComparisonPredicateContext *>(_localctx)->right = predicate(9);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<BetweenPredicateContext>(_tracker.createInstance<PredicateContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RulePredicate);
          setState(7195);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(7197);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::NOT) {
            setState(7196);
            match(MySqlParser::NOT);
          }
          setState(7199);
          match(MySqlParser::BETWEEN);
          setState(7200);
          predicate(0);
          setState(7201);
          match(MySqlParser::AND);
          setState(7202);
          predicate(7);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<SoundsLikePredicateContext>(_tracker.createInstance<PredicateContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RulePredicate);
          setState(7204);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(7205);
          match(MySqlParser::SOUNDS);
          setState(7206);
          match(MySqlParser::LIKE);
          setState(7207);
          predicate(6);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<RegexpPredicateContext>(_tracker.createInstance<PredicateContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RulePredicate);
          setState(7208);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(7210);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::NOT) {
            setState(7209);
            match(MySqlParser::NOT);
          }
          setState(7212);
          antlrcpp::downCast<RegexpPredicateContext *>(_localctx)->regex = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::REGEXP

          || _la == MySqlParser::RLIKE)) {
            antlrcpp::downCast<RegexpPredicateContext *>(_localctx)->regex = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(7213);
          predicate(4);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<InPredicateContext>(_tracker.createInstance<PredicateContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RulePredicate);
          setState(7214);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(7216);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::NOT) {
            setState(7215);
            match(MySqlParser::NOT);
          }
          setState(7218);
          match(MySqlParser::IN);
          setState(7219);
          match(MySqlParser::LR_BRACKET);
          setState(7222);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1066, _ctx)) {
          case 1: {
            setState(7220);
            selectStatement();
            break;
          }

          case 2: {
            setState(7221);
            expressions();
            break;
          }

          default:
            break;
          }
          setState(7224);
          match(MySqlParser::RR_BRACKET);
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<IsNullPredicateContext>(_tracker.createInstance<PredicateContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RulePredicate);
          setState(7226);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(7227);
          match(MySqlParser::IS);
          setState(7228);
          nullNotnull();
          break;
        }

        case 7: {
          auto newContext = _tracker.createInstance<SubqueryComparisonPredicateContext>(_tracker.createInstance<PredicateContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RulePredicate);
          setState(7229);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(7230);
          comparisonOperator();
          setState(7231);
          antlrcpp::downCast<SubqueryComparisonPredicateContext *>(_localctx)->quantifier = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySqlParser::ALL || _la == MySqlParser::ANY || _la == MySqlParser::SOME)) {
            antlrcpp::downCast<SubqueryComparisonPredicateContext *>(_localctx)->quantifier = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(7232);
          match(MySqlParser::LR_BRACKET);
          setState(7233);
          selectStatement();
          setState(7234);
          match(MySqlParser::RR_BRACKET);
          break;
        }

        case 8: {
          auto newContext = _tracker.createInstance<LikePredicateContext>(_tracker.createInstance<PredicateContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RulePredicate);
          setState(7236);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(7238);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySqlParser::NOT) {
            setState(7237);
            match(MySqlParser::NOT);
          }
          setState(7240);
          match(MySqlParser::LIKE);
          setState(7241);
          predicate(0);
          setState(7244);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1068, _ctx)) {
          case 1: {
            setState(7242);
            match(MySqlParser::ESCAPE);
            setState(7243);
            match(MySqlParser::STRING_LITERAL);
            break;
          }

          default:
            break;
          }
          break;
        }

        case 9: {
          auto newContext = _tracker.createInstance<JsonMemberOfPredicateContext>(_tracker.createInstance<PredicateContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RulePredicate);
          setState(7246);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(7247);
          match(MySqlParser::MEMBER);
          setState(7248);
          match(MySqlParser::OF);
          setState(7249);
          match(MySqlParser::LR_BRACKET);
          setState(7250);
          predicate(0);
          setState(7251);
          match(MySqlParser::RR_BRACKET);
          break;
        }

        default:
          break;
        } 
      }
      setState(7257);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1070, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ExpressionAtomContext ------------------------------------------------------------------

MySqlParser::ExpressionAtomContext::ExpressionAtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySqlParser::ExpressionAtomContext::getRuleIndex() const {
  return MySqlParser::RuleExpressionAtom;
}

void MySqlParser::ExpressionAtomContext::copyFrom(ExpressionAtomContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- UnaryExpressionAtomContext ------------------------------------------------------------------

MySqlParser::UnaryOperatorContext* MySqlParser::UnaryExpressionAtomContext::unaryOperator() {
  return getRuleContext<MySqlParser::UnaryOperatorContext>(0);
}

MySqlParser::ExpressionAtomContext* MySqlParser::UnaryExpressionAtomContext::expressionAtom() {
  return getRuleContext<MySqlParser::ExpressionAtomContext>(0);
}

MySqlParser::UnaryExpressionAtomContext::UnaryExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::UnaryExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryExpressionAtom(this);
}
void MySqlParser::UnaryExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryExpressionAtom(this);
}

std::any MySqlParser::UnaryExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUnaryExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CollateExpressionAtomContext ------------------------------------------------------------------

MySqlParser::ExpressionAtomContext* MySqlParser::CollateExpressionAtomContext::expressionAtom() {
  return getRuleContext<MySqlParser::ExpressionAtomContext>(0);
}

tree::TerminalNode* MySqlParser::CollateExpressionAtomContext::COLLATE() {
  return getToken(MySqlParser::COLLATE, 0);
}

MySqlParser::CollationNameContext* MySqlParser::CollateExpressionAtomContext::collationName() {
  return getRuleContext<MySqlParser::CollationNameContext>(0);
}

MySqlParser::CollateExpressionAtomContext::CollateExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::CollateExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollateExpressionAtom(this);
}
void MySqlParser::CollateExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollateExpressionAtom(this);
}

std::any MySqlParser::CollateExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCollateExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- MysqlVariableExpressionAtomContext ------------------------------------------------------------------

MySqlParser::MysqlVariableContext* MySqlParser::MysqlVariableExpressionAtomContext::mysqlVariable() {
  return getRuleContext<MySqlParser::MysqlVariableContext>(0);
}

MySqlParser::MysqlVariableExpressionAtomContext::MysqlVariableExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::MysqlVariableExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMysqlVariableExpressionAtom(this);
}
void MySqlParser::MysqlVariableExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMysqlVariableExpressionAtom(this);
}

std::any MySqlParser::MysqlVariableExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitMysqlVariableExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NestedExpressionAtomContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::NestedExpressionAtomContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::ExpressionContext *> MySqlParser::NestedExpressionAtomContext::expression() {
  return getRuleContexts<MySqlParser::ExpressionContext>();
}

MySqlParser::ExpressionContext* MySqlParser::NestedExpressionAtomContext::expression(size_t i) {
  return getRuleContext<MySqlParser::ExpressionContext>(i);
}

tree::TerminalNode* MySqlParser::NestedExpressionAtomContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::NestedExpressionAtomContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::NestedExpressionAtomContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::NestedExpressionAtomContext::NestedExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::NestedExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNestedExpressionAtom(this);
}
void MySqlParser::NestedExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNestedExpressionAtom(this);
}

std::any MySqlParser::NestedExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitNestedExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NestedRowExpressionAtomContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::NestedRowExpressionAtomContext::ROW() {
  return getToken(MySqlParser::ROW, 0);
}

tree::TerminalNode* MySqlParser::NestedRowExpressionAtomContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

std::vector<MySqlParser::ExpressionContext *> MySqlParser::NestedRowExpressionAtomContext::expression() {
  return getRuleContexts<MySqlParser::ExpressionContext>();
}

MySqlParser::ExpressionContext* MySqlParser::NestedRowExpressionAtomContext::expression(size_t i) {
  return getRuleContext<MySqlParser::ExpressionContext>(i);
}

tree::TerminalNode* MySqlParser::NestedRowExpressionAtomContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::NestedRowExpressionAtomContext::COMMA() {
  return getTokens(MySqlParser::COMMA);
}

tree::TerminalNode* MySqlParser::NestedRowExpressionAtomContext::COMMA(size_t i) {
  return getToken(MySqlParser::COMMA, i);
}

MySqlParser::NestedRowExpressionAtomContext::NestedRowExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::NestedRowExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNestedRowExpressionAtom(this);
}
void MySqlParser::NestedRowExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNestedRowExpressionAtom(this);
}

std::any MySqlParser::NestedRowExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitNestedRowExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- MathExpressionAtomContext ------------------------------------------------------------------

MySqlParser::MathOperatorContext* MySqlParser::MathExpressionAtomContext::mathOperator() {
  return getRuleContext<MySqlParser::MathOperatorContext>(0);
}

std::vector<MySqlParser::ExpressionAtomContext *> MySqlParser::MathExpressionAtomContext::expressionAtom() {
  return getRuleContexts<MySqlParser::ExpressionAtomContext>();
}

MySqlParser::ExpressionAtomContext* MySqlParser::MathExpressionAtomContext::expressionAtom(size_t i) {
  return getRuleContext<MySqlParser::ExpressionAtomContext>(i);
}

MySqlParser::MathExpressionAtomContext::MathExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::MathExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMathExpressionAtom(this);
}
void MySqlParser::MathExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMathExpressionAtom(this);
}

std::any MySqlParser::MathExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitMathExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ExistsExpressionAtomContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::ExistsExpressionAtomContext::EXISTS() {
  return getToken(MySqlParser::EXISTS, 0);
}

tree::TerminalNode* MySqlParser::ExistsExpressionAtomContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::SelectStatementContext* MySqlParser::ExistsExpressionAtomContext::selectStatement() {
  return getRuleContext<MySqlParser::SelectStatementContext>(0);
}

tree::TerminalNode* MySqlParser::ExistsExpressionAtomContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::ExistsExpressionAtomContext::ExistsExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::ExistsExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExistsExpressionAtom(this);
}
void MySqlParser::ExistsExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExistsExpressionAtom(this);
}

std::any MySqlParser::ExistsExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitExistsExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- IntervalExpressionAtomContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::IntervalExpressionAtomContext::INTERVAL() {
  return getToken(MySqlParser::INTERVAL, 0);
}

MySqlParser::ExpressionContext* MySqlParser::IntervalExpressionAtomContext::expression() {
  return getRuleContext<MySqlParser::ExpressionContext>(0);
}

MySqlParser::IntervalTypeContext* MySqlParser::IntervalExpressionAtomContext::intervalType() {
  return getRuleContext<MySqlParser::IntervalTypeContext>(0);
}

MySqlParser::IntervalExpressionAtomContext::IntervalExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::IntervalExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalExpressionAtom(this);
}
void MySqlParser::IntervalExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalExpressionAtom(this);
}

std::any MySqlParser::IntervalExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIntervalExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- JsonExpressionAtomContext ------------------------------------------------------------------

MySqlParser::JsonOperatorContext* MySqlParser::JsonExpressionAtomContext::jsonOperator() {
  return getRuleContext<MySqlParser::JsonOperatorContext>(0);
}

std::vector<MySqlParser::ExpressionAtomContext *> MySqlParser::JsonExpressionAtomContext::expressionAtom() {
  return getRuleContexts<MySqlParser::ExpressionAtomContext>();
}

MySqlParser::ExpressionAtomContext* MySqlParser::JsonExpressionAtomContext::expressionAtom(size_t i) {
  return getRuleContext<MySqlParser::ExpressionAtomContext>(i);
}

MySqlParser::JsonExpressionAtomContext::JsonExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::JsonExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonExpressionAtom(this);
}
void MySqlParser::JsonExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonExpressionAtom(this);
}

std::any MySqlParser::JsonExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitJsonExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SubqueryExpressionAtomContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::SubqueryExpressionAtomContext::LR_BRACKET() {
  return getToken(MySqlParser::LR_BRACKET, 0);
}

MySqlParser::SelectStatementContext* MySqlParser::SubqueryExpressionAtomContext::selectStatement() {
  return getRuleContext<MySqlParser::SelectStatementContext>(0);
}

tree::TerminalNode* MySqlParser::SubqueryExpressionAtomContext::RR_BRACKET() {
  return getToken(MySqlParser::RR_BRACKET, 0);
}

MySqlParser::SubqueryExpressionAtomContext::SubqueryExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::SubqueryExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubqueryExpressionAtom(this);
}
void MySqlParser::SubqueryExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubqueryExpressionAtom(this);
}

std::any MySqlParser::SubqueryExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitSubqueryExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ConstantExpressionAtomContext ------------------------------------------------------------------

MySqlParser::ConstantContext* MySqlParser::ConstantExpressionAtomContext::constant() {
  return getRuleContext<MySqlParser::ConstantContext>(0);
}

MySqlParser::ConstantExpressionAtomContext::ConstantExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::ConstantExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstantExpressionAtom(this);
}
void MySqlParser::ConstantExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstantExpressionAtom(this);
}

std::any MySqlParser::ConstantExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitConstantExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- FunctionCallExpressionAtomContext ------------------------------------------------------------------

MySqlParser::FunctionCallContext* MySqlParser::FunctionCallExpressionAtomContext::functionCall() {
  return getRuleContext<MySqlParser::FunctionCallContext>(0);
}

MySqlParser::FunctionCallExpressionAtomContext::FunctionCallExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::FunctionCallExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCallExpressionAtom(this);
}
void MySqlParser::FunctionCallExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCallExpressionAtom(this);
}

std::any MySqlParser::FunctionCallExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFunctionCallExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- BinaryExpressionAtomContext ------------------------------------------------------------------

tree::TerminalNode* MySqlParser::BinaryExpressionAtomContext::BINARY() {
  return getToken(MySqlParser::BINARY, 0);
}

MySqlParser::ExpressionAtomContext* MySqlParser::BinaryExpressionAtomContext::expressionAtom() {
  return getRuleContext<MySqlParser::ExpressionAtomContext>(0);
}

MySqlParser::BinaryExpressionAtomContext::BinaryExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::BinaryExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryExpressionAtom(this);
}
void MySqlParser::BinaryExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryExpressionAtom(this);
}

std::any MySqlParser::BinaryExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitBinaryExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- FullColumnNameExpressionAtomContext ------------------------------------------------------------------

MySqlParser::FullColumnNameContext* MySqlParser::FullColumnNameExpressionAtomContext::fullColumnName() {
  return getRuleContext<MySqlParser::FullColumnNameContext>(0);
}

MySqlParser::FullColumnNameExpressionAtomContext::FullColumnNameExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::FullColumnNameExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFullColumnNameExpressionAtom(this);
}
void MySqlParser::FullColumnNameExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFullColumnNameExpressionAtom(this);
}

std::any MySqlParser::FullColumnNameExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFullColumnNameExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- BitExpressionAtomContext ------------------------------------------------------------------

MySqlParser::BitOperatorContext* MySqlParser::BitExpressionAtomContext::bitOperator() {
  return getRuleContext<MySqlParser::BitOperatorContext>(0);
}

std::vector<MySqlParser::ExpressionAtomContext *> MySqlParser::BitExpressionAtomContext::expressionAtom() {
  return getRuleContexts<MySqlParser::ExpressionAtomContext>();
}

MySqlParser::ExpressionAtomContext* MySqlParser::BitExpressionAtomContext::expressionAtom(size_t i) {
  return getRuleContext<MySqlParser::ExpressionAtomContext>(i);
}

MySqlParser::BitExpressionAtomContext::BitExpressionAtomContext(ExpressionAtomContext *ctx) { copyFrom(ctx); }

void MySqlParser::BitExpressionAtomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitExpressionAtom(this);
}
void MySqlParser::BitExpressionAtomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitExpressionAtom(this);
}

std::any MySqlParser::BitExpressionAtomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitBitExpressionAtom(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ExpressionAtomContext* MySqlParser::expressionAtom() {
   return expressionAtom(0);
}

MySqlParser::ExpressionAtomContext* MySqlParser::expressionAtom(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySqlParser::ExpressionAtomContext *_localctx = _tracker.createInstance<ExpressionAtomContext>(_ctx, parentState);
  MySqlParser::ExpressionAtomContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 682;
  enterRecursionRule(_localctx, 682, MySqlParser::RuleExpressionAtom, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7303);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1073, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<ConstantExpressionAtomContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(7259);
      constant();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<FullColumnNameExpressionAtomContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(7260);
      fullColumnName();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<FunctionCallExpressionAtomContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(7261);
      functionCall();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<MysqlVariableExpressionAtomContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(7262);
      mysqlVariable();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<UnaryExpressionAtomContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(7263);
      unaryOperator();
      setState(7264);
      expressionAtom(10);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<BinaryExpressionAtomContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(7266);
      match(MySqlParser::BINARY);
      setState(7267);
      expressionAtom(9);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<NestedExpressionAtomContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(7268);
      match(MySqlParser::LR_BRACKET);
      setState(7269);
      expression(0);
      setState(7274);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySqlParser::COMMA) {
        setState(7270);
        match(MySqlParser::COMMA);
        setState(7271);
        expression(0);
        setState(7276);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(7277);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<NestedRowExpressionAtomContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(7279);
      match(MySqlParser::ROW);
      setState(7280);
      match(MySqlParser::LR_BRACKET);
      setState(7281);
      expression(0);
      setState(7284); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(7282);
        match(MySqlParser::COMMA);
        setState(7283);
        expression(0);
        setState(7286); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MySqlParser::COMMA);
      setState(7288);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<ExistsExpressionAtomContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(7290);
      match(MySqlParser::EXISTS);
      setState(7291);
      match(MySqlParser::LR_BRACKET);
      setState(7292);
      selectStatement();
      setState(7293);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<SubqueryExpressionAtomContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(7295);
      match(MySqlParser::LR_BRACKET);
      setState(7296);
      selectStatement();
      setState(7297);
      match(MySqlParser::RR_BRACKET);
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<IntervalExpressionAtomContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(7299);
      match(MySqlParser::INTERVAL);
      setState(7300);
      expression(0);
      setState(7301);
      intervalType();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(7322);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1075, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(7320);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1074, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<BitExpressionAtomContext>(_tracker.createInstance<ExpressionAtomContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpressionAtom);
          setState(7305);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(7306);
          bitOperator();
          setState(7307);
          antlrcpp::downCast<BitExpressionAtomContext *>(_localctx)->right = expressionAtom(4);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<MathExpressionAtomContext>(_tracker.createInstance<ExpressionAtomContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpressionAtom);
          setState(7309);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(7310);
          mathOperator();
          setState(7311);
          antlrcpp::downCast<MathExpressionAtomContext *>(_localctx)->right = expressionAtom(3);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<JsonExpressionAtomContext>(_tracker.createInstance<ExpressionAtomContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpressionAtom);
          setState(7313);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(7314);
          jsonOperator();
          setState(7315);
          antlrcpp::downCast<JsonExpressionAtomContext *>(_localctx)->right = expressionAtom(2);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<CollateExpressionAtomContext>(_tracker.createInstance<ExpressionAtomContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpressionAtom);
          setState(7317);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(7318);
          match(MySqlParser::COLLATE);
          setState(7319);
          collationName();
          break;
        }

        default:
          break;
        } 
      }
      setState(7324);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1075, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- UnaryOperatorContext ------------------------------------------------------------------

MySqlParser::UnaryOperatorContext::UnaryOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::UnaryOperatorContext::EXCLAMATION_SYMBOL() {
  return getToken(MySqlParser::EXCLAMATION_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::UnaryOperatorContext::BIT_NOT_OP() {
  return getToken(MySqlParser::BIT_NOT_OP, 0);
}

tree::TerminalNode* MySqlParser::UnaryOperatorContext::PLUS() {
  return getToken(MySqlParser::PLUS, 0);
}

tree::TerminalNode* MySqlParser::UnaryOperatorContext::MINUS() {
  return getToken(MySqlParser::MINUS, 0);
}

tree::TerminalNode* MySqlParser::UnaryOperatorContext::NOT() {
  return getToken(MySqlParser::NOT, 0);
}


size_t MySqlParser::UnaryOperatorContext::getRuleIndex() const {
  return MySqlParser::RuleUnaryOperator;
}

void MySqlParser::UnaryOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryOperator(this);
}

void MySqlParser::UnaryOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryOperator(this);
}


std::any MySqlParser::UnaryOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitUnaryOperator(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::UnaryOperatorContext* MySqlParser::unaryOperator() {
  UnaryOperatorContext *_localctx = _tracker.createInstance<UnaryOperatorContext>(_ctx, getState());
  enterRule(_localctx, 684, MySqlParser::RuleUnaryOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7325);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::NOT || ((((_la - 1119) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1119)) & 387) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComparisonOperatorContext ------------------------------------------------------------------

MySqlParser::ComparisonOperatorContext::ComparisonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::ComparisonOperatorContext::EQUAL_SYMBOL() {
  return getToken(MySqlParser::EQUAL_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::ComparisonOperatorContext::GREATER_SYMBOL() {
  return getToken(MySqlParser::GREATER_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::ComparisonOperatorContext::LESS_SYMBOL() {
  return getToken(MySqlParser::LESS_SYMBOL, 0);
}

tree::TerminalNode* MySqlParser::ComparisonOperatorContext::EXCLAMATION_SYMBOL() {
  return getToken(MySqlParser::EXCLAMATION_SYMBOL, 0);
}


size_t MySqlParser::ComparisonOperatorContext::getRuleIndex() const {
  return MySqlParser::RuleComparisonOperator;
}

void MySqlParser::ComparisonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComparisonOperator(this);
}

void MySqlParser::ComparisonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComparisonOperator(this);
}


std::any MySqlParser::ComparisonOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitComparisonOperator(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::ComparisonOperatorContext* MySqlParser::comparisonOperator() {
  ComparisonOperatorContext *_localctx = _tracker.createInstance<ComparisonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 686, MySqlParser::RuleComparisonOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7341);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1076, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7327);
      match(MySqlParser::EQUAL_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7328);
      match(MySqlParser::GREATER_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7329);
      match(MySqlParser::LESS_SYMBOL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7330);
      match(MySqlParser::LESS_SYMBOL);
      setState(7331);
      match(MySqlParser::EQUAL_SYMBOL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7332);
      match(MySqlParser::GREATER_SYMBOL);
      setState(7333);
      match(MySqlParser::EQUAL_SYMBOL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(7334);
      match(MySqlParser::LESS_SYMBOL);
      setState(7335);
      match(MySqlParser::GREATER_SYMBOL);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(7336);
      match(MySqlParser::EXCLAMATION_SYMBOL);
      setState(7337);
      match(MySqlParser::EQUAL_SYMBOL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(7338);
      match(MySqlParser::LESS_SYMBOL);
      setState(7339);
      match(MySqlParser::EQUAL_SYMBOL);
      setState(7340);
      match(MySqlParser::GREATER_SYMBOL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogicalOperatorContext ------------------------------------------------------------------

MySqlParser::LogicalOperatorContext::LogicalOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::LogicalOperatorContext::AND() {
  return getToken(MySqlParser::AND, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::LogicalOperatorContext::BIT_AND_OP() {
  return getTokens(MySqlParser::BIT_AND_OP);
}

tree::TerminalNode* MySqlParser::LogicalOperatorContext::BIT_AND_OP(size_t i) {
  return getToken(MySqlParser::BIT_AND_OP, i);
}

tree::TerminalNode* MySqlParser::LogicalOperatorContext::XOR() {
  return getToken(MySqlParser::XOR, 0);
}

tree::TerminalNode* MySqlParser::LogicalOperatorContext::OR() {
  return getToken(MySqlParser::OR, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::LogicalOperatorContext::BIT_OR_OP() {
  return getTokens(MySqlParser::BIT_OR_OP);
}

tree::TerminalNode* MySqlParser::LogicalOperatorContext::BIT_OR_OP(size_t i) {
  return getToken(MySqlParser::BIT_OR_OP, i);
}


size_t MySqlParser::LogicalOperatorContext::getRuleIndex() const {
  return MySqlParser::RuleLogicalOperator;
}

void MySqlParser::LogicalOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalOperator(this);
}

void MySqlParser::LogicalOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalOperator(this);
}


std::any MySqlParser::LogicalOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitLogicalOperator(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::LogicalOperatorContext* MySqlParser::logicalOperator() {
  LogicalOperatorContext *_localctx = _tracker.createInstance<LogicalOperatorContext>(_ctx, getState());
  enterRule(_localctx, 688, MySqlParser::RuleLogicalOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7350);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::AND: {
        enterOuterAlt(_localctx, 1);
        setState(7343);
        match(MySqlParser::AND);
        break;
      }

      case MySqlParser::BIT_AND_OP: {
        enterOuterAlt(_localctx, 2);
        setState(7344);
        match(MySqlParser::BIT_AND_OP);
        setState(7345);
        match(MySqlParser::BIT_AND_OP);
        break;
      }

      case MySqlParser::XOR: {
        enterOuterAlt(_localctx, 3);
        setState(7346);
        match(MySqlParser::XOR);
        break;
      }

      case MySqlParser::OR: {
        enterOuterAlt(_localctx, 4);
        setState(7347);
        match(MySqlParser::OR);
        break;
      }

      case MySqlParser::BIT_OR_OP: {
        enterOuterAlt(_localctx, 5);
        setState(7348);
        match(MySqlParser::BIT_OR_OP);
        setState(7349);
        match(MySqlParser::BIT_OR_OP);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitOperatorContext ------------------------------------------------------------------

MySqlParser::BitOperatorContext::BitOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySqlParser::BitOperatorContext::LESS_SYMBOL() {
  return getTokens(MySqlParser::LESS_SYMBOL);
}

tree::TerminalNode* MySqlParser::BitOperatorContext::LESS_SYMBOL(size_t i) {
  return getToken(MySqlParser::LESS_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySqlParser::BitOperatorContext::GREATER_SYMBOL() {
  return getTokens(MySqlParser::GREATER_SYMBOL);
}

tree::TerminalNode* MySqlParser::BitOperatorContext::GREATER_SYMBOL(size_t i) {
  return getToken(MySqlParser::GREATER_SYMBOL, i);
}

tree::TerminalNode* MySqlParser::BitOperatorContext::BIT_AND_OP() {
  return getToken(MySqlParser::BIT_AND_OP, 0);
}

tree::TerminalNode* MySqlParser::BitOperatorContext::BIT_XOR_OP() {
  return getToken(MySqlParser::BIT_XOR_OP, 0);
}

tree::TerminalNode* MySqlParser::BitOperatorContext::BIT_OR_OP() {
  return getToken(MySqlParser::BIT_OR_OP, 0);
}


size_t MySqlParser::BitOperatorContext::getRuleIndex() const {
  return MySqlParser::RuleBitOperator;
}

void MySqlParser::BitOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitOperator(this);
}

void MySqlParser::BitOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitOperator(this);
}


std::any MySqlParser::BitOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitBitOperator(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::BitOperatorContext* MySqlParser::bitOperator() {
  BitOperatorContext *_localctx = _tracker.createInstance<BitOperatorContext>(_ctx, getState());
  enterRule(_localctx, 690, MySqlParser::RuleBitOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7359);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySqlParser::LESS_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7352);
        match(MySqlParser::LESS_SYMBOL);
        setState(7353);
        match(MySqlParser::LESS_SYMBOL);
        break;
      }

      case MySqlParser::GREATER_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7354);
        match(MySqlParser::GREATER_SYMBOL);
        setState(7355);
        match(MySqlParser::GREATER_SYMBOL);
        break;
      }

      case MySqlParser::BIT_AND_OP: {
        enterOuterAlt(_localctx, 3);
        setState(7356);
        match(MySqlParser::BIT_AND_OP);
        break;
      }

      case MySqlParser::BIT_XOR_OP: {
        enterOuterAlt(_localctx, 4);
        setState(7357);
        match(MySqlParser::BIT_XOR_OP);
        break;
      }

      case MySqlParser::BIT_OR_OP: {
        enterOuterAlt(_localctx, 5);
        setState(7358);
        match(MySqlParser::BIT_OR_OP);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MathOperatorContext ------------------------------------------------------------------

MySqlParser::MathOperatorContext::MathOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::MathOperatorContext::STAR() {
  return getToken(MySqlParser::STAR, 0);
}

tree::TerminalNode* MySqlParser::MathOperatorContext::DIVIDE() {
  return getToken(MySqlParser::DIVIDE, 0);
}

tree::TerminalNode* MySqlParser::MathOperatorContext::MODULE() {
  return getToken(MySqlParser::MODULE, 0);
}

tree::TerminalNode* MySqlParser::MathOperatorContext::DIV() {
  return getToken(MySqlParser::DIV, 0);
}

tree::TerminalNode* MySqlParser::MathOperatorContext::MOD() {
  return getToken(MySqlParser::MOD, 0);
}

tree::TerminalNode* MySqlParser::MathOperatorContext::PLUS() {
  return getToken(MySqlParser::PLUS, 0);
}

tree::TerminalNode* MySqlParser::MathOperatorContext::MINUS() {
  return getToken(MySqlParser::MINUS, 0);
}


size_t MySqlParser::MathOperatorContext::getRuleIndex() const {
  return MySqlParser::RuleMathOperator;
}

void MySqlParser::MathOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMathOperator(this);
}

void MySqlParser::MathOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMathOperator(this);
}


std::any MySqlParser::MathOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitMathOperator(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::MathOperatorContext* MySqlParser::mathOperator() {
  MathOperatorContext *_localctx = _tracker.createInstance<MathOperatorContext>(_ctx, getState());
  enterRule(_localctx, 692, MySqlParser::RuleMathOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7361);
    _la = _input->LA(1);
    if (!(((((_la - 1116) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1116)) & 127) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonOperatorContext ------------------------------------------------------------------

MySqlParser::JsonOperatorContext::JsonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::JsonOperatorContext::MINUS() {
  return getToken(MySqlParser::MINUS, 0);
}

std::vector<tree::TerminalNode *> MySqlParser::JsonOperatorContext::GREATER_SYMBOL() {
  return getTokens(MySqlParser::GREATER_SYMBOL);
}

tree::TerminalNode* MySqlParser::JsonOperatorContext::GREATER_SYMBOL(size_t i) {
  return getToken(MySqlParser::GREATER_SYMBOL, i);
}


size_t MySqlParser::JsonOperatorContext::getRuleIndex() const {
  return MySqlParser::RuleJsonOperator;
}

void MySqlParser::JsonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonOperator(this);
}

void MySqlParser::JsonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonOperator(this);
}


std::any MySqlParser::JsonOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitJsonOperator(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::JsonOperatorContext* MySqlParser::jsonOperator() {
  JsonOperatorContext *_localctx = _tracker.createInstance<JsonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 694, MySqlParser::RuleJsonOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7368);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1079, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7363);
      match(MySqlParser::MINUS);
      setState(7364);
      match(MySqlParser::GREATER_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7365);
      match(MySqlParser::MINUS);
      setState(7366);
      match(MySqlParser::GREATER_SYMBOL);
      setState(7367);
      match(MySqlParser::GREATER_SYMBOL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetNameBaseContext ------------------------------------------------------------------

MySqlParser::CharsetNameBaseContext::CharsetNameBaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::ARMSCII8() {
  return getToken(MySqlParser::ARMSCII8, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::ASCII() {
  return getToken(MySqlParser::ASCII, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::BIG5() {
  return getToken(MySqlParser::BIG5, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::BINARY() {
  return getToken(MySqlParser::BINARY, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::CP1250() {
  return getToken(MySqlParser::CP1250, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::CP1251() {
  return getToken(MySqlParser::CP1251, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::CP1256() {
  return getToken(MySqlParser::CP1256, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::CP1257() {
  return getToken(MySqlParser::CP1257, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::CP850() {
  return getToken(MySqlParser::CP850, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::CP852() {
  return getToken(MySqlParser::CP852, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::CP866() {
  return getToken(MySqlParser::CP866, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::CP932() {
  return getToken(MySqlParser::CP932, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::DEC8() {
  return getToken(MySqlParser::DEC8, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::EUCJPMS() {
  return getToken(MySqlParser::EUCJPMS, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::EUCKR() {
  return getToken(MySqlParser::EUCKR, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::GB18030() {
  return getToken(MySqlParser::GB18030, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::GB2312() {
  return getToken(MySqlParser::GB2312, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::GBK() {
  return getToken(MySqlParser::GBK, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::GEOSTD8() {
  return getToken(MySqlParser::GEOSTD8, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::GREEK() {
  return getToken(MySqlParser::GREEK, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::HEBREW() {
  return getToken(MySqlParser::HEBREW, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::HP8() {
  return getToken(MySqlParser::HP8, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::KEYBCS2() {
  return getToken(MySqlParser::KEYBCS2, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::KOI8R() {
  return getToken(MySqlParser::KOI8R, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::KOI8U() {
  return getToken(MySqlParser::KOI8U, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::LATIN1() {
  return getToken(MySqlParser::LATIN1, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::LATIN2() {
  return getToken(MySqlParser::LATIN2, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::LATIN5() {
  return getToken(MySqlParser::LATIN5, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::LATIN7() {
  return getToken(MySqlParser::LATIN7, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::MACCE() {
  return getToken(MySqlParser::MACCE, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::MACROMAN() {
  return getToken(MySqlParser::MACROMAN, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::SJIS() {
  return getToken(MySqlParser::SJIS, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::SWE7() {
  return getToken(MySqlParser::SWE7, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::TIS620() {
  return getToken(MySqlParser::TIS620, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::UCS2() {
  return getToken(MySqlParser::UCS2, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::UJIS() {
  return getToken(MySqlParser::UJIS, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::UTF16() {
  return getToken(MySqlParser::UTF16, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::UTF16LE() {
  return getToken(MySqlParser::UTF16LE, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::UTF32() {
  return getToken(MySqlParser::UTF32, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::UTF8() {
  return getToken(MySqlParser::UTF8, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::UTF8MB3() {
  return getToken(MySqlParser::UTF8MB3, 0);
}

tree::TerminalNode* MySqlParser::CharsetNameBaseContext::UTF8MB4() {
  return getToken(MySqlParser::UTF8MB4, 0);
}


size_t MySqlParser::CharsetNameBaseContext::getRuleIndex() const {
  return MySqlParser::RuleCharsetNameBase;
}

void MySqlParser::CharsetNameBaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharsetNameBase(this);
}

void MySqlParser::CharsetNameBaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharsetNameBase(this);
}


std::any MySqlParser::CharsetNameBaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitCharsetNameBase(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::CharsetNameBaseContext* MySqlParser::charsetNameBase() {
  CharsetNameBaseContext *_localctx = _tracker.createInstance<CharsetNameBaseContext>(_ctx, getState());
  enterRule(_localctx, 696, MySqlParser::RuleCharsetNameBase);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7370);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::BINARY || ((((_la - 746) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 746)) & 2199023255551) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionLevelBaseContext ------------------------------------------------------------------

MySqlParser::TransactionLevelBaseContext::TransactionLevelBaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::TransactionLevelBaseContext::REPEATABLE() {
  return getToken(MySqlParser::REPEATABLE, 0);
}

tree::TerminalNode* MySqlParser::TransactionLevelBaseContext::COMMITTED() {
  return getToken(MySqlParser::COMMITTED, 0);
}

tree::TerminalNode* MySqlParser::TransactionLevelBaseContext::UNCOMMITTED() {
  return getToken(MySqlParser::UNCOMMITTED, 0);
}

tree::TerminalNode* MySqlParser::TransactionLevelBaseContext::SERIALIZABLE() {
  return getToken(MySqlParser::SERIALIZABLE, 0);
}


size_t MySqlParser::TransactionLevelBaseContext::getRuleIndex() const {
  return MySqlParser::RuleTransactionLevelBase;
}

void MySqlParser::TransactionLevelBaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionLevelBase(this);
}

void MySqlParser::TransactionLevelBaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionLevelBase(this);
}


std::any MySqlParser::TransactionLevelBaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitTransactionLevelBase(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::TransactionLevelBaseContext* MySqlParser::transactionLevelBase() {
  TransactionLevelBaseContext *_localctx = _tracker.createInstance<TransactionLevelBaseContext>(_ctx, getState());
  enterRule(_localctx, 698, MySqlParser::RuleTransactionLevelBase);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7372);
    _la = _input->LA(1);
    if (!(((((_la - 799) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 799)) & 15) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegesBaseContext ------------------------------------------------------------------

MySqlParser::PrivilegesBaseContext::PrivilegesBaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::PrivilegesBaseContext::TABLES() {
  return getToken(MySqlParser::TABLES, 0);
}

tree::TerminalNode* MySqlParser::PrivilegesBaseContext::ROUTINE() {
  return getToken(MySqlParser::ROUTINE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegesBaseContext::EXECUTE() {
  return getToken(MySqlParser::EXECUTE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegesBaseContext::FILE() {
  return getToken(MySqlParser::FILE, 0);
}

tree::TerminalNode* MySqlParser::PrivilegesBaseContext::PROCESS() {
  return getToken(MySqlParser::PROCESS, 0);
}

tree::TerminalNode* MySqlParser::PrivilegesBaseContext::RELOAD() {
  return getToken(MySqlParser::RELOAD, 0);
}

tree::TerminalNode* MySqlParser::PrivilegesBaseContext::SHUTDOWN() {
  return getToken(MySqlParser::SHUTDOWN, 0);
}

tree::TerminalNode* MySqlParser::PrivilegesBaseContext::SUPER() {
  return getToken(MySqlParser::SUPER, 0);
}

tree::TerminalNode* MySqlParser::PrivilegesBaseContext::PRIVILEGES() {
  return getToken(MySqlParser::PRIVILEGES, 0);
}


size_t MySqlParser::PrivilegesBaseContext::getRuleIndex() const {
  return MySqlParser::RulePrivilegesBase;
}

void MySqlParser::PrivilegesBaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivilegesBase(this);
}

void MySqlParser::PrivilegesBaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivilegesBase(this);
}


std::any MySqlParser::PrivilegesBaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitPrivilegesBase(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::PrivilegesBaseContext* MySqlParser::privilegesBase() {
  PrivilegesBaseContext *_localctx = _tracker.createInstance<PrivilegesBaseContext>(_ctx, getState());
  enterRule(_localctx, 700, MySqlParser::RulePrivilegesBase);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7374);
    _la = _input->LA(1);
    if (!(((((_la - 708) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 708)) & 23656792067) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalTypeBaseContext ------------------------------------------------------------------

MySqlParser::IntervalTypeBaseContext::IntervalTypeBaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::IntervalTypeBaseContext::QUARTER() {
  return getToken(MySqlParser::QUARTER, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeBaseContext::MONTH() {
  return getToken(MySqlParser::MONTH, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeBaseContext::DAY() {
  return getToken(MySqlParser::DAY, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeBaseContext::HOUR() {
  return getToken(MySqlParser::HOUR, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeBaseContext::MINUTE() {
  return getToken(MySqlParser::MINUTE, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeBaseContext::WEEK() {
  return getToken(MySqlParser::WEEK, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeBaseContext::SECOND() {
  return getToken(MySqlParser::SECOND, 0);
}

tree::TerminalNode* MySqlParser::IntervalTypeBaseContext::MICROSECOND() {
  return getToken(MySqlParser::MICROSECOND, 0);
}


size_t MySqlParser::IntervalTypeBaseContext::getRuleIndex() const {
  return MySqlParser::RuleIntervalTypeBase;
}

void MySqlParser::IntervalTypeBaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalTypeBase(this);
}

void MySqlParser::IntervalTypeBaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalTypeBase(this);
}


std::any MySqlParser::IntervalTypeBaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitIntervalTypeBase(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::IntervalTypeBaseContext* MySqlParser::intervalTypeBase() {
  IntervalTypeBaseContext *_localctx = _tracker.createInstance<IntervalTypeBaseContext>(_ctx, getState());
  enterRule(_localctx, 702, MySqlParser::RuleIntervalTypeBase);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7376);
    _la = _input->LA(1);
    if (!(((((_la - 689) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 689)) & 255) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataTypeBaseContext ------------------------------------------------------------------

MySqlParser::DataTypeBaseContext::DataTypeBaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::DataTypeBaseContext::DATE() {
  return getToken(MySqlParser::DATE, 0);
}

tree::TerminalNode* MySqlParser::DataTypeBaseContext::TIME() {
  return getToken(MySqlParser::TIME, 0);
}

tree::TerminalNode* MySqlParser::DataTypeBaseContext::TIMESTAMP() {
  return getToken(MySqlParser::TIMESTAMP, 0);
}

tree::TerminalNode* MySqlParser::DataTypeBaseContext::DATETIME() {
  return getToken(MySqlParser::DATETIME, 0);
}

tree::TerminalNode* MySqlParser::DataTypeBaseContext::YEAR() {
  return getToken(MySqlParser::YEAR, 0);
}

tree::TerminalNode* MySqlParser::DataTypeBaseContext::ENUM() {
  return getToken(MySqlParser::ENUM, 0);
}

tree::TerminalNode* MySqlParser::DataTypeBaseContext::TEXT() {
  return getToken(MySqlParser::TEXT, 0);
}


size_t MySqlParser::DataTypeBaseContext::getRuleIndex() const {
  return MySqlParser::RuleDataTypeBase;
}

void MySqlParser::DataTypeBaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataTypeBase(this);
}

void MySqlParser::DataTypeBaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataTypeBase(this);
}


std::any MySqlParser::DataTypeBaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitDataTypeBase(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::DataTypeBaseContext* MySqlParser::dataTypeBase() {
  DataTypeBaseContext *_localctx = _tracker.createInstance<DataTypeBaseContext>(_ctx, getState());
  enterRule(_localctx, 704, MySqlParser::RuleDataTypeBase);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7378);
    _la = _input->LA(1);
    if (!(((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & 1179679) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordsCanBeIdContext ------------------------------------------------------------------

MySqlParser::KeywordsCanBeIdContext::KeywordsCanBeIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ACCOUNT() {
  return getToken(MySqlParser::ACCOUNT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ACTION() {
  return getToken(MySqlParser::ACTION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ADMIN() {
  return getToken(MySqlParser::ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::AFTER() {
  return getToken(MySqlParser::AFTER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::AGGREGATE() {
  return getToken(MySqlParser::AGGREGATE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ALGORITHM() {
  return getToken(MySqlParser::ALGORITHM, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ANY() {
  return getToken(MySqlParser::ANY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::AT() {
  return getToken(MySqlParser::AT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::AUDIT_ADMIN() {
  return getToken(MySqlParser::AUDIT_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::AUDIT_ABORT_EXEMPT() {
  return getToken(MySqlParser::AUDIT_ABORT_EXEMPT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::AUTHORS() {
  return getToken(MySqlParser::AUTHORS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::AUTOCOMMIT() {
  return getToken(MySqlParser::AUTOCOMMIT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::AUTOEXTEND_SIZE() {
  return getToken(MySqlParser::AUTOEXTEND_SIZE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::AUTO_INCREMENT() {
  return getToken(MySqlParser::AUTO_INCREMENT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::AUTHENTICATION_POLICY_ADMIN() {
  return getToken(MySqlParser::AUTHENTICATION_POLICY_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::AVG() {
  return getToken(MySqlParser::AVG, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::AVG_ROW_LENGTH() {
  return getToken(MySqlParser::AVG_ROW_LENGTH, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ATTRIBUTE() {
  return getToken(MySqlParser::ATTRIBUTE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BACKUP_ADMIN() {
  return getToken(MySqlParser::BACKUP_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BEGIN() {
  return getToken(MySqlParser::BEGIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BINLOG() {
  return getToken(MySqlParser::BINLOG, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BINLOG_ADMIN() {
  return getToken(MySqlParser::BINLOG_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BINLOG_ENCRYPTION_ADMIN() {
  return getToken(MySqlParser::BINLOG_ENCRYPTION_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BIT() {
  return getToken(MySqlParser::BIT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BIT_AND() {
  return getToken(MySqlParser::BIT_AND, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BIT_OR() {
  return getToken(MySqlParser::BIT_OR, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BIT_XOR() {
  return getToken(MySqlParser::BIT_XOR, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BLOCK() {
  return getToken(MySqlParser::BLOCK, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BOOL() {
  return getToken(MySqlParser::BOOL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BOOLEAN() {
  return getToken(MySqlParser::BOOLEAN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BTREE() {
  return getToken(MySqlParser::BTREE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::BUCKETS() {
  return getToken(MySqlParser::BUCKETS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CACHE() {
  return getToken(MySqlParser::CACHE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CASCADED() {
  return getToken(MySqlParser::CASCADED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CHAIN() {
  return getToken(MySqlParser::CHAIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CHANGED() {
  return getToken(MySqlParser::CHANGED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CHANNEL() {
  return getToken(MySqlParser::CHANNEL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CHECKSUM() {
  return getToken(MySqlParser::CHECKSUM, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PAGE_CHECKSUM() {
  return getToken(MySqlParser::PAGE_CHECKSUM, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CATALOG_NAME() {
  return getToken(MySqlParser::CATALOG_NAME, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CIPHER() {
  return getToken(MySqlParser::CIPHER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CLASS_ORIGIN() {
  return getToken(MySqlParser::CLASS_ORIGIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CLIENT() {
  return getToken(MySqlParser::CLIENT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CLONE_ADMIN() {
  return getToken(MySqlParser::CLONE_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CLOSE() {
  return getToken(MySqlParser::CLOSE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CLUSTERING() {
  return getToken(MySqlParser::CLUSTERING, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::COALESCE() {
  return getToken(MySqlParser::COALESCE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CODE() {
  return getToken(MySqlParser::CODE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::COLUMNS() {
  return getToken(MySqlParser::COLUMNS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::COLUMN_FORMAT() {
  return getToken(MySqlParser::COLUMN_FORMAT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::COLUMN_NAME() {
  return getToken(MySqlParser::COLUMN_NAME, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::COMMENT() {
  return getToken(MySqlParser::COMMENT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::COMMIT() {
  return getToken(MySqlParser::COMMIT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::COMPACT() {
  return getToken(MySqlParser::COMPACT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::COMPLETION() {
  return getToken(MySqlParser::COMPLETION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::COMPRESSED() {
  return getToken(MySqlParser::COMPRESSED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::COMPRESSION() {
  return getToken(MySqlParser::COMPRESSION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CONCURRENT() {
  return getToken(MySqlParser::CONCURRENT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CONDITION() {
  return getToken(MySqlParser::CONDITION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CONNECT() {
  return getToken(MySqlParser::CONNECT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CONNECTION() {
  return getToken(MySqlParser::CONNECTION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CONNECTION_ADMIN() {
  return getToken(MySqlParser::CONNECTION_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CONSISTENT() {
  return getToken(MySqlParser::CONSISTENT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CONSTRAINT_CATALOG() {
  return getToken(MySqlParser::CONSTRAINT_CATALOG, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CONSTRAINT_NAME() {
  return getToken(MySqlParser::CONSTRAINT_NAME, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CONSTRAINT_SCHEMA() {
  return getToken(MySqlParser::CONSTRAINT_SCHEMA, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CONTAINS() {
  return getToken(MySqlParser::CONTAINS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CONTEXT() {
  return getToken(MySqlParser::CONTEXT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CONTRIBUTORS() {
  return getToken(MySqlParser::CONTRIBUTORS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::COPY() {
  return getToken(MySqlParser::COPY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::COUNT() {
  return getToken(MySqlParser::COUNT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CPU() {
  return getToken(MySqlParser::CPU, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CURRENT() {
  return getToken(MySqlParser::CURRENT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CURRENT_USER() {
  return getToken(MySqlParser::CURRENT_USER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::CURSOR_NAME() {
  return getToken(MySqlParser::CURSOR_NAME, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DATA() {
  return getToken(MySqlParser::DATA, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DATAFILE() {
  return getToken(MySqlParser::DATAFILE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DEALLOCATE() {
  return getToken(MySqlParser::DEALLOCATE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DEFAULT() {
  return getToken(MySqlParser::DEFAULT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DEFAULT_AUTH() {
  return getToken(MySqlParser::DEFAULT_AUTH, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DEFINER() {
  return getToken(MySqlParser::DEFINER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DELAY_KEY_WRITE() {
  return getToken(MySqlParser::DELAY_KEY_WRITE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DES_KEY_FILE() {
  return getToken(MySqlParser::DES_KEY_FILE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DIAGNOSTICS() {
  return getToken(MySqlParser::DIAGNOSTICS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DIRECTORY() {
  return getToken(MySqlParser::DIRECTORY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DISABLE() {
  return getToken(MySqlParser::DISABLE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DISCARD() {
  return getToken(MySqlParser::DISCARD, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DISK() {
  return getToken(MySqlParser::DISK, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DO() {
  return getToken(MySqlParser::DO, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DUMPFILE() {
  return getToken(MySqlParser::DUMPFILE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DUPLICATE() {
  return getToken(MySqlParser::DUPLICATE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::DYNAMIC() {
  return getToken(MySqlParser::DYNAMIC, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::EMPTY() {
  return getToken(MySqlParser::EMPTY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ENABLE() {
  return getToken(MySqlParser::ENABLE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ENCRYPTION() {
  return getToken(MySqlParser::ENCRYPTION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ENCRYPTION_KEY_ADMIN() {
  return getToken(MySqlParser::ENCRYPTION_KEY_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::END() {
  return getToken(MySqlParser::END, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ENDS() {
  return getToken(MySqlParser::ENDS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ENGINE() {
  return getToken(MySqlParser::ENGINE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ENGINE_ATTRIBUTE() {
  return getToken(MySqlParser::ENGINE_ATTRIBUTE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ENGINES() {
  return getToken(MySqlParser::ENGINES, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ENFORCED() {
  return getToken(MySqlParser::ENFORCED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ERROR() {
  return getToken(MySqlParser::ERROR, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ERRORS() {
  return getToken(MySqlParser::ERRORS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ESCAPE() {
  return getToken(MySqlParser::ESCAPE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::EUR() {
  return getToken(MySqlParser::EUR, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::EVEN() {
  return getToken(MySqlParser::EVEN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::EVENT() {
  return getToken(MySqlParser::EVENT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::EVENTS() {
  return getToken(MySqlParser::EVENTS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::EVERY() {
  return getToken(MySqlParser::EVERY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::EXCEPT() {
  return getToken(MySqlParser::EXCEPT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::EXCHANGE() {
  return getToken(MySqlParser::EXCHANGE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::EXCLUSIVE() {
  return getToken(MySqlParser::EXCLUSIVE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::EXPIRE() {
  return getToken(MySqlParser::EXPIRE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::EXPORT() {
  return getToken(MySqlParser::EXPORT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::EXTENDED() {
  return getToken(MySqlParser::EXTENDED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::EXTENT_SIZE() {
  return getToken(MySqlParser::EXTENT_SIZE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FAILED_LOGIN_ATTEMPTS() {
  return getToken(MySqlParser::FAILED_LOGIN_ATTEMPTS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FAST() {
  return getToken(MySqlParser::FAST, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FAULTS() {
  return getToken(MySqlParser::FAULTS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FIELDS() {
  return getToken(MySqlParser::FIELDS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FILE_BLOCK_SIZE() {
  return getToken(MySqlParser::FILE_BLOCK_SIZE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FILTER() {
  return getToken(MySqlParser::FILTER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FIREWALL_ADMIN() {
  return getToken(MySqlParser::FIREWALL_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FIREWALL_EXEMPT() {
  return getToken(MySqlParser::FIREWALL_EXEMPT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FIREWALL_USER() {
  return getToken(MySqlParser::FIREWALL_USER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FIRST() {
  return getToken(MySqlParser::FIRST, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FIXED() {
  return getToken(MySqlParser::FIXED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FLUSH() {
  return getToken(MySqlParser::FLUSH, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FOLLOWS() {
  return getToken(MySqlParser::FOLLOWS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FOUND() {
  return getToken(MySqlParser::FOUND, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FULL() {
  return getToken(MySqlParser::FULL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::FUNCTION() {
  return getToken(MySqlParser::FUNCTION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::GENERAL() {
  return getToken(MySqlParser::GENERAL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::GLOBAL() {
  return getToken(MySqlParser::GLOBAL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::GRANTS() {
  return getToken(MySqlParser::GRANTS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::GROUP() {
  return getToken(MySqlParser::GROUP, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::GROUP_CONCAT() {
  return getToken(MySqlParser::GROUP_CONCAT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::GROUP_REPLICATION() {
  return getToken(MySqlParser::GROUP_REPLICATION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::GROUP_REPLICATION_ADMIN() {
  return getToken(MySqlParser::GROUP_REPLICATION_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::HANDLER() {
  return getToken(MySqlParser::HANDLER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::HASH() {
  return getToken(MySqlParser::HASH, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::HELP() {
  return getToken(MySqlParser::HELP, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::HISTORY() {
  return getToken(MySqlParser::HISTORY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::HOST() {
  return getToken(MySqlParser::HOST, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::HOSTS() {
  return getToken(MySqlParser::HOSTS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::IDENTIFIED() {
  return getToken(MySqlParser::IDENTIFIED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::IGNORED() {
  return getToken(MySqlParser::IGNORED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::IGNORE_SERVER_IDS() {
  return getToken(MySqlParser::IGNORE_SERVER_IDS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::IMPORT() {
  return getToken(MySqlParser::IMPORT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::INDEXES() {
  return getToken(MySqlParser::INDEXES, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::INITIAL_SIZE() {
  return getToken(MySqlParser::INITIAL_SIZE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::INNODB_REDO_LOG_ARCHIVE() {
  return getToken(MySqlParser::INNODB_REDO_LOG_ARCHIVE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::INPLACE() {
  return getToken(MySqlParser::INPLACE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::INSERT_METHOD() {
  return getToken(MySqlParser::INSERT_METHOD, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::INSTALL() {
  return getToken(MySqlParser::INSTALL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::INSTANCE() {
  return getToken(MySqlParser::INSTANCE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::INSTANT() {
  return getToken(MySqlParser::INSTANT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::INTERNAL() {
  return getToken(MySqlParser::INTERNAL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::INVOKE() {
  return getToken(MySqlParser::INVOKE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::INVOKER() {
  return getToken(MySqlParser::INVOKER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::IO() {
  return getToken(MySqlParser::IO, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::IO_THREAD() {
  return getToken(MySqlParser::IO_THREAD, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::IPC() {
  return getToken(MySqlParser::IPC, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ISO() {
  return getToken(MySqlParser::ISO, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ISOLATION() {
  return getToken(MySqlParser::ISOLATION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ISSUER() {
  return getToken(MySqlParser::ISSUER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::JIS() {
  return getToken(MySqlParser::JIS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::JSON() {
  return getToken(MySqlParser::JSON, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::KEY_BLOCK_SIZE() {
  return getToken(MySqlParser::KEY_BLOCK_SIZE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::LAMBDA() {
  return getToken(MySqlParser::LAMBDA, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::LANGUAGE() {
  return getToken(MySqlParser::LANGUAGE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::LAST() {
  return getToken(MySqlParser::LAST, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::LATERAL() {
  return getToken(MySqlParser::LATERAL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::LEAVES() {
  return getToken(MySqlParser::LEAVES, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::LESS() {
  return getToken(MySqlParser::LESS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::LEVEL() {
  return getToken(MySqlParser::LEVEL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::LIST() {
  return getToken(MySqlParser::LIST, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::LOCAL() {
  return getToken(MySqlParser::LOCAL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::LOGFILE() {
  return getToken(MySqlParser::LOGFILE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::LOGS() {
  return getToken(MySqlParser::LOGS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER() {
  return getToken(MySqlParser::MASTER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_AUTO_POSITION() {
  return getToken(MySqlParser::MASTER_AUTO_POSITION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_CONNECT_RETRY() {
  return getToken(MySqlParser::MASTER_CONNECT_RETRY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_DELAY() {
  return getToken(MySqlParser::MASTER_DELAY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_HEARTBEAT_PERIOD() {
  return getToken(MySqlParser::MASTER_HEARTBEAT_PERIOD, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_HOST() {
  return getToken(MySqlParser::MASTER_HOST, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_LOG_FILE() {
  return getToken(MySqlParser::MASTER_LOG_FILE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_LOG_POS() {
  return getToken(MySqlParser::MASTER_LOG_POS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_PASSWORD() {
  return getToken(MySqlParser::MASTER_PASSWORD, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_PORT() {
  return getToken(MySqlParser::MASTER_PORT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_RETRY_COUNT() {
  return getToken(MySqlParser::MASTER_RETRY_COUNT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_SSL() {
  return getToken(MySqlParser::MASTER_SSL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_SSL_CA() {
  return getToken(MySqlParser::MASTER_SSL_CA, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_SSL_CAPATH() {
  return getToken(MySqlParser::MASTER_SSL_CAPATH, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_SSL_CERT() {
  return getToken(MySqlParser::MASTER_SSL_CERT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_SSL_CIPHER() {
  return getToken(MySqlParser::MASTER_SSL_CIPHER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_SSL_CRL() {
  return getToken(MySqlParser::MASTER_SSL_CRL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_SSL_CRLPATH() {
  return getToken(MySqlParser::MASTER_SSL_CRLPATH, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_SSL_KEY() {
  return getToken(MySqlParser::MASTER_SSL_KEY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_TLS_VERSION() {
  return getToken(MySqlParser::MASTER_TLS_VERSION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MASTER_USER() {
  return getToken(MySqlParser::MASTER_USER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MAX_CONNECTIONS_PER_HOUR() {
  return getToken(MySqlParser::MAX_CONNECTIONS_PER_HOUR, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MAX_QUERIES_PER_HOUR() {
  return getToken(MySqlParser::MAX_QUERIES_PER_HOUR, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MAX() {
  return getToken(MySqlParser::MAX, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MAX_ROWS() {
  return getToken(MySqlParser::MAX_ROWS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MAX_SIZE() {
  return getToken(MySqlParser::MAX_SIZE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MAX_UPDATES_PER_HOUR() {
  return getToken(MySqlParser::MAX_UPDATES_PER_HOUR, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MAX_USER_CONNECTIONS() {
  return getToken(MySqlParser::MAX_USER_CONNECTIONS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MEDIUM() {
  return getToken(MySqlParser::MEDIUM, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MEMBER() {
  return getToken(MySqlParser::MEMBER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MEMORY() {
  return getToken(MySqlParser::MEMORY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MERGE() {
  return getToken(MySqlParser::MERGE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MESSAGE_TEXT() {
  return getToken(MySqlParser::MESSAGE_TEXT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MID() {
  return getToken(MySqlParser::MID, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MIGRATE() {
  return getToken(MySqlParser::MIGRATE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MIN() {
  return getToken(MySqlParser::MIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MIN_ROWS() {
  return getToken(MySqlParser::MIN_ROWS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MODE() {
  return getToken(MySqlParser::MODE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MODIFY() {
  return getToken(MySqlParser::MODIFY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MUTEX() {
  return getToken(MySqlParser::MUTEX, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MYSQL() {
  return getToken(MySqlParser::MYSQL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::MYSQL_ERRNO() {
  return getToken(MySqlParser::MYSQL_ERRNO, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::NAME() {
  return getToken(MySqlParser::NAME, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::NAMES() {
  return getToken(MySqlParser::NAMES, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::NCHAR() {
  return getToken(MySqlParser::NCHAR, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::NDB_STORED_USER() {
  return getToken(MySqlParser::NDB_STORED_USER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::NESTED() {
  return getToken(MySqlParser::NESTED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::NEVER() {
  return getToken(MySqlParser::NEVER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::NEXT() {
  return getToken(MySqlParser::NEXT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::NO() {
  return getToken(MySqlParser::NO, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::NOCOPY() {
  return getToken(MySqlParser::NOCOPY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::NODEGROUP() {
  return getToken(MySqlParser::NODEGROUP, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::NONE() {
  return getToken(MySqlParser::NONE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::NOWAIT() {
  return getToken(MySqlParser::NOWAIT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::NUMBER() {
  return getToken(MySqlParser::NUMBER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ODBC() {
  return getToken(MySqlParser::ODBC, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::OFFLINE() {
  return getToken(MySqlParser::OFFLINE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::OFFSET() {
  return getToken(MySqlParser::OFFSET, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::OF() {
  return getToken(MySqlParser::OF, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::OJ() {
  return getToken(MySqlParser::OJ, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::OLD_PASSWORD() {
  return getToken(MySqlParser::OLD_PASSWORD, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ONE() {
  return getToken(MySqlParser::ONE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ONLINE() {
  return getToken(MySqlParser::ONLINE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ONLY() {
  return getToken(MySqlParser::ONLY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::OPEN() {
  return getToken(MySqlParser::OPEN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::OPTIMIZER_COSTS() {
  return getToken(MySqlParser::OPTIMIZER_COSTS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::OPTIONAL() {
  return getToken(MySqlParser::OPTIONAL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::OPTIONS() {
  return getToken(MySqlParser::OPTIONS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ORDER() {
  return getToken(MySqlParser::ORDER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ORDINALITY() {
  return getToken(MySqlParser::ORDINALITY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::OWNER() {
  return getToken(MySqlParser::OWNER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PACK_KEYS() {
  return getToken(MySqlParser::PACK_KEYS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PAGE() {
  return getToken(MySqlParser::PAGE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PARSER() {
  return getToken(MySqlParser::PARSER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PARTIAL() {
  return getToken(MySqlParser::PARTIAL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PARTITIONING() {
  return getToken(MySqlParser::PARTITIONING, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PARTITIONS() {
  return getToken(MySqlParser::PARTITIONS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PASSWORD() {
  return getToken(MySqlParser::PASSWORD, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PASSWORDLESS_USER_ADMIN() {
  return getToken(MySqlParser::PASSWORDLESS_USER_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PASSWORD_LOCK_TIME() {
  return getToken(MySqlParser::PASSWORD_LOCK_TIME, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PATH() {
  return getToken(MySqlParser::PATH, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PERSIST_RO_VARIABLES_ADMIN() {
  return getToken(MySqlParser::PERSIST_RO_VARIABLES_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PHASE() {
  return getToken(MySqlParser::PHASE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PLUGINS() {
  return getToken(MySqlParser::PLUGINS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PLUGIN_DIR() {
  return getToken(MySqlParser::PLUGIN_DIR, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PLUGIN() {
  return getToken(MySqlParser::PLUGIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PORT() {
  return getToken(MySqlParser::PORT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PRECEDES() {
  return getToken(MySqlParser::PRECEDES, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PREPARE() {
  return getToken(MySqlParser::PREPARE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PRESERVE() {
  return getToken(MySqlParser::PRESERVE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PREV() {
  return getToken(MySqlParser::PREV, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PRIMARY() {
  return getToken(MySqlParser::PRIMARY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PROCESSLIST() {
  return getToken(MySqlParser::PROCESSLIST, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PROFILE() {
  return getToken(MySqlParser::PROFILE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PROFILES() {
  return getToken(MySqlParser::PROFILES, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::PROXY() {
  return getToken(MySqlParser::PROXY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::QUERY() {
  return getToken(MySqlParser::QUERY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::QUICK() {
  return getToken(MySqlParser::QUICK, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REBUILD() {
  return getToken(MySqlParser::REBUILD, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::RECOVER() {
  return getToken(MySqlParser::RECOVER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::RECURSIVE() {
  return getToken(MySqlParser::RECURSIVE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REDO_BUFFER_SIZE() {
  return getToken(MySqlParser::REDO_BUFFER_SIZE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REDUNDANT() {
  return getToken(MySqlParser::REDUNDANT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::RELAY() {
  return getToken(MySqlParser::RELAY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::RELAYLOG() {
  return getToken(MySqlParser::RELAYLOG, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::RELAY_LOG_FILE() {
  return getToken(MySqlParser::RELAY_LOG_FILE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::RELAY_LOG_POS() {
  return getToken(MySqlParser::RELAY_LOG_POS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REMOVE() {
  return getToken(MySqlParser::REMOVE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REORGANIZE() {
  return getToken(MySqlParser::REORGANIZE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REPAIR() {
  return getToken(MySqlParser::REPAIR, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REPLICATE_DO_DB() {
  return getToken(MySqlParser::REPLICATE_DO_DB, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REPLICATE_DO_TABLE() {
  return getToken(MySqlParser::REPLICATE_DO_TABLE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REPLICATE_IGNORE_DB() {
  return getToken(MySqlParser::REPLICATE_IGNORE_DB, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REPLICATE_IGNORE_TABLE() {
  return getToken(MySqlParser::REPLICATE_IGNORE_TABLE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REPLICATE_REWRITE_DB() {
  return getToken(MySqlParser::REPLICATE_REWRITE_DB, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REPLICATE_WILD_DO_TABLE() {
  return getToken(MySqlParser::REPLICATE_WILD_DO_TABLE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REPLICATE_WILD_IGNORE_TABLE() {
  return getToken(MySqlParser::REPLICATE_WILD_IGNORE_TABLE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REPLICATION() {
  return getToken(MySqlParser::REPLICATION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REPLICATION_APPLIER() {
  return getToken(MySqlParser::REPLICATION_APPLIER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REPLICATION_SLAVE_ADMIN() {
  return getToken(MySqlParser::REPLICATION_SLAVE_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::RESET() {
  return getToken(MySqlParser::RESET, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::RESOURCE_GROUP_ADMIN() {
  return getToken(MySqlParser::RESOURCE_GROUP_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::RESOURCE_GROUP_USER() {
  return getToken(MySqlParser::RESOURCE_GROUP_USER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::RESUME() {
  return getToken(MySqlParser::RESUME, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::RETURNED_SQLSTATE() {
  return getToken(MySqlParser::RETURNED_SQLSTATE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::RETURNS() {
  return getToken(MySqlParser::RETURNS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::REUSE() {
  return getToken(MySqlParser::REUSE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ROLE() {
  return getToken(MySqlParser::ROLE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ROLE_ADMIN() {
  return getToken(MySqlParser::ROLE_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ROLLBACK() {
  return getToken(MySqlParser::ROLLBACK, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ROLLUP() {
  return getToken(MySqlParser::ROLLUP, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ROTATE() {
  return getToken(MySqlParser::ROTATE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ROW() {
  return getToken(MySqlParser::ROW, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ROWS() {
  return getToken(MySqlParser::ROWS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::ROW_FORMAT() {
  return getToken(MySqlParser::ROW_FORMAT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::RTREE() {
  return getToken(MySqlParser::RTREE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::S3() {
  return getToken(MySqlParser::S3, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SAVEPOINT() {
  return getToken(MySqlParser::SAVEPOINT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SCHEDULE() {
  return getToken(MySqlParser::SCHEDULE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SCHEMA_NAME() {
  return getToken(MySqlParser::SCHEMA_NAME, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SECURITY() {
  return getToken(MySqlParser::SECURITY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SECONDARY_ENGINE_ATTRIBUTE() {
  return getToken(MySqlParser::SECONDARY_ENGINE_ATTRIBUTE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SERIAL() {
  return getToken(MySqlParser::SERIAL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SERVER() {
  return getToken(MySqlParser::SERVER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SESSION() {
  return getToken(MySqlParser::SESSION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SESSION_VARIABLES_ADMIN() {
  return getToken(MySqlParser::SESSION_VARIABLES_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SET_USER_ID() {
  return getToken(MySqlParser::SET_USER_ID, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SHARE() {
  return getToken(MySqlParser::SHARE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SHARED() {
  return getToken(MySqlParser::SHARED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SHOW_ROUTINE() {
  return getToken(MySqlParser::SHOW_ROUTINE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SIGNED() {
  return getToken(MySqlParser::SIGNED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SIMPLE() {
  return getToken(MySqlParser::SIMPLE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SLAVE() {
  return getToken(MySqlParser::SLAVE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SLOW() {
  return getToken(MySqlParser::SLOW, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SKIP_QUERY_REWRITE() {
  return getToken(MySqlParser::SKIP_QUERY_REWRITE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SNAPSHOT() {
  return getToken(MySqlParser::SNAPSHOT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SOCKET() {
  return getToken(MySqlParser::SOCKET, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SOME() {
  return getToken(MySqlParser::SOME, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SONAME() {
  return getToken(MySqlParser::SONAME, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SOUNDS() {
  return getToken(MySqlParser::SOUNDS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SOURCE() {
  return getToken(MySqlParser::SOURCE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SQL_AFTER_GTIDS() {
  return getToken(MySqlParser::SQL_AFTER_GTIDS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SQL_AFTER_MTS_GAPS() {
  return getToken(MySqlParser::SQL_AFTER_MTS_GAPS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SQL_BEFORE_GTIDS() {
  return getToken(MySqlParser::SQL_BEFORE_GTIDS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SQL_BUFFER_RESULT() {
  return getToken(MySqlParser::SQL_BUFFER_RESULT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SQL_CACHE() {
  return getToken(MySqlParser::SQL_CACHE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SQL_NO_CACHE() {
  return getToken(MySqlParser::SQL_NO_CACHE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SQL_THREAD() {
  return getToken(MySqlParser::SQL_THREAD, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::STACKED() {
  return getToken(MySqlParser::STACKED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::START() {
  return getToken(MySqlParser::START, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::STARTS() {
  return getToken(MySqlParser::STARTS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::STATS_AUTO_RECALC() {
  return getToken(MySqlParser::STATS_AUTO_RECALC, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::STATS_PERSISTENT() {
  return getToken(MySqlParser::STATS_PERSISTENT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::STATS_SAMPLE_PAGES() {
  return getToken(MySqlParser::STATS_SAMPLE_PAGES, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::STATUS() {
  return getToken(MySqlParser::STATUS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::STD() {
  return getToken(MySqlParser::STD, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::STDDEV() {
  return getToken(MySqlParser::STDDEV, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::STDDEV_POP() {
  return getToken(MySqlParser::STDDEV_POP, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::STDDEV_SAMP() {
  return getToken(MySqlParser::STDDEV_SAMP, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::STOP() {
  return getToken(MySqlParser::STOP, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::STORAGE() {
  return getToken(MySqlParser::STORAGE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::STRING() {
  return getToken(MySqlParser::STRING, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SUBCLASS_ORIGIN() {
  return getToken(MySqlParser::SUBCLASS_ORIGIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SUBJECT() {
  return getToken(MySqlParser::SUBJECT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SUBPARTITION() {
  return getToken(MySqlParser::SUBPARTITION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SUBPARTITIONS() {
  return getToken(MySqlParser::SUBPARTITIONS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SUM() {
  return getToken(MySqlParser::SUM, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SUSPEND() {
  return getToken(MySqlParser::SUSPEND, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SWAPS() {
  return getToken(MySqlParser::SWAPS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SWITCHES() {
  return getToken(MySqlParser::SWITCHES, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::SYSTEM_VARIABLES_ADMIN() {
  return getToken(MySqlParser::SYSTEM_VARIABLES_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::TABLE_NAME() {
  return getToken(MySqlParser::TABLE_NAME, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::TABLESPACE() {
  return getToken(MySqlParser::TABLESPACE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::TABLE_ENCRYPTION_ADMIN() {
  return getToken(MySqlParser::TABLE_ENCRYPTION_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::TABLE_TYPE() {
  return getToken(MySqlParser::TABLE_TYPE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::TEMPORARY() {
  return getToken(MySqlParser::TEMPORARY, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::TEMPTABLE() {
  return getToken(MySqlParser::TEMPTABLE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::THAN() {
  return getToken(MySqlParser::THAN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::TP_CONNECTION_ADMIN() {
  return getToken(MySqlParser::TP_CONNECTION_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::TRADITIONAL() {
  return getToken(MySqlParser::TRADITIONAL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::TRANSACTION() {
  return getToken(MySqlParser::TRANSACTION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::TRANSACTIONAL() {
  return getToken(MySqlParser::TRANSACTIONAL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::TRIGGERS() {
  return getToken(MySqlParser::TRIGGERS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::TRUNCATE() {
  return getToken(MySqlParser::TRUNCATE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::UNBOUNDED() {
  return getToken(MySqlParser::UNBOUNDED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::UNDEFINED() {
  return getToken(MySqlParser::UNDEFINED, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::UNDOFILE() {
  return getToken(MySqlParser::UNDOFILE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::UNDO_BUFFER_SIZE() {
  return getToken(MySqlParser::UNDO_BUFFER_SIZE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::UNINSTALL() {
  return getToken(MySqlParser::UNINSTALL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::UNKNOWN() {
  return getToken(MySqlParser::UNKNOWN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::UNTIL() {
  return getToken(MySqlParser::UNTIL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::UPGRADE() {
  return getToken(MySqlParser::UPGRADE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::USA() {
  return getToken(MySqlParser::USA, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::USER() {
  return getToken(MySqlParser::USER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::USE_FRM() {
  return getToken(MySqlParser::USE_FRM, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::USER_RESOURCES() {
  return getToken(MySqlParser::USER_RESOURCES, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::VALIDATION() {
  return getToken(MySqlParser::VALIDATION, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::VALUE() {
  return getToken(MySqlParser::VALUE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::VAR_POP() {
  return getToken(MySqlParser::VAR_POP, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::VAR_SAMP() {
  return getToken(MySqlParser::VAR_SAMP, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::VARIABLES() {
  return getToken(MySqlParser::VARIABLES, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::VARIANCE() {
  return getToken(MySqlParser::VARIANCE, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::VERSION_TOKEN_ADMIN() {
  return getToken(MySqlParser::VERSION_TOKEN_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::VIEW() {
  return getToken(MySqlParser::VIEW, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::VIRTUAL() {
  return getToken(MySqlParser::VIRTUAL, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::WAIT() {
  return getToken(MySqlParser::WAIT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::WARNINGS() {
  return getToken(MySqlParser::WARNINGS, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::WITHOUT() {
  return getToken(MySqlParser::WITHOUT, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::WORK() {
  return getToken(MySqlParser::WORK, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::WRAPPER() {
  return getToken(MySqlParser::WRAPPER, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::X509() {
  return getToken(MySqlParser::X509, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::XA() {
  return getToken(MySqlParser::XA, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::XA_RECOVER_ADMIN() {
  return getToken(MySqlParser::XA_RECOVER_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::KeywordsCanBeIdContext::XML() {
  return getToken(MySqlParser::XML, 0);
}


size_t MySqlParser::KeywordsCanBeIdContext::getRuleIndex() const {
  return MySqlParser::RuleKeywordsCanBeId;
}

void MySqlParser::KeywordsCanBeIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeywordsCanBeId(this);
}

void MySqlParser::KeywordsCanBeIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeywordsCanBeId(this);
}


std::any MySqlParser::KeywordsCanBeIdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitKeywordsCanBeId(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::KeywordsCanBeIdContext* MySqlParser::keywordsCanBeId() {
  KeywordsCanBeIdContext *_localctx = _tracker.createInstance<KeywordsCanBeIdContext>(_ctx, getState());
  enterRule(_localctx, 706, MySqlParser::RuleKeywordsCanBeId);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7380);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 756890782757306368) != 0) || ((((_la - 73) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 73)) & 146666055054393409) != 0) || _la == MySqlParser::SKIP_QUERY_REWRITE

    || _la == MySqlParser::STACKED || ((((_la - 239) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 239)) & 1769897061370560513) != 0) || ((((_la - 305) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 305)) & -134217473) != 0) || ((((_la - 369) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 369)) & -171798822913) != 0) || ((((_la - 434) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 434)) & -33685505) != 0) || ((((_la - 498) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 498)) & -2306265222165299201) != 0) || ((((_la - 562) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 562)) & -35186788007937) != 0) || ((((_la - 626) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 626)) & 9077990211383719935) != 0) || ((((_la - 697) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 697)) & 514225960183805) != 0) || _la == MySqlParser::MEMORY

    || _la == MySqlParser::CATALOG_NAME || _la == MySqlParser::ENGINE_ATTRIBUTE || _la == MySqlParser::SECONDARY_ENGINE_ATTRIBUTE

    || _la == MySqlParser::SCHEMA_NAME || _la == MySqlParser::TP_CONNECTION_ADMIN)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionNameBaseContext ------------------------------------------------------------------

MySqlParser::FunctionNameBaseContext::FunctionNameBaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ABS() {
  return getToken(MySqlParser::ABS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ACOS() {
  return getToken(MySqlParser::ACOS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ADDDATE() {
  return getToken(MySqlParser::ADDDATE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ADDTIME() {
  return getToken(MySqlParser::ADDTIME, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::AES_DECRYPT() {
  return getToken(MySqlParser::AES_DECRYPT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::AES_ENCRYPT() {
  return getToken(MySqlParser::AES_ENCRYPT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::AREA() {
  return getToken(MySqlParser::AREA, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ASBINARY() {
  return getToken(MySqlParser::ASBINARY, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ASIN() {
  return getToken(MySqlParser::ASIN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ASTEXT() {
  return getToken(MySqlParser::ASTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ASWKB() {
  return getToken(MySqlParser::ASWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ASWKT() {
  return getToken(MySqlParser::ASWKT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ASYMMETRIC_DECRYPT() {
  return getToken(MySqlParser::ASYMMETRIC_DECRYPT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ASYMMETRIC_DERIVE() {
  return getToken(MySqlParser::ASYMMETRIC_DERIVE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ASYMMETRIC_ENCRYPT() {
  return getToken(MySqlParser::ASYMMETRIC_ENCRYPT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ASYMMETRIC_SIGN() {
  return getToken(MySqlParser::ASYMMETRIC_SIGN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ASYMMETRIC_VERIFY() {
  return getToken(MySqlParser::ASYMMETRIC_VERIFY, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ATAN() {
  return getToken(MySqlParser::ATAN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ATAN2() {
  return getToken(MySqlParser::ATAN2, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::BENCHMARK() {
  return getToken(MySqlParser::BENCHMARK, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::BIN() {
  return getToken(MySqlParser::BIN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::BIT_COUNT() {
  return getToken(MySqlParser::BIT_COUNT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::BIT_LENGTH() {
  return getToken(MySqlParser::BIT_LENGTH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::BUFFER() {
  return getToken(MySqlParser::BUFFER, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CEIL() {
  return getToken(MySqlParser::CEIL, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CEILING() {
  return getToken(MySqlParser::CEILING, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CENTROID() {
  return getToken(MySqlParser::CENTROID, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CHARACTER_LENGTH() {
  return getToken(MySqlParser::CHARACTER_LENGTH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CHARSET() {
  return getToken(MySqlParser::CHARSET, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CHAR_LENGTH() {
  return getToken(MySqlParser::CHAR_LENGTH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::COERCIBILITY() {
  return getToken(MySqlParser::COERCIBILITY, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::COLLATION() {
  return getToken(MySqlParser::COLLATION, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::COMPRESS() {
  return getToken(MySqlParser::COMPRESS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CONCAT() {
  return getToken(MySqlParser::CONCAT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CONCAT_WS() {
  return getToken(MySqlParser::CONCAT_WS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CONNECTION_ID() {
  return getToken(MySqlParser::CONNECTION_ID, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CONV() {
  return getToken(MySqlParser::CONV, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CONVERT_TZ() {
  return getToken(MySqlParser::CONVERT_TZ, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::COS() {
  return getToken(MySqlParser::COS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::COT() {
  return getToken(MySqlParser::COT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::COUNT() {
  return getToken(MySqlParser::COUNT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CRC32() {
  return getToken(MySqlParser::CRC32, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CREATE_ASYMMETRIC_PRIV_KEY() {
  return getToken(MySqlParser::CREATE_ASYMMETRIC_PRIV_KEY, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CREATE_ASYMMETRIC_PUB_KEY() {
  return getToken(MySqlParser::CREATE_ASYMMETRIC_PUB_KEY, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CREATE_DH_PARAMETERS() {
  return getToken(MySqlParser::CREATE_DH_PARAMETERS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CREATE_DIGEST() {
  return getToken(MySqlParser::CREATE_DIGEST, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CROSSES() {
  return getToken(MySqlParser::CROSSES, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::CUME_DIST() {
  return getToken(MySqlParser::CUME_DIST, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DATABASE() {
  return getToken(MySqlParser::DATABASE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DATE() {
  return getToken(MySqlParser::DATE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DATEDIFF() {
  return getToken(MySqlParser::DATEDIFF, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DATE_FORMAT() {
  return getToken(MySqlParser::DATE_FORMAT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DAY() {
  return getToken(MySqlParser::DAY, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DAYNAME() {
  return getToken(MySqlParser::DAYNAME, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DAYOFMONTH() {
  return getToken(MySqlParser::DAYOFMONTH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DAYOFWEEK() {
  return getToken(MySqlParser::DAYOFWEEK, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DAYOFYEAR() {
  return getToken(MySqlParser::DAYOFYEAR, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DECODE() {
  return getToken(MySqlParser::DECODE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DEGREES() {
  return getToken(MySqlParser::DEGREES, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DENSE_RANK() {
  return getToken(MySqlParser::DENSE_RANK, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DES_DECRYPT() {
  return getToken(MySqlParser::DES_DECRYPT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DES_ENCRYPT() {
  return getToken(MySqlParser::DES_ENCRYPT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DIMENSION() {
  return getToken(MySqlParser::DIMENSION, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::DISJOINT() {
  return getToken(MySqlParser::DISJOINT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ELT() {
  return getToken(MySqlParser::ELT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ENCODE() {
  return getToken(MySqlParser::ENCODE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ENCRYPT() {
  return getToken(MySqlParser::ENCRYPT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ENDPOINT() {
  return getToken(MySqlParser::ENDPOINT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ENVELOPE() {
  return getToken(MySqlParser::ENVELOPE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::EQUALS() {
  return getToken(MySqlParser::EQUALS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::EXP() {
  return getToken(MySqlParser::EXP, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::EXPORT_SET() {
  return getToken(MySqlParser::EXPORT_SET, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::EXTERIORRING() {
  return getToken(MySqlParser::EXTERIORRING, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::EXTRACTVALUE() {
  return getToken(MySqlParser::EXTRACTVALUE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::FIELD() {
  return getToken(MySqlParser::FIELD, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::FIND_IN_SET() {
  return getToken(MySqlParser::FIND_IN_SET, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::FIRST_VALUE() {
  return getToken(MySqlParser::FIRST_VALUE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::FLOOR() {
  return getToken(MySqlParser::FLOOR, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::FORMAT() {
  return getToken(MySqlParser::FORMAT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::FOUND_ROWS() {
  return getToken(MySqlParser::FOUND_ROWS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::FROM_BASE64() {
  return getToken(MySqlParser::FROM_BASE64, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::FROM_DAYS() {
  return getToken(MySqlParser::FROM_DAYS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::FROM_UNIXTIME() {
  return getToken(MySqlParser::FROM_UNIXTIME, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GEOMCOLLFROMTEXT() {
  return getToken(MySqlParser::GEOMCOLLFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GEOMCOLLFROMWKB() {
  return getToken(MySqlParser::GEOMCOLLFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GEOMETRYCOLLECTION() {
  return getToken(MySqlParser::GEOMETRYCOLLECTION, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GEOMETRYCOLLECTIONFROMTEXT() {
  return getToken(MySqlParser::GEOMETRYCOLLECTIONFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GEOMETRYCOLLECTIONFROMWKB() {
  return getToken(MySqlParser::GEOMETRYCOLLECTIONFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GEOMETRYFROMTEXT() {
  return getToken(MySqlParser::GEOMETRYFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GEOMETRYFROMWKB() {
  return getToken(MySqlParser::GEOMETRYFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GEOMETRYN() {
  return getToken(MySqlParser::GEOMETRYN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GEOMETRYTYPE() {
  return getToken(MySqlParser::GEOMETRYTYPE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GEOMFROMTEXT() {
  return getToken(MySqlParser::GEOMFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GEOMFROMWKB() {
  return getToken(MySqlParser::GEOMFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GET_FORMAT() {
  return getToken(MySqlParser::GET_FORMAT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GET_LOCK() {
  return getToken(MySqlParser::GET_LOCK, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GLENGTH() {
  return getToken(MySqlParser::GLENGTH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GREATEST() {
  return getToken(MySqlParser::GREATEST, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GTID_SUBSET() {
  return getToken(MySqlParser::GTID_SUBSET, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::GTID_SUBTRACT() {
  return getToken(MySqlParser::GTID_SUBTRACT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::HEX() {
  return getToken(MySqlParser::HEX, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::HOUR() {
  return getToken(MySqlParser::HOUR, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::IFNULL() {
  return getToken(MySqlParser::IFNULL, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::INET6_ATON() {
  return getToken(MySqlParser::INET6_ATON, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::INET6_NTOA() {
  return getToken(MySqlParser::INET6_NTOA, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::INET_ATON() {
  return getToken(MySqlParser::INET_ATON, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::INET_NTOA() {
  return getToken(MySqlParser::INET_NTOA, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::INSTR() {
  return getToken(MySqlParser::INSTR, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::INTERIORRINGN() {
  return getToken(MySqlParser::INTERIORRINGN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::INTERSECTS() {
  return getToken(MySqlParser::INTERSECTS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::INVISIBLE() {
  return getToken(MySqlParser::INVISIBLE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ISCLOSED() {
  return getToken(MySqlParser::ISCLOSED, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ISEMPTY() {
  return getToken(MySqlParser::ISEMPTY, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ISNULL() {
  return getToken(MySqlParser::ISNULL, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ISSIMPLE() {
  return getToken(MySqlParser::ISSIMPLE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::IS_FREE_LOCK() {
  return getToken(MySqlParser::IS_FREE_LOCK, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::IS_IPV4() {
  return getToken(MySqlParser::IS_IPV4, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::IS_IPV4_COMPAT() {
  return getToken(MySqlParser::IS_IPV4_COMPAT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::IS_IPV4_MAPPED() {
  return getToken(MySqlParser::IS_IPV4_MAPPED, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::IS_IPV6() {
  return getToken(MySqlParser::IS_IPV6, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::IS_USED_LOCK() {
  return getToken(MySqlParser::IS_USED_LOCK, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LAG() {
  return getToken(MySqlParser::LAG, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LAST_INSERT_ID() {
  return getToken(MySqlParser::LAST_INSERT_ID, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LAST_VALUE() {
  return getToken(MySqlParser::LAST_VALUE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LCASE() {
  return getToken(MySqlParser::LCASE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LEAD() {
  return getToken(MySqlParser::LEAD, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LEAST() {
  return getToken(MySqlParser::LEAST, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LEFT() {
  return getToken(MySqlParser::LEFT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LENGTH() {
  return getToken(MySqlParser::LENGTH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LINEFROMTEXT() {
  return getToken(MySqlParser::LINEFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LINEFROMWKB() {
  return getToken(MySqlParser::LINEFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LINESTRING() {
  return getToken(MySqlParser::LINESTRING, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LINESTRINGFROMTEXT() {
  return getToken(MySqlParser::LINESTRINGFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LINESTRINGFROMWKB() {
  return getToken(MySqlParser::LINESTRINGFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LN() {
  return getToken(MySqlParser::LN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LOAD_FILE() {
  return getToken(MySqlParser::LOAD_FILE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LOCATE() {
  return getToken(MySqlParser::LOCATE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LOG() {
  return getToken(MySqlParser::LOG, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LOG10() {
  return getToken(MySqlParser::LOG10, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LOG2() {
  return getToken(MySqlParser::LOG2, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LOWER() {
  return getToken(MySqlParser::LOWER, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LPAD() {
  return getToken(MySqlParser::LPAD, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::LTRIM() {
  return getToken(MySqlParser::LTRIM, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MAKEDATE() {
  return getToken(MySqlParser::MAKEDATE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MAKETIME() {
  return getToken(MySqlParser::MAKETIME, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MAKE_SET() {
  return getToken(MySqlParser::MAKE_SET, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MASTER_POS_WAIT() {
  return getToken(MySqlParser::MASTER_POS_WAIT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MBRCONTAINS() {
  return getToken(MySqlParser::MBRCONTAINS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MBRDISJOINT() {
  return getToken(MySqlParser::MBRDISJOINT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MBREQUAL() {
  return getToken(MySqlParser::MBREQUAL, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MBRINTERSECTS() {
  return getToken(MySqlParser::MBRINTERSECTS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MBROVERLAPS() {
  return getToken(MySqlParser::MBROVERLAPS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MBRTOUCHES() {
  return getToken(MySqlParser::MBRTOUCHES, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MBRWITHIN() {
  return getToken(MySqlParser::MBRWITHIN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MD5() {
  return getToken(MySqlParser::MD5, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MICROSECOND() {
  return getToken(MySqlParser::MICROSECOND, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MINUTE() {
  return getToken(MySqlParser::MINUTE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MLINEFROMTEXT() {
  return getToken(MySqlParser::MLINEFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MLINEFROMWKB() {
  return getToken(MySqlParser::MLINEFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MOD() {
  return getToken(MySqlParser::MOD, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MONTH() {
  return getToken(MySqlParser::MONTH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MONTHNAME() {
  return getToken(MySqlParser::MONTHNAME, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MPOINTFROMTEXT() {
  return getToken(MySqlParser::MPOINTFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MPOINTFROMWKB() {
  return getToken(MySqlParser::MPOINTFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MPOLYFROMTEXT() {
  return getToken(MySqlParser::MPOLYFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MPOLYFROMWKB() {
  return getToken(MySqlParser::MPOLYFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MULTILINESTRING() {
  return getToken(MySqlParser::MULTILINESTRING, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MULTILINESTRINGFROMTEXT() {
  return getToken(MySqlParser::MULTILINESTRINGFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MULTILINESTRINGFROMWKB() {
  return getToken(MySqlParser::MULTILINESTRINGFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MULTIPOINT() {
  return getToken(MySqlParser::MULTIPOINT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MULTIPOINTFROMTEXT() {
  return getToken(MySqlParser::MULTIPOINTFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MULTIPOINTFROMWKB() {
  return getToken(MySqlParser::MULTIPOINTFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MULTIPOLYGON() {
  return getToken(MySqlParser::MULTIPOLYGON, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MULTIPOLYGONFROMTEXT() {
  return getToken(MySqlParser::MULTIPOLYGONFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::MULTIPOLYGONFROMWKB() {
  return getToken(MySqlParser::MULTIPOLYGONFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::NAME_CONST() {
  return getToken(MySqlParser::NAME_CONST, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::NTH_VALUE() {
  return getToken(MySqlParser::NTH_VALUE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::NTILE() {
  return getToken(MySqlParser::NTILE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::NULLIF() {
  return getToken(MySqlParser::NULLIF, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::NUMGEOMETRIES() {
  return getToken(MySqlParser::NUMGEOMETRIES, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::NUMINTERIORRINGS() {
  return getToken(MySqlParser::NUMINTERIORRINGS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::NUMPOINTS() {
  return getToken(MySqlParser::NUMPOINTS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::OCT() {
  return getToken(MySqlParser::OCT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::OCTET_LENGTH() {
  return getToken(MySqlParser::OCTET_LENGTH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ORD() {
  return getToken(MySqlParser::ORD, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::OVERLAPS() {
  return getToken(MySqlParser::OVERLAPS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::PERCENT_RANK() {
  return getToken(MySqlParser::PERCENT_RANK, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::PERIOD_ADD() {
  return getToken(MySqlParser::PERIOD_ADD, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::PERIOD_DIFF() {
  return getToken(MySqlParser::PERIOD_DIFF, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::PI() {
  return getToken(MySqlParser::PI, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::POINT() {
  return getToken(MySqlParser::POINT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::POINTFROMTEXT() {
  return getToken(MySqlParser::POINTFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::POINTFROMWKB() {
  return getToken(MySqlParser::POINTFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::POINTN() {
  return getToken(MySqlParser::POINTN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::POLYFROMTEXT() {
  return getToken(MySqlParser::POLYFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::POLYFROMWKB() {
  return getToken(MySqlParser::POLYFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::POLYGON() {
  return getToken(MySqlParser::POLYGON, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::POLYGONFROMTEXT() {
  return getToken(MySqlParser::POLYGONFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::POLYGONFROMWKB() {
  return getToken(MySqlParser::POLYGONFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::POSITION() {
  return getToken(MySqlParser::POSITION, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::POW() {
  return getToken(MySqlParser::POW, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::POWER() {
  return getToken(MySqlParser::POWER, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::QUARTER() {
  return getToken(MySqlParser::QUARTER, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::QUOTE() {
  return getToken(MySqlParser::QUOTE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::RADIANS() {
  return getToken(MySqlParser::RADIANS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::RAND() {
  return getToken(MySqlParser::RAND, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::RANK() {
  return getToken(MySqlParser::RANK, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::RANDOM_BYTES() {
  return getToken(MySqlParser::RANDOM_BYTES, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::RELEASE_LOCK() {
  return getToken(MySqlParser::RELEASE_LOCK, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::REVERSE() {
  return getToken(MySqlParser::REVERSE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::RIGHT() {
  return getToken(MySqlParser::RIGHT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ROUND() {
  return getToken(MySqlParser::ROUND, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ROW_COUNT() {
  return getToken(MySqlParser::ROW_COUNT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ROW_NUMBER() {
  return getToken(MySqlParser::ROW_NUMBER, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::RPAD() {
  return getToken(MySqlParser::RPAD, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::RTRIM() {
  return getToken(MySqlParser::RTRIM, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SCHEMA() {
  return getToken(MySqlParser::SCHEMA, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SECOND() {
  return getToken(MySqlParser::SECOND, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SEC_TO_TIME() {
  return getToken(MySqlParser::SEC_TO_TIME, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SESSION_USER() {
  return getToken(MySqlParser::SESSION_USER, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SESSION_VARIABLES_ADMIN() {
  return getToken(MySqlParser::SESSION_VARIABLES_ADMIN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SHA() {
  return getToken(MySqlParser::SHA, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SHA1() {
  return getToken(MySqlParser::SHA1, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SHA2() {
  return getToken(MySqlParser::SHA2, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SIGN() {
  return getToken(MySqlParser::SIGN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SIN() {
  return getToken(MySqlParser::SIN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SLEEP() {
  return getToken(MySqlParser::SLEEP, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SOUNDEX() {
  return getToken(MySqlParser::SOUNDEX, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SQL_THREAD_WAIT_AFTER_GTIDS() {
  return getToken(MySqlParser::SQL_THREAD_WAIT_AFTER_GTIDS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SQRT() {
  return getToken(MySqlParser::SQRT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SRID() {
  return getToken(MySqlParser::SRID, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::STARTPOINT() {
  return getToken(MySqlParser::STARTPOINT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::STRCMP() {
  return getToken(MySqlParser::STRCMP, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::STR_TO_DATE() {
  return getToken(MySqlParser::STR_TO_DATE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_AREA() {
  return getToken(MySqlParser::ST_AREA, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_ASBINARY() {
  return getToken(MySqlParser::ST_ASBINARY, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_ASTEXT() {
  return getToken(MySqlParser::ST_ASTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_ASWKB() {
  return getToken(MySqlParser::ST_ASWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_ASWKT() {
  return getToken(MySqlParser::ST_ASWKT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_BUFFER() {
  return getToken(MySqlParser::ST_BUFFER, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_CENTROID() {
  return getToken(MySqlParser::ST_CENTROID, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_CONTAINS() {
  return getToken(MySqlParser::ST_CONTAINS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_CROSSES() {
  return getToken(MySqlParser::ST_CROSSES, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_DIFFERENCE() {
  return getToken(MySqlParser::ST_DIFFERENCE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_DIMENSION() {
  return getToken(MySqlParser::ST_DIMENSION, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_DISJOINT() {
  return getToken(MySqlParser::ST_DISJOINT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_DISTANCE() {
  return getToken(MySqlParser::ST_DISTANCE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_ENDPOINT() {
  return getToken(MySqlParser::ST_ENDPOINT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_ENVELOPE() {
  return getToken(MySqlParser::ST_ENVELOPE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_EQUALS() {
  return getToken(MySqlParser::ST_EQUALS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_EXTERIORRING() {
  return getToken(MySqlParser::ST_EXTERIORRING, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_GEOMCOLLFROMTEXT() {
  return getToken(MySqlParser::ST_GEOMCOLLFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_GEOMCOLLFROMTXT() {
  return getToken(MySqlParser::ST_GEOMCOLLFROMTXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_GEOMCOLLFROMWKB() {
  return getToken(MySqlParser::ST_GEOMCOLLFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_GEOMETRYCOLLECTIONFROMTEXT() {
  return getToken(MySqlParser::ST_GEOMETRYCOLLECTIONFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_GEOMETRYCOLLECTIONFROMWKB() {
  return getToken(MySqlParser::ST_GEOMETRYCOLLECTIONFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_GEOMETRYFROMTEXT() {
  return getToken(MySqlParser::ST_GEOMETRYFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_GEOMETRYFROMWKB() {
  return getToken(MySqlParser::ST_GEOMETRYFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_GEOMETRYN() {
  return getToken(MySqlParser::ST_GEOMETRYN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_GEOMETRYTYPE() {
  return getToken(MySqlParser::ST_GEOMETRYTYPE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_GEOMFROMTEXT() {
  return getToken(MySqlParser::ST_GEOMFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_GEOMFROMWKB() {
  return getToken(MySqlParser::ST_GEOMFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_INTERIORRINGN() {
  return getToken(MySqlParser::ST_INTERIORRINGN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_INTERSECTION() {
  return getToken(MySqlParser::ST_INTERSECTION, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_INTERSECTS() {
  return getToken(MySqlParser::ST_INTERSECTS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_ISCLOSED() {
  return getToken(MySqlParser::ST_ISCLOSED, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_ISEMPTY() {
  return getToken(MySqlParser::ST_ISEMPTY, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_ISSIMPLE() {
  return getToken(MySqlParser::ST_ISSIMPLE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_LINEFROMTEXT() {
  return getToken(MySqlParser::ST_LINEFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_LINEFROMWKB() {
  return getToken(MySqlParser::ST_LINEFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_LINESTRINGFROMTEXT() {
  return getToken(MySqlParser::ST_LINESTRINGFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_LINESTRINGFROMWKB() {
  return getToken(MySqlParser::ST_LINESTRINGFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_NUMGEOMETRIES() {
  return getToken(MySqlParser::ST_NUMGEOMETRIES, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_NUMINTERIORRING() {
  return getToken(MySqlParser::ST_NUMINTERIORRING, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_NUMINTERIORRINGS() {
  return getToken(MySqlParser::ST_NUMINTERIORRINGS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_NUMPOINTS() {
  return getToken(MySqlParser::ST_NUMPOINTS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_OVERLAPS() {
  return getToken(MySqlParser::ST_OVERLAPS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_POINTFROMTEXT() {
  return getToken(MySqlParser::ST_POINTFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_POINTFROMWKB() {
  return getToken(MySqlParser::ST_POINTFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_POINTN() {
  return getToken(MySqlParser::ST_POINTN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_POLYFROMTEXT() {
  return getToken(MySqlParser::ST_POLYFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_POLYFROMWKB() {
  return getToken(MySqlParser::ST_POLYFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_POLYGONFROMTEXT() {
  return getToken(MySqlParser::ST_POLYGONFROMTEXT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_POLYGONFROMWKB() {
  return getToken(MySqlParser::ST_POLYGONFROMWKB, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_SRID() {
  return getToken(MySqlParser::ST_SRID, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_STARTPOINT() {
  return getToken(MySqlParser::ST_STARTPOINT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_SYMDIFFERENCE() {
  return getToken(MySqlParser::ST_SYMDIFFERENCE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_TOUCHES() {
  return getToken(MySqlParser::ST_TOUCHES, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_UNION() {
  return getToken(MySqlParser::ST_UNION, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_WITHIN() {
  return getToken(MySqlParser::ST_WITHIN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_X() {
  return getToken(MySqlParser::ST_X, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::ST_Y() {
  return getToken(MySqlParser::ST_Y, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SUBDATE() {
  return getToken(MySqlParser::SUBDATE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SUBSTRING_INDEX() {
  return getToken(MySqlParser::SUBSTRING_INDEX, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SUBTIME() {
  return getToken(MySqlParser::SUBTIME, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::SYSTEM_USER() {
  return getToken(MySqlParser::SYSTEM_USER, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::TAN() {
  return getToken(MySqlParser::TAN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::TIME() {
  return getToken(MySqlParser::TIME, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::TIMEDIFF() {
  return getToken(MySqlParser::TIMEDIFF, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::TIMESTAMP() {
  return getToken(MySqlParser::TIMESTAMP, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::TIMESTAMPADD() {
  return getToken(MySqlParser::TIMESTAMPADD, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::TIMESTAMPDIFF() {
  return getToken(MySqlParser::TIMESTAMPDIFF, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::TIME_FORMAT() {
  return getToken(MySqlParser::TIME_FORMAT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::TIME_TO_SEC() {
  return getToken(MySqlParser::TIME_TO_SEC, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::TOUCHES() {
  return getToken(MySqlParser::TOUCHES, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::TO_BASE64() {
  return getToken(MySqlParser::TO_BASE64, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::TO_DAYS() {
  return getToken(MySqlParser::TO_DAYS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::TO_SECONDS() {
  return getToken(MySqlParser::TO_SECONDS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::UCASE() {
  return getToken(MySqlParser::UCASE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::UNCOMPRESS() {
  return getToken(MySqlParser::UNCOMPRESS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::UNCOMPRESSED_LENGTH() {
  return getToken(MySqlParser::UNCOMPRESSED_LENGTH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::UNHEX() {
  return getToken(MySqlParser::UNHEX, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::UNIX_TIMESTAMP() {
  return getToken(MySqlParser::UNIX_TIMESTAMP, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::UPDATEXML() {
  return getToken(MySqlParser::UPDATEXML, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::UPPER() {
  return getToken(MySqlParser::UPPER, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::UUID() {
  return getToken(MySqlParser::UUID, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::UUID_SHORT() {
  return getToken(MySqlParser::UUID_SHORT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::VALIDATE_PASSWORD_STRENGTH() {
  return getToken(MySqlParser::VALIDATE_PASSWORD_STRENGTH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::VERSION() {
  return getToken(MySqlParser::VERSION, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::VISIBLE() {
  return getToken(MySqlParser::VISIBLE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() {
  return getToken(MySqlParser::WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::WEEK() {
  return getToken(MySqlParser::WEEK, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::WEEKDAY() {
  return getToken(MySqlParser::WEEKDAY, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::WEEKOFYEAR() {
  return getToken(MySqlParser::WEEKOFYEAR, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::WEIGHT_STRING() {
  return getToken(MySqlParser::WEIGHT_STRING, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::WITHIN() {
  return getToken(MySqlParser::WITHIN, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::YEAR() {
  return getToken(MySqlParser::YEAR, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::YEARWEEK() {
  return getToken(MySqlParser::YEARWEEK, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::Y_FUNCTION() {
  return getToken(MySqlParser::Y_FUNCTION, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::X_FUNCTION() {
  return getToken(MySqlParser::X_FUNCTION, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_ARRAY() {
  return getToken(MySqlParser::JSON_ARRAY, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_OBJECT() {
  return getToken(MySqlParser::JSON_OBJECT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_QUOTE() {
  return getToken(MySqlParser::JSON_QUOTE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_CONTAINS() {
  return getToken(MySqlParser::JSON_CONTAINS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_CONTAINS_PATH() {
  return getToken(MySqlParser::JSON_CONTAINS_PATH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_EXTRACT() {
  return getToken(MySqlParser::JSON_EXTRACT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_KEYS() {
  return getToken(MySqlParser::JSON_KEYS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_OVERLAPS() {
  return getToken(MySqlParser::JSON_OVERLAPS, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_SEARCH() {
  return getToken(MySqlParser::JSON_SEARCH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_VALUE() {
  return getToken(MySqlParser::JSON_VALUE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_ARRAY_APPEND() {
  return getToken(MySqlParser::JSON_ARRAY_APPEND, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_ARRAY_INSERT() {
  return getToken(MySqlParser::JSON_ARRAY_INSERT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_INSERT() {
  return getToken(MySqlParser::JSON_INSERT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_MERGE() {
  return getToken(MySqlParser::JSON_MERGE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_MERGE_PATCH() {
  return getToken(MySqlParser::JSON_MERGE_PATCH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_MERGE_PRESERVE() {
  return getToken(MySqlParser::JSON_MERGE_PRESERVE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_REMOVE() {
  return getToken(MySqlParser::JSON_REMOVE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_REPLACE() {
  return getToken(MySqlParser::JSON_REPLACE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_SET() {
  return getToken(MySqlParser::JSON_SET, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_UNQUOTE() {
  return getToken(MySqlParser::JSON_UNQUOTE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_DEPTH() {
  return getToken(MySqlParser::JSON_DEPTH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_LENGTH() {
  return getToken(MySqlParser::JSON_LENGTH, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_TYPE() {
  return getToken(MySqlParser::JSON_TYPE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_VALID() {
  return getToken(MySqlParser::JSON_VALID, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_TABLE() {
  return getToken(MySqlParser::JSON_TABLE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_SCHEMA_VALID() {
  return getToken(MySqlParser::JSON_SCHEMA_VALID, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_SCHEMA_VALIDATION_REPORT() {
  return getToken(MySqlParser::JSON_SCHEMA_VALIDATION_REPORT, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_PRETTY() {
  return getToken(MySqlParser::JSON_PRETTY, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_STORAGE_FREE() {
  return getToken(MySqlParser::JSON_STORAGE_FREE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_STORAGE_SIZE() {
  return getToken(MySqlParser::JSON_STORAGE_SIZE, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_ARRAYAGG() {
  return getToken(MySqlParser::JSON_ARRAYAGG, 0);
}

tree::TerminalNode* MySqlParser::FunctionNameBaseContext::JSON_OBJECTAGG() {
  return getToken(MySqlParser::JSON_OBJECTAGG, 0);
}


size_t MySqlParser::FunctionNameBaseContext::getRuleIndex() const {
  return MySqlParser::RuleFunctionNameBase;
}

void MySqlParser::FunctionNameBaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionNameBase(this);
}

void MySqlParser::FunctionNameBaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySqlParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionNameBase(this);
}


std::any MySqlParser::FunctionNameBaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySqlParserVisitor*>(visitor))
    return parserVisitor->visitFunctionNameBase(this);
  else
    return visitor->visitChildren(this);
}

MySqlParser::FunctionNameBaseContext* MySqlParser::functionNameBase() {
  FunctionNameBaseContext *_localctx = _tracker.createInstance<FunctionNameBaseContext>(_ctx, getState());
  enterRule(_localctx, 708, MySqlParser::RuleFunctionNameBase);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7382);
    _la = _input->LA(1);
    if (!(_la == MySqlParser::DATABASE || ((((_la - 97) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 97)) & 11258999068426241) != 0) || ((((_la - 217) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 217)) & -17179869161) != 0) || ((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & 8796109397507) != 0) || _la == MySqlParser::INVISIBLE || ((((_la - 673) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 673)) & -9223372036838064127) != 0) || ((((_la - 803) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 803)) & -8589934599) != 0) || ((((_la - 867) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 867)) & -257) != 0) || ((((_la - 931) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 931)) & -1) != 0) || ((((_la - 995) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 995)) & -529) != 0) || ((((_la - 1059) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 1059)) & -9223090562146500609) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool MySqlParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 339: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);
    case 340: return predicateSempred(antlrcpp::downCast<PredicateContext *>(context), predicateIndex);
    case 341: return expressionAtomSempred(antlrcpp::downCast<ExpressionAtomContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool MySqlParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 3);

  default:
    break;
  }
  return true;
}

bool MySqlParser::predicateSempred(PredicateContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 8);
    case 2: return precpred(_ctx, 6);
    case 3: return precpred(_ctx, 5);
    case 4: return precpred(_ctx, 3);
    case 5: return precpred(_ctx, 10);
    case 6: return precpred(_ctx, 9);
    case 7: return precpred(_ctx, 7);
    case 8: return precpred(_ctx, 4);
    case 9: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool MySqlParser::expressionAtomSempred(ExpressionAtomContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 10: return precpred(_ctx, 3);
    case 11: return precpred(_ctx, 2);
    case 12: return precpred(_ctx, 1);
    case 13: return precpred(_ctx, 12);

  default:
    break;
  }
  return true;
}

void MySqlParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  mysqlparserParserInitialize();
#else
  ::antlr4::internal::call_once(mysqlparserParserOnceFlag, mysqlparserParserInitialize);
#endif
}
